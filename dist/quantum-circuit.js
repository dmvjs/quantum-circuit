function hr() {
  return hr = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, hr.apply(null, arguments);
}
var Du = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  relTol: 1e-12,
  // minimum absolute difference between two compared values,
  // used by all comparison functions
  absTol: 1e-15,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', 'bigint', or 'Fraction'
  number: "number",
  // type of fallback used for config { number: 'bigint' } when a value cannot be represented
  // in the configured numeric type. Choose 'number' (default) or 'BigNumber'.
  numberFallback: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: !1,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null
};
function ht(t) {
  return typeof t == "number";
}
function ct(t) {
  return !t || typeof t != "object" || typeof t.constructor != "function" ? !1 : t.isBigNumber === !0 && typeof t.constructor.prototype == "object" && t.constructor.prototype.isBigNumber === !0 || typeof t.constructor.isDecimal == "function" && t.constructor.isDecimal(t) === !0;
}
function ld(t) {
  return typeof t == "bigint";
}
function Mn(t) {
  return t && typeof t == "object" && Object.getPrototypeOf(t).isComplex === !0 || !1;
}
function Fi(t) {
  return t && typeof t == "object" && Object.getPrototypeOf(t).isFraction === !0 || !1;
}
function Xr(t) {
  return t && t.constructor.prototype.isUnit === !0 || !1;
}
function Er(t) {
  return typeof t == "string";
}
var Rt = Array.isArray;
function tt(t) {
  return t && t.constructor.prototype.isMatrix === !0 || !1;
}
function cn(t) {
  return Array.isArray(t) || tt(t);
}
function Ra(t) {
  return t && t.isDenseMatrix && t.constructor.prototype.isMatrix === !0 || !1;
}
function oi(t) {
  return t && t.isSparseMatrix && t.constructor.prototype.isMatrix === !0 || !1;
}
function ks(t) {
  return t && t.constructor.prototype.isRange === !0 || !1;
}
function Va(t) {
  return t && t.constructor.prototype.isIndex === !0 || !1;
}
function cd(t) {
  return typeof t == "boolean";
}
function fd(t) {
  return t && t.constructor.prototype.isResultSet === !0 || !1;
}
function Au(t) {
  return t && t.constructor.prototype.isHelp === !0 || !1;
}
function pd(t) {
  return typeof t == "function";
}
function hd(t) {
  return t instanceof Date;
}
function md(t) {
  return t instanceof RegExp;
}
function Wa(t) {
  return !!(t && typeof t == "object" && t.constructor === Object && !Mn(t) && !Fi(t));
}
function dd(t) {
  return t === null;
}
function vd(t) {
  return t === void 0;
}
function pi(t) {
  return t && t.isAccessorNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function un(t) {
  return t && t.isArrayNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function gd(t) {
  return t && t.isAssignmentNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function yd(t) {
  return t && t.isBlockNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function xd(t) {
  return t && t.isConditionalNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Ct(t) {
  return t && t.isConstantNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function zm(t) {
  return Ct(t) || or(t) && t.args.length === 1 && Ct(t.args[0]) && "-+~".includes(t.op);
}
function oa(t) {
  return t && t.isFunctionAssignmentNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Wn(t) {
  return t && t.isFunctionNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function qi(t) {
  return t && t.isIndexNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Ut(t) {
  return t && t.isNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function ja(t) {
  return t && t.isObjectNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function or(t) {
  return t && t.isOperatorNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function kn(t) {
  return t && t.isParenthesisNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function bd(t) {
  return t && t.isRangeNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function wd(t) {
  return t && t.isRelationalNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function mr(t) {
  return t && t.isSymbolNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Eu(t) {
  return t && t.constructor.prototype.isChain === !0 || !1;
}
function Vt(t) {
  var e = typeof t;
  return e === "object" ? t === null ? "null" : ct(t) ? "BigNumber" : t.constructor && t.constructor.name ? t.constructor.name : "Object" : e;
}
function nt(t) {
  var e = typeof t;
  if (e === "number" || e === "bigint" || e === "string" || e === "boolean" || t === null || t === void 0)
    return t;
  if (typeof t.clone == "function")
    return t.clone();
  if (Array.isArray(t))
    return t.map(function(r) {
      return nt(r);
    });
  if (t instanceof Date) return new Date(t.valueOf());
  if (ct(t)) return t;
  if (Wa(t))
    return zS(t, nt);
  throw new TypeError("Cannot clone: unknown type of value (value: ".concat(t, ")"));
}
function zS(t, e) {
  var r = {};
  for (var n in t)
    We(t, n) && (r[n] = e(t[n]));
  return r;
}
function d2(t, e) {
  for (var r in e)
    We(e, r) && (t[r] = e[r]);
  return t;
}
function v2(t, e) {
  if (Array.isArray(e))
    throw new TypeError("Arrays are not supported by deepExtend");
  for (var r in e)
    if (We(e, r) && !(r in Object.prototype) && !(r in Function.prototype))
      if (e[r] && e[r].constructor === Object)
        t[r] === void 0 && (t[r] = {}), t[r] && t[r].constructor === Object ? v2(t[r], e[r]) : t[r] = e[r];
      else {
        if (Array.isArray(e[r]))
          throw new TypeError("Arrays are not supported by deepExtend");
        t[r] = e[r];
      }
  return t;
}
function ia(t, e) {
  var r, n, a;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (n = 0, a = t.length; n < a; n++)
      if (!ia(t[n], e[n]))
        return !1;
    return !0;
  } else {
    if (typeof t == "function")
      return t === e;
    if (t instanceof Object) {
      if (Array.isArray(e) || !(e instanceof Object))
        return !1;
      for (r in t)
        if (!(r in e) || !ia(t[r], e[r]))
          return !1;
      for (r in e)
        if (!(r in t))
          return !1;
      return !0;
    } else
      return t === e;
  }
}
function US(t) {
  var e = {};
  return g2(t, e), e;
}
function g2(t, e) {
  for (var r in t)
    if (We(t, r)) {
      var n = t[r];
      typeof n == "object" && n !== null ? g2(n, e) : e[r] = n;
    }
}
function Jo(t, e, r) {
  var n = !0, a;
  Object.defineProperty(t, e, {
    get: function() {
      return n && (a = r(), n = !1), a;
    },
    set: function(o) {
      a = o, n = !1;
    },
    configurable: !0,
    enumerable: !0
  });
}
function We(t, e) {
  return t && Object.hasOwnProperty.call(t, e);
}
function GS(t) {
  return t && typeof t.factory == "function";
}
function HS(t, e) {
  for (var r = {}, n = 0; n < e.length; n++) {
    var a = e[n], s = t[a];
    s !== void 0 && (r[a] = s);
  }
  return r;
}
var Um = ["Matrix", "Array"], Gm = ["number", "BigNumber", "Fraction"];
function QS(t, e) {
  function r(n) {
    if (n) {
      if (n.epsilon !== void 0) {
        console.warn('Warning: The configuration option "epsilon" is deprecated. Use "relTol" and "absTol" instead.');
        var a = nt(n);
        return a.relTol = n.epsilon, a.absTol = n.epsilon * 1e-3, delete a.epsilon, r(a);
      }
      var s = nt(t);
      Ug(n, "matrix", Um), Ug(n, "number", Gm), v2(t, n);
      var o = nt(t), p = nt(n);
      return e("config", o, s, p), o;
    } else
      return nt(t);
  }
  return r.MATRIX_OPTIONS = Um, r.NUMBER_OPTIONS = Gm, Object.keys(Du).forEach((n) => {
    Object.defineProperty(r, n, {
      get: () => t[n],
      enumerable: !0,
      configurable: !0
    });
  }), r;
}
function Ug(t, e, r) {
  t[e] !== void 0 && !r.includes(t[e]) && console.warn('Warning: Unknown value "' + t[e] + '" for configuration option "' + e + '". Available options: ' + r.map((n) => JSON.stringify(n)).join(", ") + ".");
}
var qe = function(e) {
  if (e)
    throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);
  return Object.freeze(Du);
};
hr(qe, Du, {
  MATRIX_OPTIONS: Um,
  NUMBER_OPTIONS: Gm
});
function Gg() {
  return !0;
}
function Tn() {
  return !1;
}
function Sa() {
}
const Hg = "Argument is not a typed-function.";
function y2() {
  function t(Q) {
    return typeof Q == "object" && Q !== null && Q.constructor === Object;
  }
  const e = [{
    name: "number",
    test: function(Q) {
      return typeof Q == "number";
    }
  }, {
    name: "string",
    test: function(Q) {
      return typeof Q == "string";
    }
  }, {
    name: "boolean",
    test: function(Q) {
      return typeof Q == "boolean";
    }
  }, {
    name: "Function",
    test: function(Q) {
      return typeof Q == "function";
    }
  }, {
    name: "Array",
    test: Array.isArray
  }, {
    name: "Date",
    test: function(Q) {
      return Q instanceof Date;
    }
  }, {
    name: "RegExp",
    test: function(Q) {
      return Q instanceof RegExp;
    }
  }, {
    name: "Object",
    test: t
  }, {
    name: "null",
    test: function(Q) {
      return Q === null;
    }
  }, {
    name: "undefined",
    test: function(Q) {
      return Q === void 0;
    }
  }], r = {
    name: "any",
    test: Gg,
    isAny: !0
  };
  let n, a, s = 0, o = {
    createCount: 0
  };
  function p(Q) {
    const ee = n.get(Q);
    if (ee)
      return ee;
    let ye = 'Unknown type "' + Q + '"';
    const Ee = Q.toLowerCase();
    let Ce;
    for (Ce of a)
      if (Ce.toLowerCase() === Ee) {
        ye += '. Did you mean "' + Ce + '" ?';
        break;
      }
    throw new TypeError(ye);
  }
  function u(Q) {
    let ee = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
    const ye = ee ? p(ee).index : a.length, Ee = [];
    for (let De = 0; De < Q.length; ++De) {
      if (!Q[De] || typeof Q[De].name != "string" || typeof Q[De].test != "function")
        throw new TypeError("Object with properties {name: string, test: function} expected");
      const Oe = Q[De].name;
      if (n.has(Oe))
        throw new TypeError('Duplicate type name "' + Oe + '"');
      Ee.push(Oe), n.set(Oe, {
        name: Oe,
        test: Q[De].test,
        isAny: Q[De].isAny,
        index: ye + De,
        conversionsTo: []
        // Newly added type can't have any conversions to it
      });
    }
    const Ce = a.slice(ye);
    a = a.slice(0, ye).concat(Ee).concat(Ce);
    for (let De = ye + Ee.length; De < a.length; ++De)
      n.get(a[De]).index = De;
  }
  function f() {
    n = /* @__PURE__ */ new Map(), a = [], s = 0, u([r], !1);
  }
  f(), u(e);
  function l() {
    let Q;
    for (Q of a)
      n.get(Q).conversionsTo = [];
    s = 0;
  }
  function c(Q) {
    const ee = a.filter((ye) => {
      const Ee = n.get(ye);
      return !Ee.isAny && Ee.test(Q);
    });
    return ee.length ? ee : ["any"];
  }
  function h(Q) {
    return Q && typeof Q == "function" && "_typedFunctionData" in Q;
  }
  function d(Q, ee, ye) {
    if (!h(Q))
      throw new TypeError(Hg);
    const Ee = ye && ye.exact, Ce = Array.isArray(ee) ? ee.join(",") : ee, De = E(Ce), Oe = N(De);
    if (!Ee || Oe in Q.signatures) {
      const rt = Q._typedFunctionData.signatureMap.get(Oe);
      if (rt)
        return rt;
    }
    const Be = De.length;
    let Le;
    if (Ee) {
      Le = [];
      let rt;
      for (rt in Q.signatures)
        Le.push(Q._typedFunctionData.signatureMap.get(rt));
    } else
      Le = Q._typedFunctionData.signatures;
    for (let rt = 0; rt < Be; ++rt) {
      const Ke = De[rt], Ze = [];
      let Ie;
      for (Ie of Le) {
        const B = _(Ie.params, rt);
        if (!(!B || Ke.restParam && !B.restParam)) {
          if (!B.hasAny) {
            const ne = x(B);
            if (Ke.types.some((xe) => !ne.has(xe.name)))
              continue;
          }
          Ze.push(Ie);
        }
      }
      if (Le = Ze, Le.length === 0) break;
    }
    let Re;
    for (Re of Le)
      if (Re.params.length <= Be)
        return Re;
    throw new TypeError("Signature not found (signature: " + (Q.name || "unnamed") + "(" + N(De, ", ") + "))");
  }
  function g(Q, ee, ye) {
    return d(Q, ee, ye).implementation;
  }
  function v(Q, ee) {
    const ye = p(ee);
    if (ye.test(Q))
      return Q;
    const Ee = ye.conversionsTo;
    if (Ee.length === 0)
      throw new Error("There are no conversions to " + ee + " defined.");
    for (let Ce = 0; Ce < Ee.length; Ce++)
      if (p(Ee[Ce].from).test(Q))
        return Ee[Ce].convert(Q);
    throw new Error("Cannot convert " + Q + " to " + ee);
  }
  function N(Q) {
    let ee = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
    return Q.map((ye) => ye.name).join(ee);
  }
  function b(Q) {
    const ee = Q.indexOf("...") === 0, Ee = (ee ? Q.length > 3 ? Q.slice(3) : "any" : Q).split("|").map((Be) => p(Be.trim()));
    let Ce = !1, De = ee ? "..." : "";
    return {
      types: Ee.map(function(Be) {
        return Ce = Be.isAny || Ce, De += Be.name + "|", {
          name: Be.name,
          typeIndex: Be.index,
          test: Be.test,
          isAny: Be.isAny,
          conversion: null,
          conversionIndex: -1
        };
      }),
      name: De.slice(0, -1),
      // remove trailing '|' from above
      hasAny: Ce,
      hasConversion: !1,
      restParam: ee
    };
  }
  function C(Q) {
    const ee = Q.types.map((Oe) => Oe.name), ye = R(ee);
    let Ee = Q.hasAny, Ce = Q.name;
    const De = ye.map(function(Oe) {
      const Be = p(Oe.from);
      return Ee = Be.isAny || Ee, Ce += "|" + Oe.from, {
        name: Oe.from,
        typeIndex: Be.index,
        test: Be.test,
        isAny: Be.isAny,
        conversion: Oe,
        conversionIndex: Oe.index
      };
    });
    return {
      types: Q.types.concat(De),
      name: Ce,
      hasAny: Ee,
      hasConversion: De.length > 0,
      restParam: Q.restParam
    };
  }
  function x(Q) {
    return Q.typeSet || (Q.typeSet = /* @__PURE__ */ new Set(), Q.types.forEach((ee) => Q.typeSet.add(ee.name))), Q.typeSet;
  }
  function E(Q) {
    const ee = [];
    if (typeof Q != "string")
      throw new TypeError("Signatures must be strings");
    const ye = Q.trim();
    if (ye === "")
      return ee;
    const Ee = ye.split(",");
    for (let Ce = 0; Ce < Ee.length; ++Ce) {
      const De = b(Ee[Ce].trim());
      if (De.restParam && Ce !== Ee.length - 1)
        throw new SyntaxError('Unexpected rest parameter "' + Ee[Ce] + '": only allowed for the last parameter');
      if (De.types.length === 0)
        return null;
      ee.push(De);
    }
    return ee;
  }
  function D(Q) {
    const ee = ue(Q);
    return ee ? ee.restParam : !1;
  }
  function A(Q) {
    if (!Q || Q.types.length === 0)
      return Gg;
    if (Q.types.length === 1)
      return p(Q.types[0].name).test;
    if (Q.types.length === 2) {
      const ee = p(Q.types[0].name).test, ye = p(Q.types[1].name).test;
      return function(Ce) {
        return ee(Ce) || ye(Ce);
      };
    } else {
      const ee = Q.types.map(function(ye) {
        return p(ye.name).test;
      });
      return function(Ee) {
        for (let Ce = 0; Ce < ee.length; Ce++)
          if (ee[Ce](Ee))
            return !0;
        return !1;
      };
    }
  }
  function M(Q) {
    let ee, ye, Ee;
    if (D(Q)) {
      ee = de(Q).map(A);
      const Ce = ee.length, De = A(ue(Q)), Oe = function(Be) {
        for (let Le = Ce; Le < Be.length; Le++)
          if (!De(Be[Le]))
            return !1;
        return !0;
      };
      return function(Le) {
        for (let Re = 0; Re < ee.length; Re++)
          if (!ee[Re](Le[Re]))
            return !1;
        return Oe(Le) && Le.length >= Ce + 1;
      };
    } else
      return Q.length === 0 ? function(De) {
        return De.length === 0;
      } : Q.length === 1 ? (ye = A(Q[0]), function(De) {
        return ye(De[0]) && De.length === 1;
      }) : Q.length === 2 ? (ye = A(Q[0]), Ee = A(Q[1]), function(De) {
        return ye(De[0]) && Ee(De[1]) && De.length === 2;
      }) : (ee = Q.map(A), function(De) {
        for (let Oe = 0; Oe < ee.length; Oe++)
          if (!ee[Oe](De[Oe]))
            return !1;
        return De.length === ee.length;
      });
  }
  function _(Q, ee) {
    return ee < Q.length ? Q[ee] : D(Q) ? ue(Q) : null;
  }
  function O(Q, ee) {
    const ye = _(Q, ee);
    return ye ? x(ye) : /* @__PURE__ */ new Set();
  }
  function T(Q) {
    return Q.conversion === null || Q.conversion === void 0;
  }
  function I(Q, ee) {
    const ye = /* @__PURE__ */ new Set();
    return Q.forEach((Ee) => {
      const Ce = O(Ee.params, ee);
      let De;
      for (De of Ce)
        ye.add(De);
    }), ye.has("any") ? ["any"] : Array.from(ye);
  }
  function q(Q, ee, ye) {
    let Ee, Ce;
    const De = Q || "unnamed";
    let Oe = ye, Be;
    for (Be = 0; Be < ee.length; Be++) {
      const Ke = [];
      if (Oe.forEach((Ze) => {
        const Ie = _(Ze.params, Be), B = A(Ie);
        (Be < Ze.params.length || D(Ze.params)) && B(ee[Be]) && Ke.push(Ze);
      }), Ke.length === 0) {
        if (Ce = I(Oe, Be), Ce.length > 0) {
          const Ze = c(ee[Be]);
          return Ee = new TypeError("Unexpected type of argument in function " + De + " (expected: " + Ce.join(" or ") + ", actual: " + Ze.join(" | ") + ", index: " + Be + ")"), Ee.data = {
            category: "wrongType",
            fn: De,
            index: Be,
            actual: Ze,
            expected: Ce
          }, Ee;
        }
      } else
        Oe = Ke;
    }
    const Le = Oe.map(function(Ke) {
      return D(Ke.params) ? 1 / 0 : Ke.params.length;
    });
    if (ee.length < Math.min.apply(null, Le))
      return Ce = I(Oe, Be), Ee = new TypeError("Too few arguments in function " + De + " (expected: " + Ce.join(" or ") + ", index: " + ee.length + ")"), Ee.data = {
        category: "tooFewArgs",
        fn: De,
        index: ee.length,
        expected: Ce
      }, Ee;
    const Re = Math.max.apply(null, Le);
    if (ee.length > Re)
      return Ee = new TypeError("Too many arguments in function " + De + " (expected: " + Re + ", actual: " + ee.length + ")"), Ee.data = {
        category: "tooManyArgs",
        fn: De,
        index: ee.length,
        expectedLength: Re
      }, Ee;
    const rt = [];
    for (let Ke = 0; Ke < ee.length; ++Ke)
      rt.push(c(ee[Ke]).join("|"));
    return Ee = new TypeError('Arguments of type "' + rt.join(", ") + '" do not match any of the defined signatures of function ' + De + "."), Ee.data = {
      category: "mismatch",
      actual: rt
    }, Ee;
  }
  function $(Q) {
    let ee = a.length + 1;
    for (let ye = 0; ye < Q.types.length; ye++)
      T(Q.types[ye]) && (ee = Math.min(ee, Q.types[ye].typeIndex));
    return ee;
  }
  function U(Q) {
    let ee = s + 1;
    for (let ye = 0; ye < Q.types.length; ye++)
      T(Q.types[ye]) || (ee = Math.min(ee, Q.types[ye].conversionIndex));
    return ee;
  }
  function k(Q, ee) {
    if (Q.hasAny) {
      if (!ee.hasAny)
        return 1;
    } else if (ee.hasAny)
      return -1;
    if (Q.restParam) {
      if (!ee.restParam)
        return 1;
    } else if (ee.restParam)
      return -1;
    if (Q.hasConversion) {
      if (!ee.hasConversion)
        return 1;
    } else if (ee.hasConversion)
      return -1;
    const ye = $(Q) - $(ee);
    if (ye < 0)
      return -1;
    if (ye > 0)
      return 1;
    const Ee = U(Q) - U(ee);
    return Ee < 0 ? -1 : Ee > 0 ? 1 : 0;
  }
  function L(Q, ee) {
    const ye = Q.params, Ee = ee.params, Ce = ue(ye), De = ue(Ee), Oe = D(ye), Be = D(Ee);
    if (Oe && Ce.hasAny) {
      if (!Be || !De.hasAny)
        return 1;
    } else if (Be && De.hasAny)
      return -1;
    let Le = 0, Re = 0, rt;
    for (rt of ye)
      rt.hasAny && ++Le, rt.hasConversion && ++Re;
    let Ke = 0, Ze = 0;
    for (rt of Ee)
      rt.hasAny && ++Ke, rt.hasConversion && ++Ze;
    if (Le !== Ke)
      return Le - Ke;
    if (Oe && Ce.hasConversion) {
      if (!Be || !De.hasConversion)
        return 1;
    } else if (Be && De.hasConversion)
      return -1;
    if (Re !== Ze)
      return Re - Ze;
    if (Oe) {
      if (!Be)
        return 1;
    } else if (Be)
      return -1;
    const Ie = (ye.length - Ee.length) * (Oe ? -1 : 1);
    if (Ie !== 0)
      return Ie;
    const B = [];
    let ne = 0;
    for (let Te = 0; Te < ye.length; ++Te) {
      const Pe = k(ye[Te], Ee[Te]);
      B.push(Pe), ne += Pe;
    }
    if (ne !== 0)
      return ne;
    let xe;
    for (xe of B)
      if (xe !== 0)
        return xe;
    return 0;
  }
  function R(Q) {
    if (Q.length === 0)
      return [];
    const ee = Q.map(p);
    Q.length > 1 && ee.sort((Ce, De) => Ce.index - De.index);
    let ye = ee[0].conversionsTo;
    if (Q.length === 1)
      return ye;
    ye = ye.concat([]);
    const Ee = new Set(Q);
    for (let Ce = 1; Ce < ee.length; ++Ce) {
      let De;
      for (De of ee[Ce].conversionsTo)
        Ee.has(De.from) || (ye.push(De), Ee.add(De.from));
    }
    return ye;
  }
  function G(Q, ee) {
    let ye = ee;
    if (Q.some((Ce) => Ce.hasConversion)) {
      const Ce = D(Q), De = Q.map(P);
      ye = function() {
        const Be = [], Le = Ce ? arguments.length - 1 : arguments.length;
        for (let Re = 0; Re < Le; Re++)
          Be[Re] = De[Re](arguments[Re]);
        return Ce && (Be[Le] = arguments[Le].map(De[Le])), ee.apply(this, Be);
      };
    }
    let Ee = ye;
    if (D(Q)) {
      const Ce = Q.length - 1;
      Ee = function() {
        return ye.apply(this, ve(arguments, 0, Ce).concat([ve(arguments, Ce)]));
      };
    }
    return Ee;
  }
  function P(Q) {
    let ee, ye, Ee, Ce;
    const De = [], Oe = [];
    switch (Q.types.forEach(function(Be) {
      Be.conversion && (De.push(p(Be.conversion.from).test), Oe.push(Be.conversion.convert));
    }), Oe.length) {
      case 0:
        return function(Le) {
          return Le;
        };
      case 1:
        return ee = De[0], Ee = Oe[0], function(Le) {
          return ee(Le) ? Ee(Le) : Le;
        };
      case 2:
        return ee = De[0], ye = De[1], Ee = Oe[0], Ce = Oe[1], function(Le) {
          return ee(Le) ? Ee(Le) : ye(Le) ? Ce(Le) : Le;
        };
      default:
        return function(Le) {
          for (let Re = 0; Re < Oe.length; Re++)
            if (De[Re](Le))
              return Oe[Re](Le);
          return Le;
        };
    }
  }
  function W(Q) {
    function ee(ye, Ee, Ce) {
      if (Ee < ye.length) {
        const De = ye[Ee];
        let Oe = [];
        if (De.restParam) {
          const Be = De.types.filter(T);
          Be.length < De.types.length && Oe.push({
            types: Be,
            name: "..." + Be.map((Le) => Le.name).join("|"),
            hasAny: Be.some((Le) => Le.isAny),
            hasConversion: !1,
            restParam: !0
          }), Oe.push(De);
        } else
          Oe = De.types.map(function(Be) {
            return {
              types: [Be],
              name: Be.name,
              hasAny: Be.isAny,
              hasConversion: Be.conversion,
              restParam: !1
            };
          });
        return Ne(Oe, function(Be) {
          return ee(ye, Ee + 1, Ce.concat([Be]));
        });
      } else
        return [Ce];
    }
    return ee(Q, 0, []);
  }
  function le(Q, ee) {
    const ye = Math.max(Q.length, ee.length);
    for (let Be = 0; Be < ye; Be++) {
      const Le = O(Q, Be), Re = O(ee, Be);
      let rt = !1, Ke;
      for (Ke of Re)
        if (Le.has(Ke)) {
          rt = !0;
          break;
        }
      if (!rt)
        return !1;
    }
    const Ee = Q.length, Ce = ee.length, De = D(Q), Oe = D(ee);
    return De ? Oe ? Ee === Ce : Ce >= Ee : Oe ? Ee >= Ce : Ee === Ce;
  }
  function Z(Q) {
    return Q.map((ee) => pe(ee) ? V(ee.referToSelf.callback) : re(ee) ? Se(ee.referTo.references, ee.referTo.callback) : ee);
  }
  function H(Q, ee, ye) {
    const Ee = [];
    let Ce;
    for (Ce of Q) {
      let De = ye[Ce];
      if (typeof De != "number")
        throw new TypeError('No definition for referenced signature "' + Ce + '"');
      if (De = ee[De], typeof De != "function")
        return !1;
      Ee.push(De);
    }
    return Ee;
  }
  function te(Q, ee, ye) {
    const Ee = Z(Q), Ce = new Array(Ee.length).fill(!1);
    let De = !0;
    for (; De; ) {
      De = !1;
      let Oe = !0;
      for (let Be = 0; Be < Ee.length; ++Be) {
        if (Ce[Be]) continue;
        const Le = Ee[Be];
        if (pe(Le))
          Ee[Be] = Le.referToSelf.callback(ye), Ee[Be].referToSelf = Le.referToSelf, Ce[Be] = !0, Oe = !1;
        else if (re(Le)) {
          const Re = H(Le.referTo.references, Ee, ee);
          Re ? (Ee[Be] = Le.referTo.callback.apply(this, Re), Ee[Be].referTo = Le.referTo, Ce[Be] = !0, Oe = !1) : De = !0;
        }
      }
      if (Oe && De)
        throw new SyntaxError("Circular reference detected in resolving typed.referTo");
    }
    return Ee;
  }
  function be(Q) {
    const ee = /\bthis(\(|\.signatures\b)/;
    Object.keys(Q).forEach((ye) => {
      const Ee = Q[ye];
      if (ee.test(Ee.toString()))
        throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
    });
  }
  function K(Q, ee) {
    if (o.createCount++, Object.keys(ee).length === 0)
      throw new SyntaxError("No signatures provided");
    o.warnAgainstDeprecatedThis && be(ee);
    const ye = [], Ee = [], Ce = {}, De = [];
    let Oe;
    for (Oe in ee) {
      if (!Object.prototype.hasOwnProperty.call(ee, Oe))
        continue;
      const Pt = E(Oe);
      if (!Pt) continue;
      ye.forEach(function(Ki) {
        if (le(Ki, Pt))
          throw new TypeError('Conflicting signatures "' + N(Ki) + '" and "' + N(Pt) + '".');
      }), ye.push(Pt);
      const Gr = Ee.length;
      Ee.push(ee[Oe]);
      const Co = Pt.map(C);
      let Xi;
      for (Xi of W(Co)) {
        const Ki = N(Xi);
        De.push({
          params: Xi,
          name: Ki,
          fn: Gr
        }), Xi.every((ws) => !ws.hasConversion) && (Ce[Ki] = Gr);
      }
    }
    De.sort(L);
    const Be = te(Ee, Ce, tr);
    let Le;
    for (Le in Ce)
      Object.prototype.hasOwnProperty.call(Ce, Le) && (Ce[Le] = Be[Ce[Le]]);
    const Re = [], rt = /* @__PURE__ */ new Map();
    for (Le of De)
      rt.has(Le.name) || (Le.fn = Be[Le.fn], Re.push(Le), rt.set(Le.name, Le));
    const Ke = Re[0] && Re[0].params.length <= 2 && !D(Re[0].params), Ze = Re[1] && Re[1].params.length <= 2 && !D(Re[1].params), Ie = Re[2] && Re[2].params.length <= 2 && !D(Re[2].params), B = Re[3] && Re[3].params.length <= 2 && !D(Re[3].params), ne = Re[4] && Re[4].params.length <= 2 && !D(Re[4].params), xe = Re[5] && Re[5].params.length <= 2 && !D(Re[5].params), Te = Ke && Ze && Ie && B && ne && xe;
    for (let Pt = 0; Pt < Re.length; ++Pt)
      Re[Pt].test = M(Re[Pt].params);
    const Pe = Ke ? A(Re[0].params[0]) : Tn, Ge = Ze ? A(Re[1].params[0]) : Tn, Ve = Ie ? A(Re[2].params[0]) : Tn, ft = B ? A(Re[3].params[0]) : Tn, lt = ne ? A(Re[4].params[0]) : Tn, Nr = xe ? A(Re[5].params[0]) : Tn, Ur = Ke ? A(Re[0].params[1]) : Tn, An = Ze ? A(Re[1].params[1]) : Tn, Or = Ie ? A(Re[2].params[1]) : Tn, Aa = B ? A(Re[3].params[1]) : Tn, fr = ne ? A(Re[4].params[1]) : Tn, Fr = xe ? A(Re[5].params[1]) : Tn;
    for (let Pt = 0; Pt < Re.length; ++Pt)
      Re[Pt].implementation = G(Re[Pt].params, Re[Pt].fn);
    const Dr = Ke ? Re[0].implementation : Sa, Zt = Ze ? Re[1].implementation : Sa, pr = Ie ? Re[2].implementation : Sa, Ji = B ? Re[3].implementation : Sa, Kt = ne ? Re[4].implementation : Sa, sr = xe ? Re[5].implementation : Sa, Ar = Ke ? Re[0].params.length : -1, En = Ze ? Re[1].params.length : -1, er = Ie ? Re[2].params.length : -1, ii = B ? Re[3].params.length : -1, Yr = ne ? Re[4].params.length : -1, Yi = xe ? Re[5].params.length : -1, bs = Te ? 6 : 0, It = Re.length, So = Re.map((Pt) => Pt.test), Sm = Re.map((Pt) => Pt.implementation), Sn = function() {
      for (let Gr = bs; Gr < It; Gr++)
        if (So[Gr](arguments))
          return Sm[Gr].apply(this, arguments);
      return o.onMismatch(Q, arguments, Re);
    };
    function tr(Pt, Gr) {
      return arguments.length === Ar && Pe(Pt) && Ur(Gr) ? Dr.apply(this, arguments) : arguments.length === En && Ge(Pt) && An(Gr) ? Zt.apply(this, arguments) : arguments.length === er && Ve(Pt) && Or(Gr) ? pr.apply(this, arguments) : arguments.length === ii && ft(Pt) && Aa(Gr) ? Ji.apply(this, arguments) : arguments.length === Yr && lt(Pt) && fr(Gr) ? Kt.apply(this, arguments) : arguments.length === Yi && Nr(Pt) && Fr(Gr) ? sr.apply(this, arguments) : Sn.apply(this, arguments);
    }
    try {
      Object.defineProperty(tr, "name", {
        value: Q
      });
    } catch {
    }
    return tr.signatures = Ce, tr._typedFunctionData = {
      signatures: Re,
      signatureMap: rt
    }, tr;
  }
  function ce(Q, ee, ye) {
    throw q(Q, ee, ye);
  }
  function de(Q) {
    return ve(Q, 0, Q.length - 1);
  }
  function ue(Q) {
    return Q[Q.length - 1];
  }
  function ve(Q, ee, ye) {
    return Array.prototype.slice.call(Q, ee, ye);
  }
  function he(Q, ee) {
    for (let ye = 0; ye < Q.length; ye++)
      if (ee(Q[ye]))
        return Q[ye];
  }
  function Ne(Q, ee) {
    return Array.prototype.concat.apply([], Q.map(ee));
  }
  function we() {
    const Q = de(arguments).map((ye) => N(E(ye))), ee = ue(arguments);
    if (typeof ee != "function")
      throw new TypeError("Callback function expected as last argument");
    return Se(Q, ee);
  }
  function Se(Q, ee) {
    return {
      referTo: {
        references: Q,
        callback: ee
      }
    };
  }
  function V(Q) {
    if (typeof Q != "function")
      throw new TypeError("Callback function expected as first argument");
    return {
      referToSelf: {
        callback: Q
      }
    };
  }
  function re(Q) {
    return Q && typeof Q.referTo == "object" && Array.isArray(Q.referTo.references) && typeof Q.referTo.callback == "function";
  }
  function pe(Q) {
    return Q && typeof Q.referToSelf == "object" && typeof Q.referToSelf.callback == "function";
  }
  function X(Q, ee) {
    if (!Q)
      return ee;
    if (ee && ee !== Q) {
      const ye = new Error("Function names do not match (expected: " + Q + ", actual: " + ee + ")");
      throw ye.data = {
        actual: ee,
        expected: Q
      }, ye;
    }
    return Q;
  }
  function ie(Q) {
    let ee;
    for (const ye in Q)
      Object.prototype.hasOwnProperty.call(Q, ye) && (h(Q[ye]) || typeof Q[ye].signature == "string") && (ee = X(ee, Q[ye].name));
    return ee;
  }
  function me(Q, ee) {
    let ye;
    for (ye in ee)
      if (Object.prototype.hasOwnProperty.call(ee, ye)) {
        if (ye in Q && ee[ye] !== Q[ye]) {
          const Ee = new Error('Signature "' + ye + '" is defined twice');
          throw Ee.data = {
            signature: ye,
            sourceFunction: ee[ye],
            destFunction: Q[ye]
          }, Ee;
        }
        Q[ye] = ee[ye];
      }
  }
  const Ae = o;
  o = function(Q) {
    const ee = typeof Q == "string", ye = ee ? 1 : 0;
    let Ee = ee ? Q : "";
    const Ce = {};
    for (let De = ye; De < arguments.length; ++De) {
      const Oe = arguments[De];
      let Be = {}, Le;
      if (typeof Oe == "function" ? (Le = Oe.name, typeof Oe.signature == "string" ? Be[Oe.signature] = Oe : h(Oe) && (Be = Oe.signatures)) : t(Oe) && (Be = Oe, ee || (Le = ie(Oe))), Object.keys(Be).length === 0) {
        const Re = new TypeError("Argument to 'typed' at index " + De + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
        throw Re.data = {
          index: De,
          argument: Oe
        }, Re;
      }
      ee || (Ee = X(Ee, Le)), me(Ce, Be);
    }
    return K(Ee || "", Ce);
  }, o.create = y2, o.createCount = Ae.createCount, o.onMismatch = ce, o.throwMismatchError = ce, o.createError = q, o.clear = f, o.clearConversions = l, o.addTypes = u, o._findType = p, o.referTo = we, o.referToSelf = V, o.convert = v, o.findSignature = d, o.find = g, o.isTypedFunction = h, o.warnAgainstDeprecatedThis = !0, o.addType = function(Q, ee) {
    let ye = "any";
    ee !== !1 && n.has("Object") && (ye = "Object"), o.addTypes([Q], ye);
  };
  function Me(Q) {
    if (!Q || typeof Q.from != "string" || typeof Q.to != "string" || typeof Q.convert != "function")
      throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
    if (Q.to === Q.from)
      throw new SyntaxError('Illegal to define conversion from "' + Q.from + '" to itself.');
  }
  return o.addConversion = function(Q) {
    let ee = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      override: !1
    };
    Me(Q);
    const ye = p(Q.to), Ee = ye.conversionsTo.find((Ce) => Ce.from === Q.from);
    if (Ee)
      if (ee && ee.override)
        o.removeConversion({
          from: Ee.from,
          to: Q.to,
          convert: Ee.convert
        });
      else
        throw new Error('There is already a conversion from "' + Q.from + '" to "' + ye.name + '"');
    ye.conversionsTo.push({
      from: Q.from,
      convert: Q.convert,
      index: s++
    });
  }, o.addConversions = function(Q, ee) {
    Q.forEach((ye) => o.addConversion(ye, ee));
  }, o.removeConversion = function(Q) {
    Me(Q);
    const ee = p(Q.to), ye = he(ee.conversionsTo, (Ce) => Ce.from === Q.from);
    if (!ye)
      throw new Error("Attempt to remove nonexistent conversion from " + Q.from + " to " + Q.to);
    if (ye.convert !== Q.convert)
      throw new Error("Conversion to remove does not match existing conversion");
    const Ee = ee.conversionsTo.indexOf(ye);
    ee.conversionsTo.splice(Ee, 1);
  }, o.resolve = function(Q, ee) {
    if (!h(Q))
      throw new TypeError(Hg);
    const ye = Q._typedFunctionData.signatures;
    for (let Ee = 0; Ee < ye.length; ++Ee)
      if (ye[Ee].test(ee))
        return ye[Ee];
    return null;
  }, o;
}
const ea = y2();
function Xe(t) {
  return typeof t == "boolean" ? !0 : isFinite(t) ? t === Math.round(t) : !1;
}
function VS(t) {
  return /^-?\d+$/.test(t);
}
function Ii(t, e) {
  return e.number === "bigint" && !VS(t) ? e.numberFallback : e.number;
}
var Ci = Math.sign || function(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}, WS = Math.log2 || function(e) {
  return Math.log(e) / Math.LN2;
}, jS = Math.log10 || function(e) {
  return Math.log(e) / Math.LN10;
}, ZS = Math.log1p || function(t) {
  return Math.log(t + 1);
}, JS = Math.cbrt || function(e) {
  if (e === 0)
    return e;
  var r = e < 0, n;
  return r && (e = -e), isFinite(e) ? (n = Math.exp(Math.log(e) / 3), n = (e / (n * n) + 2 * n) / 3) : n = e, r ? -n : n;
}, YS = Math.expm1 || function(e) {
  return e >= 2e-4 || e <= -2e-4 ? Math.exp(e) - 1 : e + e * e / 2 + e * e * e / 6;
};
function Im(t, e, r) {
  var n = {
    2: "0b",
    8: "0o",
    16: "0x"
  }, a = n[e], s = "";
  if (r) {
    if (r < 1)
      throw new Error("size must be in greater than 0");
    if (!Xe(r))
      throw new Error("size must be an integer");
    if (t > 2 ** (r - 1) - 1 || t < -(2 ** (r - 1)))
      throw new Error("Value must be in range [-2^".concat(r - 1, ", 2^").concat(r - 1, "-1]"));
    if (!Xe(t))
      throw new Error("Value must be an integer");
    t < 0 && (t = t + 2 ** r), s = "i".concat(r);
  }
  var o = "";
  return t < 0 && (t = -t, o = "-"), "".concat(o).concat(a).concat(t.toString(e)).concat(s);
}
function na(t, e) {
  if (typeof e == "function")
    return e(t);
  if (t === 1 / 0)
    return "Infinity";
  if (t === -1 / 0)
    return "-Infinity";
  if (isNaN(t))
    return "NaN";
  var {
    notation: r,
    precision: n,
    wordSize: a
  } = x2(e);
  switch (r) {
    case "fixed":
      return b2(t, n);
    case "exponential":
      return w2(t, n);
    case "engineering":
      return XS(t, n);
    case "bin":
      return Im(t, 2, a);
    case "oct":
      return Im(t, 8, a);
    case "hex":
      return Im(t, 16, a);
    case "auto":
      return KS(t, n, e).replace(/((\.\d*?)(0+))($|e)/, function() {
        var s = arguments[2], o = arguments[4];
        return s !== "." ? s + o : o;
      });
    default:
      throw new Error('Unknown notation "' + r + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function x2(t) {
  var e = "auto", r, n;
  if (t !== void 0)
    if (ht(t))
      r = t;
    else if (ct(t))
      r = t.toNumber();
    else if (Wa(t))
      t.precision !== void 0 && (r = Qg(t.precision, () => {
        throw new Error('Option "precision" must be a number or BigNumber');
      })), t.wordSize !== void 0 && (n = Qg(t.wordSize, () => {
        throw new Error('Option "wordSize" must be a number or BigNumber');
      })), t.notation && (e = t.notation);
    else
      throw new Error("Unsupported type of options, number, BigNumber, or object expected");
  return {
    notation: e,
    precision: r,
    wordSize: n
  };
}
function $s(t) {
  var e = String(t).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!e)
    throw new SyntaxError("Invalid number " + t);
  var r = e[1], n = e[2], a = parseFloat(e[4] || "0"), s = n.indexOf(".");
  a += s !== -1 ? s - 1 : n.length - 1;
  var o = n.replace(".", "").replace(/^0*/, function(p) {
    return a -= p.length, "";
  }).replace(/0*$/, "").split("").map(function(p) {
    return parseInt(p);
  });
  return o.length === 0 && (o.push(0), a++), {
    sign: r,
    coefficients: o,
    exponent: a
  };
}
function XS(t, e) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var r = $s(t), n = Su(r, e), a = n.exponent, s = n.coefficients, o = a % 3 === 0 ? a : a < 0 ? a - 3 - a % 3 : a - a % 3;
  if (ht(e))
    for (; e > s.length || a - o + 1 > s.length; )
      s.push(0);
  else
    for (var p = Math.abs(a - o) - (s.length - 1), u = 0; u < p; u++)
      s.push(0);
  for (var f = Math.abs(a - o), l = 1; f > 0; )
    l++, f--;
  var c = s.slice(l).join(""), h = ht(e) && c.length || c.match(/[1-9]/) ? "." + c : "", d = s.slice(0, l).join("") + h + "e" + (a >= 0 ? "+" : "") + o.toString();
  return n.sign + d;
}
function b2(t, e) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var r = $s(t), n = typeof e == "number" ? Su(r, r.exponent + 1 + e) : r, a = n.coefficients, s = n.exponent + 1, o = s + (e || 0);
  return a.length < o && (a = a.concat(qa(o - a.length))), s < 0 && (a = qa(-s + 1).concat(a), s = 1), s < a.length && a.splice(s, 0, s === 0 ? "0." : "."), n.sign + a.join("");
}
function w2(t, e) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var r = $s(t), n = e ? Su(r, e) : r, a = n.coefficients, s = n.exponent;
  a.length < e && (a = a.concat(qa(e - a.length)));
  var o = a.shift();
  return n.sign + o + (a.length > 0 ? "." + a.join("") : "") + "e" + (s >= 0 ? "+" : "") + s;
}
function KS(t, e, r) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var n = Vg(r?.lowerExp, -3), a = Vg(r?.upperExp, 5), s = $s(t), o = e ? Su(s, e) : s;
  if (o.exponent < n || o.exponent >= a)
    return w2(t, e);
  var p = o.coefficients, u = o.exponent;
  p.length < e && (p = p.concat(qa(e - p.length))), p = p.concat(qa(u - p.length + 1 + (p.length < e ? e - p.length : 0))), p = qa(-u).concat(p);
  var f = u > 0 ? u : 0;
  return f < p.length - 1 && p.splice(f + 1, 0, "."), o.sign + p.join("");
}
function Su(t, e) {
  for (var r = {
    sign: t.sign,
    coefficients: t.coefficients,
    exponent: t.exponent
  }, n = r.coefficients; e <= 0; )
    n.unshift(0), r.exponent++, e++;
  if (n.length > e) {
    var a = n.splice(e, n.length - e);
    if (a[0] >= 5) {
      var s = e - 1;
      for (n[s]++; n[s] === 10; )
        n.pop(), s === 0 && (n.unshift(0), r.exponent++, s++), s--, n[s]++;
    }
  }
  return r;
}
function qa(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push(0);
  return e;
}
function eC(t) {
  return t.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
function Lr(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-8, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  if (r <= 0)
    throw new Error("Relative tolerance must be greater than 0");
  if (n < 0)
    throw new Error("Absolute tolerance must be at least 0");
  return isNaN(t) || isNaN(e) ? !1 : !isFinite(t) || !isFinite(e) ? t === e : t === e ? !0 : Math.abs(t - e) <= Math.max(r * Math.max(Math.abs(t), Math.abs(e)), n);
}
var tC = Math.acosh || function(t) {
  return Math.log(Math.sqrt(t * t - 1) + t);
}, rC = Math.asinh || function(t) {
  return Math.log(Math.sqrt(t * t + 1) + t);
}, nC = Math.atanh || function(t) {
  return Math.log((1 + t) / (1 - t)) / 2;
}, iC = Math.cosh || function(t) {
  return (Math.exp(t) + Math.exp(-t)) / 2;
}, aC = Math.sinh || function(t) {
  return (Math.exp(t) - Math.exp(-t)) / 2;
}, sC = Math.tanh || function(t) {
  var e = Math.exp(2 * t);
  return (e - 1) / (e + 1);
};
function oC(t, e) {
  var r = !0, n = e > 0 ? !0 : e < 0 ? !1 : 1 / e === 1 / 0;
  return r ^ n ? -t : t;
}
function Qg(t, e) {
  if (ht(t))
    return t;
  if (ct(t))
    return t.toNumber();
  e();
}
function Vg(t, e) {
  return ht(t) ? t : ct(t) ? t.toNumber() : e;
}
function j(t, e, r, n) {
  function a(s) {
    var o = HS(s, e.map(N2));
    return uC(t, e, s), r(o);
  }
  return a.isFactory = !0, a.fn = t, a.dependencies = e.slice().sort(), n && (a.meta = n), a;
}
function Ms(t) {
  return typeof t == "function" && typeof t.fn == "string" && Array.isArray(t.dependencies);
}
function uC(t, e, r) {
  var n = e.filter((s) => !lC(s)).every((s) => r[s] !== void 0);
  if (!n) {
    var a = e.filter((s) => r[s] === void 0);
    throw new Error('Cannot create function "'.concat(t, '", ') + "some dependencies are missing: ".concat(a.map((s) => '"'.concat(s, '"')).join(", "), "."));
  }
}
function lC(t) {
  return t && t[0] === "?";
}
function N2(t) {
  return t && t[0] === "?" ? t.slice(1) : t;
}
function Kr(t, e) {
  if (A2(t) && D2(t, e))
    return t[e];
  throw typeof t[e] == "function" && Nd(t, e) ? new Error('Cannot access method "' + e + '" as a property') : new Error('No access to property "' + e + '"');
}
function La(t, e, r) {
  if (A2(t) && D2(t, e))
    return t[e] = r, r;
  throw new Error('No access to property "' + e + '"');
}
function cC(t, e) {
  return e in t;
}
function D2(t, e) {
  return !t || typeof t != "object" ? !1 : We(pC, e) ? !0 : !(e in Object.prototype || e in Function.prototype);
}
function fC(t, e) {
  if (!Nd(t, e))
    throw new Error('No access to method "' + e + '"');
  return t[e];
}
function Nd(t, e) {
  return t == null || typeof t[e] != "function" || We(t, e) && Object.getPrototypeOf && e in Object.getPrototypeOf(t) ? !1 : We(hC, e) ? !0 : !(e in Object.prototype || e in Function.prototype);
}
function A2(t) {
  return typeof t == "object" && t && t.constructor === Object;
}
var pC = {
  length: !0,
  name: !0
}, hC = {
  toString: !0,
  valueOf: !0,
  toLocaleString: !0
};
class Cu {
  constructor(e) {
    this.wrappedObject = e, this[Symbol.iterator] = this.entries;
  }
  keys() {
    return Object.keys(this.wrappedObject).values();
  }
  get(e) {
    return Kr(this.wrappedObject, e);
  }
  set(e, r) {
    return La(this.wrappedObject, e, r), this;
  }
  has(e) {
    return cC(this.wrappedObject, e);
  }
  entries() {
    return S2(this.keys(), (e) => [e, this.get(e)]);
  }
  forEach(e) {
    for (var r of this.keys())
      e(this.get(r), r, this);
  }
  delete(e) {
    delete this.wrappedObject[e];
  }
  clear() {
    for (var e of this.keys())
      this.delete(e);
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
}
class E2 {
  /**
   * @param {Map} a
   * @param {Map} b
   * @param {Set} bKeys
   */
  constructor(e, r, n) {
    this.a = e, this.b = r, this.bKeys = n, this[Symbol.iterator] = this.entries;
  }
  get(e) {
    return this.bKeys.has(e) ? this.b.get(e) : this.a.get(e);
  }
  set(e, r) {
    return this.bKeys.has(e) ? this.b.set(e, r) : this.a.set(e, r), this;
  }
  has(e) {
    return this.b.has(e) || this.a.has(e);
  }
  keys() {
    return (/* @__PURE__ */ new Set([...this.a.keys(), ...this.b.keys()]))[Symbol.iterator]();
  }
  entries() {
    return S2(this.keys(), (e) => [e, this.get(e)]);
  }
  forEach(e) {
    for (var r of this.keys())
      e(this.get(r), r, this);
  }
  delete(e) {
    return this.bKeys.has(e) ? this.b.delete(e) : this.a.delete(e);
  }
  clear() {
    this.a.clear(), this.b.clear();
  }
  get size() {
    return [...this.keys()].length;
  }
}
function S2(t, e) {
  return {
    next: () => {
      var r = t.next();
      return r.done ? r : {
        value: e(r.value),
        done: !1
      };
    }
  };
}
function Os() {
  return /* @__PURE__ */ new Map();
}
function Ia(t) {
  if (!t)
    return Os();
  if (C2(t))
    return t;
  if (Wa(t))
    return new Cu(t);
  throw new Error("createMap can create maps from objects or Maps");
}
function mC(t) {
  if (t instanceof Cu)
    return t.wrappedObject;
  var e = {};
  for (var r of t.keys()) {
    var n = t.get(r);
    La(e, r, n);
  }
  return e;
}
function C2(t) {
  return t ? t instanceof Map || t instanceof Cu || typeof t.set == "function" && typeof t.get == "function" && typeof t.keys == "function" && typeof t.has == "function" : !1;
}
var T2 = function() {
  return T2 = ea.create, ea;
}, dC = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"], Tu = /* @__PURE__ */ j("typed", dC, function(e) {
  var {
    BigNumber: r,
    Complex: n,
    DenseMatrix: a,
    Fraction: s
  } = e, o = T2();
  return o.clear(), o.addTypes([
    {
      name: "number",
      test: ht
    },
    {
      name: "Complex",
      test: Mn
    },
    {
      name: "BigNumber",
      test: ct
    },
    {
      name: "bigint",
      test: ld
    },
    {
      name: "Fraction",
      test: Fi
    },
    {
      name: "Unit",
      test: Xr
    },
    // The following type matches a valid variable name, i.e., an alphanumeric
    // string starting with an alphabetic character. It is used (at least)
    // in the definition of the derivative() function, as the argument telling
    // what to differentiate over must (currently) be a variable.
    {
      name: "identifier",
      test: (p) => Er && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(p)
    },
    {
      name: "string",
      test: Er
    },
    {
      name: "Chain",
      test: Eu
    },
    {
      name: "Array",
      test: Rt
    },
    {
      name: "Matrix",
      test: tt
    },
    {
      name: "DenseMatrix",
      test: Ra
    },
    {
      name: "SparseMatrix",
      test: oi
    },
    {
      name: "Range",
      test: ks
    },
    {
      name: "Index",
      test: Va
    },
    {
      name: "boolean",
      test: cd
    },
    {
      name: "ResultSet",
      test: fd
    },
    {
      name: "Help",
      test: Au
    },
    {
      name: "function",
      test: pd
    },
    {
      name: "Date",
      test: hd
    },
    {
      name: "RegExp",
      test: md
    },
    {
      name: "null",
      test: dd
    },
    {
      name: "undefined",
      test: vd
    },
    {
      name: "AccessorNode",
      test: pi
    },
    {
      name: "ArrayNode",
      test: un
    },
    {
      name: "AssignmentNode",
      test: gd
    },
    {
      name: "BlockNode",
      test: yd
    },
    {
      name: "ConditionalNode",
      test: xd
    },
    {
      name: "ConstantNode",
      test: Ct
    },
    {
      name: "FunctionNode",
      test: Wn
    },
    {
      name: "FunctionAssignmentNode",
      test: oa
    },
    {
      name: "IndexNode",
      test: qi
    },
    {
      name: "Node",
      test: Ut
    },
    {
      name: "ObjectNode",
      test: ja
    },
    {
      name: "OperatorNode",
      test: or
    },
    {
      name: "ParenthesisNode",
      test: kn
    },
    {
      name: "RangeNode",
      test: bd
    },
    {
      name: "RelationalNode",
      test: wd
    },
    {
      name: "SymbolNode",
      test: mr
    },
    {
      name: "Map",
      test: C2
    },
    {
      name: "Object",
      test: Wa
    }
    // order 'Object' last, it matches on other classes too
  ]), o.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function(u) {
      if (r || Mo(u), eC(u) > 15)
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + u + "). Use function bignumber(x) to convert to BigNumber.");
      return new r(u);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function(u) {
      return n || Oo(u), new n(u, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function(u) {
      return n || Oo(u), new n(u.toNumber(), 0);
    }
  }, {
    from: "bigint",
    to: "number",
    convert: function(u) {
      if (u > Number.MAX_SAFE_INTEGER)
        throw new TypeError("Cannot implicitly convert bigint to number: value exceeds the max safe integer value (value: " + u + ")");
      return Number(u);
    }
  }, {
    from: "bigint",
    to: "BigNumber",
    convert: function(u) {
      return r || Mo(u), new r(u.toString());
    }
  }, {
    from: "bigint",
    to: "Fraction",
    convert: function(u) {
      return s || Fo(u), new s(u.toString());
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function(u) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function(u) {
      return n || Oo(u), new n(u.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function(u) {
      s || Fo(u);
      var f = new s(u);
      if (f.valueOf() !== u)
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + u + "). Use function fraction(x) to convert to Fraction.");
      return f;
    }
  }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf()
    //  }
    // }, {
    from: "string",
    to: "number",
    convert: function(u) {
      var f = Number(u);
      if (isNaN(f))
        throw new Error('Cannot convert "' + u + '" to a number');
      return f;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function(u) {
      r || Mo(u);
      try {
        return new r(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "bigint",
    convert: function(u) {
      try {
        return BigInt(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to BigInt');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function(u) {
      s || Fo(u);
      try {
        return new s(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function(u) {
      n || Oo(u);
      try {
        return new n(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function(u) {
      return +u;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function(u) {
      return r || Mo(u), new r(+u);
    }
  }, {
    from: "boolean",
    to: "bigint",
    convert: function(u) {
      return BigInt(+u);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function(u) {
      return s || Fo(u), new s(+u);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function(u) {
      return String(u);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function(u) {
      return a || vC(), new a(u);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function(u) {
      return u.valueOf();
    }
  }]), o.onMismatch = (p, u, f) => {
    var l = o.createError(p, u, f);
    if (["wrongType", "mismatch"].includes(l.data.category) && u.length === 1 && cn(u[0]) && // check if the function can be unary:
    f.some((h) => !h.params.includes(","))) {
      var c = new TypeError("Function '".concat(p, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(p, ")'."));
      throw c.data = l.data, c;
    }
    throw l;
  }, o.onMismatch = (p, u, f) => {
    var l = o.createError(p, u, f);
    if (["wrongType", "mismatch"].includes(l.data.category) && u.length === 1 && cn(u[0]) && // check if the function can be unary:
    f.some((h) => !h.params.includes(","))) {
      var c = new TypeError("Function '".concat(p, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(p, ")'."));
      throw c.data = l.data, c;
    }
    throw l;
  }, o;
});
function Mo(t) {
  throw new Error("Cannot convert value ".concat(t, " into a BigNumber: no class 'BigNumber' provided"));
}
function Oo(t) {
  throw new Error("Cannot convert value ".concat(t, " into a Complex number: no class 'Complex' provided"));
}
function vC() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function Fo(t) {
  throw new Error("Cannot convert value ".concat(t, " into a Fraction, no class 'Fraction' provided."));
}
var gC = "ResultSet", yC = [], _u = /* @__PURE__ */ j(gC, yC, () => {
  function t(e) {
    if (!(this instanceof t))
      throw new SyntaxError("Constructor must be called with the new operator");
    this.entries = e || [];
  }
  return t.prototype.type = "ResultSet", t.prototype.isResultSet = !0, t.prototype.valueOf = function() {
    return this.entries;
  }, t.prototype.toString = function() {
    return "[" + this.entries.join(", ") + "]";
  }, t.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  }, t.fromJSON = function(e) {
    return new t(e.entries);
  }, t;
}, {
  isClass: !0
});
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var Ma = 9e15, Bi = 1e9, Hm = "0123456789abcdef", Ko = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", eu = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", Qm = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -Ma,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: Ma,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, _2, ui, mt = !0, Mu = "[DecimalError] ", _i = Mu + "Invalid argument: ", M2 = Mu + "Precision limit exceeded", O2 = Mu + "crypto unavailable", F2 = "[object Decimal]", Wr = Math.floor, gr = Math.pow, xC = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, bC = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, wC = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, q2 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Pn = 1e7, at = 7, NC = 9007199254740991, DC = Ko.length - 1, Vm = eu.length - 1, ke = { toStringTag: F2 };
ke.absoluteValue = ke.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), et(t);
};
ke.ceil = function() {
  return et(new this.constructor(this), this.e + 1, 2);
};
ke.clampedTo = ke.clamp = function(t, e) {
  var r, n = this, a = n.constructor;
  if (t = new a(t), e = new a(e), !t.s || !e.s) return new a(NaN);
  if (t.gt(e)) throw Error(_i + e);
  return r = n.cmp(t), r < 0 ? t : n.cmp(e) > 0 ? e : new a(n);
};
ke.comparedTo = ke.cmp = function(t) {
  var e, r, n, a, s = this, o = s.d, p = (t = new s.constructor(t)).d, u = s.s, f = t.s;
  if (!o || !p)
    return !u || !f ? NaN : u !== f ? u : o === p ? 0 : !o ^ u < 0 ? 1 : -1;
  if (!o[0] || !p[0]) return o[0] ? u : p[0] ? -f : 0;
  if (u !== f) return u;
  if (s.e !== t.e) return s.e > t.e ^ u < 0 ? 1 : -1;
  for (n = o.length, a = p.length, e = 0, r = n < a ? n : a; e < r; ++e)
    if (o[e] !== p[e]) return o[e] > p[e] ^ u < 0 ? 1 : -1;
  return n === a ? 0 : n > a ^ u < 0 ? 1 : -1;
};
ke.cosine = ke.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + at, n.rounding = 1, r = AC(n, P2(n, r)), n.precision = t, n.rounding = e, et(ui == 2 || ui == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
ke.cubeRoot = ke.cbrt = function() {
  var t, e, r, n, a, s, o, p, u, f, l = this, c = l.constructor;
  if (!l.isFinite() || l.isZero()) return new c(l);
  for (mt = !1, s = l.s * gr(l.s * l, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = Ir(l.d), t = l.e, (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = gr(r, 1 / 3), t = Wr((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + t : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new c(r), n.s = l.s) : n = new c(s.toString()), o = (t = c.precision) + 3; ; )
    if (p = n, u = p.times(p).times(p), f = u.plus(l), n = Yt(f.plus(l).times(p), f.plus(u), o + 2, 1), Ir(p.d).slice(0, o) === (r = Ir(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !a && r == "4999") {
        if (!a && (et(p, t + 1, 0), p.times(p).times(p).eq(l))) {
          n = p;
          break;
        }
        o += 4, a = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (et(n, t + 1, 1), e = !n.times(n).times(n).eq(l));
        break;
      }
  return mt = !0, et(n, t, c.rounding, e);
};
ke.decimalPlaces = ke.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Wr(this.e / at)) * at, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
ke.dividedBy = ke.div = function(t) {
  return Yt(this, new this.constructor(t));
};
ke.dividedToIntegerBy = ke.divToInt = function(t) {
  var e = this, r = e.constructor;
  return et(Yt(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
ke.equals = ke.eq = function(t) {
  return this.cmp(t) === 0;
};
ke.floor = function() {
  return et(new this.constructor(this), this.e + 1, 3);
};
ke.greaterThan = ke.gt = function(t) {
  return this.cmp(t) > 0;
};
ke.greaterThanOrEqualTo = ke.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
ke.hyperbolicCosine = ke.cosh = function() {
  var t, e, r, n, a, s = this, o = s.constructor, p = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return p;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, a = s.d.length, a < 32 ? (t = Math.ceil(a / 3), e = (1 / Fu(4, t)).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), s = Pa(o, 1, s.times(e), new o(1), !0);
  for (var u, f = t, l = new o(8); f--; )
    u = s.times(s), s = p.minus(u.times(l.minus(u.times(l))));
  return et(s, o.precision = r, o.rounding = n, !0);
};
ke.hyperbolicSine = ke.sinh = function() {
  var t, e, r, n, a = this, s = a.constructor;
  if (!a.isFinite() || a.isZero()) return new s(a);
  if (e = s.precision, r = s.rounding, s.precision = e + Math.max(a.e, a.sd()) + 4, s.rounding = 1, n = a.d.length, n < 3)
    a = Pa(s, 2, a, a, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, a = a.times(1 / Fu(5, t)), a = Pa(s, 2, a, a, !0);
    for (var o, p = new s(5), u = new s(16), f = new s(20); t--; )
      o = a.times(a), a = a.times(p.plus(o.times(u.times(o).plus(f))));
  }
  return s.precision = e, s.rounding = r, et(a, e, r, !0);
};
ke.hyperbolicTangent = ke.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, Yt(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
ke.inverseCosine = ke.acos = function() {
  var t, e = this, r = e.constructor, n = e.abs().cmp(1), a = r.precision, s = r.rounding;
  return n !== -1 ? n === 0 ? e.isNeg() ? Ln(r, a, s) : new r(0) : new r(NaN) : e.isZero() ? Ln(r, a + 4, s).times(0.5) : (r.precision = a + 6, r.rounding = 1, e = e.asin(), t = Ln(r, a + 4, s).times(0.5), r.precision = a, r.rounding = s, t.minus(e));
};
ke.inverseHyperbolicCosine = ke.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, mt = !1, r = r.times(r).minus(1).sqrt().plus(r), mt = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
ke.inverseHyperbolicSine = ke.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, mt = !1, r = r.times(r).plus(1).sqrt().plus(r), mt = !0, n.precision = t, n.rounding = e, r.ln());
};
ke.inverseHyperbolicTangent = ke.atanh = function() {
  var t, e, r, n, a = this, s = a.constructor;
  return a.isFinite() ? a.e >= 0 ? new s(a.abs().eq(1) ? a.s / 0 : a.isZero() ? a : NaN) : (t = s.precision, e = s.rounding, n = a.sd(), Math.max(n, t) < 2 * -a.e - 1 ? et(new s(a), t, e, !0) : (s.precision = r = n - a.e, a = Yt(a.plus(1), new s(1).minus(a), r + t, 1), s.precision = t + 4, s.rounding = 1, a = a.ln(), s.precision = t, s.rounding = e, a.times(0.5))) : new s(NaN);
};
ke.inverseSine = ke.asin = function() {
  var t, e, r, n, a = this, s = a.constructor;
  return a.isZero() ? new s(a) : (e = a.abs().cmp(1), r = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (t = Ln(s, r + 4, n).times(0.5), t.s = a.s, t) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, a = a.div(new s(1).minus(a.times(a)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, a.times(2)));
};
ke.inverseTangent = ke.atan = function() {
  var t, e, r, n, a, s, o, p, u, f = this, l = f.constructor, c = l.precision, h = l.rounding;
  if (f.isFinite()) {
    if (f.isZero())
      return new l(f);
    if (f.abs().eq(1) && c + 4 <= Vm)
      return o = Ln(l, c + 4, h).times(0.25), o.s = f.s, o;
  } else {
    if (!f.s) return new l(NaN);
    if (c + 4 <= Vm)
      return o = Ln(l, c + 4, h).times(0.5), o.s = f.s, o;
  }
  for (l.precision = p = c + 10, l.rounding = 1, r = Math.min(28, p / at + 2 | 0), t = r; t; --t) f = f.div(f.times(f).plus(1).sqrt().plus(1));
  for (mt = !1, e = Math.ceil(p / at), n = 1, u = f.times(f), o = new l(f), a = f; t !== -1; )
    if (a = a.times(u), s = o.minus(a.div(n += 2)), a = a.times(u), o = s.plus(a.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === s.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), mt = !0, et(o, l.precision = c, l.rounding = h, !0);
};
ke.isFinite = function() {
  return !!this.d;
};
ke.isInteger = ke.isInt = function() {
  return !!this.d && Wr(this.e / at) > this.d.length - 2;
};
ke.isNaN = function() {
  return !this.s;
};
ke.isNegative = ke.isNeg = function() {
  return this.s < 0;
};
ke.isPositive = ke.isPos = function() {
  return this.s > 0;
};
ke.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
ke.lessThan = ke.lt = function(t) {
  return this.cmp(t) < 0;
};
ke.lessThanOrEqualTo = ke.lte = function(t) {
  return this.cmp(t) < 1;
};
ke.logarithm = ke.log = function(t) {
  var e, r, n, a, s, o, p, u, f = this, l = f.constructor, c = l.precision, h = l.rounding, d = 5;
  if (t == null)
    t = new l(10), e = !0;
  else {
    if (t = new l(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new l(NaN);
    e = t.eq(10);
  }
  if (r = f.d, f.s < 0 || !r || !r[0] || f.eq(1))
    return new l(r && !r[0] ? -1 / 0 : f.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      s = !0;
    else {
      for (a = r[0]; a % 10 === 0; ) a /= 10;
      s = a !== 1;
    }
  if (mt = !1, p = c + d, o = Ti(f, p), n = e ? tu(l, p + 10) : Ti(t, p), u = Yt(o, n, p, 1), Fs(u.d, a = c, h))
    do
      if (p += 10, o = Ti(f, p), n = e ? tu(l, p + 10) : Ti(t, p), u = Yt(o, n, p, 1), !s) {
        +Ir(u.d).slice(a + 1, a + 15) + 1 == 1e14 && (u = et(u, c + 1, 0));
        break;
      }
    while (Fs(u.d, a += 10, h));
  return mt = !0, et(u, c, h);
};
ke.minus = ke.sub = function(t) {
  var e, r, n, a, s, o, p, u, f, l, c, h, d = this, g = d.constructor;
  if (t = new g(t), !d.d || !t.d)
    return !d.s || !t.s ? t = new g(NaN) : d.d ? t.s = -t.s : t = new g(t.d || d.s !== t.s ? d : NaN), t;
  if (d.s != t.s)
    return t.s = -t.s, d.plus(t);
  if (f = d.d, h = t.d, p = g.precision, u = g.rounding, !f[0] || !h[0]) {
    if (h[0]) t.s = -t.s;
    else if (f[0]) t = new g(d);
    else return new g(u === 3 ? -0 : 0);
    return mt ? et(t, p, u) : t;
  }
  if (r = Wr(t.e / at), l = Wr(d.e / at), f = f.slice(), s = l - r, s) {
    for (c = s < 0, c ? (e = f, s = -s, o = h.length) : (e = h, r = l, o = f.length), n = Math.max(Math.ceil(p / at), o) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = f.length, o = h.length, c = n < o, c && (o = n), n = 0; n < o; n++)
      if (f[n] != h[n]) {
        c = f[n] < h[n];
        break;
      }
    s = 0;
  }
  for (c && (e = f, f = h, h = e, t.s = -t.s), o = f.length, n = h.length - o; n > 0; --n) f[o++] = 0;
  for (n = h.length; n > s; ) {
    if (f[--n] < h[n]) {
      for (a = n; a && f[--a] === 0; ) f[a] = Pn - 1;
      --f[a], f[n] += Pn;
    }
    f[n] -= h[n];
  }
  for (; f[--o] === 0; ) f.pop();
  for (; f[0] === 0; f.shift()) --r;
  return f[0] ? (t.d = f, t.e = Ou(f, r), mt ? et(t, p, u) : t) : new g(u === 3 ? -0 : 0);
};
ke.modulo = ke.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? et(new n(r), n.precision, n.rounding) : (mt = !1, n.modulo == 9 ? (e = Yt(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = Yt(r, t, 0, n.modulo, 1), e = e.times(t), mt = !0, r.minus(e));
};
ke.naturalExponential = ke.exp = function() {
  return Wm(this);
};
ke.naturalLogarithm = ke.ln = function() {
  return Ti(this);
};
ke.negated = ke.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, et(t);
};
ke.plus = ke.add = function(t) {
  var e, r, n, a, s, o, p, u, f, l, c = this, h = c.constructor;
  if (t = new h(t), !c.d || !t.d)
    return !c.s || !t.s ? t = new h(NaN) : c.d || (t = new h(t.d || c.s === t.s ? c : NaN)), t;
  if (c.s != t.s)
    return t.s = -t.s, c.minus(t);
  if (f = c.d, l = t.d, p = h.precision, u = h.rounding, !f[0] || !l[0])
    return l[0] || (t = new h(c)), mt ? et(t, p, u) : t;
  if (s = Wr(c.e / at), n = Wr(t.e / at), f = f.slice(), a = s - n, a) {
    for (a < 0 ? (r = f, a = -a, o = l.length) : (r = l, n = s, o = f.length), s = Math.ceil(p / at), o = s > o ? s + 1 : o + 1, a > o && (a = o, r.length = 1), r.reverse(); a--; ) r.push(0);
    r.reverse();
  }
  for (o = f.length, a = l.length, o - a < 0 && (a = o, r = l, l = f, f = r), e = 0; a; )
    e = (f[--a] = f[a] + l[a] + e) / Pn | 0, f[a] %= Pn;
  for (e && (f.unshift(e), ++n), o = f.length; f[--o] == 0; ) f.pop();
  return t.d = f, t.e = Ou(f, n), mt ? et(t, p, u) : t;
};
ke.precision = ke.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(_i + t);
  return r.d ? (e = I2(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
ke.round = function() {
  var t = this, e = t.constructor;
  return et(new e(t), t.e + 1, e.rounding);
};
ke.sine = ke.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + at, n.rounding = 1, r = SC(n, P2(n, r)), n.precision = t, n.rounding = e, et(ui > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
ke.squareRoot = ke.sqrt = function() {
  var t, e, r, n, a, s, o = this, p = o.d, u = o.e, f = o.s, l = o.constructor;
  if (f !== 1 || !p || !p[0])
    return new l(!f || f < 0 && (!p || p[0]) ? NaN : p ? o : 1 / 0);
  for (mt = !1, f = Math.sqrt(+o), f == 0 || f == 1 / 0 ? (e = Ir(p), (e.length + u) % 2 == 0 && (e += "0"), f = Math.sqrt(e), u = Wr((u + 1) / 2) - (u < 0 || u % 2), f == 1 / 0 ? e = "5e" + u : (e = f.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + u), n = new l(e)) : n = new l(f.toString()), r = (u = l.precision) + 3; ; )
    if (s = n, n = s.plus(Yt(o, s, r + 2, 1)).times(0.5), Ir(s.d).slice(0, r) === (e = Ir(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !a && e == "4999") {
        if (!a && (et(s, u + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, a = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (et(n, u + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return mt = !0, et(n, u, l.rounding, t);
};
ke.tangent = ke.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = Yt(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, et(ui == 2 || ui == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
ke.times = ke.mul = function(t) {
  var e, r, n, a, s, o, p, u, f, l = this, c = l.constructor, h = l.d, d = (t = new c(t)).d;
  if (t.s *= l.s, !h || !h[0] || !d || !d[0])
    return new c(!t.s || h && !h[0] && !d || d && !d[0] && !h ? NaN : !h || !d ? t.s / 0 : t.s * 0);
  for (r = Wr(l.e / at) + Wr(t.e / at), u = h.length, f = d.length, u < f && (s = h, h = d, d = s, o = u, u = f, f = o), s = [], o = u + f, n = o; n--; ) s.push(0);
  for (n = f; --n >= 0; ) {
    for (e = 0, a = u + n; a > n; )
      p = s[a] + d[n] * h[a - n - 1] + e, s[a--] = p % Pn | 0, e = p / Pn | 0;
    s[a] = (s[a] + e) % Pn | 0;
  }
  for (; !s[--o]; ) s.pop();
  return e ? ++r : s.shift(), t.d = s, t.e = Ou(s, r), mt ? et(t, c.precision, c.rounding) : t;
};
ke.toBinary = function(t, e) {
  return Dd(this, 2, t, e);
};
ke.toDecimalPlaces = ke.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (fn(t, 0, Bi), e === void 0 ? e = n.rounding : fn(e, 0, 8), et(r, t + r.e + 1, e));
};
ke.toExponential = function(t, e) {
  var r, n = this, a = n.constructor;
  return t === void 0 ? r = jn(n, !0) : (fn(t, 0, Bi), e === void 0 ? e = a.rounding : fn(e, 0, 8), n = et(new a(n), t + 1, e), r = jn(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
ke.toFixed = function(t, e) {
  var r, n, a = this, s = a.constructor;
  return t === void 0 ? r = jn(a) : (fn(t, 0, Bi), e === void 0 ? e = s.rounding : fn(e, 0, 8), n = et(new s(a), t + a.e + 1, e), r = jn(n, !1, t + n.e + 1)), a.isNeg() && !a.isZero() ? "-" + r : r;
};
ke.toFraction = function(t) {
  var e, r, n, a, s, o, p, u, f, l, c, h, d = this, g = d.d, v = d.constructor;
  if (!g) return new v(d);
  if (f = r = new v(1), n = u = new v(0), e = new v(n), s = e.e = I2(g) - d.e - 1, o = s % at, e.d[0] = gr(10, o < 0 ? at + o : o), t == null)
    t = s > 0 ? e : f;
  else {
    if (p = new v(t), !p.isInt() || p.lt(f)) throw Error(_i + p);
    t = p.gt(e) ? s > 0 ? e : f : p;
  }
  for (mt = !1, p = new v(Ir(g)), l = v.precision, v.precision = s = g.length * at * 2; c = Yt(p, e, 0, 1, 1), a = r.plus(c.times(n)), a.cmp(t) != 1; )
    r = n, n = a, a = f, f = u.plus(c.times(a)), u = a, a = e, e = p.minus(c.times(a)), p = a;
  return a = Yt(t.minus(r), n, 0, 1, 1), u = u.plus(a.times(f)), r = r.plus(a.times(n)), u.s = f.s = d.s, h = Yt(f, n, s, 1).minus(d).abs().cmp(Yt(u, r, s, 1).minus(d).abs()) < 1 ? [f, n] : [u, r], v.precision = l, mt = !0, h;
};
ke.toHexadecimal = ke.toHex = function(t, e) {
  return Dd(this, 16, t, e);
};
ke.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : fn(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (mt = !1, r = Yt(r, t, 0, e, 1).times(t), mt = !0, et(r)) : (t.s = r.s, r = t), r;
};
ke.toNumber = function() {
  return +this;
};
ke.toOctal = function(t, e) {
  return Dd(this, 8, t, e);
};
ke.toPower = ke.pow = function(t) {
  var e, r, n, a, s, o, p = this, u = p.constructor, f = +(t = new u(t));
  if (!p.d || !t.d || !p.d[0] || !t.d[0]) return new u(gr(+p, f));
  if (p = new u(p), p.eq(1)) return p;
  if (n = u.precision, s = u.rounding, t.eq(1)) return et(p, n, s);
  if (e = Wr(t.e / at), e >= t.d.length - 1 && (r = f < 0 ? -f : f) <= NC)
    return a = B2(u, p, r, n), t.s < 0 ? new u(1).div(a) : et(a, n, s);
  if (o = p.s, o < 0) {
    if (e < t.d.length - 1) return new u(NaN);
    if (t.d[e] & 1 || (o = 1), p.e == 0 && p.d[0] == 1 && p.d.length == 1)
      return p.s = o, p;
  }
  return r = gr(+p, f), e = r == 0 || !isFinite(r) ? Wr(f * (Math.log("0." + Ir(p.d)) / Math.LN10 + p.e + 1)) : new u(r + "").e, e > u.maxE + 1 || e < u.minE - 1 ? new u(e > 0 ? o / 0 : 0) : (mt = !1, u.rounding = p.s = 1, r = Math.min(12, (e + "").length), a = Wm(t.times(Ti(p, n + r)), n), a.d && (a = et(a, n + 5, 1), Fs(a.d, n, s) && (e = n + 10, a = et(Wm(t.times(Ti(p, e + r)), e), e + 5, 1), +Ir(a.d).slice(n + 1, n + 15) + 1 == 1e14 && (a = et(a, n + 1, 0)))), a.s = o, mt = !0, u.rounding = s, et(a, n, s));
};
ke.toPrecision = function(t, e) {
  var r, n = this, a = n.constructor;
  return t === void 0 ? r = jn(n, n.e <= a.toExpNeg || n.e >= a.toExpPos) : (fn(t, 1, Bi), e === void 0 ? e = a.rounding : fn(e, 0, 8), n = et(new a(n), t, e), r = jn(n, t <= n.e || n.e <= a.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
ke.toSignificantDigits = ke.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (fn(t, 1, Bi), e === void 0 ? e = n.rounding : fn(e, 0, 8)), et(new n(r), t, e);
};
ke.toString = function() {
  var t = this, e = t.constructor, r = jn(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
ke.truncated = ke.trunc = function() {
  return et(new this.constructor(this), this.e + 1, 1);
};
ke.valueOf = ke.toJSON = function() {
  var t = this, e = t.constructor, r = jn(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function Ir(t) {
  var e, r, n, a = t.length - 1, s = "", o = t[0];
  if (a > 0) {
    for (s += o, e = 1; e < a; e++)
      n = t[e] + "", r = at - n.length, r && (s += Ei(r)), s += n;
    o = t[e], n = o + "", r = at - n.length, r && (s += Ei(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function fn(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(_i + t);
}
function Fs(t, e, r, n) {
  var a, s, o, p;
  for (s = t[0]; s >= 10; s /= 10) --e;
  return --e < 0 ? (e += at, a = 0) : (a = Math.ceil((e + 1) / at), e %= at), s = gr(10, at - e), p = t[a] % s | 0, n == null ? e < 3 ? (e == 0 ? p = p / 100 | 0 : e == 1 && (p = p / 10 | 0), o = r < 4 && p == 99999 || r > 3 && p == 49999 || p == 5e4 || p == 0) : o = (r < 4 && p + 1 == s || r > 3 && p + 1 == s / 2) && (t[a + 1] / s / 100 | 0) == gr(10, e - 2) - 1 || (p == s / 2 || p == 0) && (t[a + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? p = p / 1e3 | 0 : e == 1 ? p = p / 100 | 0 : e == 2 && (p = p / 10 | 0), o = (n || r < 4) && p == 9999 || !n && r > 3 && p == 4999) : o = ((n || r < 4) && p + 1 == s || !n && r > 3 && p + 1 == s / 2) && (t[a + 1] / s / 1e3 | 0) == gr(10, e - 3) - 1, o;
}
function Yo(t, e, r) {
  for (var n, a = [0], s, o = 0, p = t.length; o < p; ) {
    for (s = a.length; s--; ) a[s] *= e;
    for (a[0] += Hm.indexOf(t.charAt(o++)), n = 0; n < a.length; n++)
      a[n] > r - 1 && (a[n + 1] === void 0 && (a[n + 1] = 0), a[n + 1] += a[n] / r | 0, a[n] %= r);
  }
  return a.reverse();
}
function AC(t, e) {
  var r, n, a;
  if (e.isZero()) return e;
  n = e.d.length, n < 32 ? (r = Math.ceil(n / 3), a = (1 / Fu(4, r)).toString()) : (r = 16, a = "2.3283064365386962890625e-10"), t.precision += r, e = Pa(t, 1, e.times(a), new t(1));
  for (var s = r; s--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var Yt = /* @__PURE__ */ function() {
  function t(n, a, s) {
    var o, p = 0, u = n.length;
    for (n = n.slice(); u--; )
      o = n[u] * a + p, n[u] = o % s | 0, p = o / s | 0;
    return p && n.unshift(p), n;
  }
  function e(n, a, s, o) {
    var p, u;
    if (s != o)
      u = s > o ? 1 : -1;
    else
      for (p = u = 0; p < s; p++)
        if (n[p] != a[p]) {
          u = n[p] > a[p] ? 1 : -1;
          break;
        }
    return u;
  }
  function r(n, a, s, o) {
    for (var p = 0; s--; )
      n[s] -= p, p = n[s] < a[s] ? 1 : 0, n[s] = p * o + n[s] - a[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, a, s, o, p, u) {
    var f, l, c, h, d, g, v, N, b, C, x, E, D, A, M, _, O, T, I, q, $ = n.constructor, U = n.s == a.s ? 1 : -1, k = n.d, L = a.d;
    if (!k || !k[0] || !L || !L[0])
      return new $(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !a.s || (k ? L && k[0] == L[0] : !L) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          k && k[0] == 0 || !L ? U * 0 : U / 0
        )
      );
    for (u ? (d = 1, l = n.e - a.e) : (u = Pn, d = at, l = Wr(n.e / d) - Wr(a.e / d)), I = L.length, O = k.length, b = new $(U), C = b.d = [], c = 0; L[c] == (k[c] || 0); c++) ;
    if (L[c] > (k[c] || 0) && l--, s == null ? (A = s = $.precision, o = $.rounding) : p ? A = s + (n.e - a.e) + 1 : A = s, A < 0)
      C.push(1), g = !0;
    else {
      if (A = A / d + 2 | 0, c = 0, I == 1) {
        for (h = 0, L = L[0], A++; (c < O || h) && A--; c++)
          M = h * u + (k[c] || 0), C[c] = M / L | 0, h = M % L | 0;
        g = h || c < O;
      } else {
        for (h = u / (L[0] + 1) | 0, h > 1 && (L = t(L, h, u), k = t(k, h, u), I = L.length, O = k.length), _ = I, x = k.slice(0, I), E = x.length; E < I; ) x[E++] = 0;
        q = L.slice(), q.unshift(0), T = L[0], L[1] >= u / 2 && ++T;
        do
          h = 0, f = e(L, x, I, E), f < 0 ? (D = x[0], I != E && (D = D * u + (x[1] || 0)), h = D / T | 0, h > 1 ? (h >= u && (h = u - 1), v = t(L, h, u), N = v.length, E = x.length, f = e(v, x, N, E), f == 1 && (h--, r(v, I < N ? q : L, N, u))) : (h == 0 && (f = h = 1), v = L.slice()), N = v.length, N < E && v.unshift(0), r(x, v, E, u), f == -1 && (E = x.length, f = e(L, x, I, E), f < 1 && (h++, r(x, I < E ? q : L, E, u))), E = x.length) : f === 0 && (h++, x = [0]), C[c++] = h, f && x[0] ? x[E++] = k[_] || 0 : (x = [k[_]], E = 1);
        while ((_++ < O || x[0] !== void 0) && A--);
        g = x[0] !== void 0;
      }
      C[0] || C.shift();
    }
    if (d == 1)
      b.e = l, _2 = g;
    else {
      for (c = 1, h = C[0]; h >= 10; h /= 10) c++;
      b.e = c + l * d - 1, et(b, p ? s + b.e + 1 : s, o, g);
    }
    return b;
  };
}();
function et(t, e, r, n) {
  var a, s, o, p, u, f, l, c, h, d = t.constructor;
  e: if (e != null) {
    if (c = t.d, !c) return t;
    for (a = 1, p = c[0]; p >= 10; p /= 10) a++;
    if (s = e - a, s < 0)
      s += at, o = e, l = c[h = 0], u = l / gr(10, a - o - 1) % 10 | 0;
    else if (h = Math.ceil((s + 1) / at), p = c.length, h >= p)
      if (n) {
        for (; p++ <= h; ) c.push(0);
        l = u = 0, a = 1, s %= at, o = s - at + 1;
      } else
        break e;
    else {
      for (l = p = c[h], a = 1; p >= 10; p /= 10) a++;
      s %= at, o = s - at + a, u = o < 0 ? 0 : l / gr(10, a - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || c[h + 1] !== void 0 || (o < 0 ? l : l % gr(10, a - o - 1)), f = r < 4 ? (u || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? l / gr(10, a - o) : 0 : c[h - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !c[0])
      return c.length = 0, f ? (e -= t.e + 1, c[0] = gr(10, (at - e % at) % at), t.e = -e || 0) : c[0] = t.e = 0, t;
    if (s == 0 ? (c.length = h, p = 1, h--) : (c.length = h + 1, p = gr(10, at - s), c[h] = o > 0 ? (l / gr(10, a - o) % gr(10, o) | 0) * p : 0), f)
      for (; ; )
        if (h == 0) {
          for (s = 1, o = c[0]; o >= 10; o /= 10) s++;
          for (o = c[0] += p, p = 1; o >= 10; o /= 10) p++;
          s != p && (t.e++, c[0] == Pn && (c[0] = 1));
          break;
        } else {
          if (c[h] += p, c[h] != Pn) break;
          c[h--] = 0, p = 1;
        }
    for (s = c.length; c[--s] === 0; ) c.pop();
  }
  return mt && (t.e > d.maxE ? (t.d = null, t.e = NaN) : t.e < d.minE && (t.e = 0, t.d = [0])), t;
}
function jn(t, e, r) {
  if (!t.isFinite()) return L2(t);
  var n, a = t.e, s = Ir(t.d), o = s.length;
  return e ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + Ei(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (t.e < 0 ? "e" : "e+") + t.e) : a < 0 ? (s = "0." + Ei(-a - 1) + s, r && (n = r - o) > 0 && (s += Ei(n))) : a >= o ? (s += Ei(a + 1 - o), r && (n = r - a - 1) > 0 && (s = s + "." + Ei(n))) : ((n = a + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (a + 1 === o && (s += "."), s += Ei(n))), s;
}
function Ou(t, e) {
  var r = t[0];
  for (e *= at; r >= 10; r /= 10) e++;
  return e;
}
function tu(t, e, r) {
  if (e > DC)
    throw mt = !0, r && (t.precision = r), Error(M2);
  return et(new t(Ko), e, 1, !0);
}
function Ln(t, e, r) {
  if (e > Vm) throw Error(M2);
  return et(new t(eu), e, r, !0);
}
function I2(t) {
  var e = t.length - 1, r = e * at + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function Ei(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function B2(t, e, r, n) {
  var a, s = new t(1), o = Math.ceil(n / at + 4);
  for (mt = !1; ; ) {
    if (r % 2 && (s = s.times(e), jg(s.d, o) && (a = !0)), r = Wr(r / 2), r === 0) {
      r = s.d.length - 1, a && s.d[r] === 0 && ++s.d[r];
      break;
    }
    e = e.times(e), jg(e.d, o);
  }
  return mt = !0, s;
}
function Wg(t) {
  return t.d[t.d.length - 1] & 1;
}
function R2(t, e, r) {
  for (var n, a = new t(e[0]), s = 0; ++s < e.length; )
    if (n = new t(e[s]), n.s)
      a[r](n) && (a = n);
    else {
      a = n;
      break;
    }
  return a;
}
function Wm(t, e) {
  var r, n, a, s, o, p, u, f = 0, l = 0, c = 0, h = t.constructor, d = h.rounding, g = h.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new h(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (mt = !1, u = g) : u = e, p = new h(0.03125); t.e > -2; )
    t = t.times(p), c += 5;
  for (n = Math.log(gr(2, c)) / Math.LN10 * 2 + 5 | 0, u += n, r = s = o = new h(1), h.precision = u; ; ) {
    if (s = et(s.times(t), u, 1), r = r.times(++l), p = o.plus(Yt(s, r, u, 1)), Ir(p.d).slice(0, u) === Ir(o.d).slice(0, u)) {
      for (a = c; a--; ) o = et(o.times(o), u, 1);
      if (e == null)
        if (f < 3 && Fs(o.d, u - n, d, f))
          h.precision = u += 10, r = s = p = new h(1), l = 0, f++;
        else
          return et(o, h.precision = g, d, mt = !0);
      else
        return h.precision = g, o;
    }
    o = p;
  }
}
function Ti(t, e) {
  var r, n, a, s, o, p, u, f, l, c, h, d = 1, g = 10, v = t, N = v.d, b = v.constructor, C = b.rounding, x = b.precision;
  if (v.s < 0 || !N || !N[0] || !v.e && N[0] == 1 && N.length == 1)
    return new b(N && !N[0] ? -1 / 0 : v.s != 1 ? NaN : N ? 0 : v);
  if (e == null ? (mt = !1, l = x) : l = e, b.precision = l += g, r = Ir(N), n = r.charAt(0), Math.abs(s = v.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      v = v.times(t), r = Ir(v.d), n = r.charAt(0), d++;
    s = v.e, n > 1 ? (v = new b("0." + r), s++) : v = new b(n + "." + r.slice(1));
  } else
    return f = tu(b, l + 2, x).times(s + ""), v = Ti(new b(n + "." + r.slice(1)), l - g).plus(f), b.precision = x, e == null ? et(v, x, C, mt = !0) : v;
  for (c = v, u = o = v = Yt(v.minus(1), v.plus(1), l, 1), h = et(v.times(v), l, 1), a = 3; ; ) {
    if (o = et(o.times(h), l, 1), f = u.plus(Yt(o, new b(a), l, 1)), Ir(f.d).slice(0, l) === Ir(u.d).slice(0, l))
      if (u = u.times(2), s !== 0 && (u = u.plus(tu(b, l + 2, x).times(s + ""))), u = Yt(u, new b(d), l, 1), e == null)
        if (Fs(u.d, l - g, C, p))
          b.precision = l += g, f = o = v = Yt(c.minus(1), c.plus(1), l, 1), h = et(v.times(v), l, 1), a = p = 1;
        else
          return et(u, b.precision = x, C, mt = !0);
      else
        return b.precision = x, u;
    u = f, a += 2;
  }
}
function L2(t) {
  return String(t.s * t.s / 0);
}
function jm(t, e) {
  var r, n, a;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (a = e.length; e.charCodeAt(a - 1) === 48; --a) ;
  if (e = e.slice(n, a), e) {
    if (a -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % at, r < 0 && (n += at), n < a) {
      for (n && t.d.push(+e.slice(0, n)), a -= at; n < a; ) t.d.push(+e.slice(n, n += at));
      e = e.slice(n), n = at - e.length;
    } else
      n -= a;
    for (; n--; ) e += "0";
    t.d.push(+e), mt && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function EC(t, e) {
  var r, n, a, s, o, p, u, f, l;
  if (e.indexOf("_") > -1) {
    if (e = e.replace(/(\d)_(?=\d)/g, "$1"), q2.test(e)) return jm(t, e);
  } else if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (bC.test(e))
    r = 16, e = e.toLowerCase();
  else if (xC.test(e))
    r = 2;
  else if (wC.test(e))
    r = 8;
  else
    throw Error(_i + e);
  for (s = e.search(/p/i), s > 0 ? (u = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), o = s >= 0, n = t.constructor, o && (e = e.replace(".", ""), p = e.length, s = p - s, a = B2(n, new n(r), s, s * 2)), f = Yo(e, r, Pn), l = f.length - 1, s = l; f[s] === 0; --s) f.pop();
  return s < 0 ? new n(t.s * 0) : (t.e = Ou(f, l), t.d = f, mt = !1, o && (t = Yt(t, a, p * 4)), u && (t = t.times(Math.abs(u) < 54 ? gr(2, u) : Mi.pow(2, u))), mt = !0, t);
}
function SC(t, e) {
  var r, n = e.d.length;
  if (n < 3)
    return e.isZero() ? e : Pa(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(1 / Fu(5, r)), e = Pa(t, 2, e, e);
  for (var a, s = new t(5), o = new t(16), p = new t(20); r--; )
    a = e.times(e), e = e.times(s.plus(a.times(o.times(a).minus(p))));
  return e;
}
function Pa(t, e, r, n, a) {
  var s, o, p, u, f = t.precision, l = Math.ceil(f / at);
  for (mt = !1, u = r.times(r), p = new t(n); ; ) {
    if (o = Yt(p.times(u), new t(e++ * e++), f, 1), p = a ? n.plus(o) : n.minus(o), n = Yt(o.times(u), new t(e++ * e++), f, 1), o = p.plus(n), o.d[l] !== void 0) {
      for (s = l; o.d[s] === p.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = p, p = n, n = o, o = s;
  }
  return mt = !0, o.d.length = l + 1, o;
}
function Fu(t, e) {
  for (var r = t; --e; ) r *= t;
  return r;
}
function P2(t, e) {
  var r, n = e.s < 0, a = Ln(t, t.precision, 1), s = a.times(0.5);
  if (e = e.abs(), e.lte(s))
    return ui = n ? 4 : 1, e;
  if (r = e.divToInt(a), r.isZero())
    ui = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(a)), e.lte(s))
      return ui = Wg(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    ui = Wg(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(a).abs();
}
function Dd(t, e, r, n) {
  var a, s, o, p, u, f, l, c, h, d = t.constructor, g = r !== void 0;
  if (g ? (fn(r, 1, Bi), n === void 0 ? n = d.rounding : fn(n, 0, 8)) : (r = d.precision, n = d.rounding), !t.isFinite())
    l = L2(t);
  else {
    for (l = jn(t), o = l.indexOf("."), g ? (a = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : a = e, o >= 0 && (l = l.replace(".", ""), h = new d(1), h.e = l.length - o, h.d = Yo(jn(h), 10, a), h.e = h.d.length), c = Yo(l, 10, a), s = u = c.length; c[--u] == 0; ) c.pop();
    if (!c[0])
      l = g ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (t = new d(t), t.d = c, t.e = s, t = Yt(t, h, r, n, 0, a), c = t.d, s = t.e, f = _2), o = c[r], p = a / 2, f = f || c[r + 1] !== void 0, f = n < 4 ? (o !== void 0 || f) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > p || o === p && (n === 4 || f || n === 6 && c[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), c.length = r, f)
        for (; ++c[--r] > a - 1; )
          c[r] = 0, r || (++s, c.unshift(1));
      for (u = c.length; !c[u - 1]; --u) ;
      for (o = 0, l = ""; o < u; o++) l += Hm.charAt(c[o]);
      if (g) {
        if (u > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --u; u % o; u++) l += "0";
            for (c = Yo(l, a, e), u = c.length; !c[u - 1]; --u) ;
            for (o = 1, l = "1."; o < u; o++) l += Hm.charAt(c[o]);
          } else
            l = l.charAt(0) + "." + l.slice(1);
        l = l + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) l = "0" + l;
        l = "0." + l;
      } else if (++s > u) for (s -= u; s--; ) l += "0";
      else s < u && (l = l.slice(0, s) + "." + l.slice(s));
    }
    l = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + l;
  }
  return t.s < 0 ? "-" + l : l;
}
function jg(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function CC(t) {
  return new this(t).abs();
}
function TC(t) {
  return new this(t).acos();
}
function _C(t) {
  return new this(t).acosh();
}
function MC(t, e) {
  return new this(t).plus(e);
}
function OC(t) {
  return new this(t).asin();
}
function FC(t) {
  return new this(t).asinh();
}
function qC(t) {
  return new this(t).atan();
}
function IC(t) {
  return new this(t).atanh();
}
function BC(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, a = this.rounding, s = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Ln(this, s, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Ln(this, n, a) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Ln(this, s, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(Yt(t, e, s, 1)), e = Ln(this, s, 1), this.precision = n, this.rounding = a, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(Yt(t, e, s, 1)), r;
}
function RC(t) {
  return new this(t).cbrt();
}
function LC(t) {
  return et(t = new this(t), t.e + 1, 2);
}
function PC(t, e, r) {
  return new this(t).clamp(e, r);
}
function kC(t) {
  if (!t || typeof t != "object") throw Error(Mu + "Object expected");
  var e, r, n, a = t.defaults === !0, s = [
    "precision",
    1,
    Bi,
    "rounding",
    0,
    8,
    "toExpNeg",
    -Ma,
    0,
    "toExpPos",
    0,
    Ma,
    "maxE",
    0,
    Ma,
    "minE",
    -Ma,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < s.length; e += 3)
    if (r = s[e], a && (this[r] = Qm[r]), (n = t[r]) !== void 0)
      if (Wr(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[r] = n;
      else throw Error(_i + r + ": " + n);
  if (r = "crypto", a && (this[r] = Qm[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(O2);
      else
        this[r] = !1;
    else
      throw Error(_i + r + ": " + n);
  return this;
}
function $C(t) {
  return new this(t).cos();
}
function zC(t) {
  return new this(t).cosh();
}
function k2(t) {
  var e, r, n;
  function a(s) {
    var o, p, u, f = this;
    if (!(f instanceof a)) return new a(s);
    if (f.constructor = a, Zg(s)) {
      f.s = s.s, mt ? !s.d || s.e > a.maxE ? (f.e = NaN, f.d = null) : s.e < a.minE ? (f.e = 0, f.d = [0]) : (f.e = s.e, f.d = s.d.slice()) : (f.e = s.e, f.d = s.d ? s.d.slice() : s.d);
      return;
    }
    if (u = typeof s, u === "number") {
      if (s === 0) {
        f.s = 1 / s < 0 ? -1 : 1, f.e = 0, f.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, f.s = -1) : f.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, p = s; p >= 10; p /= 10) o++;
        mt ? o > a.maxE ? (f.e = NaN, f.d = null) : o < a.minE ? (f.e = 0, f.d = [0]) : (f.e = o, f.d = [s]) : (f.e = o, f.d = [s]);
        return;
      } else if (s * 0 !== 0) {
        s || (f.s = NaN), f.e = NaN, f.d = null;
        return;
      }
      return jm(f, s.toString());
    } else if (u !== "string")
      throw Error(_i + s);
    return (p = s.charCodeAt(0)) === 45 ? (s = s.slice(1), f.s = -1) : (p === 43 && (s = s.slice(1)), f.s = 1), q2.test(s) ? jm(f, s) : EC(f, s);
  }
  if (a.prototype = ke, a.ROUND_UP = 0, a.ROUND_DOWN = 1, a.ROUND_CEIL = 2, a.ROUND_FLOOR = 3, a.ROUND_HALF_UP = 4, a.ROUND_HALF_DOWN = 5, a.ROUND_HALF_EVEN = 6, a.ROUND_HALF_CEIL = 7, a.ROUND_HALF_FLOOR = 8, a.EUCLID = 9, a.config = a.set = kC, a.clone = k2, a.isDecimal = Zg, a.abs = CC, a.acos = TC, a.acosh = _C, a.add = MC, a.asin = OC, a.asinh = FC, a.atan = qC, a.atanh = IC, a.atan2 = BC, a.cbrt = RC, a.ceil = LC, a.clamp = PC, a.cos = $C, a.cosh = zC, a.div = UC, a.exp = GC, a.floor = HC, a.hypot = QC, a.ln = VC, a.log = WC, a.log10 = ZC, a.log2 = jC, a.max = JC, a.min = YC, a.mod = XC, a.mul = KC, a.pow = eT, a.random = tT, a.round = rT, a.sign = nT, a.sin = iT, a.sinh = aT, a.sqrt = sT, a.sub = oT, a.sum = uT, a.tan = lT, a.tanh = cT, a.trunc = fT, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return a.config(t), a;
}
function UC(t, e) {
  return new this(t).div(e);
}
function GC(t) {
  return new this(t).exp();
}
function HC(t) {
  return et(t = new this(t), t.e + 1, 3);
}
function QC() {
  var t, e, r = new this(0);
  for (mt = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return mt = !0, new this(1 / 0);
      r = e;
    }
  return mt = !0, r.sqrt();
}
function Zg(t) {
  return t instanceof Mi || t && t.toStringTag === F2 || !1;
}
function VC(t) {
  return new this(t).ln();
}
function WC(t, e) {
  return new this(t).log(e);
}
function jC(t) {
  return new this(t).log(2);
}
function ZC(t) {
  return new this(t).log(10);
}
function JC() {
  return R2(this, arguments, "lt");
}
function YC() {
  return R2(this, arguments, "gt");
}
function XC(t, e) {
  return new this(t).mod(e);
}
function KC(t, e) {
  return new this(t).mul(e);
}
function eT(t, e) {
  return new this(t).pow(e);
}
function tT(t) {
  var e, r, n, a, s = 0, o = new this(1), p = [];
  if (t === void 0 ? t = this.precision : fn(t, 1, Bi), n = Math.ceil(t / at), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        a = e[s], a >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : p[s++] = a % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); s < n; )
        a = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), a >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (p.push(a % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(O2);
  else for (; s < n; ) p[s++] = Math.random() * 1e7 | 0;
  for (n = p[--s], t %= at, n && t && (a = gr(10, at - t), p[s] = (n / a | 0) * a); p[s] === 0; s--) p.pop();
  if (s < 0)
    r = 0, p = [0];
  else {
    for (r = -1; p[0] === 0; r -= at) p.shift();
    for (n = 1, a = p[0]; a >= 10; a /= 10) n++;
    n < at && (r -= at - n);
  }
  return o.e = r, o.d = p, o;
}
function rT(t) {
  return et(t = new this(t), t.e + 1, this.rounding);
}
function nT(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function iT(t) {
  return new this(t).sin();
}
function aT(t) {
  return new this(t).sinh();
}
function sT(t) {
  return new this(t).sqrt();
}
function oT(t, e) {
  return new this(t).sub(e);
}
function uT() {
  var t = 0, e = arguments, r = new this(e[t]);
  for (mt = !1; r.s && ++t < e.length; ) r = r.plus(e[t]);
  return mt = !0, et(r, this.precision, this.rounding);
}
function lT(t) {
  return new this(t).tan();
}
function cT(t) {
  return new this(t).tanh();
}
function fT(t) {
  return et(t = new this(t), t.e + 1, 1);
}
ke[Symbol.for("nodejs.util.inspect.custom")] = ke.toString;
ke[Symbol.toStringTag] = "Decimal";
var Mi = ke.constructor = k2(Qm);
Ko = new Mi(Ko);
eu = new Mi(eu);
var pT = "BigNumber", hT = ["?on", "config"], qu = /* @__PURE__ */ j(pT, hT, (t) => {
  var {
    on: e,
    config: r
  } = t, n = Mi.clone({
    precision: r.precision,
    modulo: Mi.EUCLID
  });
  return n.prototype = Object.create(n.prototype), n.prototype.type = "BigNumber", n.prototype.isBigNumber = !0, n.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  }, n.fromJSON = function(a) {
    return new n(a.value);
  }, e && e("config", function(a, s) {
    a.precision !== s.precision && n.config({
      precision: a.precision
    });
  }), n;
}, {
  isClass: !0
}), ua = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zs(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function mT(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var a = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, a.get ? a : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var $2 = { exports: {} };
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(t, e) {
  (function(r) {
    var n = Math.cosh || function(c) {
      return Math.abs(c) < 1e-9 ? 1 - c : (Math.exp(c) + Math.exp(-c)) * 0.5;
    }, a = Math.sinh || function(c) {
      return Math.abs(c) < 1e-9 ? c : (Math.exp(c) - Math.exp(-c)) * 0.5;
    }, s = function(c) {
      var h = Math.PI / 4;
      if (-h > c || c > h)
        return Math.cos(c) - 1;
      var d = c * c;
      return d * (d * (d * (d * (d * (d * (d * (d / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
    }, o = function(c, h) {
      var d = Math.abs(c), g = Math.abs(h);
      return d < 3e3 && g < 3e3 ? Math.sqrt(d * d + g * g) : (d < g ? (d = g, g = c / h) : g = h / c, d * Math.sqrt(1 + g * g));
    }, p = function() {
      throw SyntaxError("Invalid Param");
    };
    function u(c, h) {
      var d = Math.abs(c), g = Math.abs(h);
      return c === 0 ? Math.log(g) : h === 0 ? Math.log(d) : d < 3e3 && g < 3e3 ? Math.log(c * c + h * h) * 0.5 : (c = c / 2, h = h / 2, 0.5 * Math.log(c * c + h * h) + Math.LN2);
    }
    var f = function(c, h) {
      var d = { re: 0, im: 0 };
      if (c == null)
        d.re = d.im = 0;
      else if (h !== void 0)
        d.re = c, d.im = h;
      else
        switch (typeof c) {
          case "object":
            if ("im" in c && "re" in c)
              d.re = c.re, d.im = c.im;
            else if ("abs" in c && "arg" in c) {
              if (!Number.isFinite(c.abs) && Number.isFinite(c.arg))
                return l.INFINITY;
              d.re = c.abs * Math.cos(c.arg), d.im = c.abs * Math.sin(c.arg);
            } else if ("r" in c && "phi" in c) {
              if (!Number.isFinite(c.r) && Number.isFinite(c.phi))
                return l.INFINITY;
              d.re = c.r * Math.cos(c.phi), d.im = c.r * Math.sin(c.phi);
            } else c.length === 2 ? (d.re = c[0], d.im = c[1]) : p();
            break;
          case "string":
            d.im = /* void */
            d.re = 0;
            var g = c.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), v = 1, N = 0;
            g === null && p();
            for (var b = 0; b < g.length; b++) {
              var C = g[b];
              C === " " || C === "	" || C === `
` || (C === "+" ? v++ : C === "-" ? N++ : C === "i" || C === "I" ? (v + N === 0 && p(), g[b + 1] !== " " && !isNaN(g[b + 1]) ? (d.im += parseFloat((N % 2 ? "-" : "") + g[b + 1]), b++) : d.im += parseFloat((N % 2 ? "-" : "") + "1"), v = N = 0) : ((v + N === 0 || isNaN(C)) && p(), g[b + 1] === "i" || g[b + 1] === "I" ? (d.im += parseFloat((N % 2 ? "-" : "") + C), b++) : d.re += parseFloat((N % 2 ? "-" : "") + C), v = N = 0));
            }
            v + N > 0 && p();
            break;
          case "number":
            d.im = 0, d.re = c;
            break;
          default:
            p();
        }
      return isNaN(d.re) || isNaN(d.im), d;
    };
    function l(c, h) {
      if (!(this instanceof l))
        return new l(c, h);
      var d = f(c, h);
      this.re = d.re, this.im = d.im;
    }
    l.prototype = {
      re: 0,
      im: 0,
      /**
       * Calculates the sign of a complex number, which is a normalized complex
       *
       * @returns {Complex}
       */
      sign: function() {
        var c = this.abs();
        return new l(
          this.re / c,
          this.im / c
        );
      },
      /**
       * Adds two complex numbers
       *
       * @returns {Complex}
       */
      add: function(c, h) {
        var d = new l(c, h);
        return this.isInfinite() && d.isInfinite() ? l.NAN : this.isInfinite() || d.isInfinite() ? l.INFINITY : new l(
          this.re + d.re,
          this.im + d.im
        );
      },
      /**
       * Subtracts two complex numbers
       *
       * @returns {Complex}
       */
      sub: function(c, h) {
        var d = new l(c, h);
        return this.isInfinite() && d.isInfinite() ? l.NAN : this.isInfinite() || d.isInfinite() ? l.INFINITY : new l(
          this.re - d.re,
          this.im - d.im
        );
      },
      /**
       * Multiplies two complex numbers
       *
       * @returns {Complex}
       */
      mul: function(c, h) {
        var d = new l(c, h);
        return this.isInfinite() && d.isZero() || this.isZero() && d.isInfinite() ? l.NAN : this.isInfinite() || d.isInfinite() ? l.INFINITY : d.im === 0 && this.im === 0 ? new l(this.re * d.re, 0) : new l(
          this.re * d.re - this.im * d.im,
          this.re * d.im + this.im * d.re
        );
      },
      /**
       * Divides two complex numbers
       *
       * @returns {Complex}
       */
      div: function(c, h) {
        var d = new l(c, h);
        if (this.isZero() && d.isZero() || this.isInfinite() && d.isInfinite())
          return l.NAN;
        if (this.isInfinite() || d.isZero())
          return l.INFINITY;
        if (this.isZero() || d.isInfinite())
          return l.ZERO;
        c = this.re, h = this.im;
        var g = d.re, v = d.im, N, b;
        return v === 0 ? new l(c / g, h / g) : Math.abs(g) < Math.abs(v) ? (b = g / v, N = g * b + v, new l(
          (c * b + h) / N,
          (h * b - c) / N
        )) : (b = v / g, N = v * b + g, new l(
          (c + h * b) / N,
          (h - c * b) / N
        ));
      },
      /**
       * Calculate the power of two complex numbers
       *
       * @returns {Complex}
       */
      pow: function(c, h) {
        var d = new l(c, h);
        if (c = this.re, h = this.im, d.isZero())
          return l.ONE;
        if (d.im === 0) {
          if (h === 0 && c > 0)
            return new l(Math.pow(c, d.re), 0);
          if (c === 0)
            switch ((d.re % 4 + 4) % 4) {
              case 0:
                return new l(Math.pow(h, d.re), 0);
              case 1:
                return new l(0, Math.pow(h, d.re));
              case 2:
                return new l(-Math.pow(h, d.re), 0);
              case 3:
                return new l(0, -Math.pow(h, d.re));
            }
        }
        if (c === 0 && h === 0 && d.re > 0 && d.im >= 0)
          return l.ZERO;
        var g = Math.atan2(h, c), v = u(c, h);
        return c = Math.exp(d.re * v - d.im * g), h = d.im * v + d.re * g, new l(
          c * Math.cos(h),
          c * Math.sin(h)
        );
      },
      /**
       * Calculate the complex square root
       *
       * @returns {Complex}
       */
      sqrt: function() {
        var c = this.re, h = this.im, d = this.abs(), g, v;
        if (c >= 0) {
          if (h === 0)
            return new l(Math.sqrt(c), 0);
          g = 0.5 * Math.sqrt(2 * (d + c));
        } else
          g = Math.abs(h) / Math.sqrt(2 * (d - c));
        return c <= 0 ? v = 0.5 * Math.sqrt(2 * (d - c)) : v = Math.abs(h) / Math.sqrt(2 * (d + c)), new l(g, h < 0 ? -v : v);
      },
      /**
       * Calculate the complex exponent
       *
       * @returns {Complex}
       */
      exp: function() {
        var c = Math.exp(this.re);
        return this.im, new l(
          c * Math.cos(this.im),
          c * Math.sin(this.im)
        );
      },
      /**
       * Calculate the complex exponent and subtracts one.
       *
       * This may be more accurate than `Complex(x).exp().sub(1)` if
       * `x` is small.
       *
       * @returns {Complex}
       */
      expm1: function() {
        var c = this.re, h = this.im;
        return new l(
          Math.expm1(c) * Math.cos(h) + s(h),
          Math.exp(c) * Math.sin(h)
        );
      },
      /**
       * Calculate the natural log
       *
       * @returns {Complex}
       */
      log: function() {
        var c = this.re, h = this.im;
        return new l(
          u(c, h),
          Math.atan2(h, c)
        );
      },
      /**
       * Calculate the magnitude of the complex number
       *
       * @returns {number}
       */
      abs: function() {
        return o(this.re, this.im);
      },
      /**
       * Calculate the angle of the complex number
       *
       * @returns {number}
       */
      arg: function() {
        return Math.atan2(this.im, this.re);
      },
      /**
       * Calculate the sine of the complex number
       *
       * @returns {Complex}
       */
      sin: function() {
        var c = this.re, h = this.im;
        return new l(
          Math.sin(c) * n(h),
          Math.cos(c) * a(h)
        );
      },
      /**
       * Calculate the cosine
       *
       * @returns {Complex}
       */
      cos: function() {
        var c = this.re, h = this.im;
        return new l(
          Math.cos(c) * n(h),
          -Math.sin(c) * a(h)
        );
      },
      /**
       * Calculate the tangent
       *
       * @returns {Complex}
       */
      tan: function() {
        var c = 2 * this.re, h = 2 * this.im, d = Math.cos(c) + n(h);
        return new l(
          Math.sin(c) / d,
          a(h) / d
        );
      },
      /**
       * Calculate the cotangent
       *
       * @returns {Complex}
       */
      cot: function() {
        var c = 2 * this.re, h = 2 * this.im, d = Math.cos(c) - n(h);
        return new l(
          -Math.sin(c) / d,
          a(h) / d
        );
      },
      /**
       * Calculate the secant
       *
       * @returns {Complex}
       */
      sec: function() {
        var c = this.re, h = this.im, d = 0.5 * n(2 * h) + 0.5 * Math.cos(2 * c);
        return new l(
          Math.cos(c) * n(h) / d,
          Math.sin(c) * a(h) / d
        );
      },
      /**
       * Calculate the cosecans
       *
       * @returns {Complex}
       */
      csc: function() {
        var c = this.re, h = this.im, d = 0.5 * n(2 * h) - 0.5 * Math.cos(2 * c);
        return new l(
          Math.sin(c) * n(h) / d,
          -Math.cos(c) * a(h) / d
        );
      },
      /**
       * Calculate the complex arcus sinus
       *
       * @returns {Complex}
       */
      asin: function() {
        var c = this.re, h = this.im, d = new l(
          h * h - c * c + 1,
          -2 * c * h
        ).sqrt(), g = new l(
          d.re - h,
          d.im + c
        ).log();
        return new l(g.im, -g.re);
      },
      /**
       * Calculate the complex arcus cosinus
       *
       * @returns {Complex}
       */
      acos: function() {
        var c = this.re, h = this.im, d = new l(
          h * h - c * c + 1,
          -2 * c * h
        ).sqrt(), g = new l(
          d.re - h,
          d.im + c
        ).log();
        return new l(Math.PI / 2 - g.im, g.re);
      },
      /**
       * Calculate the complex arcus tangent
       *
       * @returns {Complex}
       */
      atan: function() {
        var c = this.re, h = this.im;
        if (c === 0) {
          if (h === 1)
            return new l(0, 1 / 0);
          if (h === -1)
            return new l(0, -1 / 0);
        }
        var d = c * c + (1 - h) * (1 - h), g = new l(
          (1 - h * h - c * c) / d,
          -2 * c / d
        ).log();
        return new l(-0.5 * g.im, 0.5 * g.re);
      },
      /**
       * Calculate the complex arcus cotangent
       *
       * @returns {Complex}
       */
      acot: function() {
        var c = this.re, h = this.im;
        if (h === 0)
          return new l(Math.atan2(1, c), 0);
        var d = c * c + h * h;
        return d !== 0 ? new l(
          c / d,
          -h / d
        ).atan() : new l(
          c !== 0 ? c / 0 : 0,
          h !== 0 ? -h / 0 : 0
        ).atan();
      },
      /**
       * Calculate the complex arcus secant
       *
       * @returns {Complex}
       */
      asec: function() {
        var c = this.re, h = this.im;
        if (c === 0 && h === 0)
          return new l(0, 1 / 0);
        var d = c * c + h * h;
        return d !== 0 ? new l(
          c / d,
          -h / d
        ).acos() : new l(
          c !== 0 ? c / 0 : 0,
          h !== 0 ? -h / 0 : 0
        ).acos();
      },
      /**
       * Calculate the complex arcus cosecans
       *
       * @returns {Complex}
       */
      acsc: function() {
        var c = this.re, h = this.im;
        if (c === 0 && h === 0)
          return new l(Math.PI / 2, 1 / 0);
        var d = c * c + h * h;
        return d !== 0 ? new l(
          c / d,
          -h / d
        ).asin() : new l(
          c !== 0 ? c / 0 : 0,
          h !== 0 ? -h / 0 : 0
        ).asin();
      },
      /**
       * Calculate the complex sinh
       *
       * @returns {Complex}
       */
      sinh: function() {
        var c = this.re, h = this.im;
        return new l(
          a(c) * Math.cos(h),
          n(c) * Math.sin(h)
        );
      },
      /**
       * Calculate the complex cosh
       *
       * @returns {Complex}
       */
      cosh: function() {
        var c = this.re, h = this.im;
        return new l(
          n(c) * Math.cos(h),
          a(c) * Math.sin(h)
        );
      },
      /**
       * Calculate the complex tanh
       *
       * @returns {Complex}
       */
      tanh: function() {
        var c = 2 * this.re, h = 2 * this.im, d = n(c) + Math.cos(h);
        return new l(
          a(c) / d,
          Math.sin(h) / d
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      coth: function() {
        var c = 2 * this.re, h = 2 * this.im, d = n(c) - Math.cos(h);
        return new l(
          a(c) / d,
          -Math.sin(h) / d
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      csch: function() {
        var c = this.re, h = this.im, d = Math.cos(2 * h) - n(2 * c);
        return new l(
          -2 * a(c) * Math.cos(h) / d,
          2 * n(c) * Math.sin(h) / d
        );
      },
      /**
       * Calculate the complex sech
       *
       * @returns {Complex}
       */
      sech: function() {
        var c = this.re, h = this.im, d = Math.cos(2 * h) + n(2 * c);
        return new l(
          2 * n(c) * Math.cos(h) / d,
          -2 * a(c) * Math.sin(h) / d
        );
      },
      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      asinh: function() {
        var c = this.im;
        this.im = -this.re, this.re = c;
        var h = this.asin();
        return this.re = -this.im, this.im = c, c = h.re, h.re = -h.im, h.im = c, h;
      },
      /**
       * Calculate the complex acosh
       *
       * @returns {Complex}
       */
      acosh: function() {
        var c = this.acos();
        if (c.im <= 0) {
          var h = c.re;
          c.re = -c.im, c.im = h;
        } else {
          var h = c.im;
          c.im = -c.re, c.re = h;
        }
        return c;
      },
      /**
       * Calculate the complex atanh
       *
       * @returns {Complex}
       */
      atanh: function() {
        var c = this.re, h = this.im, d = c > 1 && h === 0, g = 1 - c, v = 1 + c, N = g * g + h * h, b = N !== 0 ? new l(
          (v * g - h * h) / N,
          (h * g + v * h) / N
        ) : new l(
          c !== -1 ? c / 0 : 0,
          h !== 0 ? h / 0 : 0
        ), C = b.re;
        return b.re = u(b.re, b.im) / 2, b.im = Math.atan2(b.im, C) / 2, d && (b.im = -b.im), b;
      },
      /**
       * Calculate the complex acoth
       *
       * @returns {Complex}
       */
      acoth: function() {
        var c = this.re, h = this.im;
        if (c === 0 && h === 0)
          return new l(0, Math.PI / 2);
        var d = c * c + h * h;
        return d !== 0 ? new l(
          c / d,
          -h / d
        ).atanh() : new l(
          c !== 0 ? c / 0 : 0,
          h !== 0 ? -h / 0 : 0
        ).atanh();
      },
      /**
       * Calculate the complex acsch
       *
       * @returns {Complex}
       */
      acsch: function() {
        var c = this.re, h = this.im;
        if (h === 0)
          return new l(
            c !== 0 ? Math.log(c + Math.sqrt(c * c + 1)) : 1 / 0,
            0
          );
        var d = c * c + h * h;
        return d !== 0 ? new l(
          c / d,
          -h / d
        ).asinh() : new l(
          c !== 0 ? c / 0 : 0,
          h !== 0 ? -h / 0 : 0
        ).asinh();
      },
      /**
       * Calculate the complex asech
       *
       * @returns {Complex}
       */
      asech: function() {
        var c = this.re, h = this.im;
        if (this.isZero())
          return l.INFINITY;
        var d = c * c + h * h;
        return d !== 0 ? new l(
          c / d,
          -h / d
        ).acosh() : new l(
          c !== 0 ? c / 0 : 0,
          h !== 0 ? -h / 0 : 0
        ).acosh();
      },
      /**
       * Calculate the complex inverse 1/z
       *
       * @returns {Complex}
       */
      inverse: function() {
        if (this.isZero())
          return l.INFINITY;
        if (this.isInfinite())
          return l.ZERO;
        var c = this.re, h = this.im, d = c * c + h * h;
        return new l(c / d, -h / d);
      },
      /**
       * Returns the complex conjugate
       *
       * @returns {Complex}
       */
      conjugate: function() {
        return new l(this.re, -this.im);
      },
      /**
       * Gets the negated complex number
       *
       * @returns {Complex}
       */
      neg: function() {
        return new l(-this.re, -this.im);
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      ceil: function(c) {
        return c = Math.pow(10, c || 0), new l(
          Math.ceil(this.re * c) / c,
          Math.ceil(this.im * c) / c
        );
      },
      /**
       * Floors the actual complex number
       *
       * @returns {Complex}
       */
      floor: function(c) {
        return c = Math.pow(10, c || 0), new l(
          Math.floor(this.re * c) / c,
          Math.floor(this.im * c) / c
        );
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      round: function(c) {
        return c = Math.pow(10, c || 0), new l(
          Math.round(this.re * c) / c,
          Math.round(this.im * c) / c
        );
      },
      /**
       * Compares two complex numbers
       *
       * **Note:** new Complex(Infinity).equals(Infinity) === false
       *
       * @returns {boolean}
       */
      equals: function(c, h) {
        var d = new l(c, h);
        return Math.abs(d.re - this.re) <= l.EPSILON && Math.abs(d.im - this.im) <= l.EPSILON;
      },
      /**
       * Clones the actual object
       *
       * @returns {Complex}
       */
      clone: function() {
        return new l(this.re, this.im);
      },
      /**
       * Gets a string of the actual complex number
       *
       * @returns {string}
       */
      toString: function() {
        var c = this.re, h = this.im, d = "";
        return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(c) < l.EPSILON && (c = 0), Math.abs(h) < l.EPSILON && (h = 0), h === 0 ? d + c : (c !== 0 ? (d += c, d += " ", h < 0 ? (h = -h, d += "-") : d += "+", d += " ") : h < 0 && (h = -h, d += "-"), h !== 1 && (d += h), d + "i"));
      },
      /**
       * Returns the actual number as a vector
       *
       * @returns {Array}
       */
      toVector: function() {
        return [this.re, this.im];
      },
      /**
       * Returns the actual real value of the current object
       *
       * @returns {number|null}
       */
      valueOf: function() {
        return this.im === 0 ? this.re : null;
      },
      /**
       * Determines whether a complex number is not on the Riemann sphere.
       *
       * @returns {boolean}
       */
      isNaN: function() {
        return isNaN(this.re) || isNaN(this.im);
      },
      /**
       * Determines whether or not a complex number is at the zero pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isZero: function() {
        return this.im === 0 && this.re === 0;
      },
      /**
       * Determines whether a complex number is not at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isFinite: function() {
        return isFinite(this.re) && isFinite(this.im);
      },
      /**
       * Determines whether or not a complex number is at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isInfinite: function() {
        return !(this.isNaN() || this.isFinite());
      }
    }, l.ZERO = new l(0, 0), l.ONE = new l(1, 0), l.I = new l(0, 1), l.PI = new l(Math.PI, 0), l.E = new l(Math.E, 0), l.INFINITY = new l(1 / 0, 1 / 0), l.NAN = new l(NaN, NaN), l.EPSILON = 1e-15, Object.defineProperty(l, "__esModule", { value: !0 }), l.default = l, l.Complex = l, t.exports = l;
  })();
})($2);
var dT = $2.exports;
const qr = /* @__PURE__ */ zs(dT);
var vT = "Complex", gT = [], Iu = /* @__PURE__ */ j(vT, gT, () => (Object.defineProperty(qr, "name", {
  value: "Complex"
}), qr.prototype.constructor = qr, qr.prototype.type = "Complex", qr.prototype.isComplex = !0, qr.prototype.toJSON = function() {
  return {
    mathjs: "Complex",
    re: this.re,
    im: this.im
  };
}, qr.prototype.toPolar = function() {
  return {
    r: this.abs(),
    phi: this.arg()
  };
}, qr.prototype.format = function(t) {
  var e = "", r = this.im, n = this.re, a = na(this.re, t), s = na(this.im, t), o = ht(t) ? t : t ? t.precision : null;
  if (o !== null) {
    var p = Math.pow(10, -o);
    Math.abs(n / r) < p && (n = 0), Math.abs(r / n) < p && (r = 0);
  }
  return r === 0 ? e = a : n === 0 ? r === 1 ? e = "i" : r === -1 ? e = "-i" : e = s + "i" : r < 0 ? r === -1 ? e = a + " - i" : e = a + " - " + s.substring(1) + "i" : r === 1 ? e = a + " + i" : e = a + " + " + s + "i", e;
}, qr.fromPolar = function(t) {
  switch (arguments.length) {
    case 1: {
      var e = arguments[0];
      if (typeof e == "object")
        return qr(e);
      throw new TypeError("Input has to be an object with r and phi keys.");
    }
    case 2: {
      var r = arguments[0], n = arguments[1];
      if (ht(r)) {
        if (Xr(n) && n.hasBase("ANGLE") && (n = n.toNumber("rad")), ht(n))
          return new qr({
            r,
            phi: n
          });
        throw new TypeError("Phi is not a number nor an angle unit.");
      } else
        throw new TypeError("Radius r is not a number.");
    }
    default:
      throw new SyntaxError("Wrong number of arguments in function fromPolar");
  }
}, qr.prototype.valueOf = qr.prototype.toString, qr.fromJSON = function(t) {
  return new qr(t);
}, qr.compare = function(t, e) {
  return t.re > e.re ? 1 : t.re < e.re ? -1 : t.im > e.im ? 1 : t.im < e.im ? -1 : 0;
}, qr), {
  isClass: !0
});
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
var yT = 2e3, Ye = {
  s: 1,
  n: 0,
  d: 1
};
function ai(t, e) {
  if (isNaN(t = parseInt(t, 10)))
    throw Xo();
  return t * e;
}
function ir(t, e) {
  if (e === 0)
    throw Ad();
  var r = Object.create(Hr.prototype);
  r.s = t < 0 ? -1 : 1, t = t < 0 ? -t : t;
  var n = Oa(t, e);
  return r.n = t / n, r.d = e / n, r;
}
function Jg(t) {
  for (var e = {}, r = t, n = 2, a = 4; a <= r; ) {
    for (; r % n === 0; )
      r /= n, e[n] = (e[n] || 0) + 1;
    a += 1 + 2 * n++;
  }
  return r !== t ? r > 1 && (e[r] = (e[r] || 0) + 1) : e[t] = (e[t] || 0) + 1, e;
}
var vn = function(t, e) {
  var r = 0, n = 1, a = 1, s = 0, o = 0, p = 0, u = 1, f = 1, l = 0, c = 1, h = 1, d = 1, g = 1e7, v;
  if (t != null) if (e !== void 0) {
    if (r = t, n = e, a = r * n, r % 1 !== 0 || n % 1 !== 0)
      throw NT();
  } else
    switch (typeof t) {
      case "object": {
        if ("d" in t && "n" in t)
          r = t.n, n = t.d, "s" in t && (r *= t.s);
        else if (0 in t)
          r = t[0], 1 in t && (n = t[1]);
        else
          throw Xo();
        a = r * n;
        break;
      }
      case "number": {
        if (t < 0 && (a = t, t = -t), t % 1 === 0)
          r = t;
        else if (t > 0) {
          for (t >= 1 && (f = Math.pow(10, Math.floor(1 + Math.log(t) / Math.LN10)), t /= f); c <= g && d <= g; )
            if (v = (l + h) / (c + d), t === v) {
              c + d <= g ? (r = l + h, n = c + d) : d > c ? (r = h, n = d) : (r = l, n = c);
              break;
            } else
              t > v ? (l += h, c += d) : (h += l, d += c), c > g ? (r = h, n = d) : (r = l, n = c);
          r *= f;
        } else (isNaN(t) || isNaN(e)) && (n = r = NaN);
        break;
      }
      case "string": {
        if (c = t.match(/\d+|./g), c === null)
          throw Xo();
        if (c[l] === "-" ? (a = -1, l++) : c[l] === "+" && l++, c.length === l + 1 ? o = ai(c[l++], a) : c[l + 1] === "." || c[l] === "." ? (c[l] !== "." && (s = ai(c[l++], a)), l++, (l + 1 === c.length || c[l + 1] === "(" && c[l + 3] === ")" || c[l + 1] === "'" && c[l + 3] === "'") && (o = ai(c[l], a), u = Math.pow(10, c[l].length), l++), (c[l] === "(" && c[l + 2] === ")" || c[l] === "'" && c[l + 2] === "'") && (p = ai(c[l + 1], a), f = Math.pow(10, c[l + 1].length) - 1, l += 3)) : c[l + 1] === "/" || c[l + 1] === ":" ? (o = ai(c[l], a), u = ai(c[l + 2], 1), l += 3) : c[l + 3] === "/" && c[l + 1] === " " && (s = ai(c[l], a), o = ai(c[l + 2], a), u = ai(c[l + 4], 1), l += 5), c.length <= l) {
          n = u * f, a = /* void */
          r = p + n * s + f * o;
          break;
        }
      }
      default:
        throw Xo();
    }
  if (n === 0)
    throw Ad();
  Ye.s = a < 0 ? -1 : 1, Ye.n = Math.abs(r), Ye.d = Math.abs(n);
};
function xT(t, e, r) {
  for (var n = 1; e > 0; t = t * t % r, e >>= 1)
    e & 1 && (n = n * t % r);
  return n;
}
function bT(t, e) {
  for (; e % 2 === 0; e /= 2)
    ;
  for (; e % 5 === 0; e /= 5)
    ;
  if (e === 1)
    return 0;
  for (var r = 10 % e, n = 1; r !== 1; n++)
    if (r = r * 10 % e, n > yT)
      return 0;
  return n;
}
function wT(t, e, r) {
  for (var n = 1, a = xT(10, r, e), s = 0; s < 300; s++) {
    if (n === a)
      return s;
    n = n * 10 % e, a = a * 10 % e;
  }
  return 0;
}
function Oa(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  for (; ; ) {
    if (t %= e, !t)
      return e;
    if (e %= t, !e)
      return t;
  }
}
function Hr(t, e) {
  if (vn(t, e), this instanceof Hr)
    t = Oa(Ye.d, Ye.n), this.s = Ye.s, this.n = Ye.n / t, this.d = Ye.d / t;
  else
    return ir(Ye.s * Ye.n, Ye.d);
}
var Ad = function() {
  return new Error("Division by Zero");
}, Xo = function() {
  return new Error("Invalid argument");
}, NT = function() {
  return new Error("Parameters must be integer");
};
Hr.prototype = {
  s: 1,
  n: 0,
  d: 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return ir(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return ir(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(t, e) {
    return vn(t, e), ir(
      this.s * this.n * Ye.d + Ye.s * this.d * Ye.n,
      this.d * Ye.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(t, e) {
    return vn(t, e), ir(
      this.s * this.n * Ye.d - Ye.s * this.d * Ye.n,
      this.d * Ye.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(t, e) {
    return vn(t, e), ir(
      this.s * Ye.s * this.n * Ye.n,
      this.d * Ye.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(t, e) {
    return vn(t, e), ir(
      this.s * Ye.s * this.n * Ye.d,
      this.d * Ye.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return ir(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  mod: function(t, e) {
    if (isNaN(this.n) || isNaN(this.d))
      return new Hr(NaN);
    if (t === void 0)
      return ir(this.s * this.n % this.d, 1);
    if (vn(t, e), Ye.n === 0 && this.d === 0)
      throw Ad();
    return ir(
      this.s * (Ye.d * this.n) % (Ye.n * this.d),
      Ye.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(t, e) {
    return vn(t, e), ir(Oa(Ye.n, this.n) * Oa(Ye.d, this.d), Ye.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(t, e) {
    return vn(t, e), Ye.n === 0 && this.n === 0 ? ir(0, 1) : ir(Ye.n * this.n, Oa(Ye.n, this.n) * Oa(Ye.d, this.d));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(t) {
    return t = Math.pow(10, t || 0), isNaN(this.n) || isNaN(this.d) ? new Hr(NaN) : ir(Math.ceil(t * this.s * this.n / this.d), t);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(t) {
    return t = Math.pow(10, t || 0), isNaN(this.n) || isNaN(this.d) ? new Hr(NaN) : ir(Math.floor(t * this.s * this.n / this.d), t);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(t) {
    return t = Math.pow(10, t || 0), isNaN(this.n) || isNaN(this.d) ? new Hr(NaN) : ir(Math.round(t * this.s * this.n / this.d), t);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  roundTo: function(t, e) {
    return vn(t, e), ir(this.s * Math.round(this.n * Ye.d / (this.d * Ye.n)) * Ye.n, Ye.d);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return ir(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(t, e) {
    if (vn(t, e), Ye.d === 1)
      return Ye.s < 0 ? ir(Math.pow(this.s * this.d, Ye.n), Math.pow(this.n, Ye.n)) : ir(Math.pow(this.s * this.n, Ye.n), Math.pow(this.d, Ye.n));
    if (this.s < 0) return null;
    var r = Jg(this.n), n = Jg(this.d), a = 1, s = 1;
    for (var o in r)
      if (o !== "1") {
        if (o === "0") {
          a = 0;
          break;
        }
        if (r[o] *= Ye.n, r[o] % Ye.d === 0)
          r[o] /= Ye.d;
        else return null;
        a *= Math.pow(o, r[o]);
      }
    for (var o in n)
      if (o !== "1") {
        if (n[o] *= Ye.n, n[o] % Ye.d === 0)
          n[o] /= Ye.d;
        else return null;
        s *= Math.pow(o, n[o]);
      }
    return Ye.s < 0 ? ir(s, a) : ir(a, s);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(t, e) {
    return vn(t, e), this.s * this.n * Ye.d === Ye.s * Ye.n * this.d;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  compare: function(t, e) {
    vn(t, e);
    var r = this.s * this.n * Ye.d - Ye.s * Ye.n * this.d;
    return (0 < r) - (r < 0);
  },
  simplify: function(t) {
    if (isNaN(this.n) || isNaN(this.d))
      return this;
    t = t || 1e-3;
    for (var e = this.abs(), r = e.toContinued(), n = 1; n < r.length; n++) {
      for (var a = ir(r[n - 1], 1), s = n - 2; s >= 0; s--)
        a = a.inverse().add(r[s]);
      if (Math.abs(a.sub(e).valueOf()) < t)
        return a.mul(this.s);
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(t, e) {
    return vn(t, e), !(!(Ye.n * this.d) || this.n * Ye.d % (Ye.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return this.s * this.n / this.d;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  toFraction: function(t) {
    var e, r = "", n = this.n, a = this.d;
    return this.s < 0 && (r += "-"), a === 1 ? r += n : (t && (e = Math.floor(n / a)) > 0 && (r += e, r += " ", n %= a), r += n, r += "/", r += a), r;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(t) {
    var e, r = "", n = this.n, a = this.d;
    return this.s < 0 && (r += "-"), a === 1 ? r += n : (t && (e = Math.floor(n / a)) > 0 && (r += e, n %= a), r += "\\frac{", r += n, r += "}{", r += a, r += "}"), r;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    var t, e = this.n, r = this.d, n = [];
    if (isNaN(e) || isNaN(r))
      return n;
    do
      n.push(Math.floor(e / r)), t = e % r, e = r, r = t;
    while (e !== 1);
    return n;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(t) {
    var e = this.n, r = this.d;
    if (isNaN(e) || isNaN(r))
      return "NaN";
    t = t || 15;
    var n = bT(e, r), a = wT(e, r, n), s = this.s < 0 ? "-" : "";
    if (s += e / r | 0, e %= r, e *= 10, e && (s += "."), n) {
      for (var o = a; o--; )
        s += e / r | 0, e %= r, e *= 10;
      s += "(";
      for (var o = n; o--; )
        s += e / r | 0, e %= r, e *= 10;
      s += ")";
    } else
      for (var o = t; e && o--; )
        s += e / r | 0, e %= r, e *= 10;
    return s;
  }
};
var DT = "Fraction", AT = [], Bu = /* @__PURE__ */ j(DT, AT, () => (Object.defineProperty(Hr, "name", {
  value: "Fraction"
}), Hr.prototype.constructor = Hr, Hr.prototype.type = "Fraction", Hr.prototype.isFraction = !0, Hr.prototype.toJSON = function() {
  return {
    mathjs: "Fraction",
    n: this.s * this.n,
    d: this.d
  };
}, Hr.fromJSON = function(t) {
  return new Hr(t);
}, Hr), {
  isClass: !0
}), ET = "Range", ST = [], Ru = /* @__PURE__ */ j(ET, ST, () => {
  function t(e, r, n) {
    if (!(this instanceof t))
      throw new SyntaxError("Constructor must be called with the new operator");
    var a = e != null, s = r != null, o = n != null;
    if (a) {
      if (ct(e))
        e = e.toNumber();
      else if (typeof e != "number")
        throw new TypeError("Parameter start must be a number");
    }
    if (s) {
      if (ct(r))
        r = r.toNumber();
      else if (typeof r != "number")
        throw new TypeError("Parameter end must be a number");
    }
    if (o) {
      if (ct(n))
        n = n.toNumber();
      else if (typeof n != "number")
        throw new TypeError("Parameter step must be a number");
    }
    this.start = a ? parseFloat(e) : 0, this.end = s ? parseFloat(r) : 0, this.step = o ? parseFloat(n) : 1;
  }
  return t.prototype.type = "Range", t.prototype.isRange = !0, t.parse = function(e) {
    if (typeof e != "string")
      return null;
    var r = e.split(":"), n = r.map(function(s) {
      return parseFloat(s);
    }), a = n.some(function(s) {
      return isNaN(s);
    });
    if (a)
      return null;
    switch (n.length) {
      case 2:
        return new t(n[0], n[1]);
      case 3:
        return new t(n[0], n[2], n[1]);
      default:
        return null;
    }
  }, t.prototype.clone = function() {
    return new t(this.start, this.end, this.step);
  }, t.prototype.size = function() {
    var e = 0, r = this.start, n = this.step, a = this.end, s = a - r;
    return Ci(n) === Ci(s) ? e = Math.ceil(s / n) : s === 0 && (e = 0), isNaN(e) && (e = 0), [e];
  }, t.prototype.min = function() {
    var e = this.size()[0];
    if (e > 0)
      return this.step > 0 ? this.start : this.start + (e - 1) * this.step;
  }, t.prototype.max = function() {
    var e = this.size()[0];
    if (e > 0)
      return this.step > 0 ? this.start + (e - 1) * this.step : this.start;
  }, t.prototype.forEach = function(e) {
    var r = this.start, n = this.step, a = this.end, s = 0;
    if (n > 0)
      for (; r < a; )
        e(r, [s], this), r += n, s++;
    else if (n < 0)
      for (; r > a; )
        e(r, [s], this), r += n, s++;
  }, t.prototype.map = function(e) {
    var r = [];
    return this.forEach(function(n, a, s) {
      r[a[0]] = e(n, a, s);
    }), r;
  }, t.prototype.toArray = function() {
    var e = [];
    return this.forEach(function(r, n) {
      e[n[0]] = r;
    }), e;
  }, t.prototype.valueOf = function() {
    return this.toArray();
  }, t.prototype.format = function(e) {
    var r = na(this.start, e);
    return this.step !== 1 && (r += ":" + na(this.step, e)), r += ":" + na(this.end, e), r;
  }, t.prototype.toString = function() {
    return this.format();
  }, t.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  }, t.fromJSON = function(e) {
    return new t(e.start, e.end, e.step);
  }, t;
}, {
  isClass: !0
}), CT = "Matrix", TT = [], Lu = /* @__PURE__ */ j(CT, TT, () => {
  function t() {
    if (!(this instanceof t))
      throw new SyntaxError("Constructor must be called with the new operator");
  }
  return t.prototype.type = "Matrix", t.prototype.isMatrix = !0, t.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  }, t.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  }, t.prototype.create = function(e, r) {
    throw new Error("Cannot invoke create on a Matrix interface");
  }, t.prototype.subset = function(e, r, n) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  }, t.prototype.get = function(e) {
    throw new Error("Cannot invoke get on a Matrix interface");
  }, t.prototype.set = function(e, r, n) {
    throw new Error("Cannot invoke set on a Matrix interface");
  }, t.prototype.resize = function(e, r) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  }, t.prototype.reshape = function(e, r) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  }, t.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  }, t.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  }, t.prototype.map = function(e, r) {
    throw new Error("Cannot invoke map on a Matrix interface");
  }, t.prototype.forEach = function(e) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  }, t.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  }, t.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  }, t.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  }, t.prototype.format = function(e) {
    throw new Error("Cannot invoke format on a Matrix interface");
  }, t.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  }, t;
}, {
  isClass: !0
});
function Bm(t, e, r) {
  var n = t.constructor, a = new n(2), s = "";
  if (r) {
    if (r < 1)
      throw new Error("size must be in greater than 0");
    if (!Xe(r))
      throw new Error("size must be an integer");
    if (t.greaterThan(a.pow(r - 1).sub(1)) || t.lessThan(a.pow(r - 1).mul(-1)))
      throw new Error("Value must be in range [-2^".concat(r - 1, ", 2^").concat(r - 1, "-1]"));
    if (!t.isInteger())
      throw new Error("Value must be an integer");
    t.lessThan(0) && (t = t.add(a.pow(r))), s = "i".concat(r);
  }
  switch (e) {
    case 2:
      return "".concat(t.toBinary()).concat(s);
    case 8:
      return "".concat(t.toOctal()).concat(s);
    case 16:
      return "".concat(t.toHexadecimal()).concat(s);
    default:
      throw new Error("Base ".concat(e, " not supported "));
  }
}
function _T(t, e) {
  if (typeof e == "function")
    return e(t);
  if (!t.isFinite())
    return t.isNaN() ? "NaN" : t.gt(0) ? "Infinity" : "-Infinity";
  var {
    notation: r,
    precision: n,
    wordSize: a
  } = x2(e);
  switch (r) {
    case "fixed":
      return OT(t, n);
    case "exponential":
      return Yg(t, n);
    case "engineering":
      return MT(t, n);
    case "bin":
      return Bm(t, 2, a);
    case "oct":
      return Bm(t, 8, a);
    case "hex":
      return Bm(t, 16, a);
    case "auto": {
      var s = Xg(e?.lowerExp, -3), o = Xg(e?.upperExp, 5);
      if (t.isZero()) return "0";
      var p, u = t.toSignificantDigits(n), f = u.e;
      return f >= s && f < o ? p = u.toFixed() : p = Yg(t, n), p.replace(/((\.\d*?)(0+))($|e)/, function() {
        var l = arguments[2], c = arguments[4];
        return l !== "." ? l + c : c;
      });
    }
    default:
      throw new Error('Unknown notation "' + r + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function MT(t, e) {
  var r = t.e, n = r % 3 === 0 ? r : r < 0 ? r - 3 - r % 3 : r - r % 3, a = t.mul(Math.pow(10, -n)), s = a.toPrecision(e);
  if (s.includes("e")) {
    var o = t.constructor;
    s = new o(s).toFixed();
  }
  return s + "e" + (r >= 0 ? "+" : "") + n.toString();
}
function Yg(t, e) {
  return e !== void 0 ? t.toExponential(e - 1) : t.toExponential();
}
function OT(t, e) {
  return t.toFixed(e);
}
function Xg(t, e) {
  return ht(t) ? t : ct(t) ? t.toNumber() : e;
}
function FT(t, e) {
  var r = t.length - e.length, n = t.length;
  return t.substring(r, n) === e;
}
function Dt(t, e) {
  var r = qT(t, e);
  return e && typeof e == "object" && "truncate" in e && r.length > e.truncate ? r.substring(0, e.truncate - 3) + "..." : r;
}
function qT(t, e) {
  if (typeof t == "number")
    return na(t, e);
  if (ct(t))
    return _T(t, e);
  if (IT(t))
    return !e || e.fraction !== "decimal" ? t.s * t.n + "/" + t.d : t.toString();
  if (Array.isArray(t))
    return z2(t, e);
  if (Er(t))
    return Fa(t);
  if (typeof t == "function")
    return t.syntax ? String(t.syntax) : "function";
  if (t && typeof t == "object") {
    if (typeof t.format == "function")
      return t.format(e);
    if (t && t.toString(e) !== {}.toString())
      return t.toString(e);
    var r = Object.keys(t).map((n) => Fa(n) + ": " + Dt(t[n], e));
    return "{" + r.join(", ") + "}";
  }
  return String(t);
}
function Fa(t) {
  for (var e = String(t), r = "", n = 0; n < e.length; ) {
    var a = e.charAt(n);
    r += a in Kg ? Kg[a] : a, n++;
  }
  return '"' + r + '"';
}
var Kg = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
function _n(t) {
  var e = String(t);
  return e = e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), e;
}
function z2(t, e) {
  if (Array.isArray(t)) {
    for (var r = "[", n = t.length, a = 0; a < n; a++)
      a !== 0 && (r += ", "), r += z2(t[a], e);
    return r += "]", r;
  } else
    return Dt(t, e);
}
function IT(t) {
  return t && typeof t == "object" && typeof t.s == "number" && typeof t.n == "number" && typeof t.d == "number" || !1;
}
function Zm(t, e) {
  if (!Er(t))
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + Vt(t) + ", index: 0)");
  if (!Er(e))
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + Vt(e) + ", index: 1)");
  return t === e ? 0 : t > e ? 1 : -1;
}
function xt(t, e, r) {
  if (!(this instanceof xt))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.actual = t, this.expected = e, this.relation = r, this.message = "Dimension mismatch (" + (Array.isArray(t) ? "[" + t.join(", ") + "]" : t) + " " + (this.relation || "!=") + " " + (Array.isArray(e) ? "[" + e.join(", ") + "]" : e) + ")", this.stack = new Error().stack;
}
xt.prototype = new RangeError();
xt.prototype.constructor = RangeError;
xt.prototype.name = "DimensionError";
xt.prototype.isDimensionError = !0;
function yn(t, e, r) {
  if (!(this instanceof yn))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.index = t, arguments.length < 3 ? (this.min = 0, this.max = e) : (this.min = e, this.max = r), this.min !== void 0 && this.index < this.min ? this.message = "Index out of range (" + this.index + " < " + this.min + ")" : this.max !== void 0 && this.index >= this.max ? this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")" : this.message = "Index out of range (" + this.index + ")", this.stack = new Error().stack;
}
yn.prototype = new RangeError();
yn.prototype.constructor = RangeError;
yn.prototype.name = "IndexError";
yn.prototype.isIndexError = !0;
function gt(t) {
  for (var e = []; Array.isArray(t); )
    e.push(t.length), t = t[0];
  return e;
}
function U2(t, e, r) {
  var n, a = t.length;
  if (a !== e[r])
    throw new xt(a, e[r]);
  if (r < e.length - 1) {
    var s = r + 1;
    for (n = 0; n < a; n++) {
      var o = t[n];
      if (!Array.isArray(o))
        throw new xt(e.length - 1, e.length, "<");
      U2(t[n], e, s);
    }
  } else
    for (n = 0; n < a; n++)
      if (Array.isArray(t[n]))
        throw new xt(e.length + 1, e.length, ">");
}
function e1(t, e) {
  var r = e.length === 0;
  if (r) {
    if (Array.isArray(t))
      throw new xt(t.length, 0);
  } else
    U2(t, e, 0);
}
function ru(t, e) {
  var r = t.isMatrix ? t._size : gt(t), n = e._sourceSize;
  n.forEach((a, s) => {
    if (a !== null && a !== r[s])
      throw new xt(a, r[s]);
  });
}
function Ht(t, e) {
  if (t !== void 0) {
    if (!ht(t) || !Xe(t))
      throw new TypeError("Index must be an integer (value: " + t + ")");
    if (t < 0 || typeof e == "number" && t >= e)
      throw new yn(t, e);
  }
}
function ka(t) {
  for (var e = 0; e < t._dimensions.length; ++e) {
    var r = t._dimensions[e];
    if (r._data && Rt(r._data)) {
      if (r._size[0] === 0)
        return !0;
    } else if (r.isRange) {
      if (r.start === r.end)
        return !0;
    } else if (Er(r) && r.length === 0)
      return !0;
  }
  return !1;
}
function $a(t, e, r) {
  if (!Array.isArray(e))
    throw new TypeError("Array expected");
  if (e.length === 0)
    throw new Error("Resizing to scalar is not supported");
  e.forEach(function(a) {
    if (!ht(a) || !Xe(a) || a < 0)
      throw new TypeError("Invalid size, must contain positive integers (size: " + Dt(e) + ")");
  }), (ht(t) || ct(t)) && (t = [t]);
  var n = r !== void 0 ? r : 0;
  return Jm(t, e, 0, n), t;
}
function Jm(t, e, r, n) {
  var a, s, o = t.length, p = e[r], u = Math.min(o, p);
  if (t.length = p, r < e.length - 1) {
    var f = r + 1;
    for (a = 0; a < u; a++)
      s = t[a], Array.isArray(s) || (s = [s], t[a] = s), Jm(s, e, f, n);
    for (a = u; a < p; a++)
      s = [], t[a] = s, Jm(s, e, f, n);
  } else {
    for (a = 0; a < u; a++)
      for (; Array.isArray(t[a]); )
        t[a] = t[a][0];
    for (a = u; a < p; a++)
      t[a] = n;
  }
}
function Ed(t, e) {
  var r = Lt(t), n = r.length;
  if (!Array.isArray(t) || !Array.isArray(e))
    throw new TypeError("Array expected");
  if (e.length === 0)
    throw new xt(0, n, "!=");
  e = Sd(e, n);
  var a = G2(e);
  if (n !== a)
    throw new xt(a, n, "!=");
  try {
    return BT(r, e);
  } catch (s) {
    throw s instanceof xt ? new xt(a, n, "!=") : s;
  }
}
function Sd(t, e) {
  var r = G2(t), n = t.slice(), a = -1, s = t.indexOf(a), o = t.indexOf(a, s + 1) >= 0;
  if (o)
    throw new Error("More than one wildcard in sizes");
  var p = s >= 0, u = e % r === 0;
  if (p)
    if (u)
      n[s] = -e / r;
    else
      throw new Error("Could not replace wildcard, since " + e + " is no multiple of " + -r);
  return n;
}
function G2(t) {
  return t.reduce((e, r) => e * r, 1);
}
function BT(t, e) {
  for (var r = t, n, a = e.length - 1; a > 0; a--) {
    var s = e[a];
    n = [];
    for (var o = r.length / s, p = 0; p < o; p++)
      n.push(r.slice(p * s, (p + 1) * s));
    r = n;
  }
  return r;
}
function nu(t, e) {
  for (var r = gt(t); Array.isArray(t) && t.length === 1; )
    t = t[0], r.shift();
  for (var n = r.length; r[n - 1] === 1; )
    n--;
  return n < r.length && (t = H2(t, n, 0), r.length = n), t;
}
function H2(t, e, r) {
  var n, a;
  if (r < e) {
    var s = r + 1;
    for (n = 0, a = t.length; n < a; n++)
      t[n] = H2(t[n], e, s);
  } else
    for (; Array.isArray(t); )
      t = t[0];
  return t;
}
function Q2(t, e, r, n) {
  var a = n || gt(t);
  if (r)
    for (var s = 0; s < r; s++)
      t = [t], a.unshift(1);
  for (t = V2(t, e, 0); a.length < e; )
    a.push(1);
  return t;
}
function V2(t, e, r) {
  var n, a;
  if (Array.isArray(t)) {
    var s = r + 1;
    for (n = 0, a = t.length; n < a; n++)
      t[n] = V2(t[n], e, s);
  } else
    for (var o = r; o < e; o++)
      t = [t];
  return t;
}
function Lt(t) {
  if (!Array.isArray(t))
    return t;
  var e = [];
  return t.forEach(function r(n) {
    Array.isArray(n) ? n.forEach(r) : e.push(n);
  }), e;
}
function fi(t, e) {
  return Array.prototype.map.call(t, e);
}
function Pu(t, e) {
  Array.prototype.forEach.call(t, e);
}
function W2(t, e) {
  if (gt(t).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(t, e);
}
function iu(t, e) {
  if (gt(t).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(t, (r) => e.test(r));
}
function t1(t, e) {
  return Array.prototype.join.call(t, e);
}
function za(t) {
  if (!Array.isArray(t))
    throw new TypeError("Array input expected");
  if (t.length === 0)
    return t;
  var e = [], r = 0;
  e[0] = {
    value: t[0],
    identifier: 0
  };
  for (var n = 1; n < t.length; n++)
    t[n] === t[n - 1] ? r++ : r = 0, e.push({
      value: t[n],
      identifier: r
    });
  return e;
}
function au(t) {
  if (!Array.isArray(t))
    throw new TypeError("Array input expected");
  if (t.length === 0)
    return t;
  for (var e = [], r = 0; r < t.length; r++)
    e.push(t[r].value);
  return e;
}
function qs(t, e) {
  for (var r, n = 0, a = 0; a < t.length; a++) {
    var s = t[a], o = Array.isArray(s);
    if (a === 0 && o && (n = s.length), o && s.length !== n)
      return;
    var p = o ? qs(s, e) : e(s);
    if (r === void 0)
      r = p;
    else if (r !== p)
      return "mixed";
  }
  return r;
}
function j2(t, e, r, n) {
  if (n < r) {
    if (t.length !== e.length)
      throw new xt(t.length, e.length);
    for (var a = [], s = 0; s < t.length; s++)
      a[s] = j2(t[s], e[s], r, n + 1);
    return a;
  } else
    return t.concat(e);
}
function Z2() {
  var t = Array.prototype.slice.call(arguments, 0, -1), e = Array.prototype.slice.call(arguments, -1);
  if (t.length === 1)
    return t[0];
  if (t.length > 1)
    return t.slice(1).reduce(function(r, n) {
      return j2(r, n, e, 0);
    }, t[0]);
  throw new Error("Wrong number of arguments in function concat");
}
function RT() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  for (var n = e.map((h) => h.length), a = Math.max(...n), s = new Array(a).fill(null), o = 0; o < e.length; o++)
    for (var p = e[o], u = n[o], f = 0; f < u; f++) {
      var l = a - u + f;
      p[f] > s[l] && (s[l] = p[f]);
    }
  for (var c = 0; c < e.length; c++)
    su(e[c], s);
  return s;
}
function su(t, e) {
  for (var r = e.length, n = t.length, a = 0; a < n; a++) {
    var s = r - n + a;
    if (t[a] < e[s] && t[a] > 1 || t[a] > e[s])
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(t, ") not possible to broadcast dimension ").concat(n, " with size ").concat(t[a], " to size ").concat(e[s]));
  }
}
function r1(t, e) {
  var r = gt(t);
  if (ia(r, e))
    return t;
  su(r, e);
  var n = RT(r, e), a = n.length, s = [...Array(a - r.length).fill(1), ...r], o = PT(t);
  r.length < a && (o = Ed(o, s), r = gt(o));
  for (var p = 0; p < a; p++)
    r[p] < n[p] && (o = LT(o, n[p], p), r = gt(o));
  return o;
}
function LT(t, e, r) {
  return Z2(...Array(e).fill(t), r);
}
function PT(t) {
  return hr([], t);
}
function kT(t) {
  var e = 0, r = 1, n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null), s = 0, o = function(u) {
    var f = a[u];
    if (f && (delete n[f], delete a[u], --e, r === f)) {
      if (!e) {
        s = 0, r = 1;
        return;
      }
      for (; !Object.prototype.hasOwnProperty.call(n, ++r); )
        ;
    }
  };
  return t = Math.abs(t), {
    hit: function(u) {
      var f = a[u], l = ++s;
      if (n[l] = u, a[u] = l, !f)
        return ++e, e <= t ? void 0 : (u = n[r], o(u), u);
      if (delete n[f], r === f)
        for (; !Object.prototype.hasOwnProperty.call(n, ++r); )
          ;
    },
    delete: o,
    clear: function() {
      e = s = 0, r = 1, n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
    }
  };
}
function Us(t) {
  var {
    hasher: e,
    limit: r
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return r = r ?? Number.POSITIVE_INFINITY, e = e ?? JSON.stringify, function n() {
    typeof n.cache != "object" && (n.cache = {
      values: /* @__PURE__ */ new Map(),
      lru: kT(r || Number.POSITIVE_INFINITY)
    });
    for (var a = [], s = 0; s < arguments.length; s++)
      a[s] = arguments[s];
    var o = e(a);
    if (n.cache.values.has(o))
      return n.cache.lru.hit(o), n.cache.values.get(o);
    var p = t.apply(t, a);
    return n.cache.values.set(o, p), n.cache.values.delete(n.cache.lru.hit(o)), p;
  };
}
function J2(t) {
  return Object.keys(t.signatures || {}).reduce(function(e, r) {
    var n = (r.match(/,/g) || []).length + 1;
    return Math.max(e, n);
  }, -1);
}
var $T = "DenseMatrix", zT = ["Matrix"], ku = /* @__PURE__ */ j($T, zT, (t) => {
  var {
    Matrix: e
  } = t;
  function r(l, c) {
    if (!(this instanceof r))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (c && !Er(c))
      throw new Error("Invalid datatype: " + c);
    if (tt(l))
      l.type === "DenseMatrix" ? (this._data = nt(l._data), this._size = nt(l._size), this._datatype = c || l._datatype) : (this._data = l.toArray(), this._size = l.size(), this._datatype = c || l._datatype);
    else if (l && Rt(l.data) && Rt(l.size))
      this._data = l.data, this._size = l.size, e1(this._data, this._size), this._datatype = c || l.datatype;
    else if (Rt(l))
      this._data = f(l), this._size = gt(this._data), e1(this._data, this._size), this._datatype = c;
    else {
      if (l)
        throw new TypeError("Unsupported type of data (" + Vt(l) + ")");
      this._data = [], this._size = [0], this._datatype = c;
    }
  }
  r.prototype = new e(), r.prototype.createDenseMatrix = function(l, c) {
    return new r(l, c);
  }, Object.defineProperty(r, "name", {
    value: "DenseMatrix"
  }), r.prototype.constructor = r, r.prototype.type = "DenseMatrix", r.prototype.isDenseMatrix = !0, r.prototype.getDataType = function() {
    return qs(this._data, Vt);
  }, r.prototype.storage = function() {
    return "dense";
  }, r.prototype.datatype = function() {
    return this._datatype;
  }, r.prototype.create = function(l, c) {
    return new r(l, c);
  }, r.prototype.subset = function(l, c, h) {
    switch (arguments.length) {
      case 1:
        return n(this, l);
      case 2:
      case 3:
        return s(this, l, c, h);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  }, r.prototype.get = function(l) {
    if (!Rt(l))
      throw new TypeError("Array expected");
    if (l.length !== this._size.length)
      throw new xt(l.length, this._size.length);
    for (var c = 0; c < l.length; c++)
      Ht(l[c], this._size[c]);
    for (var h = this._data, d = 0, g = l.length; d < g; d++) {
      var v = l[d];
      Ht(v, h.length), h = h[v];
    }
    return h;
  }, r.prototype.set = function(l, c, h) {
    if (!Rt(l))
      throw new TypeError("Array expected");
    if (l.length < this._size.length)
      throw new xt(l.length, this._size.length, "<");
    var d, g, v, N = l.map(function(C) {
      return C + 1;
    });
    u(this, N, h);
    var b = this._data;
    for (d = 0, g = l.length - 1; d < g; d++)
      v = l[d], Ht(v, b.length), b = b[v];
    return v = l[l.length - 1], Ht(v, b.length), b[v] = c, this;
  };
  function n(l, c) {
    if (!Va(c))
      throw new TypeError("Invalid index");
    var h = c.isScalar();
    if (h)
      return l.get(c.min());
    var d = c.size();
    if (d.length !== l._size.length)
      throw new xt(d.length, l._size.length);
    for (var g = c.min(), v = c.max(), N = 0, b = l._size.length; N < b; N++)
      Ht(g[N], l._size[N]), Ht(v[N], l._size[N]);
    return new r(a(l._data, c, d.length, 0), l._datatype);
  }
  function a(l, c, h, d) {
    var g = d === h - 1, v = c.dimension(d);
    return g ? v.map(function(N) {
      return Ht(N, l.length), l[N];
    }).valueOf() : v.map(function(N) {
      Ht(N, l.length);
      var b = l[N];
      return a(b, c, h, d + 1);
    }).valueOf();
  }
  function s(l, c, h, d) {
    if (!c || c.isIndex !== !0)
      throw new TypeError("Invalid index");
    var g = c.size(), v = c.isScalar(), N;
    if (tt(h) ? (N = h.size(), h = h.valueOf()) : N = gt(h), v) {
      if (N.length !== 0)
        throw new TypeError("Scalar expected");
      l.set(c.min(), h, d);
    } else {
      if (!ia(N, g))
        try {
          N.length === 0 ? h = r1([h], g) : h = r1(h, g), N = gt(h);
        } catch {
        }
      if (g.length < l._size.length)
        throw new xt(g.length, l._size.length, "<");
      if (N.length < g.length) {
        for (var b = 0, C = 0; g[b] === 1 && N[b] === 1; )
          b++;
        for (; g[b] === 1; )
          C++, b++;
        h = Q2(h, g.length, C, N);
      }
      if (!ia(g, N))
        throw new xt(g, N, ">");
      var x = c.max().map(function(A) {
        return A + 1;
      });
      u(l, x, d);
      var E = g.length, D = 0;
      o(l._data, c, h, E, D);
    }
    return l;
  }
  function o(l, c, h, d, g) {
    var v = g === d - 1, N = c.dimension(g);
    v ? N.forEach(function(b, C) {
      Ht(b), l[b] = h[C[0]];
    }) : N.forEach(function(b, C) {
      Ht(b), o(l[b], c, h[C[0]], d, g + 1);
    });
  }
  r.prototype.resize = function(l, c, h) {
    if (!cn(l))
      throw new TypeError("Array or Matrix expected");
    var d = l.valueOf().map((v) => Array.isArray(v) && v.length === 1 ? v[0] : v), g = h ? this.clone() : this;
    return p(g, d, c);
  };
  function p(l, c, h) {
    if (c.length === 0) {
      for (var d = l._data; Rt(d); )
        d = d[0];
      return d;
    }
    return l._size = c.slice(0), l._data = $a(l._data, l._size, h), l;
  }
  r.prototype.reshape = function(l, c) {
    var h = c ? this.clone() : this;
    h._data = Ed(h._data, l);
    var d = h._size.reduce((g, v) => g * v);
    return h._size = Sd(l, d), h;
  };
  function u(l, c, h) {
    for (var d = l._size.slice(0), g = !1; d.length < c.length; )
      d.push(0), g = !0;
    for (var v = 0, N = c.length; v < N; v++)
      c[v] > d[v] && (d[v] = c[v], g = !0);
    g && p(l, d, h);
  }
  r.prototype.clone = function() {
    var l = new r({
      data: nt(this._data),
      size: nt(this._size),
      datatype: this._datatype
    });
    return l;
  }, r.prototype.size = function() {
    return this._size.slice(0);
  }, r.prototype.map = function(l) {
    var c = this, h = J2(l), d = function N(b, C) {
      return Rt(b) ? b.map(function(x, E) {
        return N(x, C.concat(E));
      }) : h === 1 ? l(b) : h === 2 ? l(b, C) : l(b, C, c);
    }, g = d(this._data, []), v = this._datatype !== void 0 ? qs(g, Vt) : void 0;
    return new r(g, v);
  }, r.prototype.forEach = function(l) {
    var c = this, h = function d(g, v) {
      Rt(g) ? g.forEach(function(N, b) {
        d(N, v.concat(b));
      }) : l(g, v, c);
    };
    h(this._data, []);
  }, r.prototype[Symbol.iterator] = function* () {
    var l = function* c(h, d) {
      if (Rt(h))
        for (var g = 0; g < h.length; g++)
          yield* c(h[g], d.concat(g));
      else
        yield {
          value: h,
          index: d
        };
    };
    yield* l(this._data, []);
  }, r.prototype.rows = function() {
    var l = [], c = this.size();
    if (c.length !== 2)
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    var h = this._data;
    for (var d of h)
      l.push(new r([d], this._datatype));
    return l;
  }, r.prototype.columns = function() {
    var l = this, c = [], h = this.size();
    if (h.length !== 2)
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    for (var d = this._data, g = function(b) {
      var C = d.map((x) => [x[b]]);
      c.push(new r(C, l._datatype));
    }, v = 0; v < h[1]; v++)
      g(v);
    return c;
  }, r.prototype.toArray = function() {
    return nt(this._data);
  }, r.prototype.valueOf = function() {
    return this._data;
  }, r.prototype.format = function(l) {
    return Dt(this._data, l);
  }, r.prototype.toString = function() {
    return Dt(this._data);
  }, r.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  }, r.prototype.diagonal = function(l) {
    if (l) {
      if (ct(l) && (l = l.toNumber()), !ht(l) || !Xe(l))
        throw new TypeError("The parameter k must be an integer number");
    } else
      l = 0;
    for (var c = l > 0 ? l : 0, h = l < 0 ? -l : 0, d = this._size[0], g = this._size[1], v = Math.min(d - h, g - c), N = [], b = 0; b < v; b++)
      N[b] = this._data[b + h][b + c];
    return new r({
      data: N,
      size: [v],
      datatype: this._datatype
    });
  }, r.diagonal = function(l, c, h, d) {
    if (!Rt(l))
      throw new TypeError("Array expected, size parameter");
    if (l.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    if (l = l.map(function(M) {
      if (ct(M) && (M = M.toNumber()), !ht(M) || !Xe(M) || M < 1)
        throw new Error("Size values must be positive integers");
      return M;
    }), h) {
      if (ct(h) && (h = h.toNumber()), !ht(h) || !Xe(h))
        throw new TypeError("The parameter k must be an integer number");
    } else
      h = 0;
    var g = h > 0 ? h : 0, v = h < 0 ? -h : 0, N = l[0], b = l[1], C = Math.min(N - v, b - g), x;
    if (Rt(c)) {
      if (c.length !== C)
        throw new Error("Invalid value array length");
      x = function(_) {
        return c[_];
      };
    } else if (tt(c)) {
      var E = c.size();
      if (E.length !== 1 || E[0] !== C)
        throw new Error("Invalid matrix length");
      x = function(_) {
        return c.get([_]);
      };
    } else
      x = function() {
        return c;
      };
    d || (d = ct(x(0)) ? x(0).mul(0) : 0);
    var D = [];
    if (l.length > 0) {
      D = $a(D, l, d);
      for (var A = 0; A < C; A++)
        D[A + v][A + g] = x(A);
    }
    return new r({
      data: D,
      size: [N, b]
    });
  }, r.fromJSON = function(l) {
    return new r(l);
  }, r.prototype.swapRows = function(l, c) {
    if (!ht(l) || !Xe(l) || !ht(c) || !Xe(c))
      throw new Error("Row index must be positive integers");
    if (this._size.length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    return Ht(l, this._size[0]), Ht(c, this._size[0]), r._swapRows(l, c, this._data), this;
  }, r._swapRows = function(l, c, h) {
    var d = h[l];
    h[l] = h[c], h[c] = d;
  };
  function f(l) {
    return tt(l) ? f(l.valueOf()) : Rt(l) ? l.map(f) : l;
  }
  return r;
}, {
  isClass: !0
}), n1 = "clone", UT = ["typed"], $u = /* @__PURE__ */ j(n1, UT, (t) => {
  var {
    typed: e
  } = t;
  return e(n1, {
    any: nt
  });
});
function Y2(t) {
  var e = t.length, r = t[0].length, n, a, s = [];
  for (a = 0; a < r; a++) {
    var o = [];
    for (n = 0; n < e; n++)
      o.push(t[n][a]);
    s.push(o);
  }
  return s;
}
function Za(t) {
  for (var e = 0; e < t.length; e++)
    if (cn(t[e]))
      return !0;
  return !1;
}
function hi(t, e) {
  tt(t) && (t = t.valueOf());
  for (var r = 0, n = t.length; r < n; r++) {
    var a = t[r];
    Array.isArray(a) ? hi(a, e) : e(a);
  }
}
function Nt(t, e, r) {
  return t && typeof t.map == "function" ? t.map(function(n) {
    return Nt(n, e);
  }) : e(t);
}
function zu(t, e, r) {
  var n = Array.isArray(t) ? gt(t) : t.size();
  if (e < 0 || e >= n.length)
    throw new yn(e, n.length);
  return tt(t) ? t.create(ou(t.valueOf(), e, r)) : ou(t, e, r);
}
function ou(t, e, r) {
  var n, a, s, o;
  if (e <= 0)
    if (Array.isArray(t[0])) {
      for (o = Y2(t), a = [], n = 0; n < o.length; n++)
        a[n] = ou(o[n], e - 1, r);
      return a;
    } else {
      for (s = t[0], n = 1; n < t.length; n++)
        s = r(s, t[n]);
      return s;
    }
  else {
    for (a = [], n = 0; n < t.length; n++)
      a[n] = ou(t[n], e - 1, r);
    return a;
  }
}
function i1(t, e, r, n, a, s, o, p, u, f, l) {
  var c = t._values, h = t._index, d = t._ptr, g, v, N, b;
  if (n)
    for (v = d[e], N = d[e + 1], g = v; g < N; g++)
      b = h[g], r[b] !== s ? (r[b] = s, o.push(b), n[b] = c[g]) : (n[b] = p(n[b], c[g]), a[b] = s);
  else
    for (v = d[e], N = d[e + 1], g = v; g < N; g++)
      b = h[g], r[b] !== s ? (r[b] = s, o.push(b)) : a[b] = s;
}
var a1 = "isInteger", GT = ["typed"], Uu = /* @__PURE__ */ j(a1, GT, (t) => {
  var {
    typed: e
  } = t;
  return e(a1, {
    number: Xe,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function(n) {
      return n.isInt();
    },
    bigint: function(n) {
      return !0;
    },
    Fraction: function(n) {
      return n.d === 1 && isFinite(n.n);
    },
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), $n = "number", Ja = "number, number";
function X2(t) {
  return Math.abs(t);
}
X2.signature = $n;
function K2(t, e) {
  return t + e;
}
K2.signature = Ja;
function ew(t, e) {
  return t - e;
}
ew.signature = Ja;
function tw(t, e) {
  return t * e;
}
tw.signature = Ja;
function rw(t) {
  return -t;
}
rw.signature = $n;
function nw(t) {
  return t;
}
nw.signature = $n;
function Cs(t) {
  return JS(t);
}
Cs.signature = $n;
function iw(t) {
  return t * t * t;
}
iw.signature = $n;
function aw(t) {
  return Math.exp(t);
}
aw.signature = $n;
function sw(t) {
  return YS(t);
}
sw.signature = $n;
function ow(t, e) {
  if (!Xe(t) || !Xe(e))
    throw new Error("Parameters in function lcm must be integer numbers");
  if (t === 0 || e === 0)
    return 0;
  for (var r, n = t * e; e !== 0; )
    r = e, e = t % r, t = r;
  return Math.abs(n / t);
}
ow.signature = Ja;
function HT(t, e) {
  return Math.log(t);
}
function uw(t) {
  return jS(t);
}
uw.signature = $n;
function lw(t) {
  return WS(t);
}
lw.signature = $n;
function s1(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, r = e < 0;
  if (r && (e = -e), e === 0)
    throw new Error("Root must be non-zero");
  if (t < 0 && Math.abs(e) % 2 !== 1)
    throw new Error("Root must be odd when a is negative.");
  if (t === 0)
    return r ? 1 / 0 : 0;
  if (!isFinite(t))
    return r ? 0 : t;
  var n = Math.pow(Math.abs(t), 1 / e);
  return n = t < 0 ? -n : n, r ? 1 / n : n;
}
function Ym(t) {
  return Ci(t);
}
Ym.signature = $n;
function cw(t) {
  return t * t;
}
cw.signature = $n;
function fw(t, e) {
  var r, n, a, s = 0, o = 1, p = 1, u = 0;
  if (!Xe(t) || !Xe(e))
    throw new Error("Parameters in function xgcd must be integer numbers");
  for (; e; )
    n = Math.floor(t / e), a = t - n * e, r = s, s = o - n * s, o = r, r = p, p = u - n * p, u = r, t = e, e = a;
  var f;
  return t < 0 ? f = [-t, -o, -u] : f = [t, t ? o : 0, u], f;
}
fw.signature = Ja;
function pw(t, e) {
  return t * t < 1 && e === 1 / 0 || t * t > 1 && e === -1 / 0 ? 0 : Math.pow(t, e);
}
pw.signature = Ja;
function Es(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!Xe(e) || e < 0 || e > 15)
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  return parseFloat(b2(t, e));
}
var QT = "number", Ya = "number, number";
function hw(t, e) {
  if (!Xe(t) || !Xe(e))
    throw new Error("Integers expected in function bitAnd");
  return t & e;
}
hw.signature = Ya;
function mw(t) {
  if (!Xe(t))
    throw new Error("Integer expected in function bitNot");
  return ~t;
}
mw.signature = QT;
function dw(t, e) {
  if (!Xe(t) || !Xe(e))
    throw new Error("Integers expected in function bitOr");
  return t | e;
}
dw.signature = Ya;
function vw(t, e) {
  if (!Xe(t) || !Xe(e))
    throw new Error("Integers expected in function bitXor");
  return t ^ e;
}
vw.signature = Ya;
function gw(t, e) {
  if (!Xe(t) || !Xe(e))
    throw new Error("Integers expected in function leftShift");
  return t << e;
}
gw.signature = Ya;
function yw(t, e) {
  if (!Xe(t) || !Xe(e))
    throw new Error("Integers expected in function rightArithShift");
  return t >> e;
}
yw.signature = Ya;
function xw(t, e) {
  if (!Xe(t) || !Xe(e))
    throw new Error("Integers expected in function rightLogShift");
  return t >>> e;
}
xw.signature = Ya;
function li(t, e) {
  if (e < t)
    return 1;
  if (e === t)
    return e;
  var r = e + t >> 1;
  return li(t, r) * li(r + 1, e);
}
function bw(t, e) {
  if (!Xe(t) || t < 0)
    throw new TypeError("Positive integer value expected in function combinations");
  if (!Xe(e) || e < 0)
    throw new TypeError("Positive integer value expected in function combinations");
  if (e > t)
    throw new TypeError("k must be less than or equal to n");
  for (var r = t - e, n = 1, a = e < r ? r + 1 : e + 1, s = 2, o = e < r ? e : r, p = a; p <= t; ++p)
    for (n *= p; s <= o && n % s === 0; )
      n /= s, ++s;
  return s <= o && (n /= li(s, o)), n;
}
bw.signature = "number, number";
var VT = Math.PI, WT = 2 * Math.PI, jT = Math.E, ZT = 1.618033988749895, JT = "number", Cd = "number, number";
function ww(t) {
  return !t;
}
ww.signature = JT;
function Xm(t, e) {
  return !!(t || e);
}
Xm.signature = Cd;
function Km(t, e) {
  return !!t != !!e;
}
Km.signature = Cd;
function ed(t, e) {
  return !!(t && e);
}
ed.signature = Cd;
function uu(t) {
  var e;
  if (Xe(t))
    return t <= 0 ? isFinite(t) ? 1 / 0 : NaN : t > 171 ? 1 / 0 : li(1, t - 1);
  if (t < 0.5)
    return Math.PI / (Math.sin(Math.PI * t) * uu(1 - t));
  if (t >= 171.35)
    return 1 / 0;
  if (t > 85) {
    var r = t * t, n = r * t, a = n * t, s = a * t;
    return Math.sqrt(2 * Math.PI / t) * Math.pow(t / Math.E, t) * (1 + 1 / (12 * t) + 1 / (288 * r) - 139 / (51840 * n) - 571 / (2488320 * a) + 163879 / (209018880 * s) + 5246819 / (75246796800 * s * t));
  }
  --t, e = Ba[0];
  for (var o = 1; o < Ba.length; ++o)
    e += Ba[o] / (t + o);
  var p = t + Nw + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(p, t + 0.5) * Math.exp(-p) * e;
}
uu.signature = "number";
var Nw = 4.7421875, Ba = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22], Dw = 0.9189385332046728, YT = 5, XT = 7, o1 = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
function lu(t) {
  if (t < 0) return NaN;
  if (t === 0) return 1 / 0;
  if (!isFinite(t)) return t;
  if (t < 0.5)
    return Math.log(Math.PI / Math.sin(Math.PI * t)) - lu(1 - t);
  t = t - 1;
  for (var e = t + YT + 0.5, r = o1[0], n = XT - 1; n >= 1; n--)
    r += o1[n] / (t + n);
  return Dw + (t + 0.5) * Math.log(e) - e + Math.log(r);
}
lu.signature = "number";
var jr = "number";
function Aw(t) {
  return tC(t);
}
Aw.signature = jr;
function Ew(t) {
  return Math.atan(1 / t);
}
Ew.signature = jr;
function Sw(t) {
  return isFinite(t) ? (Math.log((t + 1) / t) + Math.log(t / (t - 1))) / 2 : 0;
}
Sw.signature = jr;
function Cw(t) {
  return Math.asin(1 / t);
}
Cw.signature = jr;
function Tw(t) {
  var e = 1 / t;
  return Math.log(e + Math.sqrt(e * e + 1));
}
Tw.signature = jr;
function _w(t) {
  return Math.acos(1 / t);
}
_w.signature = jr;
function Mw(t) {
  var e = 1 / t, r = Math.sqrt(e * e - 1);
  return Math.log(r + e);
}
Mw.signature = jr;
function Ow(t) {
  return rC(t);
}
Ow.signature = jr;
function Fw(t) {
  return nC(t);
}
Fw.signature = jr;
function qw(t) {
  return 1 / Math.tan(t);
}
qw.signature = jr;
function Iw(t) {
  var e = Math.exp(2 * t);
  return (e + 1) / (e - 1);
}
Iw.signature = jr;
function Bw(t) {
  return 1 / Math.sin(t);
}
Bw.signature = jr;
function Rw(t) {
  return t === 0 ? Number.POSITIVE_INFINITY : Math.abs(2 / (Math.exp(t) - Math.exp(-t))) * Ci(t);
}
Rw.signature = jr;
function Lw(t) {
  return 1 / Math.cos(t);
}
Lw.signature = jr;
function Pw(t) {
  return 2 / (Math.exp(t) + Math.exp(-t));
}
Pw.signature = jr;
function kw(t) {
  return aC(t);
}
kw.signature = jr;
var Td = "number";
function $w(t) {
  return t < 0;
}
$w.signature = Td;
function zw(t) {
  return t > 0;
}
zw.signature = Td;
function Uw(t) {
  return Number.isNaN(t);
}
Uw.signature = Td;
function pn(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-9, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  if (r <= 0)
    throw new Error("Relative tolerance must be greater than 0");
  if (n < 0)
    throw new Error("Absolute tolerance must be at least 0");
  return t.isNaN() || e.isNaN() ? !1 : !t.isFinite() || !e.isFinite() ? t.eq(e) : t.eq(e) ? !0 : t.minus(e).abs().lte(t.constructor.max(t.constructor.max(t.abs(), e.abs()).mul(r), n));
}
var u1 = "isNegative", KT = ["typed", "config"], Gu = /* @__PURE__ */ j(u1, KT, (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(u1, {
    number: (n) => Lr(n, 0, r.relTol, r.absTol) ? !1 : $w(n),
    BigNumber: (n) => pn(n, new n.constructor(0), r.relTol, r.absTol) ? !1 : n.isNeg() && !n.isZero() && !n.isNaN(),
    bigint: (n) => n < 0n,
    Fraction: (n) => n.s < 0,
    // It's enough to decide on the sign
    Unit: e.referToSelf((n) => (a) => e.find(n, a.valueType())(a.value)),
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), l1 = "isNumeric", e3 = ["typed"], Hu = /* @__PURE__ */ j(l1, e3, (t) => {
  var {
    typed: e
  } = t;
  return e(l1, {
    "number | BigNumber | bigint | Fraction | boolean": () => !0,
    "Complex | Unit | string | null | undefined | Node": () => !1,
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), c1 = "hasNumericValue", t3 = ["typed", "isNumeric"], Qu = /* @__PURE__ */ j(c1, t3, (t) => {
  var {
    typed: e,
    isNumeric: r
  } = t;
  return e(c1, {
    boolean: () => !0,
    string: function(a) {
      return a.trim().length > 0 && !isNaN(Number(a));
    },
    any: function(a) {
      return r(a);
    }
  });
}), f1 = "isPositive", r3 = ["typed", "config"], Vu = /* @__PURE__ */ j(f1, r3, (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(f1, {
    number: (n) => Lr(n, 0, r.relTol, r.absTol) ? !1 : zw(n),
    BigNumber: (n) => pn(n, new n.constructor(0), r.relTol, r.absTol) ? !1 : !n.isNeg() && !n.isZero() && !n.isNaN(),
    bigint: (n) => n > 0n,
    Fraction: (n) => n.s > 0 && n.n > 0,
    Unit: e.referToSelf((n) => (a) => e.find(n, a.valueType())(a.value)),
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), p1 = "isZero", n3 = ["typed", "equalScalar"], Wu = /* @__PURE__ */ j(p1, n3, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return e(p1, {
    "number | BigNumber | Complex | Fraction": (n) => r(n, 0),
    bigint: (n) => n === 0n,
    Unit: e.referToSelf((n) => (a) => e.find(n, a.valueType())(a.value)),
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), h1 = "isNaN", i3 = ["typed"], ju = /* @__PURE__ */ j(h1, i3, (t) => {
  var {
    typed: e
  } = t;
  return e(h1, {
    number: Uw,
    BigNumber: function(n) {
      return n.isNaN();
    },
    bigint: function(n) {
      return !1;
    },
    Fraction: function(n) {
      return !1;
    },
    Complex: function(n) {
      return n.isNaN();
    },
    Unit: function(n) {
      return Number.isNaN(n.value);
    },
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), m1 = "typeOf", a3 = ["typed"], Zu = /* @__PURE__ */ j(m1, a3, (t) => {
  var {
    typed: e
  } = t;
  return e(m1, {
    any: Vt
  });
});
function s3(t, e, r, n) {
  return Lr(t.re, e.re, r, n) && Lr(t.im, e.im, r, n);
}
var Xa = /* @__PURE__ */ j("compareUnits", ["typed"], (t) => {
  var {
    typed: e
  } = t;
  return {
    "Unit, Unit": e.referToSelf((r) => (n, a) => {
      if (!n.equalBase(a))
        throw new Error("Cannot compare units with different base");
      return e.find(r, [n.valueType(), a.valueType()])(n.value, a.value);
    })
  };
}), cu = "equalScalar", o3 = ["typed", "config"], Ju = /* @__PURE__ */ j(cu, o3, (t) => {
  var {
    typed: e,
    config: r
  } = t, n = Xa({
    typed: e
  });
  return e(cu, {
    "boolean, boolean": function(s, o) {
      return s === o;
    },
    "number, number": function(s, o) {
      return Lr(s, o, r.relTol, r.absTol);
    },
    "BigNumber, BigNumber": function(s, o) {
      return s.eq(o) || pn(s, o, r.relTol, r.absTol);
    },
    "bigint, bigint": function(s, o) {
      return s === o;
    },
    "Fraction, Fraction": function(s, o) {
      return s.equals(o);
    },
    "Complex, Complex": function(s, o) {
      return s3(s, o, r.relTol, r.absTol);
    }
  }, n);
});
j(cu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(cu, {
    "number, number": function(a, s) {
      return Lr(a, s, r.relTol, r.absTol);
    }
  });
});
var u3 = "SparseMatrix", l3 = ["typed", "equalScalar", "Matrix"], Yu = /* @__PURE__ */ j(u3, l3, (t) => {
  var {
    typed: e,
    equalScalar: r,
    Matrix: n
  } = t;
  function a(v, N) {
    if (!(this instanceof a))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (N && !Er(N))
      throw new Error("Invalid datatype: " + N);
    if (tt(v))
      s(this, v, N);
    else if (v && Rt(v.index) && Rt(v.ptr) && Rt(v.size))
      this._values = v.values, this._index = v.index, this._ptr = v.ptr, this._size = v.size, this._datatype = N || v.datatype;
    else if (Rt(v))
      o(this, v, N);
    else {
      if (v)
        throw new TypeError("Unsupported type of data (" + Vt(v) + ")");
      this._values = [], this._index = [], this._ptr = [0], this._size = [0, 0], this._datatype = N;
    }
  }
  function s(v, N, b) {
    N.type === "SparseMatrix" ? (v._values = N._values ? nt(N._values) : void 0, v._index = nt(N._index), v._ptr = nt(N._ptr), v._size = nt(N._size), v._datatype = b || N._datatype) : o(v, N.valueOf(), b || N._datatype);
  }
  function o(v, N, b) {
    v._values = [], v._index = [], v._ptr = [], v._datatype = b;
    var C = N.length, x = 0, E = r, D = 0;
    if (Er(b) && (E = e.find(r, [b, b]) || r, D = e.convert(0, b)), C > 0) {
      var A = 0;
      do {
        v._ptr.push(v._index.length);
        for (var M = 0; M < C; M++) {
          var _ = N[M];
          if (Rt(_)) {
            if (A === 0 && x < _.length && (x = _.length), A < _.length) {
              var O = _[A];
              E(O, D) || (v._values.push(O), v._index.push(M));
            }
          } else
            A === 0 && x < 1 && (x = 1), E(_, D) || (v._values.push(_), v._index.push(M));
        }
        A++;
      } while (A < x);
    }
    v._ptr.push(v._index.length), v._size = [C, x];
  }
  a.prototype = new n(), a.prototype.createSparseMatrix = function(v, N) {
    return new a(v, N);
  }, Object.defineProperty(a, "name", {
    value: "SparseMatrix"
  }), a.prototype.constructor = a, a.prototype.type = "SparseMatrix", a.prototype.isSparseMatrix = !0, a.prototype.getDataType = function() {
    return qs(this._values, Vt);
  }, a.prototype.storage = function() {
    return "sparse";
  }, a.prototype.datatype = function() {
    return this._datatype;
  }, a.prototype.create = function(v, N) {
    return new a(v, N);
  }, a.prototype.density = function() {
    var v = this._size[0], N = this._size[1];
    return v !== 0 && N !== 0 ? this._index.length / (v * N) : 0;
  }, a.prototype.subset = function(v, N, b) {
    if (!this._values)
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    switch (arguments.length) {
      case 1:
        return p(this, v);
      case 2:
      case 3:
        return u(this, v, N, b);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function p(v, N) {
    if (!Va(N))
      throw new TypeError("Invalid index");
    var b = N.isScalar();
    if (b)
      return v.get(N.min());
    var C = N.size();
    if (C.length !== v._size.length)
      throw new xt(C.length, v._size.length);
    var x, E, D, A, M = N.min(), _ = N.max();
    for (x = 0, E = v._size.length; x < E; x++)
      Ht(M[x], v._size[x]), Ht(_[x], v._size[x]);
    var O = v._values, T = v._index, I = v._ptr, q = N.dimension(0), $ = N.dimension(1), U = [], k = [];
    q.forEach(function(P, W) {
      k[P] = W[0], U[P] = !0;
    });
    var L = O ? [] : void 0, R = [], G = [];
    return $.forEach(function(P) {
      for (G.push(R.length), D = I[P], A = I[P + 1]; D < A; D++)
        x = T[D], U[x] === !0 && (R.push(k[x]), L && L.push(O[D]));
    }), G.push(R.length), new a({
      values: L,
      index: R,
      ptr: G,
      size: C,
      datatype: v._datatype
    });
  }
  function u(v, N, b, C) {
    if (!N || N.isIndex !== !0)
      throw new TypeError("Invalid index");
    var x = N.size(), E = N.isScalar(), D;
    if (tt(b) ? (D = b.size(), b = b.toArray()) : D = gt(b), E) {
      if (D.length !== 0)
        throw new TypeError("Scalar expected");
      v.set(N.min(), b, C);
    } else {
      if (x.length !== 1 && x.length !== 2)
        throw new xt(x.length, v._size.length, "<");
      if (D.length < x.length) {
        for (var A = 0, M = 0; x[A] === 1 && D[A] === 1; )
          A++;
        for (; x[A] === 1; )
          M++, A++;
        b = Q2(b, x.length, M, D);
      }
      if (!ia(x, D))
        throw new xt(x, D, ">");
      if (x.length === 1) {
        var _ = N.dimension(0);
        _.forEach(function(I, q) {
          Ht(I), v.set([I, 0], b[q[0]], C);
        });
      } else {
        var O = N.dimension(0), T = N.dimension(1);
        O.forEach(function(I, q) {
          Ht(I), T.forEach(function($, U) {
            Ht($), v.set([I, $], b[q[0]][U[0]], C);
          });
        });
      }
    }
    return v;
  }
  a.prototype.get = function(v) {
    if (!Rt(v))
      throw new TypeError("Array expected");
    if (v.length !== this._size.length)
      throw new xt(v.length, this._size.length);
    if (!this._values)
      throw new Error("Cannot invoke get on a Pattern only matrix");
    var N = v[0], b = v[1];
    Ht(N, this._size[0]), Ht(b, this._size[1]);
    var C = f(N, this._ptr[b], this._ptr[b + 1], this._index);
    return C < this._ptr[b + 1] && this._index[C] === N ? this._values[C] : 0;
  }, a.prototype.set = function(v, N, b) {
    if (!Rt(v))
      throw new TypeError("Array expected");
    if (v.length !== this._size.length)
      throw new xt(v.length, this._size.length);
    if (!this._values)
      throw new Error("Cannot invoke set on a Pattern only matrix");
    var C = v[0], x = v[1], E = this._size[0], D = this._size[1], A = r, M = 0;
    Er(this._datatype) && (A = e.find(r, [this._datatype, this._datatype]) || r, M = e.convert(0, this._datatype)), (C > E - 1 || x > D - 1) && (h(this, Math.max(C + 1, E), Math.max(x + 1, D), b), E = this._size[0], D = this._size[1]), Ht(C, E), Ht(x, D);
    var _ = f(C, this._ptr[x], this._ptr[x + 1], this._index);
    return _ < this._ptr[x + 1] && this._index[_] === C ? A(N, M) ? l(_, x, this._values, this._index, this._ptr) : this._values[_] = N : A(N, M) || c(_, C, x, N, this._values, this._index, this._ptr), this;
  };
  function f(v, N, b, C) {
    if (b - N === 0)
      return b;
    for (var x = N; x < b; x++)
      if (C[x] === v)
        return x;
    return N;
  }
  function l(v, N, b, C, x) {
    b.splice(v, 1), C.splice(v, 1);
    for (var E = N + 1; E < x.length; E++)
      x[E]--;
  }
  function c(v, N, b, C, x, E, D) {
    x.splice(v, 0, C), E.splice(v, 0, N);
    for (var A = b + 1; A < D.length; A++)
      D[A]++;
  }
  a.prototype.resize = function(v, N, b) {
    if (!cn(v))
      throw new TypeError("Array or Matrix expected");
    var C = v.valueOf().map((E) => Array.isArray(E) && E.length === 1 ? E[0] : E);
    if (C.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    C.forEach(function(E) {
      if (!ht(E) || !Xe(E) || E < 0)
        throw new TypeError("Invalid size, must contain positive integers (size: " + Dt(C) + ")");
    });
    var x = b ? this.clone() : this;
    return h(x, C[0], C[1], N);
  };
  function h(v, N, b, C) {
    var x = C || 0, E = r, D = 0;
    Er(v._datatype) && (E = e.find(r, [v._datatype, v._datatype]) || r, D = e.convert(0, v._datatype), x = e.convert(x, v._datatype));
    var A = !E(x, D), M = v._size[0], _ = v._size[1], O, T, I;
    if (b > _) {
      for (T = _; T < b; T++)
        if (v._ptr[T] = v._values.length, A)
          for (O = 0; O < M; O++)
            v._values.push(x), v._index.push(O);
      v._ptr[b] = v._values.length;
    } else b < _ && (v._ptr.splice(b + 1, _ - b), v._values.splice(v._ptr[b], v._values.length), v._index.splice(v._ptr[b], v._index.length));
    if (_ = b, N > M) {
      if (A) {
        var q = 0;
        for (T = 0; T < _; T++) {
          v._ptr[T] = v._ptr[T] + q, I = v._ptr[T + 1] + q;
          var $ = 0;
          for (O = M; O < N; O++, $++)
            v._values.splice(I + $, 0, x), v._index.splice(I + $, 0, O), q++;
        }
        v._ptr[_] = v._values.length;
      }
    } else if (N < M) {
      var U = 0;
      for (T = 0; T < _; T++) {
        v._ptr[T] = v._ptr[T] - U;
        var k = v._ptr[T], L = v._ptr[T + 1] - U;
        for (I = k; I < L; I++)
          O = v._index[I], O > N - 1 && (v._values.splice(I, 1), v._index.splice(I, 1), U++);
      }
      v._ptr[T] = v._values.length;
    }
    return v._size[0] = N, v._size[1] = b, v;
  }
  a.prototype.reshape = function(v, N) {
    if (!Rt(v))
      throw new TypeError("Array expected");
    if (v.length !== 2)
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    v.forEach(function(P) {
      if (!ht(P) || !Xe(P) || P <= -2 || P === 0)
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + Dt(v) + ")");
    });
    var b = this._size[0] * this._size[1];
    v = Sd(v, b);
    var C = v[0] * v[1];
    if (b !== C)
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    var x = N ? this.clone() : this;
    if (this._size[0] === v[0] && this._size[1] === v[1])
      return x;
    for (var E = [], D = 0; D < x._ptr.length; D++)
      for (var A = 0; A < x._ptr[D + 1] - x._ptr[D]; A++)
        E.push(D);
    for (var M = x._values.slice(), _ = x._index.slice(), O = 0; O < x._index.length; O++) {
      var T = _[O], I = E[O], q = T * x._size[1] + I;
      E[O] = q % v[1], _[O] = Math.floor(q / v[1]);
    }
    x._values.length = 0, x._index.length = 0, x._ptr.length = v[1] + 1, x._size = v.slice();
    for (var $ = 0; $ < x._ptr.length; $++)
      x._ptr[$] = 0;
    for (var U = 0; U < M.length; U++) {
      var k = _[U], L = E[U], R = M[U], G = f(k, x._ptr[L], x._ptr[L + 1], x._index);
      c(G, k, L, R, x._values, x._index, x._ptr);
    }
    return x;
  }, a.prototype.clone = function() {
    var v = new a({
      values: this._values ? nt(this._values) : void 0,
      index: nt(this._index),
      ptr: nt(this._ptr),
      size: nt(this._size),
      datatype: this._datatype
    });
    return v;
  }, a.prototype.size = function() {
    return this._size.slice(0);
  }, a.prototype.map = function(v, N) {
    if (!this._values)
      throw new Error("Cannot invoke map on a Pattern only matrix");
    var b = this, C = this._size[0], x = this._size[1], E = J2(v), D = function(M, _, O) {
      return E === 1 ? v(M) : E === 2 ? v(M, [_, O]) : v(M, [_, O], b);
    };
    return d(this, 0, C - 1, 0, x - 1, D, N);
  };
  function d(v, N, b, C, x, E, D) {
    var A = [], M = [], _ = [], O = r, T = 0;
    Er(v._datatype) && (O = e.find(r, [v._datatype, v._datatype]) || r, T = e.convert(0, v._datatype));
    for (var I = function(H, te, be) {
      H = E(H, te, be), O(H, T) || (A.push(H), M.push(te));
    }, q = C; q <= x; q++) {
      _.push(A.length);
      var $ = v._ptr[q], U = v._ptr[q + 1];
      if (D)
        for (var k = $; k < U; k++) {
          var L = v._index[k];
          L >= N && L <= b && I(v._values[k], L - N, q - C);
        }
      else {
        for (var R = {}, G = $; G < U; G++) {
          var P = v._index[G];
          R[P] = v._values[G];
        }
        for (var W = N; W <= b; W++) {
          var le = W in R ? R[W] : 0;
          I(le, W - N, q - C);
        }
      }
    }
    return _.push(A.length), new a({
      values: A,
      index: M,
      ptr: _,
      size: [b - N + 1, x - C + 1]
    });
  }
  a.prototype.forEach = function(v, N) {
    if (!this._values)
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    for (var b = this, C = this._size[0], x = this._size[1], E = 0; E < x; E++) {
      var D = this._ptr[E], A = this._ptr[E + 1];
      if (N)
        for (var M = D; M < A; M++) {
          var _ = this._index[M];
          v(this._values[M], [_, E], b);
        }
      else {
        for (var O = {}, T = D; T < A; T++) {
          var I = this._index[T];
          O[I] = this._values[T];
        }
        for (var q = 0; q < C; q++) {
          var $ = q in O ? O[q] : 0;
          v($, [q, E], b);
        }
      }
    }
  }, a.prototype[Symbol.iterator] = function* () {
    if (!this._values)
      throw new Error("Cannot iterate a Pattern only matrix");
    for (var v = this._size[1], N = 0; N < v; N++)
      for (var b = this._ptr[N], C = this._ptr[N + 1], x = b; x < C; x++) {
        var E = this._index[x];
        yield {
          value: this._values[x],
          index: [E, N]
        };
      }
  }, a.prototype.toArray = function() {
    return g(this._values, this._index, this._ptr, this._size, !0);
  }, a.prototype.valueOf = function() {
    return g(this._values, this._index, this._ptr, this._size, !1);
  };
  function g(v, N, b, C, x) {
    var E = C[0], D = C[1], A = [], M, _;
    for (M = 0; M < E; M++)
      for (A[M] = [], _ = 0; _ < D; _++)
        A[M][_] = 0;
    for (_ = 0; _ < D; _++)
      for (var O = b[_], T = b[_ + 1], I = O; I < T; I++)
        M = N[I], A[M][_] = v ? x ? nt(v[I]) : v[I] : 1;
    return A;
  }
  return a.prototype.format = function(v) {
    for (var N = this._size[0], b = this._size[1], C = this.density(), x = "Sparse Matrix [" + Dt(N, v) + " x " + Dt(b, v) + "] density: " + Dt(C, v) + `
`, E = 0; E < b; E++)
      for (var D = this._ptr[E], A = this._ptr[E + 1], M = D; M < A; M++) {
        var _ = this._index[M];
        x += `
    (` + Dt(_, v) + ", " + Dt(E, v) + ") ==> " + (this._values ? Dt(this._values[M], v) : "X");
      }
    return x;
  }, a.prototype.toString = function() {
    return Dt(this.toArray());
  }, a.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  }, a.prototype.diagonal = function(v) {
    if (v) {
      if (ct(v) && (v = v.toNumber()), !ht(v) || !Xe(v))
        throw new TypeError("The parameter k must be an integer number");
    } else
      v = 0;
    var N = v > 0 ? v : 0, b = v < 0 ? -v : 0, C = this._size[0], x = this._size[1], E = Math.min(C - b, x - N), D = [], A = [], M = [];
    M[0] = 0;
    for (var _ = N; _ < x && D.length < E; _++)
      for (var O = this._ptr[_], T = this._ptr[_ + 1], I = O; I < T; I++) {
        var q = this._index[I];
        if (q === _ - N + b) {
          D.push(this._values[I]), A[D.length - 1] = q - b;
          break;
        }
      }
    return M.push(D.length), new a({
      values: D,
      index: A,
      ptr: M,
      size: [E, 1]
    });
  }, a.fromJSON = function(v) {
    return new a(v);
  }, a.diagonal = function(v, N, b, C, x) {
    if (!Rt(v))
      throw new TypeError("Array expected, size parameter");
    if (v.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    if (v = v.map(function(P) {
      if (ct(P) && (P = P.toNumber()), !ht(P) || !Xe(P) || P < 1)
        throw new Error("Size values must be positive integers");
      return P;
    }), b) {
      if (ct(b) && (b = b.toNumber()), !ht(b) || !Xe(b))
        throw new TypeError("The parameter k must be an integer number");
    } else
      b = 0;
    var E = r, D = 0;
    Er(x) && (E = e.find(r, [x, x]) || r, D = e.convert(0, x));
    var A = b > 0 ? b : 0, M = b < 0 ? -b : 0, _ = v[0], O = v[1], T = Math.min(_ - M, O - A), I;
    if (Rt(N)) {
      if (N.length !== T)
        throw new Error("Invalid value array length");
      I = function(W) {
        return N[W];
      };
    } else if (tt(N)) {
      var q = N.size();
      if (q.length !== 1 || q[0] !== T)
        throw new Error("Invalid matrix length");
      I = function(W) {
        return N.get([W]);
      };
    } else
      I = function() {
        return N;
      };
    for (var $ = [], U = [], k = [], L = 0; L < O; L++) {
      k.push($.length);
      var R = L - A;
      if (R >= 0 && R < T) {
        var G = I(R);
        E(G, D) || (U.push(R + M), $.push(G));
      }
    }
    return k.push($.length), new a({
      values: $,
      index: U,
      ptr: k,
      size: [_, O]
    });
  }, a.prototype.swapRows = function(v, N) {
    if (!ht(v) || !Xe(v) || !ht(N) || !Xe(N))
      throw new Error("Row index must be positive integers");
    if (this._size.length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    return Ht(v, this._size[0]), Ht(N, this._size[0]), a._swapRows(v, N, this._size[1], this._values, this._index, this._ptr), this;
  }, a._forEachRow = function(v, N, b, C, x) {
    for (var E = C[v], D = C[v + 1], A = E; A < D; A++)
      x(b[A], N[A]);
  }, a._swapRows = function(v, N, b, C, x, E) {
    for (var D = 0; D < b; D++) {
      var A = E[D], M = E[D + 1], _ = f(v, A, M, x), O = f(N, A, M, x);
      if (_ < M && O < M && x[_] === v && x[O] === N) {
        if (C) {
          var T = C[_];
          C[_] = C[O], C[O] = T;
        }
        continue;
      }
      if (_ < M && x[_] === v && (O >= M || x[O] !== N)) {
        var I = C ? C[_] : void 0;
        x.splice(O, 0, N), C && C.splice(O, 0, I), x.splice(O <= _ ? _ + 1 : _, 1), C && C.splice(O <= _ ? _ + 1 : _, 1);
        continue;
      }
      if (O < M && x[O] === N && (_ >= M || x[_] !== v)) {
        var q = C ? C[O] : void 0;
        x.splice(_, 0, v), C && C.splice(_, 0, q), x.splice(_ <= O ? O + 1 : O, 1), C && C.splice(_ <= O ? O + 1 : O, 1);
      }
    }
  }, a;
}, {
  isClass: !0
}), c3 = "number", f3 = ["typed"];
function p3(t) {
  var e = t.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (e) {
    var r = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[e[1]], n = e[2], a = e[3];
    return {
      input: t,
      radix: r,
      integerPart: n,
      fractionalPart: a
    };
  } else
    return null;
}
function h3(t) {
  for (var e = parseInt(t.integerPart, t.radix), r = 0, n = 0; n < t.fractionalPart.length; n++) {
    var a = parseInt(t.fractionalPart[n], t.radix);
    r += a / Math.pow(t.radix, n + 1);
  }
  var s = e + r;
  if (isNaN(s))
    throw new SyntaxError('String "' + t.input + '" is not a valid number');
  return s;
}
var Xu = /* @__PURE__ */ j(c3, f3, (t) => {
  var {
    typed: e
  } = t, r = e("number", {
    "": function() {
      return 0;
    },
    number: function(a) {
      return a;
    },
    string: function(a) {
      if (a === "NaN") return NaN;
      var s = p3(a);
      if (s)
        return h3(s);
      var o = 0, p = a.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      p && (o = Number(p[2]), a = p[1]);
      var u = Number(a);
      if (isNaN(u))
        throw new SyntaxError('String "' + a + '" is not a valid number');
      if (p) {
        if (u > 2 ** o - 1)
          throw new SyntaxError('String "'.concat(a, '" is out of range'));
        u >= 2 ** (o - 1) && (u = u - 2 ** o);
      }
      return u;
    },
    BigNumber: function(a) {
      return a.toNumber();
    },
    bigint: function(a) {
      return Number(a);
    },
    Fraction: function(a) {
      return a.valueOf();
    },
    Unit: e.referToSelf((n) => (a) => {
      var s = a.clone();
      return s.value = n(a.value), s;
    }),
    null: function(a) {
      return 0;
    },
    "Unit, string | Unit": function(a, s) {
      return a.toNumber(s);
    },
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
  return r.fromJSON = function(n) {
    return parseFloat(n.value);
  }, r;
}), m3 = "bigint", d3 = ["typed"], Ku = /* @__PURE__ */ j(m3, d3, (t) => {
  var {
    typed: e
  } = t, r = e("bigint", {
    "": function() {
      return 0n;
    },
    bigint: function(a) {
      return a;
    },
    number: function(a) {
      return BigInt(a.toFixed());
    },
    BigNumber: function(a) {
      return BigInt(a.round().toString());
    },
    Fraction: function(a) {
      return BigInt(a.valueOf().toFixed());
    },
    "string | boolean": function(a) {
      return BigInt(a);
    },
    null: function(a) {
      return 0n;
    },
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
  return r.fromJSON = function(n) {
    return BigInt(n.value);
  }, r;
}), d1 = "string", v3 = ["typed"], e0 = /* @__PURE__ */ j(d1, v3, (t) => {
  var {
    typed: e
  } = t;
  return e(d1, {
    "": function() {
      return "";
    },
    number: na,
    null: function(n) {
      return "null";
    },
    boolean: function(n) {
      return n + "";
    },
    string: function(n) {
      return n;
    },
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r)),
    any: function(n) {
      return String(n);
    }
  });
}), v1 = "boolean", g3 = ["typed"], t0 = /* @__PURE__ */ j(v1, g3, (t) => {
  var {
    typed: e
  } = t;
  return e(v1, {
    "": function() {
      return !1;
    },
    boolean: function(n) {
      return n;
    },
    number: function(n) {
      return !!n;
    },
    null: function(n) {
      return !1;
    },
    BigNumber: function(n) {
      return !n.isZero();
    },
    string: function(n) {
      var a = n.toLowerCase();
      if (a === "true")
        return !0;
      if (a === "false")
        return !1;
      var s = Number(n);
      if (n !== "" && !isNaN(s))
        return !!s;
      throw new Error('Cannot convert "' + n + '" to a boolean');
    },
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), y3 = "bignumber", x3 = ["typed", "BigNumber"], r0 = /* @__PURE__ */ j(y3, x3, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e("bignumber", {
    "": function() {
      return new r(0);
    },
    number: function(a) {
      return new r(a + "");
    },
    string: function(a) {
      var s = a.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (s) {
        var o = s[2], p = r(s[1]), u = new r(2).pow(Number(o));
        if (p.gt(u.sub(1)))
          throw new SyntaxError('String "'.concat(a, '" is out of range'));
        var f = new r(2).pow(Number(o) - 1);
        return p.gte(f) ? p.sub(u) : p;
      }
      return new r(a);
    },
    BigNumber: function(a) {
      return a;
    },
    bigint: function(a) {
      return new r(a.toString());
    },
    Unit: e.referToSelf((n) => (a) => {
      var s = a.clone();
      return s.value = n(a.value), s;
    }),
    Fraction: function(a) {
      return new r(a.n).div(a.d).times(a.s);
    },
    null: function(a) {
      return new r(0);
    },
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), b3 = "complex", w3 = ["typed", "Complex"], n0 = /* @__PURE__ */ j(b3, w3, (t) => {
  var {
    typed: e,
    Complex: r
  } = t;
  return e("complex", {
    "": function() {
      return r.ZERO;
    },
    number: function(a) {
      return new r(a, 0);
    },
    "number, number": function(a, s) {
      return new r(a, s);
    },
    // TODO: this signature should be redundant
    "BigNumber, BigNumber": function(a, s) {
      return new r(a.toNumber(), s.toNumber());
    },
    Fraction: function(a) {
      return new r(a.valueOf(), 0);
    },
    Complex: function(a) {
      return a.clone();
    },
    string: function(a) {
      return r(a);
    },
    null: function(a) {
      return r(0);
    },
    Object: function(a) {
      if ("re" in a && "im" in a)
        return new r(a.re, a.im);
      if ("r" in a && "phi" in a || "abs" in a && "arg" in a)
        return new r(a);
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), N3 = "fraction", D3 = ["typed", "Fraction"], i0 = /* @__PURE__ */ j(N3, D3, (t) => {
  var {
    typed: e,
    Fraction: r
  } = t;
  return e("fraction", {
    number: function(a) {
      if (!isFinite(a) || isNaN(a))
        throw new Error(a + " cannot be represented as a fraction");
      return new r(a);
    },
    string: function(a) {
      return new r(a);
    },
    "number, number": function(a, s) {
      return new r(a, s);
    },
    null: function(a) {
      return new r(0);
    },
    BigNumber: function(a) {
      return new r(a.toString());
    },
    bigint: function(a) {
      return new r(a.toString());
    },
    Fraction: function(a) {
      return a;
    },
    Unit: e.referToSelf((n) => (a) => {
      var s = a.clone();
      return s.value = n(a.value), s;
    }),
    Object: function(a) {
      return new r(a);
    },
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), g1 = "matrix", A3 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"], a0 = /* @__PURE__ */ j(g1, A3, (t) => {
  var {
    typed: e,
    Matrix: r,
    DenseMatrix: n,
    SparseMatrix: a
  } = t;
  return e(g1, {
    "": function() {
      return s([]);
    },
    string: function(p) {
      return s([], p);
    },
    "string, string": function(p, u) {
      return s([], p, u);
    },
    Array: function(p) {
      return s(p);
    },
    Matrix: function(p) {
      return s(p, p.storage());
    },
    "Array | Matrix, string": s,
    "Array | Matrix, string, string": s
  });
  function s(o, p, u) {
    if (p === "dense" || p === "default" || p === void 0)
      return new n(o, u);
    if (p === "sparse")
      return new a(o, u);
    throw new TypeError("Unknown matrix type " + JSON.stringify(p) + ".");
  }
}), y1 = "matrixFromFunction", E3 = ["typed", "matrix", "isZero"], s0 = /* @__PURE__ */ j(y1, E3, (t) => {
  var {
    typed: e,
    matrix: r,
    isZero: n
  } = t;
  return e(y1, {
    "Array | Matrix, function, string, string": function(o, p, u, f) {
      return a(o, p, u, f);
    },
    "Array | Matrix, function, string": function(o, p, u) {
      return a(o, p, u);
    },
    "Matrix, function": function(o, p) {
      return a(o, p, "dense");
    },
    "Array, function": function(o, p) {
      return a(o, p, "dense").toArray();
    },
    "Array | Matrix, string, function": function(o, p, u) {
      return a(o, u, p);
    },
    "Array | Matrix, string, string, function": function(o, p, u, f) {
      return a(o, f, p, u);
    }
  });
  function a(s, o, p, u) {
    var f;
    return u !== void 0 ? f = r(p, u) : f = r(p), f.resize(s), f.forEach(function(l, c) {
      var h = o(c);
      n(h) || f.set(c, h);
    }), f;
  }
}), x1 = "matrixFromRows", S3 = ["typed", "matrix", "flatten", "size"], o0 = /* @__PURE__ */ j(x1, S3, (t) => {
  var {
    typed: e,
    matrix: r,
    flatten: n,
    size: a
  } = t;
  return e(x1, {
    "...Array": function(u) {
      return s(u);
    },
    "...Matrix": function(u) {
      return r(s(u.map((f) => f.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function s(p) {
    if (p.length === 0) throw new TypeError("At least one row is needed to construct a matrix.");
    var u = o(p[0]), f = [];
    for (var l of p) {
      var c = o(l);
      if (c !== u)
        throw new TypeError("The vectors had different length: " + (u | 0) + " ≠ " + (c | 0));
      f.push(n(l));
    }
    return f;
  }
  function o(p) {
    var u = a(p);
    if (u.length === 1)
      return u[0];
    if (u.length === 2) {
      if (u[0] === 1)
        return u[1];
      if (u[1] === 1)
        return u[0];
      throw new TypeError("At least one of the arguments is not a vector.");
    } else
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
  }
}), b1 = "matrixFromColumns", C3 = ["typed", "matrix", "flatten", "size"], u0 = /* @__PURE__ */ j(b1, C3, (t) => {
  var {
    typed: e,
    matrix: r,
    flatten: n,
    size: a
  } = t;
  return e(b1, {
    "...Array": function(u) {
      return s(u);
    },
    "...Matrix": function(u) {
      return r(s(u.map((f) => f.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function s(p) {
    if (p.length === 0) throw new TypeError("At least one column is needed to construct a matrix.");
    for (var u = o(p[0]), f = [], l = 0; l < u; l++)
      f[l] = [];
    for (var c of p) {
      var h = o(c);
      if (h !== u)
        throw new TypeError("The vectors had different length: " + (u | 0) + " ≠ " + (h | 0));
      for (var d = n(c), g = 0; g < u; g++)
        f[g].push(d[g]);
    }
    return f;
  }
  function o(p) {
    var u = a(p);
    if (u.length === 1)
      return u[0];
    if (u.length === 2) {
      if (u[0] === 1)
        return u[1];
      if (u[1] === 1)
        return u[0];
      throw new TypeError("At least one of the arguments is not a vector.");
    } else
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
  }
}), w1 = "splitUnit", T3 = ["typed"], l0 = /* @__PURE__ */ j(w1, T3, (t) => {
  var {
    typed: e
  } = t;
  return e(w1, {
    "Unit, Array": function(n, a) {
      return n.splitUnit(a);
    }
  });
}), N1 = "unaryMinus", _3 = ["typed"], c0 = /* @__PURE__ */ j(N1, _3, (t) => {
  var {
    typed: e
  } = t;
  return e(N1, {
    number: rw,
    "Complex | BigNumber | Fraction": (r) => r.neg(),
    bigint: (r) => -r,
    Unit: e.referToSelf((r) => (n) => {
      var a = n.clone();
      return a.value = e.find(r, a.valueType())(n.value), a;
    }),
    // deep map collection, skip zeros since unaryMinus(0) = 0
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
    // TODO: add support for string
  });
}), D1 = "unaryPlus", M3 = ["typed", "config", "numeric"], f0 = /* @__PURE__ */ j(D1, M3, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n
  } = t;
  return e(D1, {
    number: nw,
    Complex: function(s) {
      return s;
    },
    BigNumber: function(s) {
      return s;
    },
    bigint: function(s) {
      return s;
    },
    Fraction: function(s) {
      return s;
    },
    Unit: function(s) {
      return s.clone();
    },
    // deep map collection, skip zeros since unaryPlus(0) = 0
    "Array | Matrix": e.referToSelf((a) => (s) => Nt(s, a)),
    boolean: function(s) {
      return n(s ? 1 : 0, r.number);
    },
    string: function(s) {
      return n(s, Ii(s, r));
    }
  });
}), A1 = "abs", O3 = ["typed"], p0 = /* @__PURE__ */ j(A1, O3, (t) => {
  var {
    typed: e
  } = t;
  return e(A1, {
    number: X2,
    "Complex | BigNumber | Fraction | Unit": (r) => r.abs(),
    bigint: (r) => r < 0n ? -r : r,
    // deep map collection, skip zeros since abs(0) = 0
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), E1 = "apply", F3 = ["typed", "isInteger"], Ka = /* @__PURE__ */ j(E1, F3, (t) => {
  var {
    typed: e,
    isInteger: r
  } = t;
  return e(E1, {
    "Array | Matrix, number | BigNumber, function": function(a, s, o) {
      if (!r(s))
        throw new TypeError("Integer number expected for dimension");
      var p = Array.isArray(a) ? gt(a) : a.size();
      if (s < 0 || s >= p.length)
        throw new yn(s, p.length);
      return tt(a) ? a.create(fu(a.valueOf(), s, o)) : fu(a, s, o);
    }
  });
});
function fu(t, e, r) {
  var n, a, s;
  if (e <= 0)
    if (Array.isArray(t[0])) {
      for (s = q3(t), a = [], n = 0; n < s.length; n++)
        a[n] = fu(s[n], e - 1, r);
      return a;
    } else
      return r(t);
  else {
    for (a = [], n = 0; n < t.length; n++)
      a[n] = fu(t[n], e - 1, r);
    return a;
  }
}
function q3(t) {
  var e = t.length, r = t[0].length, n, a, s = [];
  for (a = 0; a < r; a++) {
    var o = [];
    for (n = 0; n < e; n++)
      o.push(t[n][a]);
    s.push(o);
  }
  return s;
}
var S1 = "addScalar", I3 = ["typed"], h0 = /* @__PURE__ */ j(S1, I3, (t) => {
  var {
    typed: e
  } = t;
  return e(S1, {
    "number, number": K2,
    "Complex, Complex": function(n, a) {
      return n.add(a);
    },
    "BigNumber, BigNumber": function(n, a) {
      return n.plus(a);
    },
    "bigint, bigint": function(n, a) {
      return n + a;
    },
    "Fraction, Fraction": function(n, a) {
      return n.add(a);
    },
    "Unit, Unit": e.referToSelf((r) => (n, a) => {
      if (n.value === null || n.value === void 0)
        throw new Error("Parameter x contains a unit with undefined value");
      if (a.value === null || a.value === void 0)
        throw new Error("Parameter y contains a unit with undefined value");
      if (!n.equalBase(a)) throw new Error("Units do not match");
      var s = n.clone();
      return s.value = e.find(r, [s.valueType(), a.valueType()])(s.value, a.value), s.fixPrefix = !1, s;
    })
  });
}), C1 = "subtractScalar", B3 = ["typed"], m0 = /* @__PURE__ */ j(C1, B3, (t) => {
  var {
    typed: e
  } = t;
  return e(C1, {
    "number, number": ew,
    "Complex, Complex": function(n, a) {
      return n.sub(a);
    },
    "BigNumber, BigNumber": function(n, a) {
      return n.minus(a);
    },
    "bigint, bigint": function(n, a) {
      return n - a;
    },
    "Fraction, Fraction": function(n, a) {
      return n.sub(a);
    },
    "Unit, Unit": e.referToSelf((r) => (n, a) => {
      if (n.value === null || n.value === void 0)
        throw new Error("Parameter x contains a unit with undefined value");
      if (a.value === null || a.value === void 0)
        throw new Error("Parameter y contains a unit with undefined value");
      if (!n.equalBase(a)) throw new Error("Units do not match");
      var s = n.clone();
      return s.value = e.find(r, [s.valueType(), a.valueType()])(s.value, a.value), s.fixPrefix = !1, s;
    })
  });
}), T1 = "cbrt", R3 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"], d0 = /* @__PURE__ */ j(T1, R3, (t) => {
  var {
    config: e,
    typed: r,
    isNegative: n,
    unaryMinus: a,
    matrix: s,
    Complex: o,
    BigNumber: p,
    Fraction: u
  } = t;
  return r(T1, {
    number: Cs,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex
    Complex: f,
    "Complex, boolean": f,
    BigNumber: function(h) {
      return h.cbrt();
    },
    Unit: l
  });
  function f(c, h) {
    var d = c.arg() / 3, g = c.abs(), v = new o(Cs(g), 0).mul(new o(0, d).exp());
    if (h) {
      var N = [v, new o(Cs(g), 0).mul(new o(0, d + Math.PI * 2 / 3).exp()), new o(Cs(g), 0).mul(new o(0, d - Math.PI * 2 / 3).exp())];
      return e.matrix === "Array" ? N : s(N);
    } else
      return v;
  }
  function l(c) {
    if (c.value && Mn(c.value)) {
      var h = c.clone();
      return h.value = 1, h = h.pow(1 / 3), h.value = f(c.value), h;
    } else {
      var d = n(c.value);
      d && (c.value = a(c.value));
      var g;
      ct(c.value) ? g = new p(1).div(3) : Fi(c.value) ? g = new u(1, 3) : g = 1 / 3;
      var v = c.pow(g);
      return d && (v.value = a(v.value)), v;
    }
  }
}), L3 = "matAlgo11xS0s", P3 = ["typed", "equalScalar"], Pr = /* @__PURE__ */ j(L3, P3, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(a, s, o, p) {
    var u = a._values, f = a._index, l = a._ptr, c = a._size, h = a._datatype;
    if (!u)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var d = c[0], g = c[1], v, N = r, b = 0, C = o;
    typeof h == "string" && (v = h, N = e.find(r, [v, v]), b = e.convert(0, v), s = e.convert(s, v), C = e.find(o, [v, v]));
    for (var x = [], E = [], D = [], A = 0; A < g; A++) {
      D[A] = E.length;
      for (var M = l[A], _ = l[A + 1], O = M; O < _; O++) {
        var T = f[O], I = p ? C(s, u[O]) : C(u[O], s);
        N(I, b) || (E.push(T), x.push(I));
      }
    }
    return D[g] = E.length, a.createSparseMatrix({
      values: x,
      index: E,
      ptr: D,
      size: [d, g],
      datatype: v
    });
  };
}), k3 = "matAlgo12xSfs", $3 = ["typed", "DenseMatrix"], br = /* @__PURE__ */ j(k3, $3, (t) => {
  var {
    typed: e,
    DenseMatrix: r
  } = t;
  return function(a, s, o, p) {
    var u = a._values, f = a._index, l = a._ptr, c = a._size, h = a._datatype;
    if (!u)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var d = c[0], g = c[1], v, N = o;
    typeof h == "string" && (v = h, s = e.convert(s, v), N = e.find(o, [v, v]));
    for (var b = [], C = [], x = [], E = 0; E < g; E++) {
      for (var D = E + 1, A = l[E], M = l[E + 1], _ = A; _ < M; _++) {
        var O = f[_];
        C[O] = u[_], x[O] = D;
      }
      for (var T = 0; T < d; T++)
        E === 0 && (b[T] = []), x[T] === D ? b[T][E] = p ? N(s, C[T]) : N(C[T], s) : b[T][E] = p ? N(s, 0) : N(0, s);
    }
    return new r({
      data: b,
      size: [d, g],
      datatype: v
    });
  };
}), z3 = "matAlgo14xDs", U3 = ["typed"], zn = /* @__PURE__ */ j(z3, U3, (t) => {
  var {
    typed: e
  } = t;
  return function(a, s, o, p) {
    var u = a._data, f = a._size, l = a._datatype, c, h = o;
    typeof l == "string" && (c = l, s = e.convert(s, c), h = e.find(o, [c, c]));
    var d = f.length > 0 ? r(h, 0, f, f[0], u, s, p) : [];
    return a.createDenseMatrix({
      data: d,
      size: nt(f),
      datatype: c
    });
  };
  function r(n, a, s, o, p, u, f) {
    var l = [];
    if (a === s.length - 1)
      for (var c = 0; c < o; c++)
        l[c] = f ? n(u, p[c]) : n(p[c], u);
    else
      for (var h = 0; h < o; h++)
        l[h] = r(n, a + 1, s, s[a + 1], p[h], u, f);
    return l;
  }
}), td = "ceil", G3 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"], H3 = /* @__PURE__ */ j(td, ["typed", "config", "round"], (t) => {
  var {
    typed: e,
    config: r,
    round: n
  } = t;
  return e(td, {
    number: function(s) {
      return Lr(s, n(s), r.relTol, r.absTol) ? n(s) : Math.ceil(s);
    },
    "number, number": function(s, o) {
      if (Lr(s, n(s, o), r.relTol, r.absTol))
        return n(s, o);
      var [p, u] = "".concat(s, "e").split("e"), f = Math.ceil(Number("".concat(p, "e").concat(Number(u) + o)));
      return [p, u] = "".concat(f, "e").split("e"), Number("".concat(p, "e").concat(Number(u) - o));
    }
  });
}), v0 = /* @__PURE__ */ j(td, G3, (t) => {
  var {
    typed: e,
    config: r,
    round: n,
    matrix: a,
    equalScalar: s,
    zeros: o,
    DenseMatrix: p
  } = t, u = Pr({
    typed: e,
    equalScalar: s
  }), f = br({
    typed: e,
    DenseMatrix: p
  }), l = zn({
    typed: e
  }), c = H3({
    typed: e,
    config: r,
    round: n
  });
  return e("ceil", {
    number: c.signatures.number,
    "number,number": c.signatures["number,number"],
    Complex: function(d) {
      return d.ceil();
    },
    "Complex, number": function(d, g) {
      return d.ceil(g);
    },
    "Complex, BigNumber": function(d, g) {
      return d.ceil(g.toNumber());
    },
    BigNumber: function(d) {
      return pn(d, n(d), r.relTol, r.absTol) ? n(d) : d.ceil();
    },
    "BigNumber, BigNumber": function(d, g) {
      return pn(d, n(d, g), r.relTol, r.absTol) ? n(d, g) : d.toDecimalPlaces(g.toNumber(), Mi.ROUND_CEIL);
    },
    Fraction: function(d) {
      return d.ceil();
    },
    "Fraction, number": function(d, g) {
      return d.ceil(g);
    },
    "Fraction, BigNumber": function(d, g) {
      return d.ceil(g.toNumber());
    },
    "Array | Matrix": e.referToSelf((h) => (d) => Nt(d, h)),
    "Array, number | BigNumber": e.referToSelf((h) => (d, g) => Nt(d, (v) => h(v, g))),
    "SparseMatrix, number | BigNumber": e.referToSelf((h) => (d, g) => u(d, g, h, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((h) => (d, g) => l(d, g, h, !1)),
    "number | Complex | Fraction | BigNumber, Array": e.referToSelf((h) => (d, g) => l(a(g), d, h, !0).valueOf()),
    "number | Complex | Fraction | BigNumber, Matrix": e.referToSelf((h) => (d, g) => s(d, 0) ? o(g.size(), g.storage()) : g.storage() === "dense" ? l(g, d, h, !0) : f(g, d, h, !0))
  });
}), _1 = "cube", Q3 = ["typed"], g0 = /* @__PURE__ */ j(_1, Q3, (t) => {
  var {
    typed: e
  } = t;
  return e(_1, {
    number: iw,
    Complex: function(n) {
      return n.mul(n).mul(n);
    },
    BigNumber: function(n) {
      return n.times(n).times(n);
    },
    bigint: function(n) {
      return n * n * n;
    },
    Fraction: function(n) {
      return n.pow(3);
    },
    Unit: function(n) {
      return n.pow(3);
    }
  });
}), M1 = "exp", V3 = ["typed"], y0 = /* @__PURE__ */ j(M1, V3, (t) => {
  var {
    typed: e
  } = t;
  return e(M1, {
    number: aw,
    Complex: function(n) {
      return n.exp();
    },
    BigNumber: function(n) {
      return n.exp();
    }
  });
}), O1 = "expm1", W3 = ["typed", "Complex"], x0 = /* @__PURE__ */ j(O1, W3, (t) => {
  var {
    typed: e,
    Complex: r
  } = t;
  return e(O1, {
    number: sw,
    Complex: function(a) {
      var s = Math.exp(a.re);
      return new r(s * Math.cos(a.im) - 1, s * Math.sin(a.im));
    },
    BigNumber: function(a) {
      return a.exp().minus(1);
    }
  });
}), rd = "fix", j3 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"], Z3 = /* @__PURE__ */ j(rd, ["typed", "ceil", "floor"], (t) => {
  var {
    typed: e,
    ceil: r,
    floor: n
  } = t;
  return e(rd, {
    number: function(s) {
      return s > 0 ? n(s) : r(s);
    },
    "number, number": function(s, o) {
      return s > 0 ? n(s, o) : r(s, o);
    }
  });
}), b0 = /* @__PURE__ */ j(rd, j3, (t) => {
  var {
    typed: e,
    Complex: r,
    matrix: n,
    ceil: a,
    floor: s,
    equalScalar: o,
    zeros: p,
    DenseMatrix: u
  } = t, f = br({
    typed: e,
    DenseMatrix: u
  }), l = zn({
    typed: e
  }), c = Z3({
    typed: e,
    ceil: a,
    floor: s
  });
  return e("fix", {
    number: c.signatures.number,
    "number, number | BigNumber": c.signatures["number,number"],
    Complex: function(d) {
      return new r(d.re > 0 ? Math.floor(d.re) : Math.ceil(d.re), d.im > 0 ? Math.floor(d.im) : Math.ceil(d.im));
    },
    "Complex, number": function(d, g) {
      return new r(d.re > 0 ? s(d.re, g) : a(d.re, g), d.im > 0 ? s(d.im, g) : a(d.im, g));
    },
    "Complex, BigNumber": function(d, g) {
      var v = g.toNumber();
      return new r(d.re > 0 ? s(d.re, v) : a(d.re, v), d.im > 0 ? s(d.im, v) : a(d.im, v));
    },
    BigNumber: function(d) {
      return d.isNegative() ? a(d) : s(d);
    },
    "BigNumber, number | BigNumber": function(d, g) {
      return d.isNegative() ? a(d, g) : s(d, g);
    },
    Fraction: function(d) {
      return d.s < 0 ? d.ceil() : d.floor();
    },
    "Fraction, number | BigNumber": function(d, g) {
      return d.s < 0 ? a(d, g) : s(d, g);
    },
    "Array | Matrix": e.referToSelf((h) => (d) => Nt(d, h)),
    "Array | Matrix, number | BigNumber": e.referToSelf((h) => (d, g) => Nt(d, (v) => h(v, g))),
    "number | Complex | Fraction | BigNumber, Array": e.referToSelf((h) => (d, g) => l(n(g), d, h, !0).valueOf()),
    "number | Complex | Fraction | BigNumber, Matrix": e.referToSelf((h) => (d, g) => o(d, 0) ? p(g.size(), g.storage()) : g.storage() === "dense" ? l(g, d, h, !0) : f(g, d, h, !0))
  });
}), nd = "floor", J3 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"], Y3 = /* @__PURE__ */ j(nd, ["typed", "config", "round"], (t) => {
  var {
    typed: e,
    config: r,
    round: n
  } = t;
  return e(nd, {
    number: function(s) {
      return Lr(s, n(s), r.relTol, r.absTol) ? n(s) : Math.floor(s);
    },
    "number, number": function(s, o) {
      if (Lr(s, n(s, o), r.relTol, r.absTol))
        return n(s, o);
      var [p, u] = "".concat(s, "e").split("e"), f = Math.floor(Number("".concat(p, "e").concat(Number(u) + o)));
      return [p, u] = "".concat(f, "e").split("e"), Number("".concat(p, "e").concat(Number(u) - o));
    }
  });
}), Gs = /* @__PURE__ */ j(nd, J3, (t) => {
  var {
    typed: e,
    config: r,
    round: n,
    matrix: a,
    equalScalar: s,
    zeros: o,
    DenseMatrix: p
  } = t, u = Pr({
    typed: e,
    equalScalar: s
  }), f = br({
    typed: e,
    DenseMatrix: p
  }), l = zn({
    typed: e
  }), c = Y3({
    typed: e,
    config: r,
    round: n
  });
  return e("floor", {
    number: c.signatures.number,
    "number,number": c.signatures["number,number"],
    Complex: function(d) {
      return d.floor();
    },
    "Complex, number": function(d, g) {
      return d.floor(g);
    },
    "Complex, BigNumber": function(d, g) {
      return d.floor(g.toNumber());
    },
    BigNumber: function(d) {
      return pn(d, n(d), r.relTol, r.absTol) ? n(d) : d.floor();
    },
    "BigNumber, BigNumber": function(d, g) {
      return pn(d, n(d, g), r.relTol, r.absTol) ? n(d, g) : d.toDecimalPlaces(g.toNumber(), Mi.ROUND_FLOOR);
    },
    Fraction: function(d) {
      return d.floor();
    },
    "Fraction, number": function(d, g) {
      return d.floor(g);
    },
    "Fraction, BigNumber": function(d, g) {
      return d.floor(g.toNumber());
    },
    "Array | Matrix": e.referToSelf((h) => (d) => Nt(d, h)),
    "Array, number | BigNumber": e.referToSelf((h) => (d, g) => Nt(d, (v) => h(v, g))),
    "SparseMatrix, number | BigNumber": e.referToSelf((h) => (d, g) => u(d, g, h, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((h) => (d, g) => l(d, g, h, !1)),
    "number | Complex | Fraction | BigNumber, Array": e.referToSelf((h) => (d, g) => l(a(g), d, h, !0).valueOf()),
    "number | Complex | Fraction | BigNumber, Matrix": e.referToSelf((h) => (d, g) => s(d, 0) ? o(g.size(), g.storage()) : g.storage() === "dense" ? l(g, d, h, !0) : f(g, d, h, !0))
  });
}), X3 = "matAlgo02xDS0", K3 = ["typed", "equalScalar"], Un = /* @__PURE__ */ j(X3, K3, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(a, s, o, p) {
    var u = a._data, f = a._size, l = a._datatype || a.getDataType(), c = s._values, h = s._index, d = s._ptr, g = s._size, v = s._datatype || s._data === void 0 ? s._datatype : s.getDataType();
    if (f.length !== g.length)
      throw new xt(f.length, g.length);
    if (f[0] !== g[0] || f[1] !== g[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + f + ") must match Matrix B (" + g + ")");
    if (!c)
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    var N = f[0], b = f[1], C, x = r, E = 0, D = o;
    typeof l == "string" && l === v && l !== "mixed" && (C = l, x = e.find(r, [C, C]), E = e.convert(0, C), D = e.find(o, [C, C]));
    for (var A = [], M = [], _ = [], O = 0; O < b; O++) {
      _[O] = M.length;
      for (var T = d[O], I = d[O + 1], q = T; q < I; q++) {
        var $ = h[q], U = p ? D(c[q], u[$][O]) : D(u[$][O], c[q]);
        x(U, E) || (M.push($), A.push(U));
      }
    }
    return _[b] = M.length, s.createSparseMatrix({
      values: A,
      index: M,
      ptr: _,
      size: [N, b],
      datatype: l === a._datatype && v === s._datatype ? C : void 0
    });
  };
}), e_ = "matAlgo03xDSf", t_ = ["typed"], rn = /* @__PURE__ */ j(e_, t_, (t) => {
  var {
    typed: e
  } = t;
  return function(n, a, s, o) {
    var p = n._data, u = n._size, f = n._datatype || n.getDataType(), l = a._values, c = a._index, h = a._ptr, d = a._size, g = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (u.length !== d.length)
      throw new xt(u.length, d.length);
    if (u[0] !== d[0] || u[1] !== d[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + d + ")");
    if (!l)
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    var v = u[0], N = u[1], b, C = 0, x = s;
    typeof f == "string" && f === g && f !== "mixed" && (b = f, C = e.convert(0, b), x = e.find(s, [b, b]));
    for (var E = [], D = 0; D < v; D++)
      E[D] = [];
    for (var A = [], M = [], _ = 0; _ < N; _++) {
      for (var O = _ + 1, T = h[_], I = h[_ + 1], q = T; q < I; q++) {
        var $ = c[q];
        A[$] = o ? x(l[q], p[$][_]) : x(p[$][_], l[q]), M[$] = O;
      }
      for (var U = 0; U < v; U++)
        M[U] === O ? E[U][_] = A[U] : E[U][_] = o ? x(C, p[U][_]) : x(p[U][_], C);
    }
    return n.createDenseMatrix({
      data: E,
      size: [v, N],
      datatype: f === n._datatype && g === a._datatype ? b : void 0
    });
  };
}), r_ = "matAlgo05xSfSf", n_ = ["typed", "equalScalar"], w0 = /* @__PURE__ */ j(r_, n_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(a, s, o) {
    var p = a._values, u = a._index, f = a._ptr, l = a._size, c = a._datatype || a._data === void 0 ? a._datatype : a.getDataType(), h = s._values, d = s._index, g = s._ptr, v = s._size, N = s._datatype || s._data === void 0 ? s._datatype : s.getDataType();
    if (l.length !== v.length)
      throw new xt(l.length, v.length);
    if (l[0] !== v[0] || l[1] !== v[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + l + ") must match Matrix B (" + v + ")");
    var b = l[0], C = l[1], x, E = r, D = 0, A = o;
    typeof c == "string" && c === N && c !== "mixed" && (x = c, E = e.find(r, [x, x]), D = e.convert(0, x), A = e.find(o, [x, x]));
    var M = p && h ? [] : void 0, _ = [], O = [], T = M ? [] : void 0, I = M ? [] : void 0, q = [], $ = [], U, k, L, R;
    for (k = 0; k < C; k++) {
      O[k] = _.length;
      var G = k + 1;
      for (L = f[k], R = f[k + 1]; L < R; L++)
        U = u[L], _.push(U), q[U] = G, T && (T[U] = p[L]);
      for (L = g[k], R = g[k + 1]; L < R; L++)
        U = d[L], q[U] !== G && _.push(U), $[U] = G, I && (I[U] = h[L]);
      if (M)
        for (L = O[k]; L < _.length; ) {
          U = _[L];
          var P = q[U], W = $[U];
          if (P === G || W === G) {
            var le = P === G ? T[U] : D, Z = W === G ? I[U] : D, H = A(le, Z);
            E(H, D) ? _.splice(L, 1) : (M.push(H), L++);
          }
        }
    }
    return O[C] = _.length, a.createSparseMatrix({
      values: M,
      index: _,
      ptr: O,
      size: [b, C],
      datatype: c === a._datatype && N === s._datatype ? x : void 0
    });
  };
}), i_ = "matAlgo13xDD", a_ = ["typed"], s_ = /* @__PURE__ */ j(i_, a_, (t) => {
  var {
    typed: e
  } = t;
  return function(a, s, o) {
    var p = a._data, u = a._size, f = a._datatype, l = s._data, c = s._size, h = s._datatype, d = [];
    if (u.length !== c.length)
      throw new xt(u.length, c.length);
    for (var g = 0; g < u.length; g++) {
      if (u[g] !== c[g])
        throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + c + ")");
      d[g] = u[g];
    }
    var v, N = o;
    typeof f == "string" && f === h && (v = f, N = e.find(o, [v, v]));
    var b = d.length > 0 ? r(N, 0, d, d[0], p, l) : [];
    return a.createDenseMatrix({
      data: b,
      size: d,
      datatype: v
    });
  };
  function r(n, a, s, o, p, u) {
    var f = [];
    if (a === s.length - 1)
      for (var l = 0; l < o; l++)
        f[l] = n(p[l], u[l]);
    else
      for (var c = 0; c < o; c++)
        f[c] = r(n, a + 1, s, s[a + 1], p[c], u[c]);
    return f;
  }
}), o_ = "broadcast", u_ = ["concat"], l_ = /* @__PURE__ */ j(o_, u_, (t) => {
  var {
    concat: e
  } = t;
  return function(a, s) {
    var o = Math.max(a._size.length, s._size.length);
    if (a._size.length === s._size.length && a._size.every((g, v) => g === s._size[v]))
      return [a, s];
    for (var p = r(a._size, o, 0), u = r(s._size, o, 0), f = [], l = 0; l < o; l++)
      f[l] = Math.max(p[l], u[l]);
    su(p, f), su(u, f);
    var c = a.clone(), h = s.clone();
    c._size.length < o ? c.reshape(r(c._size, o, 1)) : h._size.length < o && h.reshape(r(h._size, o, 1));
    for (var d = 0; d < o; d++)
      c._size[d] < f[d] && (c = n(c, f[d], d)), h._size[d] < f[d] && (h = n(h, f[d], d));
    return [c, h];
  };
  function r(a, s, o) {
    return [...Array(s - a.length).fill(o), ...a];
  }
  function n(a, s, o) {
    return e(...Array(s).fill(a), o);
  }
}), c_ = "matrixAlgorithmSuite", f_ = ["typed", "matrix", "concat"], Jt = /* @__PURE__ */ j(c_, f_, (t) => {
  var {
    typed: e,
    matrix: r,
    concat: n
  } = t, a = s_({
    typed: e
  }), s = zn({
    typed: e
  }), o = l_({
    concat: n
  });
  return function(u) {
    var f = u.elop, l = u.SD || u.DS, c;
    f ? (c = {
      "DenseMatrix, DenseMatrix": (v, N) => a(...o(v, N), f),
      "Array, Array": (v, N) => a(...o(r(v), r(N)), f).valueOf(),
      "Array, DenseMatrix": (v, N) => a(...o(r(v), N), f),
      "DenseMatrix, Array": (v, N) => a(...o(v, r(N)), f)
    }, u.SS && (c["SparseMatrix, SparseMatrix"] = (v, N) => u.SS(...o(v, N), f, !1)), u.DS && (c["DenseMatrix, SparseMatrix"] = (v, N) => u.DS(...o(v, N), f, !1), c["Array, SparseMatrix"] = (v, N) => u.DS(...o(r(v), N), f, !1)), l && (c["SparseMatrix, DenseMatrix"] = (v, N) => l(...o(N, v), f, !0), c["SparseMatrix, Array"] = (v, N) => l(...o(r(N), v), f, !0))) : (c = {
      "DenseMatrix, DenseMatrix": e.referToSelf((v) => (N, b) => a(...o(N, b), v)),
      "Array, Array": e.referToSelf((v) => (N, b) => a(...o(r(N), r(b)), v).valueOf()),
      "Array, DenseMatrix": e.referToSelf((v) => (N, b) => a(...o(r(N), b), v)),
      "DenseMatrix, Array": e.referToSelf((v) => (N, b) => a(...o(N, r(b)), v))
    }, u.SS && (c["SparseMatrix, SparseMatrix"] = e.referToSelf((v) => (N, b) => u.SS(...o(N, b), v, !1))), u.DS && (c["DenseMatrix, SparseMatrix"] = e.referToSelf((v) => (N, b) => u.DS(...o(N, b), v, !1)), c["Array, SparseMatrix"] = e.referToSelf((v) => (N, b) => u.DS(...o(r(N), b), v, !1))), l && (c["SparseMatrix, DenseMatrix"] = e.referToSelf((v) => (N, b) => l(...o(b, N), v, !0)), c["SparseMatrix, Array"] = e.referToSelf((v) => (N, b) => l(...o(r(b), N), v, !0))));
    var h = u.scalar || "any", d = u.Ds || u.Ss;
    d && (f ? (c["DenseMatrix," + h] = (v, N) => s(v, N, f, !1), c[h + ", DenseMatrix"] = (v, N) => s(N, v, f, !0), c["Array," + h] = (v, N) => s(r(v), N, f, !1).valueOf(), c[h + ", Array"] = (v, N) => s(r(N), v, f, !0).valueOf()) : (c["DenseMatrix," + h] = e.referToSelf((v) => (N, b) => s(N, b, v, !1)), c[h + ", DenseMatrix"] = e.referToSelf((v) => (N, b) => s(b, N, v, !0)), c["Array," + h] = e.referToSelf((v) => (N, b) => s(r(N), b, v, !1).valueOf()), c[h + ", Array"] = e.referToSelf((v) => (N, b) => s(r(b), N, v, !0).valueOf())));
    var g = u.sS !== void 0 ? u.sS : u.Ss;
    return f ? (u.Ss && (c["SparseMatrix," + h] = (v, N) => u.Ss(v, N, f, !1)), g && (c[h + ", SparseMatrix"] = (v, N) => g(N, v, f, !0))) : (u.Ss && (c["SparseMatrix," + h] = e.referToSelf((v) => (N, b) => u.Ss(N, b, v, !1))), g && (c[h + ", SparseMatrix"] = e.referToSelf((v) => (N, b) => g(b, N, v, !0)))), f && f.signatures && d2(c, f.signatures), c;
  };
}), F1 = "mod", p_ = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], Hs = /* @__PURE__ */ j(F1, p_, (t) => {
  var {
    typed: e,
    config: r,
    round: n,
    matrix: a,
    equalScalar: s,
    zeros: o,
    DenseMatrix: p,
    concat: u
  } = t, f = Gs({
    typed: e,
    config: r,
    round: n,
    matrix: a,
    equalScalar: s,
    zeros: o,
    DenseMatrix: p
  }), l = Un({
    typed: e,
    equalScalar: s
  }), c = rn({
    typed: e
  }), h = w0({
    typed: e,
    equalScalar: s
  }), d = Pr({
    typed: e,
    equalScalar: s
  }), g = br({
    typed: e,
    DenseMatrix: p
  }), v = Jt({
    typed: e,
    matrix: a,
    concat: u
  });
  return e(F1, {
    "number, number": N,
    "BigNumber, BigNumber": function(C, x) {
      return x.isZero() ? C : C.sub(x.mul(f(C.div(x))));
    },
    "bigint, bigint": function(C, x) {
      if (x === 0n)
        return C;
      if (C < 0) {
        var E = C % x;
        return E === 0n ? E : E + x;
      }
      return C % x;
    },
    "Fraction, Fraction": function(C, x) {
      return x.equals(0) ? C : C.sub(x.mul(f(C.div(x))));
    }
  }, v({
    SS: h,
    DS: c,
    SD: l,
    Ss: d,
    sS: g
  }));
  function N(b, C) {
    return C === 0 ? b : b - C * f(b / C);
  }
}), h_ = "matAlgo01xDSid", m_ = ["typed"], Ri = /* @__PURE__ */ j(h_, m_, (t) => {
  var {
    typed: e
  } = t;
  return function(n, a, s, o) {
    var p = n._data, u = n._size, f = n._datatype || n.getDataType(), l = a._values, c = a._index, h = a._ptr, d = a._size, g = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (u.length !== d.length)
      throw new xt(u.length, d.length);
    if (u[0] !== d[0] || u[1] !== d[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + d + ")");
    if (!l)
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    var v = u[0], N = u[1], b = typeof f == "string" && f !== "mixed" && f === g ? f : void 0, C = b ? e.find(s, [b, b]) : s, x, E, D = [];
    for (x = 0; x < v; x++)
      D[x] = [];
    var A = [], M = [];
    for (E = 0; E < N; E++) {
      for (var _ = E + 1, O = h[E], T = h[E + 1], I = O; I < T; I++)
        x = c[I], A[x] = o ? C(l[I], p[x][E]) : C(p[x][E], l[I]), M[x] = _;
      for (x = 0; x < v; x++)
        M[x] === _ ? D[x][E] = A[x] : D[x][E] = p[x][E];
    }
    return n.createDenseMatrix({
      data: D,
      size: [v, N],
      datatype: f === n._datatype && g === a._datatype ? b : void 0
    });
  };
}), d_ = "matAlgo04xSidSid", v_ = ["typed", "equalScalar"], _d = /* @__PURE__ */ j(d_, v_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(a, s, o) {
    var p = a._values, u = a._index, f = a._ptr, l = a._size, c = a._datatype || a._data === void 0 ? a._datatype : a.getDataType(), h = s._values, d = s._index, g = s._ptr, v = s._size, N = s._datatype || s._data === void 0 ? s._datatype : s.getDataType();
    if (l.length !== v.length)
      throw new xt(l.length, v.length);
    if (l[0] !== v[0] || l[1] !== v[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + l + ") must match Matrix B (" + v + ")");
    var b = l[0], C = l[1], x, E = r, D = 0, A = o;
    typeof c == "string" && c === N && c !== "mixed" && (x = c, E = e.find(r, [x, x]), D = e.convert(0, x), A = e.find(o, [x, x]));
    var M = p && h ? [] : void 0, _ = [], O = [], T = p && h ? [] : void 0, I = p && h ? [] : void 0, q = [], $ = [], U, k, L, R, G;
    for (k = 0; k < C; k++) {
      O[k] = _.length;
      var P = k + 1;
      for (R = f[k], G = f[k + 1], L = R; L < G; L++)
        U = u[L], _.push(U), q[U] = P, T && (T[U] = p[L]);
      for (R = g[k], G = g[k + 1], L = R; L < G; L++)
        if (U = d[L], q[U] === P) {
          if (T) {
            var W = A(T[U], h[L]);
            E(W, D) ? q[U] = null : T[U] = W;
          }
        } else
          _.push(U), $[U] = P, I && (I[U] = h[L]);
      if (T && I)
        for (L = O[k]; L < _.length; )
          U = _[L], q[U] === P ? (M[L] = T[U], L++) : $[U] === P ? (M[L] = I[U], L++) : _.splice(L, 1);
    }
    return O[C] = _.length, a.createSparseMatrix({
      values: M,
      index: _,
      ptr: O,
      size: [b, C],
      datatype: c === a._datatype && N === s._datatype ? x : void 0
    });
  };
}), g_ = "matAlgo10xSids", y_ = ["typed", "DenseMatrix"], la = /* @__PURE__ */ j(g_, y_, (t) => {
  var {
    typed: e,
    DenseMatrix: r
  } = t;
  return function(a, s, o, p) {
    var u = a._values, f = a._index, l = a._ptr, c = a._size, h = a._datatype;
    if (!u)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var d = c[0], g = c[1], v, N = o;
    typeof h == "string" && (v = h, s = e.convert(s, v), N = e.find(o, [v, v]));
    for (var b = [], C = [], x = [], E = 0; E < g; E++) {
      for (var D = E + 1, A = l[E], M = l[E + 1], _ = A; _ < M; _++) {
        var O = f[_];
        C[O] = u[_], x[O] = D;
      }
      for (var T = 0; T < d; T++)
        E === 0 && (b[T] = []), x[T] === D ? b[T][E] = p ? N(s, C[T]) : N(C[T], s) : b[T][E] = s;
    }
    return new r({
      data: b,
      size: [d, g],
      datatype: v
    });
  };
});
function Zn(t, e, r, n) {
  if (!(this instanceof Zn))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.fn = t, this.count = e, this.min = r, this.max = n, this.message = "Wrong number of arguments in function " + t + " (" + e + " provided, " + r + (n != null ? "-" + n : "") + " expected)", this.stack = new Error().stack;
}
Zn.prototype = new Error();
Zn.prototype.constructor = Error;
Zn.prototype.name = "ArgumentsError";
Zn.prototype.isArgumentsError = !0;
var q1 = "gcd", x_ = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"], Rm = "number | BigNumber | Fraction | Matrix | Array", b_ = "".concat(Rm, ", ").concat(Rm, ", ...").concat(Rm);
function I1(t) {
  return !t.some((e) => Array.isArray(e));
}
var N0 = /* @__PURE__ */ j(q1, x_, (t) => {
  var {
    typed: e,
    matrix: r,
    config: n,
    round: a,
    equalScalar: s,
    zeros: o,
    BigNumber: p,
    DenseMatrix: u,
    concat: f
  } = t, l = Hs({
    typed: e,
    config: n,
    round: a,
    matrix: r,
    equalScalar: s,
    zeros: o,
    DenseMatrix: u,
    concat: f
  }), c = Ri({
    typed: e
  }), h = _d({
    typed: e,
    equalScalar: s
  }), d = la({
    typed: e,
    DenseMatrix: u
  }), g = Jt({
    typed: e,
    matrix: r,
    concat: f
  });
  return e(q1, {
    "number, number": v,
    "BigNumber, BigNumber": N,
    "Fraction, Fraction": (b, C) => b.gcd(C)
  }, g({
    SS: h,
    DS: c,
    Ss: d
  }), {
    [b_]: e.referToSelf((b) => (C, x, E) => {
      for (var D = b(C, x), A = 0; A < E.length; A++)
        D = b(D, E[A]);
      return D;
    }),
    Array: e.referToSelf((b) => (C) => {
      if (C.length === 1 && Array.isArray(C[0]) && I1(C[0]))
        return b(...C[0]);
      if (I1(C))
        return b(...C);
      throw new Zn("gcd() supports only 1d matrices!");
    }),
    Matrix: e.referToSelf((b) => (C) => b(C.toArray()))
  });
  function v(b, C) {
    if (!Xe(b) || !Xe(C))
      throw new Error("Parameters in function gcd must be integer numbers");
    for (var x; C !== 0; )
      x = l(b, C), b = C, C = x;
    return b < 0 ? -b : b;
  }
  function N(b, C) {
    if (!b.isInt() || !C.isInt())
      throw new Error("Parameters in function gcd must be integer numbers");
    for (var x = new p(0); !C.isZero(); ) {
      var E = l(b, C);
      b = C, C = E;
    }
    return b.lt(x) ? b.neg() : b;
  }
}), w_ = "matAlgo06xS0S0", N_ = ["typed", "equalScalar"], D0 = /* @__PURE__ */ j(w_, N_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(a, s, o) {
    var p = a._values, u = a._size, f = a._datatype || a._data === void 0 ? a._datatype : a.getDataType(), l = s._values, c = s._size, h = s._datatype || s._data === void 0 ? s._datatype : s.getDataType();
    if (u.length !== c.length)
      throw new xt(u.length, c.length);
    if (u[0] !== c[0] || u[1] !== c[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + c + ")");
    var d = u[0], g = u[1], v, N = r, b = 0, C = o;
    typeof f == "string" && f === h && f !== "mixed" && (v = f, N = e.find(r, [v, v]), b = e.convert(0, v), C = e.find(o, [v, v]));
    for (var x = p && l ? [] : void 0, E = [], D = [], A = x ? [] : void 0, M = [], _ = [], O = 0; O < g; O++) {
      D[O] = E.length;
      var T = O + 1;
      if (i1(a, O, M, A, _, T, E, C), i1(s, O, M, A, _, T, E, C), A)
        for (var I = D[O]; I < E.length; ) {
          var q = E[I];
          if (_[q] === T) {
            var $ = A[q];
            N($, b) ? E.splice(I, 1) : (x.push($), I++);
          } else
            E.splice(I, 1);
        }
      else
        for (var U = D[O]; U < E.length; ) {
          var k = E[U];
          _[k] !== T ? E.splice(U, 1) : U++;
        }
    }
    return D[g] = E.length, a.createSparseMatrix({
      values: x,
      index: E,
      ptr: D,
      size: [d, g],
      datatype: f === a._datatype && h === s._datatype ? v : void 0
    });
  };
}), B1 = "lcm", D_ = ["typed", "matrix", "equalScalar", "concat"], A0 = /* @__PURE__ */ j(B1, D_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    concat: a
  } = t, s = Un({
    typed: e,
    equalScalar: n
  }), o = D0({
    typed: e,
    equalScalar: n
  }), p = Pr({
    typed: e,
    equalScalar: n
  }), u = Jt({
    typed: e,
    matrix: r,
    concat: a
  }), f = "number | BigNumber | Fraction | Matrix | Array", l = {};
  return l["".concat(f, ", ").concat(f, ", ...").concat(f)] = e.referToSelf((h) => (d, g, v) => {
    for (var N = h(d, g), b = 0; b < v.length; b++)
      N = h(N, v[b]);
    return N;
  }), e(B1, {
    "number, number": ow,
    "BigNumber, BigNumber": c,
    "Fraction, Fraction": (h, d) => h.lcm(d)
  }, u({
    SS: o,
    DS: s,
    Ss: p
  }), l);
  function c(h, d) {
    if (!h.isInt() || !d.isInt())
      throw new Error("Parameters in function lcm must be integer numbers");
    if (h.isZero())
      return h;
    if (d.isZero())
      return d;
    for (var g = h.times(d); !d.isZero(); ) {
      var v = d;
      d = h.mod(v), h = v;
    }
    return g.div(h).abs();
  }
}), R1 = "log10", A_ = ["typed", "config", "Complex"], E0 = /* @__PURE__ */ j(R1, A_, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(R1, {
    number: function(s) {
      return s >= 0 || r.predictable ? uw(s) : new n(s, 0).log().div(Math.LN10);
    },
    Complex: function(s) {
      return new n(s).log().div(Math.LN10);
    },
    BigNumber: function(s) {
      return !s.isNegative() || r.predictable ? s.log() : new n(s.toNumber(), 0).log().div(Math.LN10);
    },
    "Array | Matrix": e.referToSelf((a) => (s) => Nt(s, a))
  });
}), L1 = "log2", E_ = ["typed", "config", "Complex"], S0 = /* @__PURE__ */ j(L1, E_, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(L1, {
    number: function(o) {
      return o >= 0 || r.predictable ? lw(o) : a(new n(o, 0));
    },
    Complex: a,
    BigNumber: function(o) {
      return !o.isNegative() || r.predictable ? o.log(2) : a(new n(o.toNumber(), 0));
    },
    "Array | Matrix": e.referToSelf((s) => (o) => Nt(o, s))
  });
  function a(s) {
    var o = Math.sqrt(s.re * s.re + s.im * s.im);
    return new n(Math.log2 ? Math.log2(o) : Math.log(o) / Math.LN2, Math.atan2(s.im, s.re) / Math.LN2);
  }
}), S_ = "multiplyScalar", C_ = ["typed"], C0 = /* @__PURE__ */ j(S_, C_, (t) => {
  var {
    typed: e
  } = t;
  return e("multiplyScalar", {
    "number, number": tw,
    "Complex, Complex": function(n, a) {
      return n.mul(a);
    },
    "BigNumber, BigNumber": function(n, a) {
      return n.times(a);
    },
    "bigint, bigint": function(n, a) {
      return n * a;
    },
    "Fraction, Fraction": function(n, a) {
      return n.mul(a);
    },
    "number | Fraction | BigNumber | Complex, Unit": (r, n) => n.multiply(r),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (r, n) => r.multiply(n)
  });
}), P1 = "multiply", T_ = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"], T0 = /* @__PURE__ */ j(P1, T_, (t) => {
  var {
    typed: e,
    matrix: r,
    addScalar: n,
    multiplyScalar: a,
    equalScalar: s,
    dot: o
  } = t, p = Pr({
    typed: e,
    equalScalar: s
  }), u = zn({
    typed: e
  });
  function f(D, A) {
    switch (D.length) {
      case 1:
        switch (A.length) {
          case 1:
            if (D[0] !== A[0])
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            break;
          case 2:
            if (D[0] !== A[0])
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + D[0] + ") must match Matrix rows (" + A[0] + ")");
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + A.length + " dimensions)");
        }
        break;
      case 2:
        switch (A.length) {
          case 1:
            if (D[1] !== A[0])
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + D[1] + ") must match Vector length (" + A[0] + ")");
            break;
          case 2:
            if (D[1] !== A[0])
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + D[1] + ") must match Matrix B rows (" + A[0] + ")");
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + A.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + D.length + " dimensions)");
    }
  }
  function l(D, A, M) {
    if (M === 0)
      throw new Error("Cannot multiply two empty vectors");
    return o(D, A);
  }
  function c(D, A) {
    if (A.storage() !== "dense")
      throw new Error("Support for SparseMatrix not implemented");
    return h(D, A);
  }
  function h(D, A) {
    var M = D._data, _ = D._size, O = D._datatype || D.getDataType(), T = A._data, I = A._size, q = A._datatype || A.getDataType(), $ = _[0], U = I[1], k, L = n, R = a;
    O && q && O === q && typeof O == "string" && O !== "mixed" && (k = O, L = e.find(n, [k, k]), R = e.find(a, [k, k]));
    for (var G = [], P = 0; P < U; P++) {
      for (var W = R(M[0], T[0][P]), le = 1; le < $; le++)
        W = L(W, R(M[le], T[le][P]));
      G[P] = W;
    }
    return D.createDenseMatrix({
      data: G,
      size: [U],
      datatype: O === D._datatype && q === A._datatype ? k : void 0
    });
  }
  var d = e("_multiplyMatrixVector", {
    "DenseMatrix, any": v,
    "SparseMatrix, any": C
  }), g = e("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": N,
    "DenseMatrix, SparseMatrix": b,
    "SparseMatrix, DenseMatrix": x,
    "SparseMatrix, SparseMatrix": E
  });
  function v(D, A) {
    var M = D._data, _ = D._size, O = D._datatype || D.getDataType(), T = A._data, I = A._datatype || A.getDataType(), q = _[0], $ = _[1], U, k = n, L = a;
    O && I && O === I && typeof O == "string" && O !== "mixed" && (U = O, k = e.find(n, [U, U]), L = e.find(a, [U, U]));
    for (var R = [], G = 0; G < q; G++) {
      for (var P = M[G], W = L(P[0], T[0]), le = 1; le < $; le++)
        W = k(W, L(P[le], T[le]));
      R[G] = W;
    }
    return D.createDenseMatrix({
      data: R,
      size: [q],
      datatype: O === D._datatype && I === A._datatype ? U : void 0
    });
  }
  function N(D, A) {
    var M = D._data, _ = D._size, O = D._datatype || D.getDataType(), T = A._data, I = A._size, q = A._datatype || A.getDataType(), $ = _[0], U = _[1], k = I[1], L, R = n, G = a;
    O && q && O === q && typeof O == "string" && O !== "mixed" && O !== "mixed" && (L = O, R = e.find(n, [L, L]), G = e.find(a, [L, L]));
    for (var P = [], W = 0; W < $; W++) {
      var le = M[W];
      P[W] = [];
      for (var Z = 0; Z < k; Z++) {
        for (var H = G(le[0], T[0][Z]), te = 1; te < U; te++)
          H = R(H, G(le[te], T[te][Z]));
        P[W][Z] = H;
      }
    }
    return D.createDenseMatrix({
      data: P,
      size: [$, k],
      datatype: O === D._datatype && q === A._datatype ? L : void 0
    });
  }
  function b(D, A) {
    var M = D._data, _ = D._size, O = D._datatype || D.getDataType(), T = A._values, I = A._index, q = A._ptr, $ = A._size, U = A._datatype || A._data === void 0 ? A._datatype : A.getDataType();
    if (!T)
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    var k = _[0], L = $[1], R, G = n, P = a, W = s, le = 0;
    O && U && O === U && typeof O == "string" && O !== "mixed" && (R = O, G = e.find(n, [R, R]), P = e.find(a, [R, R]), W = e.find(s, [R, R]), le = e.convert(0, R));
    for (var Z = [], H = [], te = [], be = A.createSparseMatrix({
      values: Z,
      index: H,
      ptr: te,
      size: [k, L],
      datatype: O === D._datatype && U === A._datatype ? R : void 0
    }), K = 0; K < L; K++) {
      te[K] = H.length;
      var ce = q[K], de = q[K + 1];
      if (de > ce)
        for (var ue = 0, ve = 0; ve < k; ve++) {
          for (var he = ve + 1, Ne = void 0, we = ce; we < de; we++) {
            var Se = I[we];
            ue !== he ? (Ne = P(M[ve][Se], T[we]), ue = he) : Ne = G(Ne, P(M[ve][Se], T[we]));
          }
          ue === he && !W(Ne, le) && (H.push(ve), Z.push(Ne));
        }
    }
    return te[L] = H.length, be;
  }
  function C(D, A) {
    var M = D._values, _ = D._index, O = D._ptr, T = D._datatype || D._data === void 0 ? D._datatype : D.getDataType();
    if (!M)
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    var I = A._data, q = A._datatype || A.getDataType(), $ = D._size[0], U = A._size[0], k = [], L = [], R = [], G, P = n, W = a, le = s, Z = 0;
    T && q && T === q && typeof T == "string" && T !== "mixed" && (G = T, P = e.find(n, [G, G]), W = e.find(a, [G, G]), le = e.find(s, [G, G]), Z = e.convert(0, G));
    var H = [], te = [];
    R[0] = 0;
    for (var be = 0; be < U; be++) {
      var K = I[be];
      if (!le(K, Z))
        for (var ce = O[be], de = O[be + 1], ue = ce; ue < de; ue++) {
          var ve = _[ue];
          te[ve] ? H[ve] = P(H[ve], W(K, M[ue])) : (te[ve] = !0, L.push(ve), H[ve] = W(K, M[ue]));
        }
    }
    for (var he = L.length, Ne = 0; Ne < he; Ne++) {
      var we = L[Ne];
      k[Ne] = H[we];
    }
    return R[1] = L.length, D.createSparseMatrix({
      values: k,
      index: L,
      ptr: R,
      size: [$, 1],
      datatype: T === D._datatype && q === A._datatype ? G : void 0
    });
  }
  function x(D, A) {
    var M = D._values, _ = D._index, O = D._ptr, T = D._datatype || D._data === void 0 ? D._datatype : D.getDataType();
    if (!M)
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    var I = A._data, q = A._datatype || A.getDataType(), $ = D._size[0], U = A._size[0], k = A._size[1], L, R = n, G = a, P = s, W = 0;
    T && q && T === q && typeof T == "string" && T !== "mixed" && (L = T, R = e.find(n, [L, L]), G = e.find(a, [L, L]), P = e.find(s, [L, L]), W = e.convert(0, L));
    for (var le = [], Z = [], H = [], te = D.createSparseMatrix({
      values: le,
      index: Z,
      ptr: H,
      size: [$, k],
      datatype: T === D._datatype && q === A._datatype ? L : void 0
    }), be = [], K = [], ce = 0; ce < k; ce++) {
      H[ce] = Z.length;
      for (var de = ce + 1, ue = 0; ue < U; ue++) {
        var ve = I[ue][ce];
        if (!P(ve, W))
          for (var he = O[ue], Ne = O[ue + 1], we = he; we < Ne; we++) {
            var Se = _[we];
            K[Se] !== de ? (K[Se] = de, Z.push(Se), be[Se] = G(ve, M[we])) : be[Se] = R(be[Se], G(ve, M[we]));
          }
      }
      for (var V = H[ce], re = Z.length, pe = V; pe < re; pe++) {
        var X = Z[pe];
        le[pe] = be[X];
      }
    }
    return H[k] = Z.length, te;
  }
  function E(D, A) {
    var M = D._values, _ = D._index, O = D._ptr, T = D._datatype || D._data === void 0 ? D._datatype : D.getDataType(), I = A._values, q = A._index, $ = A._ptr, U = A._datatype || A._data === void 0 ? A._datatype : A.getDataType(), k = D._size[0], L = A._size[1], R = M && I, G, P = n, W = a;
    T && U && T === U && typeof T == "string" && T !== "mixed" && (G = T, P = e.find(n, [G, G]), W = e.find(a, [G, G]));
    for (var le = R ? [] : void 0, Z = [], H = [], te = D.createSparseMatrix({
      values: le,
      index: Z,
      ptr: H,
      size: [k, L],
      datatype: T === D._datatype && U === A._datatype ? G : void 0
    }), be = R ? [] : void 0, K = [], ce, de, ue, ve, he, Ne, we, Se, V = 0; V < L; V++) {
      H[V] = Z.length;
      var re = V + 1;
      for (he = $[V], Ne = $[V + 1], ve = he; ve < Ne; ve++)
        if (Se = q[ve], R)
          for (de = O[Se], ue = O[Se + 1], ce = de; ce < ue; ce++)
            we = _[ce], K[we] !== re ? (K[we] = re, Z.push(we), be[we] = W(I[ve], M[ce])) : be[we] = P(be[we], W(I[ve], M[ce]));
        else
          for (de = O[Se], ue = O[Se + 1], ce = de; ce < ue; ce++)
            we = _[ce], K[we] !== re && (K[we] = re, Z.push(we));
      if (R)
        for (var pe = H[V], X = Z.length, ie = pe; ie < X; ie++) {
          var me = Z[ie];
          le[ie] = be[me];
        }
    }
    return H[L] = Z.length, te;
  }
  return e(P1, a, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": e.referTo("Matrix, Matrix", (D) => (A, M) => {
      f(gt(A), gt(M));
      var _ = D(r(A), r(M));
      return tt(_) ? _.valueOf() : _;
    }),
    "Matrix, Matrix": function(A, M) {
      var _ = A.size(), O = M.size();
      return f(_, O), _.length === 1 ? O.length === 1 ? l(A, M, _[0]) : c(A, M) : O.length === 1 ? d(A, M) : g(A, M);
    },
    "Matrix, Array": e.referTo("Matrix,Matrix", (D) => (A, M) => D(A, r(M))),
    "Array, Matrix": e.referToSelf((D) => (A, M) => D(r(A, M.storage()), M)),
    "SparseMatrix, any": function(A, M) {
      return p(A, M, a, !1);
    },
    "DenseMatrix, any": function(A, M) {
      return u(A, M, a, !1);
    },
    "any, SparseMatrix": function(A, M) {
      return p(M, A, a, !0);
    },
    "any, DenseMatrix": function(A, M) {
      return u(M, A, a, !0);
    },
    "Array, any": function(A, M) {
      return u(r(A), M, a, !1).valueOf();
    },
    "any, Array": function(A, M) {
      return u(r(M), A, a, !0).valueOf();
    },
    "any, any": a,
    "any, any, ...any": e.referToSelf((D) => (A, M, _) => {
      for (var O = D(A, M), T = 0; T < _.length; T++)
        O = D(O, _[T]);
      return O;
    })
  });
}), k1 = "nthRoot", __ = ["typed", "matrix", "equalScalar", "BigNumber", "concat"], _0 = /* @__PURE__ */ j(k1, __, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    BigNumber: a,
    concat: s
  } = t, o = Ri({
    typed: e
  }), p = Un({
    typed: e,
    equalScalar: n
  }), u = D0({
    typed: e,
    equalScalar: n
  }), f = Pr({
    typed: e,
    equalScalar: n
  }), l = Jt({
    typed: e,
    matrix: r,
    concat: s
  });
  function c() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return e(k1, {
    number: s1,
    "number, number": s1,
    BigNumber: (d) => h(d, new a(2)),
    "BigNumber, BigNumber": h,
    Complex: c,
    "Complex, number": c,
    Array: e.referTo("DenseMatrix,number", (d) => (g) => d(r(g), 2).valueOf()),
    DenseMatrix: e.referTo("DenseMatrix,number", (d) => (g) => d(g, 2)),
    SparseMatrix: e.referTo("SparseMatrix,number", (d) => (g) => d(g, 2)),
    "SparseMatrix, SparseMatrix": e.referToSelf((d) => (g, v) => {
      if (v.density() === 1)
        return u(g, v, d);
      throw new Error("Root must be non-zero");
    }),
    "DenseMatrix, SparseMatrix": e.referToSelf((d) => (g, v) => {
      if (v.density() === 1)
        return o(g, v, d, !1);
      throw new Error("Root must be non-zero");
    }),
    "Array, SparseMatrix": e.referTo("DenseMatrix,SparseMatrix", (d) => (g, v) => d(r(g), v)),
    "number | BigNumber, SparseMatrix": e.referToSelf((d) => (g, v) => {
      if (v.density() === 1)
        return f(v, g, d, !0);
      throw new Error("Root must be non-zero");
    })
  }, l({
    scalar: "number | BigNumber",
    SD: p,
    Ss: f,
    sS: !1
  }));
  function h(d, g) {
    var v = a.precision, N = a.clone({
      precision: v + 2
    }), b = new a(0), C = new N(1), x = g.isNegative();
    if (x && (g = g.neg()), g.isZero())
      throw new Error("Root must be non-zero");
    if (d.isNegative() && !g.abs().mod(2).equals(1))
      throw new Error("Root must be odd when a is negative.");
    if (d.isZero())
      return x ? new N(1 / 0) : 0;
    if (!d.isFinite())
      return x ? b : d;
    var E = d.abs().pow(C.div(g));
    return E = d.isNeg() ? E.neg() : E, new a((x ? C.div(E) : E).toPrecision(v));
  }
}), $1 = "sign", M_ = ["typed", "BigNumber", "Fraction", "complex"], M0 = /* @__PURE__ */ j($1, M_, (t) => {
  var {
    typed: e,
    BigNumber: r,
    complex: n,
    Fraction: a
  } = t;
  return e($1, {
    number: Ym,
    Complex: function(o) {
      return o.im === 0 ? n(Ym(o.re)) : o.sign();
    },
    BigNumber: function(o) {
      return new r(o.cmp(0));
    },
    bigint: function(o) {
      return o > 0n ? 1n : o < 0n ? -1n : 0n;
    },
    Fraction: function(o) {
      return new a(o.s, 1);
    },
    // deep map collection, skip zeros since sign(0) = 0
    "Array | Matrix": e.referToSelf((s) => (o) => Nt(o, s)),
    Unit: e.referToSelf((s) => (o) => {
      if (!o._isDerived() && o.units[0].unit.offset !== 0)
        throw new TypeError("sign is ambiguous for units with offset");
      return e.find(s, o.valueType())(o.value);
    })
  });
}), O_ = "sqrt", F_ = ["config", "typed", "Complex"], O0 = /* @__PURE__ */ j(O_, F_, (t) => {
  var {
    config: e,
    typed: r,
    Complex: n
  } = t;
  return r("sqrt", {
    number: a,
    Complex: function(o) {
      return o.sqrt();
    },
    BigNumber: function(o) {
      return !o.isNegative() || e.predictable ? o.sqrt() : a(o.toNumber());
    },
    Unit: function(o) {
      return o.pow(0.5);
    }
  });
  function a(s) {
    return isNaN(s) ? NaN : s >= 0 || e.predictable ? Math.sqrt(s) : new n(s, 0).sqrt();
  }
}), z1 = "square", q_ = ["typed"], F0 = /* @__PURE__ */ j(z1, q_, (t) => {
  var {
    typed: e
  } = t;
  return e(z1, {
    number: cw,
    Complex: function(n) {
      return n.mul(n);
    },
    BigNumber: function(n) {
      return n.times(n);
    },
    bigint: function(n) {
      return n * n;
    },
    Fraction: function(n) {
      return n.mul(n);
    },
    Unit: function(n) {
      return n.pow(2);
    }
  });
}), U1 = "subtract", I_ = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"], q0 = /* @__PURE__ */ j(U1, I_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    subtractScalar: a,
    unaryMinus: s,
    DenseMatrix: o,
    concat: p
  } = t, u = Ri({
    typed: e
  }), f = rn({
    typed: e
  }), l = w0({
    typed: e,
    equalScalar: n
  }), c = la({
    typed: e,
    DenseMatrix: o
  }), h = br({
    typed: e,
    DenseMatrix: o
  }), d = Jt({
    typed: e,
    matrix: r,
    concat: p
  });
  return e(U1, {
    "any, any": a
  }, d({
    elop: a,
    SS: l,
    DS: u,
    SD: f,
    Ss: h,
    sS: c
  }));
}), G1 = "xgcd", B_ = ["typed", "config", "matrix", "BigNumber"], I0 = /* @__PURE__ */ j(G1, B_, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: a
  } = t;
  return e(G1, {
    "number, number": function(p, u) {
      var f = fw(p, u);
      return r.matrix === "Array" ? f : n(f);
    },
    "BigNumber, BigNumber": s
    // TODO: implement support for Fraction
  });
  function s(o, p) {
    var u, f, l, c = new a(0), h = new a(1), d = c, g = h, v = h, N = c;
    if (!o.isInt() || !p.isInt())
      throw new Error("Parameters in function xgcd must be integer numbers");
    for (; !p.isZero(); )
      f = o.div(p).floor(), l = o.mod(p), u = d, d = g.minus(f.times(d)), g = u, u = v, v = N.minus(f.times(v)), N = u, o = p, p = l;
    var b;
    return o.lt(c) ? b = [o.neg(), g.neg(), N.neg()] : b = [o, o.isZero() ? 0 : g, N], r.matrix === "Array" ? b : n(b);
  }
}), H1 = "invmod", R_ = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"], B0 = /* @__PURE__ */ j(H1, R_, (t) => {
  var {
    typed: e,
    config: r,
    BigNumber: n,
    xgcd: a,
    equal: s,
    smaller: o,
    mod: p,
    add: u,
    isInteger: f
  } = t;
  return e(H1, {
    "number, number": l,
    "BigNumber, BigNumber": l
  });
  function l(c, h) {
    if (!f(c) || !f(h)) throw new Error("Parameters in function invmod must be integer numbers");
    if (c = p(c, h), s(h, 0)) throw new Error("Divisor must be non zero");
    var d = a(c, h);
    d = d.valueOf();
    var [g, v] = d;
    return s(g, n(1)) ? (v = p(v, h), o(v, n(0)) && (v = u(v, h)), v) : NaN;
  }
}), L_ = "matAlgo09xS0Sf", P_ = ["typed", "equalScalar"], Gw = /* @__PURE__ */ j(L_, P_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(a, s, o) {
    var p = a._values, u = a._index, f = a._ptr, l = a._size, c = a._datatype || a._data === void 0 ? a._datatype : a.getDataType(), h = s._values, d = s._index, g = s._ptr, v = s._size, N = s._datatype || s._data === void 0 ? s._datatype : s.getDataType();
    if (l.length !== v.length)
      throw new xt(l.length, v.length);
    if (l[0] !== v[0] || l[1] !== v[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + l + ") must match Matrix B (" + v + ")");
    var b = l[0], C = l[1], x, E = r, D = 0, A = o;
    typeof c == "string" && c === N && c !== "mixed" && (x = c, E = e.find(r, [x, x]), D = e.convert(0, x), A = e.find(o, [x, x]));
    var M = p && h ? [] : void 0, _ = [], O = [], T = M ? [] : void 0, I = [], q, $, U, k, L;
    for ($ = 0; $ < C; $++) {
      O[$] = _.length;
      var R = $ + 1;
      if (T)
        for (k = g[$], L = g[$ + 1], U = k; U < L; U++)
          q = d[U], I[q] = R, T[q] = h[U];
      for (k = f[$], L = f[$ + 1], U = k; U < L; U++)
        if (q = u[U], T) {
          var G = I[q] === R ? T[q] : D, P = A(p[U], G);
          E(P, D) || (_.push(q), M.push(P));
        } else
          _.push(q);
    }
    return O[C] = _.length, a.createSparseMatrix({
      values: M,
      index: _,
      ptr: O,
      size: [b, C],
      datatype: c === a._datatype && N === s._datatype ? x : void 0
    });
  };
}), Q1 = "dotMultiply", k_ = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"], R0 = /* @__PURE__ */ j(Q1, k_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    multiplyScalar: a,
    concat: s
  } = t, o = Un({
    typed: e,
    equalScalar: n
  }), p = Gw({
    typed: e,
    equalScalar: n
  }), u = Pr({
    typed: e,
    equalScalar: n
  }), f = Jt({
    typed: e,
    matrix: r,
    concat: s
  });
  return e(Q1, f({
    elop: a,
    SS: p,
    DS: o,
    Ss: u
  }));
});
function $_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function bitAnd");
  var r = t.constructor;
  if (t.isNaN() || e.isNaN())
    return new r(NaN);
  if (t.isZero() || e.eq(-1) || t.eq(e))
    return t;
  if (e.isZero() || t.eq(-1))
    return e;
  if (!t.isFinite() || !e.isFinite()) {
    if (!t.isFinite() && !e.isFinite())
      return t.isNegative() === e.isNegative() ? t : new r(0);
    if (!t.isFinite())
      return e.isNegative() ? t : t.isNegative() ? new r(0) : e;
    if (!e.isFinite())
      return t.isNegative() ? e : e.isNegative() ? new r(0) : t;
  }
  return Md(t, e, function(n, a) {
    return n & a;
  });
}
function Is(t) {
  if (t.isFinite() && !t.isInteger())
    throw new Error("Integer expected in function bitNot");
  var e = t.constructor, r = e.precision;
  e.config({
    precision: 1e9
  });
  var n = t.plus(new e(1));
  return n.s = -n.s || null, e.config({
    precision: r
  }), n;
}
function z_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function bitOr");
  var r = t.constructor;
  if (t.isNaN() || e.isNaN())
    return new r(NaN);
  var n = new r(-1);
  return t.isZero() || e.eq(n) || t.eq(e) ? e : e.isZero() || t.eq(n) ? t : !t.isFinite() || !e.isFinite() ? !t.isFinite() && !t.isNegative() && e.isNegative() || t.isNegative() && !e.isNegative() && !e.isFinite() ? n : t.isNegative() && e.isNegative() ? t.isFinite() ? t : e : t.isFinite() ? e : t : Md(t, e, function(a, s) {
    return a | s;
  });
}
function Md(t, e, r) {
  var n = t.constructor, a, s, o = +(t.s < 0), p = +(e.s < 0);
  if (o) {
    a = qo(Is(t));
    for (var u = 0; u < a.length; ++u)
      a[u] ^= 1;
  } else
    a = qo(t);
  if (p) {
    s = qo(Is(e));
    for (var f = 0; f < s.length; ++f)
      s[f] ^= 1;
  } else
    s = qo(e);
  var l, c, h;
  a.length <= s.length ? (l = a, c = s, h = o) : (l = s, c = a, h = p);
  var d = l.length, g = c.length, v = r(o, p) ^ 1, N = new n(v ^ 1), b = new n(1), C = new n(2), x = n.precision;
  for (n.config({
    precision: 1e9
  }); d > 0; )
    r(l[--d], c[--g]) === v && (N = N.plus(b)), b = b.times(C);
  for (; g > 0; )
    r(h, c[--g]) === v && (N = N.plus(b)), b = b.times(C);
  return n.config({
    precision: x
  }), v === 0 && (N.s = -N.s), N;
}
function qo(t) {
  for (var e = t.d, r = e[0] + "", n = 1; n < e.length; ++n) {
    for (var a = e[n] + "", s = 7 - a.length; s--; )
      a = "0" + a;
    r += a;
  }
  for (var o = r.length; r.charAt(o) === "0"; )
    o--;
  var p = t.e, u = r.slice(0, o + 1 || 1), f = u.length;
  if (p > 0)
    if (++p > f)
      for (p -= f; p--; )
        u += "0";
    else p < f && (u = u.slice(0, p) + "." + u.slice(p));
  for (var l = [0], c = 0; c < u.length; ) {
    for (var h = l.length; h--; )
      l[h] *= 10;
    l[0] += parseInt(u.charAt(c++));
    for (var d = 0; d < l.length; ++d)
      l[d] > 1 && ((l[d + 1] === null || l[d + 1] === void 0) && (l[d + 1] = 0), l[d + 1] += l[d] >> 1, l[d] &= 1);
  }
  return l.reverse();
}
function U_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function bitXor");
  var r = t.constructor;
  if (t.isNaN() || e.isNaN())
    return new r(NaN);
  if (t.isZero())
    return e;
  if (e.isZero())
    return t;
  if (t.eq(e))
    return new r(0);
  var n = new r(-1);
  return t.eq(n) ? Is(e) : e.eq(n) ? Is(t) : !t.isFinite() || !e.isFinite() ? !t.isFinite() && !e.isFinite() ? n : new r(t.isNegative() === e.isNegative() ? 1 / 0 : -1 / 0) : Md(t, e, function(a, s) {
    return a ^ s;
  });
}
function G_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function leftShift");
  var r = t.constructor;
  return t.isNaN() || e.isNaN() || e.isNegative() && !e.isZero() ? new r(NaN) : t.isZero() || e.isZero() ? t : !t.isFinite() && !e.isFinite() ? new r(NaN) : e.lt(55) ? t.times(Math.pow(2, e.toNumber()) + "") : t.times(new r(2).pow(e));
}
function H_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function rightArithShift");
  var r = t.constructor;
  return t.isNaN() || e.isNaN() || e.isNegative() && !e.isZero() ? new r(NaN) : t.isZero() || e.isZero() ? t : e.isFinite() ? e.lt(55) ? t.div(Math.pow(2, e.toNumber()) + "").floor() : t.div(new r(2).pow(e)).floor() : t.isNegative() ? new r(-1) : t.isFinite() ? new r(0) : new r(NaN);
}
var V1 = "bitAnd", Q_ = ["typed", "matrix", "equalScalar", "concat"], Qs = /* @__PURE__ */ j(V1, Q_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    concat: a
  } = t, s = Un({
    typed: e,
    equalScalar: n
  }), o = D0({
    typed: e,
    equalScalar: n
  }), p = Pr({
    typed: e,
    equalScalar: n
  }), u = Jt({
    typed: e,
    matrix: r,
    concat: a
  });
  return e(V1, {
    "number, number": hw,
    "BigNumber, BigNumber": $_,
    "bigint, bigint": (f, l) => f & l
  }, u({
    SS: o,
    DS: s,
    Ss: p
  }));
}), W1 = "bitNot", V_ = ["typed"], L0 = /* @__PURE__ */ j(W1, V_, (t) => {
  var {
    typed: e
  } = t;
  return e(W1, {
    number: mw,
    BigNumber: Is,
    bigint: (r) => ~r,
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), j1 = "bitOr", W_ = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Vs = /* @__PURE__ */ j(j1, W_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: a,
    concat: s
  } = t, o = Ri({
    typed: e
  }), p = _d({
    typed: e,
    equalScalar: n
  }), u = la({
    typed: e,
    DenseMatrix: a
  }), f = Jt({
    typed: e,
    matrix: r,
    concat: s
  });
  return e(j1, {
    "number, number": dw,
    "BigNumber, BigNumber": z_,
    "bigint, bigint": (l, c) => l | c
  }, f({
    SS: p,
    DS: o,
    Ss: u
  }));
}), j_ = "matAlgo07xSSf", Z_ = ["typed", "DenseMatrix"], Jn = /* @__PURE__ */ j(j_, Z_, (t) => {
  var {
    typed: e,
    DenseMatrix: r
  } = t;
  return function(s, o, p) {
    var u = s._size, f = s._datatype || s._data === void 0 ? s._datatype : s.getDataType(), l = o._size, c = o._datatype || o._data === void 0 ? o._datatype : o.getDataType();
    if (u.length !== l.length)
      throw new xt(u.length, l.length);
    if (u[0] !== l[0] || u[1] !== l[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + l + ")");
    var h = u[0], d = u[1], g, v = 0, N = p;
    typeof f == "string" && f === c && f !== "mixed" && (g = f, v = e.convert(0, g), N = e.find(p, [g, g]));
    var b, C, x = [];
    for (b = 0; b < h; b++)
      x[b] = [];
    var E = [], D = [], A = [], M = [];
    for (C = 0; C < d; C++) {
      var _ = C + 1;
      for (n(s, C, A, E, _), n(o, C, M, D, _), b = 0; b < h; b++) {
        var O = A[b] === _ ? E[b] : v, T = M[b] === _ ? D[b] : v;
        x[b][C] = N(O, T);
      }
    }
    return new r({
      data: x,
      size: [h, d],
      datatype: f === s._datatype && c === o._datatype ? g : void 0
    });
  };
  function n(a, s, o, p, u) {
    for (var f = a._values, l = a._index, c = a._ptr, h = c[s], d = c[s + 1]; h < d; h++) {
      var g = l[h];
      o[g] = u, p[g] = f[h];
    }
  }
}), Z1 = "bitXor", J_ = ["typed", "matrix", "DenseMatrix", "concat"], P0 = /* @__PURE__ */ j(Z1, J_, (t) => {
  var {
    typed: e,
    matrix: r,
    DenseMatrix: n,
    concat: a
  } = t, s = rn({
    typed: e
  }), o = Jn({
    typed: e,
    DenseMatrix: n
  }), p = br({
    typed: e,
    DenseMatrix: n
  }), u = Jt({
    typed: e,
    matrix: r,
    concat: a
  });
  return e(Z1, {
    "number, number": vw,
    "BigNumber, BigNumber": U_,
    "bigint, bigint": (f, l) => f ^ l
  }, u({
    SS: o,
    DS: s,
    Ss: p
  }));
}), J1 = "arg", Y_ = ["typed"], k0 = /* @__PURE__ */ j(J1, Y_, (t) => {
  var {
    typed: e
  } = t;
  return e(J1, {
    number: function(n) {
      return Math.atan2(0, n);
    },
    BigNumber: function(n) {
      return n.constructor.atan2(0, n);
    },
    Complex: function(n) {
      return n.arg();
    },
    // TODO: implement BigNumber support for function arg
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), Y1 = "conj", X_ = ["typed"], $0 = /* @__PURE__ */ j(Y1, X_, (t) => {
  var {
    typed: e
  } = t;
  return e(Y1, {
    "number | BigNumber | Fraction": (r) => r,
    Complex: (r) => r.conjugate(),
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), X1 = "im", K_ = ["typed"], z0 = /* @__PURE__ */ j(X1, K_, (t) => {
  var {
    typed: e
  } = t;
  return e(X1, {
    number: () => 0,
    "BigNumber | Fraction": (r) => r.mul(0),
    Complex: (r) => r.im,
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), K1 = "re", eM = ["typed"], U0 = /* @__PURE__ */ j(K1, eM, (t) => {
  var {
    typed: e
  } = t;
  return e(K1, {
    "number | BigNumber | Fraction": (r) => r,
    Complex: (r) => r.re,
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), ey = "not", tM = ["typed"], G0 = /* @__PURE__ */ j(ey, tM, (t) => {
  var {
    typed: e
  } = t;
  return e(ey, {
    "null | undefined": () => !0,
    number: ww,
    Complex: function(n) {
      return n.re === 0 && n.im === 0;
    },
    BigNumber: function(n) {
      return n.isZero() || n.isNaN();
    },
    bigint: (r) => !r,
    Unit: e.referToSelf((r) => (n) => e.find(r, n.valueType())(n.value)),
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), ty = "or", rM = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Ws = /* @__PURE__ */ j(ty, rM, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: a,
    concat: s
  } = t, o = rn({
    typed: e
  }), p = w0({
    typed: e,
    equalScalar: n
  }), u = br({
    typed: e,
    DenseMatrix: a
  }), f = Jt({
    typed: e,
    matrix: r,
    concat: s
  });
  return e(ty, {
    "number, number": Xm,
    "Complex, Complex": function(c, h) {
      return c.re !== 0 || c.im !== 0 || h.re !== 0 || h.im !== 0;
    },
    "BigNumber, BigNumber": function(c, h) {
      return !c.isZero() && !c.isNaN() || !h.isZero() && !h.isNaN();
    },
    "bigint, bigint": Xm,
    "Unit, Unit": e.referToSelf((l) => (c, h) => l(c.value || 0, h.value || 0))
  }, f({
    SS: p,
    DS: o,
    Ss: u
  }));
}), ry = "xor", nM = ["typed", "matrix", "DenseMatrix", "concat"], H0 = /* @__PURE__ */ j(ry, nM, (t) => {
  var {
    typed: e,
    matrix: r,
    DenseMatrix: n,
    concat: a
  } = t, s = rn({
    typed: e
  }), o = Jn({
    typed: e,
    DenseMatrix: n
  }), p = br({
    typed: e,
    DenseMatrix: n
  }), u = Jt({
    typed: e,
    matrix: r,
    concat: a
  });
  return e(ry, {
    "number, number": Km,
    "Complex, Complex": function(l, c) {
      return (l.re !== 0 || l.im !== 0) != (c.re !== 0 || c.im !== 0);
    },
    "bigint, bigint": Km,
    "BigNumber, BigNumber": function(l, c) {
      return (!l.isZero() && !l.isNaN()) != (!c.isZero() && !c.isNaN());
    },
    "Unit, Unit": e.referToSelf((f) => (l, c) => f(l.value || 0, c.value || 0))
  }, u({
    SS: o,
    DS: s,
    Ss: p
  }));
}), ny = "concat", iM = ["typed", "matrix", "isInteger"], js = /* @__PURE__ */ j(ny, iM, (t) => {
  var {
    typed: e,
    matrix: r,
    isInteger: n
  } = t;
  return e(ny, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function(s) {
      var o, p = s.length, u = -1, f, l = !1, c = [];
      for (o = 0; o < p; o++) {
        var h = s[o];
        if (tt(h) && (l = !0), ht(h) || ct(h)) {
          if (o !== p - 1)
            throw new Error("Dimension must be specified as last argument");
          if (f = u, u = h.valueOf(), !n(u))
            throw new TypeError("Integer number expected for dimension");
          if (u < 0 || o > 0 && u > f)
            throw new yn(u, f + 1);
        } else {
          var d = nt(h).valueOf(), g = gt(d);
          if (c[o] = d, f = u, u = g.length - 1, o > 0 && u !== f)
            throw new xt(f + 1, u + 1);
        }
      }
      if (c.length === 0)
        throw new SyntaxError("At least one matrix expected");
      for (var v = c.shift(); c.length; )
        v = Z2(v, c.shift(), u);
      return l ? r(v) : v;
    },
    "...string": function(s) {
      return s.join("");
    }
  });
}), iy = "column", aM = ["typed", "Index", "matrix", "range"], Zs = /* @__PURE__ */ j(iy, aM, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: a
  } = t;
  return e(iy, {
    "Matrix, number": s,
    "Array, number": function(p, u) {
      return s(n(nt(p)), u).valueOf();
    }
  });
  function s(o, p) {
    if (o.size().length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    Ht(p, o.size()[1]);
    var u = a(0, o.size()[0]), f = new r(u, p), l = o.subset(f);
    return tt(l) ? l : n([[l]]);
  }
}), ay = "count", sM = ["typed", "size", "prod"], Q0 = /* @__PURE__ */ j(ay, sM, (t) => {
  var {
    typed: e,
    size: r,
    prod: n
  } = t;
  return e(ay, {
    string: function(s) {
      return s.length;
    },
    "Matrix | Array": function(s) {
      return n(r(s));
    }
  });
}), sy = "cross", oM = ["typed", "matrix", "subtract", "multiply"], V0 = /* @__PURE__ */ j(sy, oM, (t) => {
  var {
    typed: e,
    matrix: r,
    subtract: n,
    multiply: a
  } = t;
  return e(sy, {
    "Matrix, Matrix": function(p, u) {
      return r(s(p.toArray(), u.toArray()));
    },
    "Matrix, Array": function(p, u) {
      return r(s(p.toArray(), u));
    },
    "Array, Matrix": function(p, u) {
      return r(s(p, u.toArray()));
    },
    "Array, Array": s
  });
  function s(o, p) {
    var u = Math.max(gt(o).length, gt(p).length);
    o = nu(o), p = nu(p);
    var f = gt(o), l = gt(p);
    if (f.length !== 1 || l.length !== 1 || f[0] !== 3 || l[0] !== 3)
      throw new RangeError("Vectors with length 3 expected (Size A = [" + f.join(", ") + "], B = [" + l.join(", ") + "])");
    var c = [n(a(o[1], p[2]), a(o[2], p[1])), n(a(o[2], p[0]), a(o[0], p[2])), n(a(o[0], p[1]), a(o[1], p[0]))];
    return u > 1 ? [c] : c;
  }
}), oy = "diag", uM = ["typed", "matrix", "DenseMatrix", "SparseMatrix"], W0 = /* @__PURE__ */ j(oy, uM, (t) => {
  var {
    typed: e,
    matrix: r,
    DenseMatrix: n,
    SparseMatrix: a
  } = t;
  return e(oy, {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
    Array: function(f) {
      return s(f, 0, gt(f), null);
    },
    "Array, number": function(f, l) {
      return s(f, l, gt(f), null);
    },
    "Array, BigNumber": function(f, l) {
      return s(f, l.toNumber(), gt(f), null);
    },
    "Array, string": function(f, l) {
      return s(f, 0, gt(f), l);
    },
    "Array, number, string": function(f, l, c) {
      return s(f, l, gt(f), c);
    },
    "Array, BigNumber, string": function(f, l, c) {
      return s(f, l.toNumber(), gt(f), c);
    },
    Matrix: function(f) {
      return s(f, 0, f.size(), f.storage());
    },
    "Matrix, number": function(f, l) {
      return s(f, l, f.size(), f.storage());
    },
    "Matrix, BigNumber": function(f, l) {
      return s(f, l.toNumber(), f.size(), f.storage());
    },
    "Matrix, string": function(f, l) {
      return s(f, 0, f.size(), l);
    },
    "Matrix, number, string": function(f, l, c) {
      return s(f, l, f.size(), c);
    },
    "Matrix, BigNumber, string": function(f, l, c) {
      return s(f, l.toNumber(), f.size(), c);
    }
  });
  function s(u, f, l, c) {
    if (!Xe(f))
      throw new TypeError("Second parameter in function diag must be an integer");
    var h = f > 0 ? f : 0, d = f < 0 ? -f : 0;
    switch (l.length) {
      case 1:
        return o(u, f, c, l[0], d, h);
      case 2:
        return p(u, f, c, l, d, h);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function o(u, f, l, c, h, d) {
    var g = [c + h, c + d];
    if (l && l !== "sparse" && l !== "dense")
      throw new TypeError("Unknown matrix type ".concat(l, '"'));
    var v = l === "sparse" ? a.diagonal(g, u, f) : n.diagonal(g, u, f);
    return l !== null ? v : v.valueOf();
  }
  function p(u, f, l, c, h, d) {
    if (tt(u)) {
      var g = u.diagonal(f);
      return l !== null ? l !== g.storage() ? r(g, l) : g : g.valueOf();
    }
    for (var v = Math.min(c[0] - h, c[1] - d), N = [], b = 0; b < v; b++)
      N[b] = u[b + h][b + d];
    return l !== null ? r(N) : N;
  }
});
function es(t, e, r, n, a) {
  if (ea.isTypedFunction(t)) {
    var s = [e, r, n], o = ea.resolve(t, s);
    if (o)
      return c(o.implementation, s);
    var p = [e, r], u = ea.resolve(t, p);
    if (u)
      return c(u.implementation, p);
    var f = [e], l = ea.resolve(t, f);
    return l ? c(l.implementation, f) : c(t, s);
  } else
    return t(e, r, n);
  function c(h, d) {
    try {
      return h.apply(h, d);
    } catch (N) {
      var g;
      if (N instanceof TypeError && ((g = N.data) === null || g === void 0 ? void 0 : g.category) === "wrongType") {
        var v = [];
        throw v.push("value: ".concat(Vt(e))), d.length >= 2 && v.push("index: ".concat(Vt(r))), d.length >= 3 && v.push("array: ".concat(Vt(n))), new TypeError("Function ".concat(a, " cannot apply callback arguments ") + "".concat(t.name, "(").concat(v.join(", "), ") at index ").concat(JSON.stringify(r)));
      } else
        throw new TypeError("Function ".concat(a, " cannot apply callback arguments ") + "to function ".concat(t.name, ": ").concat(N.message));
    }
  }
}
var lM = "filter", cM = ["typed"], j0 = /* @__PURE__ */ j(lM, cM, (t) => {
  var {
    typed: e
  } = t;
  return e("filter", {
    "Array, function": uy,
    "Matrix, function": function(n, a) {
      return n.create(uy(n.toArray(), a));
    },
    "Array, RegExp": iu,
    "Matrix, RegExp": function(n, a) {
      return n.create(iu(n.toArray(), a));
    }
  });
});
function uy(t, e) {
  return W2(t, function(r, n, a) {
    return es(e, r, [n], a, "filter");
  });
}
var ly = "flatten", fM = ["typed", "matrix"], Z0 = /* @__PURE__ */ j(ly, fM, (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return e(ly, {
    Array: function(a) {
      return Lt(a);
    },
    Matrix: function(a) {
      var s = Lt(a.toArray());
      return r(s);
    }
  });
}), cy = "forEach", pM = ["typed"], J0 = /* @__PURE__ */ j(cy, pM, (t) => {
  var {
    typed: e
  } = t;
  return e(cy, {
    "Array, function": hM,
    "Matrix, function": function(n, a) {
      n.forEach(a);
    }
  });
});
function hM(t, e) {
  var r = function n(a, s) {
    if (Array.isArray(a))
      Pu(a, function(o, p) {
        n(o, s.concat(p));
      });
    else
      return es(e, a, s, t, "forEach");
  };
  r(t, []);
}
var fy = "getMatrixDataType", mM = ["typed"], Y0 = /* @__PURE__ */ j(fy, mM, (t) => {
  var {
    typed: e
  } = t;
  return e(fy, {
    Array: function(n) {
      return qs(n, Vt);
    },
    Matrix: function(n) {
      return n.getDataType();
    }
  });
}), py = "identity", dM = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"], X0 = /* @__PURE__ */ j(py, dM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: a,
    DenseMatrix: s,
    SparseMatrix: o
  } = t;
  return e(py, {
    "": function() {
      return r.matrix === "Matrix" ? n([]) : [];
    },
    string: function(l) {
      return n(l);
    },
    "number | BigNumber": function(l) {
      return u(l, l, r.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function(l, c) {
      return u(l, l, c);
    },
    "number | BigNumber, number | BigNumber": function(l, c) {
      return u(l, c, r.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function(l, c, h) {
      return u(l, c, h);
    },
    Array: function(l) {
      return p(l);
    },
    "Array, string": function(l, c) {
      return p(l, c);
    },
    Matrix: function(l) {
      return p(l.valueOf(), l.storage());
    },
    "Matrix, string": function(l, c) {
      return p(l.valueOf(), c);
    }
  });
  function p(f, l) {
    switch (f.length) {
      case 0:
        return l ? n(l) : [];
      case 1:
        return u(f[0], f[0], l);
      case 2:
        return u(f[0], f[1], l);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function u(f, l, c) {
    var h = ct(f) || ct(l) ? a : null;
    if (ct(f) && (f = f.toNumber()), ct(l) && (l = l.toNumber()), !Xe(f) || f < 1)
      throw new Error("Parameters in function identity must be positive integers");
    if (!Xe(l) || l < 1)
      throw new Error("Parameters in function identity must be positive integers");
    var d = h ? new a(1) : 1, g = h ? new h(0) : 0, v = [f, l];
    if (c) {
      if (c === "sparse")
        return o.diagonal(v, d, 0, g);
      if (c === "dense")
        return s.diagonal(v, d, 0, g);
      throw new TypeError('Unknown matrix type "'.concat(c, '"'));
    }
    for (var N = $a([], v, g), b = f < l ? f : l, C = 0; C < b; C++)
      N[C][C] = d;
    return N;
  }
}), hy = "kron", vM = ["typed", "matrix", "multiplyScalar"], K0 = /* @__PURE__ */ j(hy, vM, (t) => {
  var {
    typed: e,
    matrix: r,
    multiplyScalar: n
  } = t;
  return e(hy, {
    "Matrix, Matrix": function(o, p) {
      return r(a(o.toArray(), p.toArray()));
    },
    "Matrix, Array": function(o, p) {
      return r(a(o.toArray(), p));
    },
    "Array, Matrix": function(o, p) {
      return r(a(o, p.toArray()));
    },
    "Array, Array": a
  });
  function a(s, o) {
    if (gt(s).length === 1 && (s = [s]), gt(o).length === 1 && (o = [o]), gt(s).length > 2 || gt(o).length > 2)
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(s.length) + ", y = " + JSON.stringify(o.length) + ")");
    var p = [], u = [];
    return s.map(function(f) {
      return o.map(function(l) {
        return u = [], p.push(u), f.map(function(c) {
          return l.map(function(h) {
            return u.push(n(c, h));
          });
        });
      });
    }) && p;
  }
}), my = "map", gM = ["typed"], tl = /* @__PURE__ */ j(my, gM, (t) => {
  var {
    typed: e
  } = t;
  return e(my, {
    "Array, function": yM,
    "Matrix, function": function(n, a) {
      return n.map(a);
    }
  });
});
function yM(t, e) {
  var r = function n(a, s) {
    return Array.isArray(a) ? a.map(function(o, p) {
      return n(o, s.concat(p));
    }) : es(e, a, s, t, "map");
  };
  return r(t, []);
}
var dy = "diff", xM = ["typed", "matrix", "subtract", "number"], Js = /* @__PURE__ */ j(dy, xM, (t) => {
  var {
    typed: e,
    matrix: r,
    subtract: n,
    number: a
  } = t;
  return e(dy, {
    "Array | Matrix": function(l) {
      return tt(l) ? r(o(l.toArray())) : o(l);
    },
    "Array | Matrix, number": function(l, c) {
      if (!Xe(c)) throw new RangeError("Dimension must be a whole number");
      return tt(l) ? r(s(l.toArray(), c)) : s(l, c);
    },
    "Array, BigNumber": e.referTo("Array,number", (f) => (l, c) => f(l, a(c))),
    "Matrix, BigNumber": e.referTo("Matrix,number", (f) => (l, c) => f(l, a(c)))
  });
  function s(f, l) {
    if (tt(f) && (f = f.toArray()), !Array.isArray(f))
      throw RangeError("Array/Matrix does not have that many dimensions");
    if (l > 0) {
      var c = [];
      return f.forEach((h) => {
        c.push(s(h, l - 1));
      }), c;
    } else {
      if (l === 0)
        return o(f);
      throw RangeError("Cannot have negative dimension");
    }
  }
  function o(f) {
    for (var l = [], c = f.length, h = 1; h < c; h++)
      l.push(p(f[h - 1], f[h]));
    return l;
  }
  function p(f, l) {
    tt(f) && (f = f.toArray()), tt(l) && (l = l.toArray());
    var c = Array.isArray(f), h = Array.isArray(l);
    if (c && h)
      return u(f, l);
    if (!c && !h)
      return n(l, f);
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function u(f, l) {
    if (f.length !== l.length)
      throw RangeError("Not all sub-arrays have the same length");
    for (var c = [], h = f.length, d = 0; d < h; d++)
      c.push(p(f[d], l[d]));
    return c;
  }
}), bM = "ones", wM = ["typed", "config", "matrix", "BigNumber"], rl = /* @__PURE__ */ j(bM, wM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: a
  } = t;
  return e("ones", {
    "": function() {
      return r.matrix === "Array" ? s([]) : s([], "default");
    },
    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function(f) {
      var l = f[f.length - 1];
      if (typeof l == "string") {
        var c = f.pop();
        return s(f, c);
      } else return r.matrix === "Array" ? s(f) : s(f, "default");
    },
    Array: s,
    Matrix: function(f) {
      var l = f.storage();
      return s(f.valueOf(), l);
    },
    "Array | Matrix, string": function(f, l) {
      return s(f.valueOf(), l);
    }
  });
  function s(u, f) {
    var l = o(u), c = l ? new a(1) : 1;
    if (p(u), f) {
      var h = n(f);
      return u.length > 0 ? h.resize(u, c) : h;
    } else {
      var d = [];
      return u.length > 0 ? $a(d, u, c) : d;
    }
  }
  function o(u) {
    var f = !1;
    return u.forEach(function(l, c, h) {
      ct(l) && (f = !0, h[c] = l.toNumber());
    }), f;
  }
  function p(u) {
    u.forEach(function(f) {
      if (typeof f != "number" || !Xe(f) || f < 0)
        throw new Error("Parameters in function ones must be positive integers");
    });
  }
});
function Od() {
  throw new Error('No "bignumber" implementation available');
}
function Hw() {
  throw new Error('No "fraction" implementation available');
}
function Qw() {
  throw new Error('No "matrix" implementation available');
}
var vy = "range", NM = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"], Ys = /* @__PURE__ */ j(vy, NM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    bignumber: a,
    smaller: s,
    smallerEq: o,
    larger: p,
    largerEq: u,
    add: f,
    isPositive: l
  } = t;
  return e(vy, {
    // TODO: simplify signatures when typed-function supports default values and optional arguments
    // TODO: a number or boolean should not be converted to string here
    string: h,
    "string, boolean": h,
    "number, number": function(N, b) {
      return c(d(N, b, 1, !1));
    },
    "number, number, number": function(N, b, C) {
      return c(d(N, b, C, !1));
    },
    "number, number, boolean": function(N, b, C) {
      return c(d(N, b, 1, C));
    },
    "number, number, number, boolean": function(N, b, C, x) {
      return c(d(N, b, C, x));
    },
    "BigNumber, BigNumber": function(N, b) {
      var C = N.constructor;
      return c(d(N, b, new C(1), !1));
    },
    "BigNumber, BigNumber, BigNumber": function(N, b, C) {
      return c(d(N, b, C, !1));
    },
    "BigNumber, BigNumber, boolean": function(N, b, C) {
      var x = N.constructor;
      return c(d(N, b, new x(1), C));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function(N, b, C, x) {
      return c(d(N, b, C, x));
    },
    "Unit, Unit, Unit": function(N, b, C) {
      return c(d(N, b, C, !1));
    },
    "Unit, Unit, Unit, boolean": function(N, b, C, x) {
      return c(d(N, b, C, x));
    }
  });
  function c(v) {
    return r.matrix === "Matrix" ? n ? n(v) : Qw() : v;
  }
  function h(v, N) {
    var b = g(v);
    if (!b)
      throw new SyntaxError('String "' + v + '" is no valid range');
    return r.number === "BigNumber" ? (a === void 0 && Od(), c(d(a(b.start), a(b.end), a(b.step)))) : c(d(b.start, b.end, b.step, N));
  }
  function d(v, N, b, C) {
    for (var x = [], E = l(b) ? C ? o : s : C ? u : p, D = v; E(D, N); )
      x.push(D), D = f(D, b);
    return x;
  }
  function g(v) {
    var N = v.split(":"), b = N.map(function(x) {
      return Number(x);
    }), C = b.some(function(x) {
      return isNaN(x);
    });
    if (C)
      return null;
    switch (b.length) {
      case 2:
        return {
          start: b[0],
          end: b[1],
          step: 1
        };
      case 3:
        return {
          start: b[0],
          end: b[2],
          step: b[1]
        };
      default:
        return null;
    }
  }
}), gy = "reshape", DM = ["typed", "isInteger", "matrix"], nl = /* @__PURE__ */ j(gy, DM, (t) => {
  var {
    typed: e,
    isInteger: r
  } = t;
  return e(gy, {
    "Matrix, Array": function(a, s) {
      return a.reshape(s, !0);
    },
    "Array, Array": function(a, s) {
      return s.forEach(function(o) {
        if (!r(o))
          throw new TypeError("Invalid size for dimension: " + o);
      }), Ed(a, s);
    }
  });
}), AM = "resize", EM = ["config", "matrix"], il = /* @__PURE__ */ j(AM, EM, (t) => {
  var {
    config: e,
    matrix: r
  } = t;
  return function(s, o, p) {
    if (arguments.length !== 2 && arguments.length !== 3)
      throw new Zn("resize", arguments.length, 2, 3);
    if (tt(o) && (o = o.valueOf()), ct(o[0]) && (o = o.map(function(l) {
      return ct(l) ? l.toNumber() : l;
    })), tt(s))
      return s.resize(o, p, !0);
    if (typeof s == "string")
      return n(s, o, p);
    var u = Array.isArray(s) ? !1 : e.matrix !== "Array";
    if (o.length === 0) {
      for (; Array.isArray(s); )
        s = s[0];
      return nt(s);
    } else {
      Array.isArray(s) || (s = [s]), s = nt(s);
      var f = $a(s, o, p);
      return u ? r(f) : f;
    }
  };
  function n(a, s, o) {
    if (o !== void 0) {
      if (typeof o != "string" || o.length !== 1)
        throw new TypeError("Single character expected as defaultValue");
    } else
      o = " ";
    if (s.length !== 1)
      throw new xt(s.length, 1);
    var p = s[0];
    if (typeof p != "number" || !Xe(p))
      throw new TypeError("Invalid size, must contain positive integers (size: " + Dt(s) + ")");
    if (a.length > p)
      return a.substring(0, p);
    if (a.length < p) {
      for (var u = a, f = 0, l = p - a.length; f < l; f++)
        u += o;
      return u;
    } else
      return a;
  }
}), yy = "rotate", SM = ["typed", "multiply", "rotationMatrix"], al = /* @__PURE__ */ j(yy, SM, (t) => {
  var {
    typed: e,
    multiply: r,
    rotationMatrix: n
  } = t;
  return e(yy, {
    "Array , number | BigNumber | Complex | Unit": function(o, p) {
      a(o, 2);
      var u = r(n(p), o);
      return u.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function(o, p) {
      return a(o, 2), r(n(p), o);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function(o, p, u) {
      a(o, 3);
      var f = r(n(p, u), o);
      return f;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function(o, p, u) {
      return a(o, 3), r(n(p, u), o);
    }
  });
  function a(s, o) {
    var p = Array.isArray(s) ? gt(s) : s.size();
    if (p.length > 2)
      throw new RangeError("Vector must be of dimensions 1x".concat(o));
    if (p.length === 2 && p[1] !== 1)
      throw new RangeError("Vector must be of dimensions 1x".concat(o));
    if (p[0] !== o)
      throw new RangeError("Vector must be of dimensions 1x".concat(o));
  }
}), xy = "rotationMatrix", CM = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"], sl = /* @__PURE__ */ j(xy, CM, (t) => {
  var {
    typed: e,
    config: r,
    multiplyScalar: n,
    addScalar: a,
    unaryMinus: s,
    norm: o,
    BigNumber: p,
    matrix: u,
    DenseMatrix: f,
    SparseMatrix: l,
    cos: c,
    sin: h
  } = t;
  return e(xy, {
    "": function() {
      return r.matrix === "Matrix" ? u([]) : [];
    },
    string: function(x) {
      return u(x);
    },
    "number | BigNumber | Complex | Unit": function(x) {
      return d(x, r.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function(x, E) {
      return d(x, E);
    },
    "number | BigNumber | Complex | Unit, Array": function(x, E) {
      var D = u(E);
      return g(D), b(x, D, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function(x, E) {
      g(E);
      var D = E.storage() || (r.matrix === "Matrix" ? "dense" : void 0);
      return b(x, E, D);
    },
    "number | BigNumber | Complex | Unit, Array, string": function(x, E, D) {
      var A = u(E);
      return g(A), b(x, A, D);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function(x, E, D) {
      return g(E), b(x, E, D);
    }
  });
  function d(C, x) {
    var E = ct(C), D = E ? new p(-1) : -1, A = c(C), M = h(C), _ = [[A, n(D, M)], [M, A]];
    return N(_, x);
  }
  function g(C) {
    var x = C.size();
    if (x.length < 1 || x[0] !== 3)
      throw new RangeError("Vector must be of dimensions 1x3");
  }
  function v(C) {
    return C.reduce((x, E) => n(x, E));
  }
  function N(C, x) {
    if (x) {
      if (x === "sparse")
        return new l(C);
      if (x === "dense")
        return new f(C);
      throw new TypeError('Unknown matrix type "'.concat(x, '"'));
    }
    return C;
  }
  function b(C, x, E) {
    var D = o(x);
    if (D === 0)
      throw new RangeError("Rotation around zero vector");
    var A = ct(C) ? p : null, M = A ? new A(1) : 1, _ = A ? new A(-1) : -1, O = A ? new A(x.get([0]) / D) : x.get([0]) / D, T = A ? new A(x.get([1]) / D) : x.get([1]) / D, I = A ? new A(x.get([2]) / D) : x.get([2]) / D, q = c(C), $ = a(M, s(q)), U = h(C), k = a(q, v([O, O, $])), L = a(v([O, T, $]), v([_, I, U])), R = a(v([O, I, $]), v([T, U])), G = a(v([O, T, $]), v([I, U])), P = a(q, v([T, T, $])), W = a(v([T, I, $]), v([_, O, U])), le = a(v([O, I, $]), v([_, T, U])), Z = a(v([T, I, $]), v([O, U])), H = a(q, v([I, I, $])), te = [[k, L, R], [G, P, W], [le, Z, H]];
    return N(te, E);
  }
}), by = "row", TM = ["typed", "Index", "matrix", "range"], Xs = /* @__PURE__ */ j(by, TM, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: a
  } = t;
  return e(by, {
    "Matrix, number": s,
    "Array, number": function(p, u) {
      return s(n(nt(p)), u).valueOf();
    }
  });
  function s(o, p) {
    if (o.size().length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    Ht(p, o.size()[0]);
    var u = a(0, o.size()[1]), f = new r(p, u), l = o.subset(f);
    return tt(l) ? l : n([[l]]);
  }
}), wy = "size", _M = ["typed", "config", "?matrix"], ol = /* @__PURE__ */ j(wy, _M, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n
  } = t;
  return e(wy, {
    Matrix: function(s) {
      return s.create(s.size());
    },
    Array: gt,
    string: function(s) {
      return r.matrix === "Array" ? [s.length] : n([s.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function(s) {
      return r.matrix === "Array" ? [] : n ? n([]) : Qw();
    }
  });
}), Ny = "squeeze", MM = ["typed", "matrix"], ul = /* @__PURE__ */ j(Ny, MM, (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return e(Ny, {
    Array: function(a) {
      return nu(nt(a));
    },
    Matrix: function(a) {
      var s = nu(a.toArray());
      return Array.isArray(s) ? r(s) : s;
    },
    any: function(a) {
      return nt(a);
    }
  });
}), Dy = "subset", OM = ["typed", "matrix", "zeros", "add"], Ks = /* @__PURE__ */ j(Dy, OM, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    add: a
  } = t;
  return e(Dy, {
    // get subset
    "Matrix, Index": function(p, u) {
      return ka(u) ? r() : (ru(p, u), p.subset(u));
    },
    "Array, Index": e.referTo("Matrix, Index", function(o) {
      return function(p, u) {
        var f = o(r(p), u);
        return u.isScalar() ? f : f.valueOf();
      };
    }),
    "Object, Index": qM,
    "string, Index": FM,
    // set subset
    "Matrix, Index, any, any": function(p, u, f, l) {
      return ka(u) ? p : (ru(p, u), p.clone().subset(u, s(f, u), l));
    },
    "Array, Index, any, any": e.referTo("Matrix, Index, any, any", function(o) {
      return function(p, u, f, l) {
        var c = o(r(p), u, f, l);
        return c.isMatrix ? c.valueOf() : c;
      };
    }),
    "Array, Index, any": e.referTo("Matrix, Index, any, any", function(o) {
      return function(p, u, f) {
        return o(r(p), u, f, void 0).valueOf();
      };
    }),
    "Matrix, Index, any": e.referTo("Matrix, Index, any, any", function(o) {
      return function(p, u, f) {
        return o(p, u, f, void 0);
      };
    }),
    "string, Index, string": Ay,
    "string, Index, string, string": Ay,
    "Object, Index, any": IM
  });
  function s(o, p) {
    if (typeof o == "string")
      throw new Error("can't boradcast a string");
    if (p._isScalar)
      return o;
    var u = p.size();
    if (u.every((f) => f > 0))
      try {
        return a(o, n(u));
      } catch {
        return o;
      }
    else
      return o;
  }
});
function FM(t, e) {
  if (!Va(e))
    throw new TypeError("Index expected");
  if (ka(e))
    return "";
  if (ru(Array.from(t), e), e.size().length !== 1)
    throw new xt(e.size().length, 1);
  var r = t.length;
  Ht(e.min()[0], r), Ht(e.max()[0], r);
  var n = e.dimension(0), a = "";
  return n.forEach(function(s) {
    a += t.charAt(s);
  }), a;
}
function Ay(t, e, r, n) {
  if (!e || e.isIndex !== !0)
    throw new TypeError("Index expected");
  if (ka(e))
    return t;
  if (ru(Array.from(t), e), e.size().length !== 1)
    throw new xt(e.size().length, 1);
  if (n !== void 0) {
    if (typeof n != "string" || n.length !== 1)
      throw new TypeError("Single character expected as defaultValue");
  } else
    n = " ";
  var a = e.dimension(0), s = a.size()[0];
  if (s !== r.length)
    throw new xt(a.size()[0], r.length);
  var o = t.length;
  Ht(e.min()[0]), Ht(e.max()[0]);
  for (var p = [], u = 0; u < o; u++)
    p[u] = t.charAt(u);
  if (a.forEach(function(c, h) {
    p[c] = r.charAt(h[0]);
  }), p.length > o)
    for (var f = o - 1, l = p.length; f < l; f++)
      p[f] || (p[f] = n);
  return p.join("");
}
function qM(t, e) {
  if (!ka(e)) {
    if (e.size().length !== 1)
      throw new xt(e.size(), 1);
    var r = e.dimension(0);
    if (typeof r != "string")
      throw new TypeError("String expected as index to retrieve an object property");
    return Kr(t, r);
  }
}
function IM(t, e, r) {
  if (ka(e))
    return t;
  if (e.size().length !== 1)
    throw new xt(e.size(), 1);
  var n = e.dimension(0);
  if (typeof n != "string")
    throw new TypeError("String expected as index to retrieve an object property");
  var a = nt(t);
  return La(a, n, r), a;
}
var Ey = "transpose", BM = ["typed", "matrix"], ll = /* @__PURE__ */ j(Ey, BM, (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return e(Ey, {
    Array: (o) => n(r(o)).valueOf(),
    Matrix: n,
    any: nt
    // scalars
  });
  function n(o) {
    var p = o.size(), u;
    switch (p.length) {
      case 1:
        u = o.clone();
        break;
      case 2:
        {
          var f = p[0], l = p[1];
          if (l === 0)
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + Dt(p) + ")");
          switch (o.storage()) {
            case "dense":
              u = a(o, f, l);
              break;
            case "sparse":
              u = s(o, f, l);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + Dt(p) + ")");
    }
    return u;
  }
  function a(o, p, u) {
    for (var f = o._data, l = [], c, h = 0; h < u; h++) {
      c = l[h] = [];
      for (var d = 0; d < p; d++)
        c[d] = nt(f[d][h]);
    }
    return o.createDenseMatrix({
      data: l,
      size: [u, p],
      datatype: o._datatype
    });
  }
  function s(o, p, u) {
    for (var f = o._values, l = o._index, c = o._ptr, h = f ? [] : void 0, d = [], g = [], v = [], N = 0; N < p; N++)
      v[N] = 0;
    var b, C, x;
    for (b = 0, C = l.length; b < C; b++)
      v[l[b]]++;
    for (var E = 0, D = 0; D < p; D++)
      g.push(E), E += v[D], v[D] = g[D];
    for (g.push(E), x = 0; x < u; x++)
      for (var A = c[x], M = c[x + 1], _ = A; _ < M; _++) {
        var O = v[l[_]]++;
        d[O] = x, f && (h[O] = nt(f[_]));
      }
    return o.createSparseMatrix({
      values: h,
      index: d,
      ptr: g,
      size: [u, p],
      datatype: o._datatype
    });
  }
}), Sy = "ctranspose", RM = ["typed", "transpose", "conj"], cl = /* @__PURE__ */ j(Sy, RM, (t) => {
  var {
    typed: e,
    transpose: r,
    conj: n
  } = t;
  return e(Sy, {
    any: function(s) {
      return n(r(s));
    }
  });
}), Cy = "zeros", LM = ["typed", "config", "matrix", "BigNumber"], fl = /* @__PURE__ */ j(Cy, LM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: a
  } = t;
  return e(Cy, {
    "": function() {
      return r.matrix === "Array" ? s([]) : s([], "default");
    },
    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function(f) {
      var l = f[f.length - 1];
      if (typeof l == "string") {
        var c = f.pop();
        return s(f, c);
      } else return r.matrix === "Array" ? s(f) : s(f, "default");
    },
    Array: s,
    Matrix: function(f) {
      var l = f.storage();
      return s(f.valueOf(), l);
    },
    "Array | Matrix, string": function(f, l) {
      return s(f.valueOf(), l);
    }
  });
  function s(u, f) {
    var l = o(u), c = l ? new a(0) : 0;
    if (p(u), f) {
      var h = n(f);
      return u.length > 0 ? h.resize(u, c) : h;
    } else {
      var d = [];
      return u.length > 0 ? $a(d, u, c) : d;
    }
  }
  function o(u) {
    var f = !1;
    return u.forEach(function(l, c, h) {
      ct(l) && (f = !0, h[c] = l.toNumber());
    }), f;
  }
  function p(u) {
    u.forEach(function(f) {
      if (typeof f != "number" || !Xe(f) || f < 0)
        throw new Error("Parameters in function zeros must be positive integers");
    });
  }
}), Ty = "fft", PM = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"], pl = /* @__PURE__ */ j(Ty, PM, (t) => {
  var {
    typed: e,
    matrix: r,
    addScalar: n,
    multiplyScalar: a,
    divideScalar: s,
    exp: o,
    tau: p,
    i: u,
    dotDivide: f,
    conj: l,
    pow: c,
    ceil: h,
    log2: d
  } = t;
  return e(Ty, {
    Array: g,
    Matrix: function(x) {
      return x.create(g(x.toArray()));
    }
  });
  function g(C) {
    var x = gt(C);
    return x.length === 1 ? b(C, x[0]) : v(C.map((E) => g(E, x.slice(1))), 0);
  }
  function v(C, x) {
    var E = gt(C);
    if (x !== 0) return new Array(E[0]).fill(0).map((A, M) => v(C[M], x - 1));
    if (E.length === 1) return b(C);
    function D(A) {
      var M = gt(A);
      return new Array(M[1]).fill(0).map((_, O) => new Array(M[0]).fill(0).map((T, I) => A[I][O]));
    }
    return D(v(D(C), 1));
  }
  function N(C) {
    for (var x = C.length, E = o(s(a(-1, a(u, p)), x)), D = [], A = 1 - x; A < x; A++)
      D.push(c(E, s(c(A, 2), 2)));
    for (var M = c(2, h(d(x + x - 1))), _ = [...new Array(x).fill(0).map((L, R) => a(C[R], D[x - 1 + R])), ...new Array(M - x).fill(0)], O = [...new Array(x + x - 1).fill(0).map((L, R) => s(1, D[R])), ...new Array(M - (x + x - 1)).fill(0)], T = b(_), I = b(O), q = new Array(M).fill(0).map((L, R) => a(T[R], I[R])), $ = f(l(g(l(q))), M), U = [], k = x - 1; k < x + x - 1; k++)
      U.push(a($[k], D[k]));
    return U;
  }
  function b(C) {
    var x = C.length;
    if (x === 1) return [C[0]];
    if (x % 2 === 0) {
      for (var E = [...b(C.filter((_, O) => O % 2 === 0)), ...b(C.filter((_, O) => O % 2 === 1))], D = 0; D < x / 2; D++) {
        var A = E[D], M = a(E[D + x / 2], o(a(a(p, u), s(-D, x))));
        E[D] = n(A, M), E[D + x / 2] = n(A, a(-1, M));
      }
      return E;
    } else
      return N(C);
  }
}), _y = "ifft", kM = ["typed", "fft", "dotDivide", "conj"], hl = /* @__PURE__ */ j(_y, kM, (t) => {
  var {
    typed: e,
    fft: r,
    dotDivide: n,
    conj: a
  } = t;
  return e(_y, {
    "Array | Matrix": function(o) {
      var p = tt(o) ? o.size() : gt(o);
      return n(a(r(a(o))), p.reduce((u, f) => u * f, 1));
    }
  });
});
function Bs(t) {
  "@babel/helpers - typeof";
  return Bs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Bs(t);
}
function $M(t, e) {
  if (Bs(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (Bs(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function zM(t) {
  var e = $M(t, "string");
  return Bs(e) == "symbol" ? e : e + "";
}
function xr(t, e, r) {
  return (e = zM(e)) in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function My(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function UM(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? My(Object(r), !0).forEach(function(n) {
      xr(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : My(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var GM = "solveODE", HM = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"], ml = /* @__PURE__ */ j(GM, HM, (t) => {
  var {
    typed: e,
    add: r,
    subtract: n,
    multiply: a,
    divide: s,
    max: o,
    map: p,
    abs: u,
    isPositive: f,
    isNegative: l,
    larger: c,
    smaller: h,
    matrix: d,
    bignumber: g,
    unaryMinus: v
  } = t;
  function N(_) {
    return function(O, T, I, q) {
      var $ = !(T.length === 2 && (T.every(A) || T.every(Xr)));
      if ($)
        throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
      var U = T[0], k = T[1], L = c(k, U), R = q.firstStep;
      if (R !== void 0 && !f(R))
        throw new Error('"firstStep" must be positive');
      var G = q.maxStep;
      if (G !== void 0 && !f(G))
        throw new Error('"maxStep" must be positive');
      var P = q.minStep;
      if (P && l(P))
        throw new Error('"minStep" must be positive or zero');
      var W = [U, k, R, P, G].filter((Q) => Q !== void 0);
      if (!(W.every(A) || W.every(Xr)))
        throw new Error('Inconsistent type of "t" dependant variables');
      for (var le = 1, Z = q.tol ? q.tol : 1e-4, H = q.minDelta ? q.minDelta : 0.2, te = q.maxDelta ? q.maxDelta : 5, be = q.maxIter ? q.maxIter : 1e4, K = [U, k, ...I, G, P].some(ct), [ce, de, ue, ve] = K ? [g(_.a), g(_.c), g(_.b), g(_.bp)] : [_.a, _.c, _.b, _.bp], he = R ? L ? R : v(R) : s(n(k, U), le), Ne = [U], we = [I], Se = n(ue, ve), V = 0, re = 0, pe = E(L), X = D(L); pe(Ne[V], k); ) {
        var ie = [];
        he = X(Ne[V], k, he), ie.push(O(Ne[V], we[V]));
        for (var me = 1; me < de.length; ++me)
          ie.push(O(r(Ne[V], a(de[me], he)), r(we[V], a(he, ce[me], ie))));
        var Ae = o(u(p(a(Se, ie), (Q) => Xr(Q) ? Q.value : Q)));
        Ae < Z && Z / Ae > 1 / 4 && (Ne.push(r(Ne[V], he)), we.push(r(we[V], a(he, ue, ie))), V++);
        var Me = 0.84 * (Z / Ae) ** (1 / 5);
        if (h(Me, H) ? Me = H : c(Me, te) && (Me = te), Me = K ? g(Me) : Me, he = a(he, Me), G && c(u(he), G) ? he = L ? G : v(G) : P && h(u(he), P) && (he = L ? P : v(P)), re++, re > be)
          throw new Error("Maximum number of iterations reached, try changing options");
      }
      return {
        t: Ne,
        y: we
      };
    };
  }
  function b(_, O, T, I) {
    var q = [[], [0.5], [0, 0.75], [0.2222222222222222, 0.3333333333333333, 0.4444444444444444]], $ = [null, 1 / 2, 3 / 4, 1], U = [2 / 9, 1 / 3, 4 / 9, 0], k = [7 / 24, 1 / 4, 1 / 3, 1 / 8], L = {
      a: q,
      c: $,
      b: U,
      bp: k
    };
    return N(L)(_, O, T, I);
  }
  function C(_, O, T, I) {
    var q = [[], [0.2], [0.075, 0.225], [0.9777777777777777, -3.7333333333333334, 3.5555555555555554], [2.9525986892242035, -11.595793324188385, 9.822892851699436, -0.2908093278463649], [2.8462752525252526, -10.757575757575758, 8.906422717743473, 0.2784090909090909, -0.2735313036020583], [0.09114583333333333, 0, 0.44923629829290207, 0.6510416666666666, -0.322376179245283, 0.13095238095238096]], $ = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1], U = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0], k = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40], L = {
      a: q,
      c: $,
      b: U,
      bp: k
    };
    return N(L)(_, O, T, I);
  }
  function x(_, O, T, I) {
    var q = I.method ? I.method : "RK45", $ = {
      RK23: b,
      RK45: C
    };
    if (q.toUpperCase() in $) {
      var U = UM({}, I);
      return delete U.method, $[q.toUpperCase()](_, O, T, U);
    } else {
      var k = Object.keys($).map((R) => '"'.concat(R, '"')), L = "".concat(k.slice(0, -1).join(", "), " and ").concat(k.slice(-1));
      throw new Error('Unavailable method "'.concat(q, '". Available methods are ').concat(L));
    }
  }
  function E(_) {
    return _ ? h : c;
  }
  function D(_) {
    var O = _ ? c : h;
    return function(T, I, q) {
      var $ = r(T, q);
      return O($, I) ? n(I, T) : q;
    };
  }
  function A(_) {
    return ct(_) || ht(_);
  }
  function M(_, O, T, I) {
    var q = x(_, O.toArray(), T.toArray(), I);
    return {
      t: d(q.t),
      y: d(q.y)
    };
  }
  return e("solveODE", {
    "function, Array, Array, Object": x,
    "function, Matrix, Matrix, Object": M,
    "function, Array, Array": (_, O, T) => x(_, O, T, {}),
    "function, Matrix, Matrix": (_, O, T) => M(_, O, T, {}),
    "function, Array, number | BigNumber | Unit": (_, O, T) => {
      var I = x(_, O, [T], {});
      return {
        t: I.t,
        y: I.y.map((q) => q[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit": (_, O, T) => {
      var I = x(_, O.toArray(), [T], {});
      return {
        t: d(I.t),
        y: d(I.y.map((q) => q[0]))
      };
    },
    "function, Array, number | BigNumber | Unit, Object": (_, O, T, I) => {
      var q = x(_, O, [T], I);
      return {
        t: q.t,
        y: q.y.map(($) => $[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit, Object": (_, O, T, I) => {
      var q = x(_, O.toArray(), [T], I);
      return {
        t: d(q.t),
        y: d(q.y.map(($) => $[0]))
      };
    }
  });
}), QM = "erf", VM = ["typed"], dl = /* @__PURE__ */ j(QM, VM, (t) => {
  var {
    typed: e
  } = t;
  return e("name", {
    number: function(o) {
      var p = Math.abs(o);
      return p >= ZM ? Ci(o) : p <= WM ? Ci(o) * r(p) : p <= 4 ? Ci(o) * (1 - n(p)) : Ci(o) * (1 - a(p));
    },
    "Array | Matrix": e.referToSelf((s) => (o) => Nt(o, s))
    // TODO: For complex numbers, use the approximation for the Faddeeva function
    //  from "More Efficient Computation of the Complex Error Function" (AMS)
  });
  function r(s) {
    var o = s * s, p = si[0][4] * o, u = o, f;
    for (f = 0; f < 3; f += 1)
      p = (p + si[0][f]) * o, u = (u + Ca[0][f]) * o;
    return s * (p + si[0][3]) / (u + Ca[0][3]);
  }
  function n(s) {
    var o = si[1][8] * s, p = s, u;
    for (u = 0; u < 7; u += 1)
      o = (o + si[1][u]) * s, p = (p + Ca[1][u]) * s;
    var f = (o + si[1][7]) / (p + Ca[1][7]), l = parseInt(s * 16) / 16, c = (s - l) * (s + l);
    return Math.exp(-l * l) * Math.exp(-c) * f;
  }
  function a(s) {
    var o = 1 / (s * s), p = si[2][5] * o, u = o, f;
    for (f = 0; f < 4; f += 1)
      p = (p + si[2][f]) * o, u = (u + Ca[2][f]) * o;
    var l = o * (p + si[2][4]) / (u + Ca[2][4]);
    l = (jM - l) / s, o = parseInt(s * 16) / 16;
    var c = (s - o) * (s + o);
    return Math.exp(-o * o) * Math.exp(-c) * l;
  }
}), WM = 0.46875, jM = 0.5641895835477563, si = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]], Ca = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]], ZM = Math.pow(2, 53), Oy = "zeta", JM = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"], vl = /* @__PURE__ */ j(Oy, JM, (t) => {
  var {
    typed: e,
    config: r,
    multiply: n,
    pow: a,
    divide: s,
    factorial: o,
    equal: p,
    smallerEq: u,
    isNegative: f,
    gamma: l,
    sin: c,
    subtract: h,
    add: d,
    Complex: g,
    BigNumber: v,
    pi: N
  } = t;
  return e(Oy, {
    number: (A) => b(A, (M) => M, () => 20),
    BigNumber: (A) => b(A, (M) => new v(M), () => Math.abs(Math.log10(r.relTol))),
    Complex: C
  });
  function b(A, M, _) {
    return p(A, 0) ? M(-0.5) : p(A, 1) ? M(NaN) : isFinite(A) ? x(A, M, _, (O) => O) : f(A) ? M(NaN) : M(1);
  }
  function C(A) {
    return A.re === 0 && A.im === 0 ? new g(-0.5) : A.re === 1 ? new g(NaN, NaN) : A.re === 1 / 0 && A.im === 0 ? new g(1) : A.im === 1 / 0 || A.re === -1 / 0 ? new g(NaN, NaN) : x(A, (M) => M, (M) => Math.round(1.3 * 15 + 0.9 * Math.abs(M.im)), (M) => M.re);
  }
  function x(A, M, _, O) {
    var T = _(A);
    if (O(A) > -(T - 1) / 2)
      return D(A, M(T), M);
    var I = n(a(2, A), a(M(N), h(A, 1)));
    return I = n(I, c(n(s(M(N), 2), A))), I = n(I, l(h(1, A))), n(I, x(h(1, A), M, _, O));
  }
  function E(A, M) {
    for (var _ = A, O = A; u(O, M); O = d(O, 1)) {
      var T = s(n(o(d(M, h(O, 1))), a(4, O)), n(o(h(M, O)), o(n(2, O))));
      _ = d(_, T);
    }
    return n(M, _);
  }
  function D(A, M, _) {
    for (var O = s(1, n(E(_(0), M), h(1, a(2, h(1, A))))), T = _(0), I = _(1); u(I, M); I = d(I, 1))
      T = d(T, s(n((-1) ** (I - 1), E(I, M)), a(I, A)));
    return n(O, T);
  }
}), Fy = "mode", YM = ["typed", "isNaN", "isNumeric"], gl = /* @__PURE__ */ j(Fy, YM, (t) => {
  var {
    typed: e,
    isNaN: r,
    isNumeric: n
  } = t;
  return e(Fy, {
    "Array | Matrix": a,
    "...": function(o) {
      return a(o);
    }
  });
  function a(s) {
    s = Lt(s.valueOf());
    var o = s.length;
    if (o === 0)
      throw new Error("Cannot calculate mode of an empty array");
    for (var p = {}, u = [], f = 0, l = 0; l < s.length; l++) {
      var c = s[l];
      if (n(c) && r(c))
        throw new Error("Cannot calculate mode of an array containing NaN values");
      c in p || (p[c] = 0), p[c]++, p[c] === f ? u.push(c) : p[c] > f && (f = p[c], u = [c]);
    }
    return u;
  }
});
function tn(t, e, r) {
  var n;
  return String(t).includes("Unexpected type") ? (n = arguments.length > 2 ? " (type: " + Vt(r) + ", value: " + JSON.stringify(r) + ")" : " (type: " + t.data.actual + ")", new TypeError("Cannot calculate " + e + ", unexpected type of argument" + n)) : String(t).includes("complex numbers") ? (n = arguments.length > 2 ? " (type: " + Vt(r) + ", value: " + JSON.stringify(r) + ")" : "", new TypeError("Cannot calculate " + e + ", no ordering relation is defined for complex numbers" + n)) : t;
}
var qy = "prod", XM = ["typed", "config", "multiplyScalar", "numeric"], yl = /* @__PURE__ */ j(qy, XM, (t) => {
  var {
    typed: e,
    config: r,
    multiplyScalar: n,
    numeric: a
  } = t;
  return e(qy, {
    // prod([a, b, c, d, ...])
    "Array | Matrix": s,
    // prod([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(p, u) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    // prod(a, b, c, d, ...)
    "...": function(p) {
      return s(p);
    }
  });
  function s(o) {
    var p;
    if (hi(o, function(u) {
      try {
        p = p === void 0 ? u : n(p, u);
      } catch (f) {
        throw tn(f, "prod", u);
      }
    }), typeof p == "string" && (p = a(p, Ii(p, r))), p === void 0)
      throw new Error("Cannot calculate prod of an empty array");
    return p;
  }
}), Iy = "format", KM = ["typed"], xl = /* @__PURE__ */ j(Iy, KM, (t) => {
  var {
    typed: e
  } = t;
  return e(Iy, {
    any: Dt,
    "any, Object | function | number | BigNumber": Dt
  });
}), By = "bin", eO = ["typed", "format"], bl = j(By, eO, (t) => {
  var {
    typed: e,
    format: r
  } = t;
  return e(By, {
    "number | BigNumber": function(a) {
      return r(a, {
        notation: "bin"
      });
    },
    "number | BigNumber, number | BigNumber": function(a, s) {
      return r(a, {
        notation: "bin",
        wordSize: s
      });
    }
  });
}), Ry = "oct", tO = ["typed", "format"], wl = j(Ry, tO, (t) => {
  var {
    typed: e,
    format: r
  } = t;
  return e(Ry, {
    "number | BigNumber": function(a) {
      return r(a, {
        notation: "oct"
      });
    },
    "number | BigNumber, number | BigNumber": function(a, s) {
      return r(a, {
        notation: "oct",
        wordSize: s
      });
    }
  });
}), Ly = "hex", rO = ["typed", "format"], Nl = j(Ly, rO, (t) => {
  var {
    typed: e,
    format: r
  } = t;
  return e(Ly, {
    "number | BigNumber": function(a) {
      return r(a, {
        notation: "hex"
      });
    },
    "number | BigNumber, number | BigNumber": function(a, s) {
      return r(a, {
        notation: "hex",
        wordSize: s
      });
    }
  });
}), Vw = /\$([\w.]+)/g, Py = "print", nO = ["typed"], eo = /* @__PURE__ */ j(Py, nO, (t) => {
  var {
    typed: e
  } = t;
  return e(Py, {
    // note: Matrix will be converted automatically to an Array
    "string, Object | Array": ky,
    "string, Object | Array, number | Object": ky
  });
});
function ky(t, e, r) {
  return t.replace(Vw, function(n, a) {
    var s = a.split("."), o = e[s.shift()];
    for (o !== void 0 && o.isMatrix && (o = o.toArray()); s.length && o !== void 0; ) {
      var p = s.shift();
      o = p ? o[p] : o + ".";
    }
    return o !== void 0 ? Er(o) ? o : Dt(o, r) : n;
  });
}
var $y = "to", iO = ["typed", "matrix", "concat"], Dl = /* @__PURE__ */ j($y, iO, (t) => {
  var {
    typed: e,
    matrix: r,
    concat: n
  } = t, a = Jt({
    typed: e,
    matrix: r,
    concat: n
  });
  return e($y, {
    "Unit, Unit | string": (s, o) => s.to(o)
  }, a({
    Ds: !0
  }));
}), zy = "isPrime", aO = ["typed"], Al = /* @__PURE__ */ j(zy, aO, (t) => {
  var {
    typed: e
  } = t;
  return e(zy, {
    number: function(n) {
      if (n <= 3)
        return n > 1;
      if (n % 2 === 0 || n % 3 === 0)
        return !1;
      for (var a = 5; a * a <= n; a += 6)
        if (n % a === 0 || n % (a + 2) === 0)
          return !1;
      return !0;
    },
    bigint: function(n) {
      if (n <= 3n)
        return n > 1n;
      if (n % 2n === 0n || n % 3n === 0n)
        return !1;
      for (var a = 5n; a * a <= n; a += 6n)
        if (n % a === 0n || n % (a + 2n) === 0n)
          return !1;
      return !0;
    },
    BigNumber: function(n) {
      if (n.lte(3)) return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0)) return !1;
      if (n.lt(Math.pow(2, 32))) {
        for (var a = n.toNumber(), s = 5; s * s <= a; s += 6)
          if (a % s === 0 || a % (s + 2) === 0)
            return !1;
        return !0;
      }
      function o(C, x, E) {
        for (var D = 1; !x.eq(0); )
          x.mod(2).eq(0) ? (x = x.div(2), C = C.mul(C).mod(E)) : (x = x.sub(1), D = C.mul(D).mod(E));
        return D;
      }
      var p = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new p(n);
      for (var u = 0, f = n.sub(1); f.mod(2).eq(0); )
        f = f.div(2), u += 1;
      var l = null;
      if (n.lt("3317044064679887385961981"))
        l = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((C) => C < n);
      else {
        var c = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        l = [];
        for (var h = 2; h <= c; h += 1)
          l.push(c);
      }
      for (var d = 0; d < l.length; d += 1) {
        var g = l[d], v = o(n.sub(n).add(g), f, n);
        if (!v.eq(1)) {
          for (var N = 0, b = v; !b.eq(n.sub(1)); N += 1, b = b.mul(b).mod(n))
            if (N === u - 1)
              return !1;
        }
      }
      return !0;
    },
    "Array | Matrix": e.referToSelf((r) => (n) => Nt(n, r))
  });
}), sO = "numeric", oO = ["number", "?bignumber", "?fraction"], El = /* @__PURE__ */ j(sO, oO, (t) => {
  var {
    number: e,
    bignumber: r,
    fraction: n
  } = t, a = {
    string: !0,
    number: !0,
    BigNumber: !0,
    Fraction: !0
  }, s = {
    number: (o) => e(o),
    BigNumber: r ? (o) => r(o) : Od,
    bigint: (o) => BigInt(o),
    Fraction: n ? (o) => n(o) : Hw
  };
  return function(p) {
    var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number", f = arguments.length > 2 ? arguments[2] : void 0;
    if (f !== void 0)
      throw new SyntaxError("numeric() takes one or two arguments");
    var l = Vt(p);
    if (!(l in a))
      throw new TypeError("Cannot convert " + p + ' of type "' + l + '"; valid input types are ' + Object.keys(a).join(", "));
    if (!(u in s))
      throw new TypeError("Cannot convert " + p + ' to type "' + u + '"; valid output types are ' + Object.keys(s).join(", "));
    return u === l ? p : s[u](p);
  };
}), Uy = "divideScalar", uO = ["typed", "numeric"], Sl = /* @__PURE__ */ j(Uy, uO, (t) => {
  var {
    typed: e,
    numeric: r
  } = t;
  return e(Uy, {
    "number, number": function(a, s) {
      return a / s;
    },
    "Complex, Complex": function(a, s) {
      return a.div(s);
    },
    "BigNumber, BigNumber": function(a, s) {
      return a.div(s);
    },
    "bigint, bigint": function(a, s) {
      return a / s;
    },
    "Fraction, Fraction": function(a, s) {
      return a.div(s);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (n, a) => n.divide(a),
    "number | Fraction | Complex | BigNumber, Unit": (n, a) => a.divideInto(n)
  });
}), Gy = "pow", lO = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"], Cl = /* @__PURE__ */ j(Gy, lO, (t) => {
  var {
    typed: e,
    config: r,
    identity: n,
    multiply: a,
    matrix: s,
    inv: o,
    number: p,
    fraction: u,
    Complex: f
  } = t;
  return e(Gy, {
    "number, number": l,
    "Complex, Complex": function(g, v) {
      return g.pow(v);
    },
    "BigNumber, BigNumber": function(g, v) {
      return v.isInteger() || g >= 0 || r.predictable ? g.pow(v) : new f(g.toNumber(), 0).pow(v.toNumber(), 0);
    },
    "bigint, bigint": (d, g) => d ** g,
    "Fraction, Fraction": function(g, v) {
      var N = g.pow(v);
      if (N != null)
        return N;
      if (r.predictable)
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      return l(g.valueOf(), v.valueOf());
    },
    "Array, number": c,
    "Array, BigNumber": function(g, v) {
      return c(g, v.toNumber());
    },
    "Matrix, number": h,
    "Matrix, BigNumber": function(g, v) {
      return h(g, v.toNumber());
    },
    "Unit, number | BigNumber": function(g, v) {
      return g.pow(v);
    }
  });
  function l(d, g) {
    if (r.predictable && !Xe(g) && d < 0)
      try {
        var v = u(g), N = p(v);
        if ((g === N || Math.abs((g - N) / g) < 1e-14) && v.d % 2 === 1)
          return (v.n % 2 === 0 ? 1 : -1) * Math.pow(-d, g);
      } catch {
      }
    return r.predictable && (d < -1 && g === 1 / 0 || d > -1 && d < 0 && g === -1 / 0) ? NaN : Xe(g) || d >= 0 || r.predictable ? pw(d, g) : d * d < 1 && g === 1 / 0 || d * d > 1 && g === -1 / 0 ? 0 : new f(d, 0).pow(g, 0);
  }
  function c(d, g) {
    if (!Xe(g))
      throw new TypeError("For A^b, b must be an integer (value is " + g + ")");
    var v = gt(d);
    if (v.length !== 2)
      throw new Error("For A^b, A must be 2 dimensional (A has " + v.length + " dimensions)");
    if (v[0] !== v[1])
      throw new Error("For A^b, A must be square (size is " + v[0] + "x" + v[1] + ")");
    if (g < 0)
      try {
        return c(o(d), -g);
      } catch (C) {
        throw C.message === "Cannot calculate inverse, determinant is zero" ? new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + g + ")") : C;
      }
    for (var N = n(v[0]).valueOf(), b = d; g >= 1; )
      (g & 1) === 1 && (N = a(b, N)), g >>= 1, b = a(b, b);
    return N;
  }
  function h(d, g) {
    return s(c(d.valueOf(), g));
  }
}), Ta = "Number of decimals in function round must be an integer", Hy = "round", cO = ["typed", "config", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"], Tl = /* @__PURE__ */ j(Hy, cO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    equalScalar: a,
    zeros: s,
    BigNumber: o,
    DenseMatrix: p
  } = t, u = Pr({
    typed: e,
    equalScalar: a
  }), f = br({
    typed: e,
    DenseMatrix: p
  }), l = zn({
    typed: e
  });
  function c(h) {
    return Math.abs($s(h).exponent);
  }
  return e(Hy, {
    number: function(d) {
      var g = Es(d, c(r.relTol)), v = Lr(d, g, r.relTol, r.absTol) ? g : d;
      return Es(v);
    },
    "number, number": function(d, g) {
      var v = c(r.relTol);
      if (g >= v)
        return Es(d, g);
      var N = Es(d, v), b = Lr(d, N, r.relTol, r.absTol) ? N : d;
      return Es(b, g);
    },
    "number, BigNumber": function(d, g) {
      if (!g.isInteger())
        throw new TypeError(Ta);
      return new o(d).toDecimalPlaces(g.toNumber());
    },
    Complex: function(d) {
      return d.round();
    },
    "Complex, number": function(d, g) {
      if (g % 1)
        throw new TypeError(Ta);
      return d.round(g);
    },
    "Complex, BigNumber": function(d, g) {
      if (!g.isInteger())
        throw new TypeError(Ta);
      var v = g.toNumber();
      return d.round(v);
    },
    BigNumber: function(d) {
      var g = new o(d).toDecimalPlaces(c(r.relTol)), v = pn(d, g, r.relTol, r.absTol) ? g : d;
      return v.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function(d, g) {
      if (!g.isInteger())
        throw new TypeError(Ta);
      var v = c(r.relTol);
      if (g >= v)
        return d.toDecimalPlaces(g.toNumber());
      var N = d.toDecimalPlaces(v), b = pn(d, N, r.relTol, r.absTol) ? N : d;
      return b.toDecimalPlaces(g.toNumber());
    },
    Fraction: function(d) {
      return d.round();
    },
    "Fraction, number": function(d, g) {
      if (g % 1)
        throw new TypeError(Ta);
      return d.round(g);
    },
    "Fraction, BigNumber": function(d, g) {
      if (!g.isInteger())
        throw new TypeError(Ta);
      return d.round(g.toNumber());
    },
    "Unit, number, Unit": e.referToSelf((h) => function(d, g, v) {
      var N = d.toNumeric(v);
      return v.multiply(h(N, g));
    }),
    "Unit, BigNumber, Unit": e.referToSelf((h) => (d, g, v) => h(d, g.toNumber(), v)),
    "Unit, Unit": e.referToSelf((h) => (d, g) => h(d, 0, g)),
    "Array | Matrix, number, Unit": e.referToSelf((h) => (d, g, v) => Nt(d, (N) => h(N, g, v))),
    "Array | Matrix, BigNumber, Unit": e.referToSelf((h) => (d, g, v) => h(d, g.toNumber(), v)),
    "Array | Matrix, Unit": e.referToSelf((h) => (d, g) => h(d, 0, g)),
    "Array | Matrix": e.referToSelf((h) => (d) => Nt(d, h)),
    "SparseMatrix, number | BigNumber": e.referToSelf((h) => (d, g) => u(d, g, h, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((h) => (d, g) => l(d, g, h, !1)),
    "Array, number | BigNumber": e.referToSelf((h) => (d, g) => l(n(d), g, h, !1).valueOf()),
    "number | Complex | BigNumber | Fraction, SparseMatrix": e.referToSelf((h) => (d, g) => a(d, 0) ? s(g.size(), g.storage()) : f(g, d, h, !0)),
    "number | Complex | BigNumber | Fraction, DenseMatrix": e.referToSelf((h) => (d, g) => a(d, 0) ? s(g.size(), g.storage()) : l(g, d, h, !0)),
    "number | Complex | BigNumber | Fraction, Array": e.referToSelf((h) => (d, g) => l(n(g), d, h, !0).valueOf())
  });
}), Qy = "log", fO = ["config", "typed", "divideScalar", "Complex"], _l = /* @__PURE__ */ j(Qy, fO, (t) => {
  var {
    typed: e,
    config: r,
    divideScalar: n,
    Complex: a
  } = t;
  return e(Qy, {
    number: function(o) {
      return o >= 0 || r.predictable ? HT(o) : new a(o, 0).log();
    },
    Complex: function(o) {
      return o.log();
    },
    BigNumber: function(o) {
      return !o.isNegative() || r.predictable ? o.ln() : new a(o.toNumber(), 0).log();
    },
    "any, any": e.referToSelf((s) => (o, p) => n(s(o), s(p)))
  });
}), Vy = "log1p", pO = ["typed", "config", "divideScalar", "log", "Complex"], Ml = /* @__PURE__ */ j(Vy, pO, (t) => {
  var {
    typed: e,
    config: r,
    divideScalar: n,
    log: a,
    Complex: s
  } = t;
  return e(Vy, {
    number: function(u) {
      return u >= -1 || r.predictable ? ZS(u) : o(new s(u, 0));
    },
    Complex: o,
    BigNumber: function(u) {
      var f = u.plus(1);
      return !f.isNegative() || r.predictable ? f.ln() : o(new s(u.toNumber(), 0));
    },
    "Array | Matrix": e.referToSelf((p) => (u) => Nt(u, p)),
    "any, any": e.referToSelf((p) => (u, f) => n(p(u), a(f)))
  });
  function o(p) {
    var u = p.re + 1;
    return new s(Math.log(Math.sqrt(u * u + p.im * p.im)), Math.atan2(p.im, u));
  }
}), Wy = "nthRoots", hO = ["config", "typed", "divideScalar", "Complex"], Ol = /* @__PURE__ */ j(Wy, hO, (t) => {
  var {
    typed: e,
    config: r,
    divideScalar: n,
    Complex: a
  } = t, s = [function(u) {
    return new a(u, 0);
  }, function(u) {
    return new a(0, u);
  }, function(u) {
    return new a(-u, 0);
  }, function(u) {
    return new a(0, -u);
  }];
  function o(p, u) {
    if (u < 0) throw new Error("Root must be greater than zero");
    if (u === 0) throw new Error("Root must be non-zero");
    if (u % 1 !== 0) throw new Error("Root must be an integer");
    if (p === 0 || p.abs() === 0) return [new a(0, 0)];
    var f = typeof p == "number", l;
    (f || p.re === 0 || p.im === 0) && (f ? l = 2 * +(p < 0) : p.im === 0 ? l = 2 * +(p.re < 0) : l = 2 * +(p.im < 0) + 1);
    for (var c = p.arg(), h = p.abs(), d = [], g = Math.pow(h, 1 / u), v = 0; v < u; v++) {
      var N = (l + 4 * v) / u;
      if (N === Math.round(N)) {
        d.push(s[N % 4](g));
        continue;
      }
      d.push(new a({
        r: g,
        phi: (c + 2 * Math.PI * v) / u
      }));
    }
    return d;
  }
  return e(Wy, {
    Complex: function(u) {
      return o(u, 2);
    },
    "Complex, number": o
  });
}), jy = "dotPow", mO = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"], Fl = /* @__PURE__ */ j(jy, mO, (t) => {
  var {
    typed: e,
    equalScalar: r,
    matrix: n,
    pow: a,
    DenseMatrix: s,
    concat: o
  } = t, p = rn({
    typed: e
  }), u = Jn({
    typed: e,
    DenseMatrix: s
  }), f = Pr({
    typed: e,
    equalScalar: r
  }), l = br({
    typed: e,
    DenseMatrix: s
  }), c = Jt({
    typed: e,
    matrix: n,
    concat: o
  }), h = {};
  for (var d in a.signatures)
    Object.prototype.hasOwnProperty.call(a.signatures, d) && !d.includes("Matrix") && !d.includes("Array") && (h[d] = a.signatures[d]);
  var g = e(h);
  return e(jy, c({
    elop: g,
    SS: u,
    DS: p,
    Ss: f,
    sS: l
  }));
}), Zy = "dotDivide", dO = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"], ql = /* @__PURE__ */ j(Zy, dO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    divideScalar: a,
    DenseMatrix: s,
    concat: o
  } = t, p = Un({
    typed: e,
    equalScalar: n
  }), u = rn({
    typed: e
  }), f = Jn({
    typed: e,
    DenseMatrix: s
  }), l = Pr({
    typed: e,
    equalScalar: n
  }), c = br({
    typed: e,
    DenseMatrix: s
  }), h = Jt({
    typed: e,
    matrix: r,
    concat: o
  });
  return e(Zy, h({
    elop: a,
    SS: f,
    DS: u,
    SD: p,
    Ss: l,
    sS: c
  }));
});
function to(t) {
  var {
    DenseMatrix: e
  } = t;
  return function(n, a, s) {
    var o = n.size();
    if (o.length !== 2)
      throw new RangeError("Matrix must be two dimensional (size: " + Dt(o) + ")");
    var p = o[0], u = o[1];
    if (p !== u)
      throw new RangeError("Matrix must be square (size: " + Dt(o) + ")");
    var f = [];
    if (tt(a)) {
      var l = a.size(), c = a._data;
      if (l.length === 1) {
        if (l[0] !== p)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        for (var h = 0; h < p; h++)
          f[h] = [c[h]];
        return new e({
          data: f,
          size: [p, 1],
          datatype: a._datatype
        });
      }
      if (l.length === 2) {
        if (l[0] !== p || l[1] !== 1)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        if (Ra(a)) {
          if (s) {
            f = [];
            for (var d = 0; d < p; d++)
              f[d] = [c[d][0]];
            return new e({
              data: f,
              size: [p, 1],
              datatype: a._datatype
            });
          }
          return a;
        }
        if (oi(a)) {
          for (var g = 0; g < p; g++)
            f[g] = [0];
          for (var v = a._values, N = a._index, b = a._ptr, C = b[1], x = b[0]; x < C; x++) {
            var E = N[x];
            f[E][0] = v[x];
          }
          return new e({
            data: f,
            size: [p, 1],
            datatype: a._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (Rt(a)) {
      var D = gt(a);
      if (D.length === 1) {
        if (D[0] !== p)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        for (var A = 0; A < p; A++)
          f[A] = [a[A]];
        return new e({
          data: f,
          size: [p, 1]
        });
      }
      if (D.length === 2) {
        if (D[0] !== p || D[1] !== 1)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        for (var M = 0; M < p; M++)
          f[M] = [a[M][0]];
        return new e({
          data: f,
          size: [p, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}
var Jy = "lsolve", vO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], Il = /* @__PURE__ */ j(Jy, vO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: a,
    subtractScalar: s,
    equalScalar: o,
    DenseMatrix: p
  } = t, u = to({
    DenseMatrix: p
  });
  return e(Jy, {
    "SparseMatrix, Array | Matrix": function(h, d) {
      return l(h, d);
    },
    "DenseMatrix, Array | Matrix": function(h, d) {
      return f(h, d);
    },
    "Array, Array | Matrix": function(h, d) {
      var g = r(h), v = f(g, d);
      return v.valueOf();
    }
  });
  function f(c, h) {
    h = u(c, h, !0);
    for (var d = h._data, g = c._size[0], v = c._size[1], N = [], b = c._data, C = 0; C < v; C++) {
      var x = d[C][0] || 0, E = void 0;
      if (o(x, 0))
        E = 0;
      else {
        var D = b[C][C];
        if (o(D, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        E = n(x, D);
        for (var A = C + 1; A < g; A++)
          d[A] = [s(d[A][0] || 0, a(E, b[A][C]))];
      }
      N[C] = [E];
    }
    return new p({
      data: N,
      size: [g, 1]
    });
  }
  function l(c, h) {
    h = u(c, h, !0);
    for (var d = h._data, g = c._size[0], v = c._size[1], N = c._values, b = c._index, C = c._ptr, x = [], E = 0; E < v; E++) {
      var D = d[E][0] || 0;
      if (o(D, 0))
        x[E] = [0];
      else {
        for (var A = 0, M = [], _ = [], O = C[E], T = C[E + 1], I = O; I < T; I++) {
          var q = b[I];
          q === E ? A = N[I] : q > E && (M.push(N[I]), _.push(q));
        }
        if (o(A, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        for (var $ = n(D, A), U = 0, k = _.length; U < k; U++) {
          var L = _[U];
          d[L] = [s(d[L][0] || 0, a($, M[U]))];
        }
        x[E] = [$];
      }
    }
    return new p({
      data: x,
      size: [g, 1]
    });
  }
}), Yy = "usolve", gO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], Bl = /* @__PURE__ */ j(Yy, gO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: a,
    subtractScalar: s,
    equalScalar: o,
    DenseMatrix: p
  } = t, u = to({
    DenseMatrix: p
  });
  return e(Yy, {
    "SparseMatrix, Array | Matrix": function(h, d) {
      return l(h, d);
    },
    "DenseMatrix, Array | Matrix": function(h, d) {
      return f(h, d);
    },
    "Array, Array | Matrix": function(h, d) {
      var g = r(h), v = f(g, d);
      return v.valueOf();
    }
  });
  function f(c, h) {
    h = u(c, h, !0);
    for (var d = h._data, g = c._size[0], v = c._size[1], N = [], b = c._data, C = v - 1; C >= 0; C--) {
      var x = d[C][0] || 0, E = void 0;
      if (o(x, 0))
        E = 0;
      else {
        var D = b[C][C];
        if (o(D, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        E = n(x, D);
        for (var A = C - 1; A >= 0; A--)
          d[A] = [s(d[A][0] || 0, a(E, b[A][C]))];
      }
      N[C] = [E];
    }
    return new p({
      data: N,
      size: [g, 1]
    });
  }
  function l(c, h) {
    h = u(c, h, !0);
    for (var d = h._data, g = c._size[0], v = c._size[1], N = c._values, b = c._index, C = c._ptr, x = [], E = v - 1; E >= 0; E--) {
      var D = d[E][0] || 0;
      if (o(D, 0))
        x[E] = [0];
      else {
        for (var A = 0, M = [], _ = [], O = C[E], T = C[E + 1], I = T - 1; I >= O; I--) {
          var q = b[I];
          q === E ? A = N[I] : q < E && (M.push(N[I]), _.push(q));
        }
        if (o(A, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        for (var $ = n(D, A), U = 0, k = _.length; U < k; U++) {
          var L = _[U];
          d[L] = [s(d[L][0], a($, M[U]))];
        }
        x[E] = [$];
      }
    }
    return new p({
      data: x,
      size: [g, 1]
    });
  }
}), Xy = "lsolveAll", yO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], Rl = /* @__PURE__ */ j(Xy, yO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: a,
    subtractScalar: s,
    equalScalar: o,
    DenseMatrix: p
  } = t, u = to({
    DenseMatrix: p
  });
  return e(Xy, {
    "SparseMatrix, Array | Matrix": function(h, d) {
      return l(h, d);
    },
    "DenseMatrix, Array | Matrix": function(h, d) {
      return f(h, d);
    },
    "Array, Array | Matrix": function(h, d) {
      var g = r(h), v = f(g, d);
      return v.map((N) => N.valueOf());
    }
  });
  function f(c, h) {
    for (var d = [u(c, h, !0)._data.map((_) => _[0])], g = c._data, v = c._size[0], N = c._size[1], b = 0; b < N; b++)
      for (var C = d.length, x = 0; x < C; x++) {
        var E = d[x];
        if (o(g[b][b], 0))
          if (o(E[b], 0)) {
            if (x === 0) {
              var A = [...E];
              A[b] = 1;
              for (var M = b + 1; M < N; M++)
                A[M] = s(A[M], g[M][b]);
              d.push(A);
            }
          } else {
            if (x === 0)
              return [];
            d.splice(x, 1), x -= 1, C -= 1;
          }
        else {
          E[b] = n(E[b], g[b][b]);
          for (var D = b + 1; D < N; D++)
            E[D] = s(E[D], a(E[b], g[D][b]));
        }
      }
    return d.map((_) => new p({
      data: _.map((O) => [O]),
      size: [v, 1]
    }));
  }
  function l(c, h) {
    for (var d = [u(c, h, !0)._data.map((le) => le[0])], g = c._size[0], v = c._size[1], N = c._values, b = c._index, C = c._ptr, x = 0; x < v; x++)
      for (var E = d.length, D = 0; D < E; D++) {
        for (var A = d[D], M = [], _ = [], O = C[x], T = C[x + 1], I = 0, q = O; q < T; q++) {
          var $ = b[q];
          $ === x ? I = N[q] : $ > x && (M.push(N[q]), _.push($));
        }
        if (o(I, 0))
          if (o(A[x], 0)) {
            if (D === 0) {
              var R = [...A];
              R[x] = 1;
              for (var G = 0, P = _.length; G < P; G++) {
                var W = _[G];
                R[W] = s(R[W], M[G]);
              }
              d.push(R);
            }
          } else {
            if (D === 0)
              return [];
            d.splice(D, 1), D -= 1, E -= 1;
          }
        else {
          A[x] = n(A[x], I);
          for (var U = 0, k = _.length; U < k; U++) {
            var L = _[U];
            A[L] = s(A[L], a(A[x], M[U]));
          }
        }
      }
    return d.map((le) => new p({
      data: le.map((Z) => [Z]),
      size: [g, 1]
    }));
  }
}), Ky = "usolveAll", xO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], Ll = /* @__PURE__ */ j(Ky, xO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: a,
    subtractScalar: s,
    equalScalar: o,
    DenseMatrix: p
  } = t, u = to({
    DenseMatrix: p
  });
  return e(Ky, {
    "SparseMatrix, Array | Matrix": function(h, d) {
      return l(h, d);
    },
    "DenseMatrix, Array | Matrix": function(h, d) {
      return f(h, d);
    },
    "Array, Array | Matrix": function(h, d) {
      var g = r(h), v = f(g, d);
      return v.map((N) => N.valueOf());
    }
  });
  function f(c, h) {
    for (var d = [u(c, h, !0)._data.map((_) => _[0])], g = c._data, v = c._size[0], N = c._size[1], b = N - 1; b >= 0; b--)
      for (var C = d.length, x = 0; x < C; x++) {
        var E = d[x];
        if (o(g[b][b], 0))
          if (o(E[b], 0)) {
            if (x === 0) {
              var A = [...E];
              A[b] = 1;
              for (var M = b - 1; M >= 0; M--)
                A[M] = s(A[M], g[M][b]);
              d.push(A);
            }
          } else {
            if (x === 0)
              return [];
            d.splice(x, 1), x -= 1, C -= 1;
          }
        else {
          E[b] = n(E[b], g[b][b]);
          for (var D = b - 1; D >= 0; D--)
            E[D] = s(E[D], a(E[b], g[D][b]));
        }
      }
    return d.map((_) => new p({
      data: _.map((O) => [O]),
      size: [v, 1]
    }));
  }
  function l(c, h) {
    for (var d = [u(c, h, !0)._data.map((le) => le[0])], g = c._size[0], v = c._size[1], N = c._values, b = c._index, C = c._ptr, x = v - 1; x >= 0; x--)
      for (var E = d.length, D = 0; D < E; D++) {
        for (var A = d[D], M = [], _ = [], O = C[x], T = C[x + 1], I = 0, q = T - 1; q >= O; q--) {
          var $ = b[q];
          $ === x ? I = N[q] : $ < x && (M.push(N[q]), _.push($));
        }
        if (o(I, 0))
          if (o(A[x], 0)) {
            if (D === 0) {
              var R = [...A];
              R[x] = 1;
              for (var G = 0, P = _.length; G < P; G++) {
                var W = _[G];
                R[W] = s(R[W], M[G]);
              }
              d.push(R);
            }
          } else {
            if (D === 0)
              return [];
            d.splice(D, 1), D -= 1, E -= 1;
          }
        else {
          A[x] = n(A[x], I);
          for (var U = 0, k = _.length; U < k; U++) {
            var L = _[U];
            A[L] = s(A[L], a(A[x], M[U]));
          }
        }
      }
    return d.map((le) => new p({
      data: le.map((Z) => [Z]),
      size: [g, 1]
    }));
  }
}), bO = "matAlgo08xS0Sid", wO = ["typed", "equalScalar"], Fd = /* @__PURE__ */ j(bO, wO, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(a, s, o) {
    var p = a._values, u = a._index, f = a._ptr, l = a._size, c = a._datatype || a._data === void 0 ? a._datatype : a.getDataType(), h = s._values, d = s._index, g = s._ptr, v = s._size, N = s._datatype || s._data === void 0 ? s._datatype : s.getDataType();
    if (l.length !== v.length)
      throw new xt(l.length, v.length);
    if (l[0] !== v[0] || l[1] !== v[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + l + ") must match Matrix B (" + v + ")");
    if (!p || !h)
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    var b = l[0], C = l[1], x, E = r, D = 0, A = o;
    typeof c == "string" && c === N && c !== "mixed" && (x = c, E = e.find(r, [x, x]), D = e.convert(0, x), A = e.find(o, [x, x]));
    for (var M = [], _ = [], O = [], T = [], I = [], q, $, U, k, L = 0; L < C; L++) {
      O[L] = _.length;
      var R = L + 1;
      for ($ = f[L], U = f[L + 1], q = $; q < U; q++)
        k = u[q], I[k] = R, T[k] = p[q], _.push(k);
      for ($ = g[L], U = g[L + 1], q = $; q < U; q++)
        k = d[q], I[k] === R && (T[k] = A(T[k], h[q]));
      for (q = O[L]; q < _.length; ) {
        k = _[q];
        var G = T[k];
        E(G, D) ? _.splice(q, 1) : (M.push(G), q++);
      }
    }
    return O[C] = _.length, a.createSparseMatrix({
      values: M,
      index: _,
      ptr: O,
      size: [b, C],
      datatype: c === a._datatype && N === s._datatype ? x : void 0
    });
  };
}), qd = /* @__PURE__ */ j("useMatrixForArrayScalar", ["typed", "matrix"], (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return {
    "Array, number": e.referTo("DenseMatrix, number", (n) => (a, s) => n(r(a), s).valueOf()),
    "Array, BigNumber": e.referTo("DenseMatrix, BigNumber", (n) => (a, s) => n(r(a), s).valueOf()),
    "number, Array": e.referTo("number, DenseMatrix", (n) => (a, s) => n(a, r(s)).valueOf()),
    "BigNumber, Array": e.referTo("BigNumber, DenseMatrix", (n) => (a, s) => n(a, r(s)).valueOf())
  };
}), ex = "leftShift", NO = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], Pl = /* @__PURE__ */ j(ex, NO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    DenseMatrix: s,
    concat: o
  } = t, p = Ri({
    typed: e
  }), u = Un({
    typed: e,
    equalScalar: n
  }), f = Fd({
    typed: e,
    equalScalar: n
  }), l = la({
    typed: e,
    DenseMatrix: s
  }), c = Pr({
    typed: e,
    equalScalar: n
  }), h = zn({
    typed: e
  }), d = Jt({
    typed: e,
    matrix: r,
    concat: o
  }), g = qd({
    typed: e,
    matrix: r
  });
  return e(ex, {
    "number, number": gw,
    "BigNumber, BigNumber": G_,
    "bigint, bigint": (v, N) => v << N,
    "SparseMatrix, number | BigNumber": e.referToSelf((v) => (N, b) => n(b, 0) ? N.clone() : c(N, b, v, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((v) => (N, b) => n(b, 0) ? N.clone() : h(N, b, v, !1)),
    "number | BigNumber, SparseMatrix": e.referToSelf((v) => (N, b) => n(N, 0) ? a(b.size(), b.storage()) : l(b, N, v, !0)),
    "number | BigNumber, DenseMatrix": e.referToSelf((v) => (N, b) => n(N, 0) ? a(b.size(), b.storage()) : h(b, N, v, !0))
  }, g, d({
    SS: f,
    DS: p,
    SD: u
  }));
}), tx = "rightArithShift", DO = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], kl = /* @__PURE__ */ j(tx, DO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    DenseMatrix: s,
    concat: o
  } = t, p = Ri({
    typed: e
  }), u = Un({
    typed: e,
    equalScalar: n
  }), f = Fd({
    typed: e,
    equalScalar: n
  }), l = la({
    typed: e,
    DenseMatrix: s
  }), c = Pr({
    typed: e,
    equalScalar: n
  }), h = zn({
    typed: e
  }), d = Jt({
    typed: e,
    matrix: r,
    concat: o
  }), g = qd({
    typed: e,
    matrix: r
  });
  return e(tx, {
    "number, number": yw,
    "BigNumber, BigNumber": H_,
    "bigint, bigint": (v, N) => v >> N,
    "SparseMatrix, number | BigNumber": e.referToSelf((v) => (N, b) => n(b, 0) ? N.clone() : c(N, b, v, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((v) => (N, b) => n(b, 0) ? N.clone() : h(N, b, v, !1)),
    "number | BigNumber, SparseMatrix": e.referToSelf((v) => (N, b) => n(N, 0) ? a(b.size(), b.storage()) : l(b, N, v, !0)),
    "number | BigNumber, DenseMatrix": e.referToSelf((v) => (N, b) => n(N, 0) ? a(b.size(), b.storage()) : h(b, N, v, !0))
  }, g, d({
    SS: f,
    DS: p,
    SD: u
  }));
}), rx = "rightLogShift", AO = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], $l = /* @__PURE__ */ j(rx, AO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    DenseMatrix: s,
    concat: o
  } = t, p = Ri({
    typed: e
  }), u = Un({
    typed: e,
    equalScalar: n
  }), f = Fd({
    typed: e,
    equalScalar: n
  }), l = la({
    typed: e,
    DenseMatrix: s
  }), c = Pr({
    typed: e,
    equalScalar: n
  }), h = zn({
    typed: e
  }), d = Jt({
    typed: e,
    matrix: r,
    concat: o
  }), g = qd({
    typed: e,
    matrix: r
  });
  return e(rx, {
    "number, number": xw,
    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
    "SparseMatrix, number | BigNumber": e.referToSelf((v) => (N, b) => n(b, 0) ? N.clone() : c(N, b, v, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((v) => (N, b) => n(b, 0) ? N.clone() : h(N, b, v, !1)),
    "number | BigNumber, SparseMatrix": e.referToSelf((v) => (N, b) => n(N, 0) ? a(b.size(), b.storage()) : l(b, N, v, !0)),
    "number | BigNumber, DenseMatrix": e.referToSelf((v) => (N, b) => n(N, 0) ? a(b.size(), b.storage()) : h(b, N, v, !0))
  }, g, d({
    SS: f,
    DS: p,
    SD: u
  }));
}), nx = "and", EO = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"], ro = /* @__PURE__ */ j(nx, EO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    not: s,
    concat: o
  } = t, p = Un({
    typed: e,
    equalScalar: n
  }), u = D0({
    typed: e,
    equalScalar: n
  }), f = Pr({
    typed: e,
    equalScalar: n
  }), l = zn({
    typed: e
  }), c = Jt({
    typed: e,
    matrix: r,
    concat: o
  });
  return e(nx, {
    "number, number": ed,
    "Complex, Complex": function(d, g) {
      return (d.re !== 0 || d.im !== 0) && (g.re !== 0 || g.im !== 0);
    },
    "BigNumber, BigNumber": function(d, g) {
      return !d.isZero() && !g.isZero() && !d.isNaN() && !g.isNaN();
    },
    "bigint, bigint": ed,
    "Unit, Unit": e.referToSelf((h) => (d, g) => h(d.value || 0, g.value || 0)),
    "SparseMatrix, any": e.referToSelf((h) => (d, g) => s(g) ? a(d.size(), d.storage()) : f(d, g, h, !1)),
    "DenseMatrix, any": e.referToSelf((h) => (d, g) => s(g) ? a(d.size(), d.storage()) : l(d, g, h, !1)),
    "any, SparseMatrix": e.referToSelf((h) => (d, g) => s(d) ? a(d.size(), d.storage()) : f(g, d, h, !0)),
    "any, DenseMatrix": e.referToSelf((h) => (d, g) => s(d) ? a(d.size(), d.storage()) : l(g, d, h, !0)),
    "Array, any": e.referToSelf((h) => (d, g) => h(r(d), g).valueOf()),
    "any, Array": e.referToSelf((h) => (d, g) => h(d, r(g)).valueOf())
  }, c({
    SS: u,
    DS: p
  }));
}), pu = "compare", SO = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"], zl = /* @__PURE__ */ j(pu, SO, (t) => {
  var {
    typed: e,
    config: r,
    equalScalar: n,
    matrix: a,
    BigNumber: s,
    Fraction: o,
    DenseMatrix: p,
    concat: u
  } = t, f = rn({
    typed: e
  }), l = w0({
    typed: e,
    equalScalar: n
  }), c = br({
    typed: e,
    DenseMatrix: p
  }), h = Jt({
    typed: e,
    matrix: a,
    concat: u
  }), d = Xa({
    typed: e
  });
  return e(pu, CO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": function(v, N) {
      return v === N ? 0 : v > N ? 1 : -1;
    },
    "BigNumber, BigNumber": function(v, N) {
      return pn(v, N, r.relTol, r.absTol) ? new s(0) : new s(v.cmp(N));
    },
    "bigint, bigint": function(v, N) {
      return v === N ? 0n : v > N ? 1n : -1n;
    },
    "Fraction, Fraction": function(v, N) {
      return new o(v.compare(N));
    },
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, d, h({
    SS: l,
    DS: f,
    Ss: c
  }));
}), CO = /* @__PURE__ */ j(pu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(pu, {
    "number, number": function(a, s) {
      return Lr(a, s, r.relTol, r.absTol) ? 0 : a > s ? 1 : -1;
    }
  });
}), TO = function t(e, r) {
  var n = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, a = /(^[ ]*|[ ]*$)/g, s = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, o = /^0x[0-9a-f]+$/i, p = /^0/, u = function(x) {
    return t.insensitive && ("" + x).toLowerCase() || "" + x;
  }, f = u(e).replace(a, "") || "", l = u(r).replace(a, "") || "", c = f.replace(n, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), h = l.replace(n, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), d = parseInt(f.match(o), 16) || c.length !== 1 && f.match(s) && Date.parse(f), g = parseInt(l.match(o), 16) || d && l.match(s) && Date.parse(l) || null, v, N;
  if (g) {
    if (d < g)
      return -1;
    if (d > g)
      return 1;
  }
  for (var b = 0, C = Math.max(c.length, h.length); b < C; b++) {
    if (v = !(c[b] || "").match(p) && parseFloat(c[b]) || c[b] || 0, N = !(h[b] || "").match(p) && parseFloat(h[b]) || h[b] || 0, isNaN(v) !== isNaN(N))
      return isNaN(v) ? 1 : -1;
    if (typeof v != typeof N && (v += "", N += ""), v < N)
      return -1;
    if (v > N)
      return 1;
  }
  return 0;
};
const _a = /* @__PURE__ */ zs(TO);
var ix = "compareNatural", _O = ["typed", "compare"], Ul = /* @__PURE__ */ j(ix, _O, (t) => {
  var {
    typed: e,
    compare: r
  } = t, n = r.signatures["boolean,boolean"];
  return e(ix, {
    "any, any": a
  });
  function a(u, f) {
    var l = Vt(u), c = Vt(f), h;
    if ((l === "number" || l === "BigNumber" || l === "Fraction") && (c === "number" || c === "BigNumber" || c === "Fraction"))
      return h = r(u, f), h.toString() !== "0" ? h > 0 ? 1 : -1 : _a(l, c);
    var d = ["Array", "DenseMatrix", "SparseMatrix"];
    if (d.includes(l) || d.includes(c))
      return h = s(a, u, f), h !== 0 ? h : _a(l, c);
    if (l !== c)
      return _a(l, c);
    if (l === "Complex")
      return MO(u, f);
    if (l === "Unit")
      return u.equalBase(f) ? a(u.value, f.value) : o(a, u.formatUnits(), f.formatUnits());
    if (l === "boolean")
      return n(u, f);
    if (l === "string")
      return _a(u, f);
    if (l === "Object")
      return p(a, u, f);
    if (l === "null" || l === "undefined")
      return 0;
    throw new TypeError('Unsupported type of value "' + l + '"');
  }
  function s(u, f, l) {
    return oi(f) && oi(l) ? o(u, f.toJSON().values, l.toJSON().values) : oi(f) ? s(u, f.toArray(), l) : oi(l) ? s(u, f, l.toArray()) : Ra(f) ? s(u, f.toJSON().data, l) : Ra(l) ? s(u, f, l.toJSON().data) : Array.isArray(f) ? Array.isArray(l) ? o(u, f, l) : s(u, f, [l]) : s(u, [f], l);
  }
  function o(u, f, l) {
    for (var c = 0, h = Math.min(f.length, l.length); c < h; c++) {
      var d = u(f[c], l[c]);
      if (d !== 0)
        return d;
    }
    return f.length > l.length ? 1 : f.length < l.length ? -1 : 0;
  }
  function p(u, f, l) {
    var c = Object.keys(f), h = Object.keys(l);
    c.sort(_a), h.sort(_a);
    var d = o(u, c, h);
    if (d !== 0)
      return d;
    for (var g = 0; g < c.length; g++) {
      var v = u(f[c[g]], l[h[g]]);
      if (v !== 0)
        return v;
    }
    return 0;
  }
});
function MO(t, e) {
  return t.re > e.re ? 1 : t.re < e.re ? -1 : t.im > e.im ? 1 : t.im < e.im ? -1 : 0;
}
var ax = "compareText", OO = ["typed", "matrix", "concat"];
Zm.signature = "any, any";
var Gl = /* @__PURE__ */ j(ax, OO, (t) => {
  var {
    typed: e,
    matrix: r,
    concat: n
  } = t, a = Jt({
    typed: e,
    matrix: r,
    concat: n
  });
  return e(ax, Zm, a({
    elop: Zm,
    Ds: !0
  }));
}), hu = "equal", FO = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Hl = /* @__PURE__ */ j(hu, FO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: a,
    concat: s
  } = t, o = rn({
    typed: e
  }), p = Jn({
    typed: e,
    DenseMatrix: a
  }), u = br({
    typed: e,
    DenseMatrix: a
  }), f = Jt({
    typed: e,
    matrix: r,
    concat: s
  });
  return e(hu, qO({
    typed: e,
    equalScalar: n
  }), f({
    elop: n,
    SS: p,
    DS: o,
    Ss: u
  }));
}), qO = j(hu, ["typed", "equalScalar"], (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return e(hu, {
    "any, any": function(a, s) {
      return a === null ? s === null : s === null ? a === null : a === void 0 ? s === void 0 : s === void 0 ? a === void 0 : r(a, s);
    }
  });
}), sx = "equalText", IO = ["typed", "compareText", "isZero"], Ql = /* @__PURE__ */ j(sx, IO, (t) => {
  var {
    typed: e,
    compareText: r,
    isZero: n
  } = t;
  return e(sx, {
    "any, any": function(s, o) {
      return n(r(s, o));
    }
  });
}), mu = "smaller", BO = ["typed", "config", "matrix", "DenseMatrix", "concat"], Vl = /* @__PURE__ */ j(mu, BO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: a,
    concat: s
  } = t, o = rn({
    typed: e
  }), p = Jn({
    typed: e,
    DenseMatrix: a
  }), u = br({
    typed: e,
    DenseMatrix: a
  }), f = Jt({
    typed: e,
    matrix: n,
    concat: s
  }), l = Xa({
    typed: e
  });
  return e(mu, RO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (c, h) => c < h,
    "BigNumber, BigNumber": function(h, d) {
      return h.lt(d) && !pn(h, d, r.relTol, r.absTol);
    },
    "bigint, bigint": (c, h) => c < h,
    "Fraction, Fraction": (c, h) => c.compare(h) === -1,
    "Complex, Complex": function(h, d) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, l, f({
    SS: p,
    DS: o,
    Ss: u
  }));
}), RO = /* @__PURE__ */ j(mu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(mu, {
    "number, number": function(a, s) {
      return a < s && !Lr(a, s, r.relTol, r.absTol);
    }
  });
}), du = "smallerEq", LO = ["typed", "config", "matrix", "DenseMatrix", "concat"], Wl = /* @__PURE__ */ j(du, LO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: a,
    concat: s
  } = t, o = rn({
    typed: e
  }), p = Jn({
    typed: e,
    DenseMatrix: a
  }), u = br({
    typed: e,
    DenseMatrix: a
  }), f = Jt({
    typed: e,
    matrix: n,
    concat: s
  }), l = Xa({
    typed: e
  });
  return e(du, PO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (c, h) => c <= h,
    "BigNumber, BigNumber": function(h, d) {
      return h.lte(d) || pn(h, d, r.relTol, r.absTol);
    },
    "bigint, bigint": (c, h) => c <= h,
    "Fraction, Fraction": (c, h) => c.compare(h) !== 1,
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, l, f({
    SS: p,
    DS: o,
    Ss: u
  }));
}), PO = /* @__PURE__ */ j(du, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(du, {
    "number, number": function(a, s) {
      return a <= s || Lr(a, s, r.relTol, r.absTol);
    }
  });
}), vu = "larger", kO = ["typed", "config", "matrix", "DenseMatrix", "concat"], jl = /* @__PURE__ */ j(vu, kO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: a,
    concat: s
  } = t, o = rn({
    typed: e
  }), p = Jn({
    typed: e,
    DenseMatrix: a
  }), u = br({
    typed: e,
    DenseMatrix: a
  }), f = Jt({
    typed: e,
    matrix: n,
    concat: s
  }), l = Xa({
    typed: e
  });
  return e(vu, $O({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (c, h) => c > h,
    "BigNumber, BigNumber": function(h, d) {
      return h.gt(d) && !pn(h, d, r.relTol, r.absTol);
    },
    "bigint, bigint": (c, h) => c > h,
    "Fraction, Fraction": (c, h) => c.compare(h) === 1,
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, l, f({
    SS: p,
    DS: o,
    Ss: u
  }));
}), $O = /* @__PURE__ */ j(vu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(vu, {
    "number, number": function(a, s) {
      return a > s && !Lr(a, s, r.relTol, r.absTol);
    }
  });
}), gu = "largerEq", zO = ["typed", "config", "matrix", "DenseMatrix", "concat"], Zl = /* @__PURE__ */ j(gu, zO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: a,
    concat: s
  } = t, o = rn({
    typed: e
  }), p = Jn({
    typed: e,
    DenseMatrix: a
  }), u = br({
    typed: e,
    DenseMatrix: a
  }), f = Jt({
    typed: e,
    matrix: n,
    concat: s
  }), l = Xa({
    typed: e
  });
  return e(gu, UO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (c, h) => c >= h,
    "BigNumber, BigNumber": function(h, d) {
      return h.gte(d) || pn(h, d, r.relTol, r.absTol);
    },
    "bigint, bigint": function(h, d) {
      return h >= d;
    },
    "Fraction, Fraction": (c, h) => c.compare(h) !== -1,
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, l, f({
    SS: p,
    DS: o,
    Ss: u
  }));
}), UO = /* @__PURE__ */ j(gu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(gu, {
    "number, number": function(a, s) {
      return a >= s || Lr(a, s, r.relTol, r.absTol);
    }
  });
}), ox = "deepEqual", GO = ["typed", "equal"], Jl = /* @__PURE__ */ j(ox, GO, (t) => {
  var {
    typed: e,
    equal: r
  } = t;
  return e(ox, {
    "any, any": function(s, o) {
      return n(s.valueOf(), o.valueOf());
    }
  });
  function n(a, s) {
    if (Array.isArray(a))
      if (Array.isArray(s)) {
        var o = a.length;
        if (o !== s.length)
          return !1;
        for (var p = 0; p < o; p++)
          if (!n(a[p], s[p]))
            return !1;
        return !0;
      } else
        return !1;
    else
      return Array.isArray(s) ? !1 : r(a, s);
  }
}), yu = "unequal", HO = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"], Yl = /* @__PURE__ */ j(yu, HO, (t) => {
  var {
    typed: e,
    config: r,
    equalScalar: n,
    matrix: a,
    DenseMatrix: s,
    concat: o
  } = t, p = rn({
    typed: e
  }), u = Jn({
    typed: e,
    DenseMatrix: s
  }), f = br({
    typed: e,
    DenseMatrix: s
  }), l = Jt({
    typed: e,
    matrix: a,
    concat: o
  });
  return e(yu, QO({
    typed: e,
    equalScalar: n
  }), l({
    elop: c,
    SS: u,
    DS: p,
    Ss: f
  }));
  function c(h, d) {
    return !n(h, d);
  }
}), QO = j(yu, ["typed", "equalScalar"], (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return e(yu, {
    "any, any": function(a, s) {
      return a === null ? s !== null : s === null ? a !== null : a === void 0 ? s !== void 0 : s === void 0 ? a !== void 0 : !r(a, s);
    }
  });
}), ux = "partitionSelect", VO = ["typed", "isNumeric", "isNaN", "compare"], Xl = /* @__PURE__ */ j(ux, VO, (t) => {
  var {
    typed: e,
    isNumeric: r,
    isNaN: n,
    compare: a
  } = t, s = a, o = (f, l) => -a(f, l);
  return e(ux, {
    "Array | Matrix, number": function(l, c) {
      return p(l, c, s);
    },
    "Array | Matrix, number, string": function(l, c, h) {
      if (h === "asc")
        return p(l, c, s);
      if (h === "desc")
        return p(l, c, o);
      throw new Error('Compare string must be "asc" or "desc"');
    },
    "Array | Matrix, number, function": p
  });
  function p(f, l, c) {
    if (!Xe(l) || l < 0)
      throw new Error("k must be a non-negative integer");
    if (tt(f)) {
      var h = f.size();
      if (h.length > 1)
        throw new Error("Only one dimensional matrices supported");
      return u(f.valueOf(), l, c);
    }
    if (Array.isArray(f))
      return u(f, l, c);
  }
  function u(f, l, c) {
    if (l >= f.length)
      throw new Error("k out of bounds");
    for (var h = 0; h < f.length; h++)
      if (r(f[h]) && n(f[h]))
        return f[h];
    for (var d = 0, g = f.length - 1; d < g; ) {
      for (var v = d, N = g, b = f[Math.floor(Math.random() * (g - d + 1)) + d]; v < N; )
        if (c(f[v], b) >= 0) {
          var C = f[N];
          f[N] = f[v], f[v] = C, --N;
        } else
          ++v;
      c(f[v], b) > 0 && --v, l <= v ? g = v : d = v + 1;
    }
    return f[l];
  }
}), lx = "sort", WO = ["typed", "matrix", "compare", "compareNatural"], Kl = /* @__PURE__ */ j(lx, WO, (t) => {
  var {
    typed: e,
    matrix: r,
    compare: n,
    compareNatural: a
  } = t, s = n, o = (l, c) => -n(l, c);
  return e(lx, {
    Array: function(c) {
      return u(c), c.sort(s);
    },
    Matrix: function(c) {
      return f(c), r(c.toArray().sort(s), c.storage());
    },
    "Array, function": function(c, h) {
      return u(c), c.sort(h);
    },
    "Matrix, function": function(c, h) {
      return f(c), r(c.toArray().sort(h), c.storage());
    },
    "Array, string": function(c, h) {
      return u(c), c.sort(p(h));
    },
    "Matrix, string": function(c, h) {
      return f(c), r(c.toArray().sort(p(h)), c.storage());
    }
  });
  function p(l) {
    if (l === "asc")
      return s;
    if (l === "desc")
      return o;
    if (l === "natural")
      return a;
    throw new Error('String "asc", "desc", or "natural" expected');
  }
  function u(l) {
    if (gt(l).length !== 1)
      throw new Error("One dimensional array expected");
  }
  function f(l) {
    if (l.size().length !== 1)
      throw new Error("One dimensional matrix expected");
  }
}), cx = "max", jO = ["typed", "config", "numeric", "larger"], no = /* @__PURE__ */ j(cx, jO, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    larger: a
  } = t;
  return e(cx, {
    // max([a, b, c, d, ...])
    "Array | Matrix": o,
    // max([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(u, f) {
      return zu(u, f.valueOf(), s);
    },
    // max(a, b, c, d, ...)
    "...": function(u) {
      if (Za(u))
        throw new TypeError("Scalar values expected in function max");
      return o(u);
    }
  });
  function s(p, u) {
    try {
      return a(p, u) ? p : u;
    } catch (f) {
      throw tn(f, "max", u);
    }
  }
  function o(p) {
    var u;
    if (hi(p, function(f) {
      try {
        isNaN(f) && typeof f == "number" ? u = NaN : (u === void 0 || a(f, u)) && (u = f);
      } catch (l) {
        throw tn(l, "max", f);
      }
    }), u === void 0)
      throw new Error("Cannot calculate max of an empty array");
    return typeof u == "string" && (u = n(u, Ii(u, r))), u;
  }
}), fx = "min", ZO = ["typed", "config", "numeric", "smaller"], io = /* @__PURE__ */ j(fx, ZO, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    smaller: a
  } = t;
  return e(fx, {
    // min([a, b, c, d, ...])
    "Array | Matrix": o,
    // min([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(u, f) {
      return zu(u, f.valueOf(), s);
    },
    // min(a, b, c, d, ...)
    "...": function(u) {
      if (Za(u))
        throw new TypeError("Scalar values expected in function min");
      return o(u);
    }
  });
  function s(p, u) {
    try {
      return a(p, u) ? p : u;
    } catch (f) {
      throw tn(f, "min", u);
    }
  }
  function o(p) {
    var u;
    if (hi(p, function(f) {
      try {
        isNaN(f) && typeof f == "number" ? u = NaN : (u === void 0 || a(f, u)) && (u = f);
      } catch (l) {
        throw tn(l, "min", f);
      }
    }), u === void 0)
      throw new Error("Cannot calculate min of an empty array");
    return typeof u == "string" && (u = n(u, Ii(u, r))), u;
  }
}), JO = "ImmutableDenseMatrix", YO = ["smaller", "DenseMatrix"], ec = /* @__PURE__ */ j(JO, YO, (t) => {
  var {
    smaller: e,
    DenseMatrix: r
  } = t;
  function n(a, s) {
    if (!(this instanceof n))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (s && !Er(s))
      throw new Error("Invalid datatype: " + s);
    if (tt(a) || Rt(a)) {
      var o = new r(a, s);
      this._data = o._data, this._size = o._size, this._datatype = o._datatype, this._min = null, this._max = null;
    } else if (a && Rt(a.data) && Rt(a.size))
      this._data = a.data, this._size = a.size, this._datatype = a.datatype, this._min = typeof a.min < "u" ? a.min : null, this._max = typeof a.max < "u" ? a.max : null;
    else {
      if (a)
        throw new TypeError("Unsupported type of data (" + Vt(a) + ")");
      this._data = [], this._size = [0], this._datatype = s, this._min = null, this._max = null;
    }
  }
  return n.prototype = new r(), n.prototype.type = "ImmutableDenseMatrix", n.prototype.isImmutableDenseMatrix = !0, n.prototype.subset = function(a) {
    switch (arguments.length) {
      case 1: {
        var s = r.prototype.subset.call(this, a);
        return tt(s) ? new n({
          data: s._data,
          size: s._size,
          datatype: s._datatype
        }) : s;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  }, n.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  }, n.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  }, n.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  }, n.prototype.clone = function() {
    return new n({
      data: nt(this._data),
      size: nt(this._size),
      datatype: this._datatype
    });
  }, n.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  }, n.fromJSON = function(a) {
    return new n(a);
  }, n.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  }, n.prototype.min = function() {
    if (this._min === null) {
      var a = null;
      this.forEach(function(s) {
        (a === null || e(s, a)) && (a = s);
      }), this._min = a !== null ? a : void 0;
    }
    return this._min;
  }, n.prototype.max = function() {
    if (this._max === null) {
      var a = null;
      this.forEach(function(s) {
        (a === null || e(a, s)) && (a = s);
      }), this._max = a !== null ? a : void 0;
    }
    return this._max;
  }, n;
}, {
  isClass: !0
}), XO = "Index", KO = ["ImmutableDenseMatrix", "getMatrixDataType"], tc = /* @__PURE__ */ j(XO, KO, (t) => {
  var {
    ImmutableDenseMatrix: e,
    getMatrixDataType: r
  } = t;
  function n(s) {
    if (!(this instanceof n))
      throw new SyntaxError("Constructor must be called with the new operator");
    this._dimensions = [], this._sourceSize = [], this._isScalar = !0;
    for (var o = 0, p = arguments.length; o < p; o++) {
      var u = arguments[o], f = Rt(u), l = tt(u), c = null;
      if (ks(u))
        this._dimensions.push(u), this._isScalar = !1;
      else if (f || l) {
        var h = void 0;
        r(u) === "boolean" ? (f && (h = a(px(u).valueOf())), l && (h = a(px(u._data).valueOf())), c = u.valueOf().length) : h = a(u.valueOf()), this._dimensions.push(h);
        var d = h.size();
        (d.length !== 1 || d[0] !== 1 || c !== null) && (this._isScalar = !1);
      } else if (typeof u == "number")
        this._dimensions.push(a([u]));
      else if (typeof u == "string")
        this._dimensions.push(u);
      else
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      this._sourceSize.push(c);
    }
  }
  n.prototype.type = "Index", n.prototype.isIndex = !0;
  function a(s) {
    for (var o = 0, p = s.length; o < p; o++)
      if (typeof s[o] != "number" || !Xe(s[o]))
        throw new TypeError("Index parameters must be positive integer numbers");
    return new e(s);
  }
  return n.prototype.clone = function() {
    var s = new n();
    return s._dimensions = nt(this._dimensions), s._isScalar = this._isScalar, s._sourceSize = this._sourceSize, s;
  }, n.create = function(s) {
    var o = new n();
    return n.apply(o, s), o;
  }, n.prototype.size = function() {
    for (var s = [], o = 0, p = this._dimensions.length; o < p; o++) {
      var u = this._dimensions[o];
      s[o] = typeof u == "string" ? 1 : u.size()[0];
    }
    return s;
  }, n.prototype.max = function() {
    for (var s = [], o = 0, p = this._dimensions.length; o < p; o++) {
      var u = this._dimensions[o];
      s[o] = typeof u == "string" ? u : u.max();
    }
    return s;
  }, n.prototype.min = function() {
    for (var s = [], o = 0, p = this._dimensions.length; o < p; o++) {
      var u = this._dimensions[o];
      s[o] = typeof u == "string" ? u : u.min();
    }
    return s;
  }, n.prototype.forEach = function(s) {
    for (var o = 0, p = this._dimensions.length; o < p; o++)
      s(this._dimensions[o], o, this);
  }, n.prototype.dimension = function(s) {
    return this._dimensions[s] || null;
  }, n.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] == "string";
  }, n.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  }, n.prototype.isScalar = function() {
    return this._isScalar;
  }, n.prototype.toArray = function() {
    for (var s = [], o = 0, p = this._dimensions.length; o < p; o++) {
      var u = this._dimensions[o];
      s.push(typeof u == "string" ? u : u.toArray());
    }
    return s;
  }, n.prototype.valueOf = n.prototype.toArray, n.prototype.toString = function() {
    for (var s = [], o = 0, p = this._dimensions.length; o < p; o++) {
      var u = this._dimensions[o];
      typeof u == "string" ? s.push(JSON.stringify(u)) : s.push(u.toString());
    }
    return "[" + s.join(", ") + "]";
  }, n.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  }, n.fromJSON = function(s) {
    return n.create(s.dimensions);
  }, n;
}, {
  isClass: !0
});
function px(t) {
  var e = [];
  return t.forEach((r, n) => {
    r && e.push(n);
  }), e;
}
var eF = "FibonacciHeap", tF = ["smaller", "larger"], rc = /* @__PURE__ */ j(eF, tF, (t) => {
  var {
    smaller: e,
    larger: r
  } = t, n = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function a() {
    if (!(this instanceof a))
      throw new SyntaxError("Constructor must be called with the new operator");
    this._minimum = null, this._size = 0;
  }
  a.prototype.type = "FibonacciHeap", a.prototype.isFibonacciHeap = !0, a.prototype.insert = function(l, c) {
    var h = {
      key: l,
      value: c,
      degree: 0
    };
    if (this._minimum) {
      var d = this._minimum;
      h.left = d, h.right = d.right, d.right = h, h.right.left = h, e(l, d.key) && (this._minimum = h);
    } else
      h.left = h, h.right = h, this._minimum = h;
    return this._size++, h;
  }, a.prototype.size = function() {
    return this._size;
  }, a.prototype.clear = function() {
    this._minimum = null, this._size = 0;
  }, a.prototype.isEmpty = function() {
    return this._size === 0;
  }, a.prototype.extractMinimum = function() {
    var l = this._minimum;
    if (l === null)
      return l;
    for (var c = this._minimum, h = l.degree, d = l.child; h > 0; ) {
      var g = d.right;
      d.left.right = d.right, d.right.left = d.left, d.left = c, d.right = c.right, c.right = d, d.right.left = d, d.parent = null, d = g, h--;
    }
    return l.left.right = l.right, l.right.left = l.left, l === l.right ? c = null : (c = l.right, c = f(c, this._size)), this._size--, this._minimum = c, l;
  }, a.prototype.remove = function(l) {
    this._minimum = s(this._minimum, l, -1), this.extractMinimum();
  };
  function s(l, c, h) {
    c.key = h;
    var d = c.parent;
    return d && e(c.key, d.key) && (o(l, c, d), p(l, d)), e(c.key, l.key) && (l = c), l;
  }
  function o(l, c, h) {
    c.left.right = c.right, c.right.left = c.left, h.degree--, h.child === c && (h.child = c.right), h.degree === 0 && (h.child = null), c.left = l, c.right = l.right, l.right = c, c.right.left = c, c.parent = null, c.mark = !1;
  }
  function p(l, c) {
    var h = c.parent;
    h && (c.mark ? (o(l, c, h), p(h)) : c.mark = !0);
  }
  var u = function(c, h) {
    c.left.right = c.right, c.right.left = c.left, c.parent = h, h.child ? (c.left = h.child, c.right = h.child.right, h.child.right = c, c.right.left = c) : (h.child = c, c.right = c, c.left = c), h.degree++, c.mark = !1;
  };
  function f(l, c) {
    var h = Math.floor(Math.log(c) * n) + 1, d = new Array(h), g = 0, v = l;
    if (v)
      for (g++, v = v.right; v !== l; )
        g++, v = v.right;
    for (var N; g > 0; ) {
      for (var b = v.degree, C = v.right; N = d[b], !!N; ) {
        if (r(v.key, N.key)) {
          var x = N;
          N = v, v = x;
        }
        u(N, v), d[b] = null, b++;
      }
      d[b] = v, v = C, g--;
    }
    l = null;
    for (var E = 0; E < h; E++)
      N = d[E], N && (l ? (N.left.right = N.right, N.right.left = N.left, N.left = l, N.right = l.right, l.right = N, N.right.left = N, e(N.key, l.key) && (l = N)) : l = N);
    return l;
  }
  return a;
}, {
  isClass: !0
}), rF = "Spa", nF = ["addScalar", "equalScalar", "FibonacciHeap"], nc = /* @__PURE__ */ j(rF, nF, (t) => {
  var {
    addScalar: e,
    equalScalar: r,
    FibonacciHeap: n
  } = t;
  function a() {
    if (!(this instanceof a))
      throw new SyntaxError("Constructor must be called with the new operator");
    this._values = [], this._heap = new n();
  }
  return a.prototype.type = "Spa", a.prototype.isSpa = !0, a.prototype.set = function(s, o) {
    if (this._values[s])
      this._values[s].value = o;
    else {
      var p = this._heap.insert(s, o);
      this._values[s] = p;
    }
  }, a.prototype.get = function(s) {
    var o = this._values[s];
    return o ? o.value : 0;
  }, a.prototype.accumulate = function(s, o) {
    var p = this._values[s];
    p ? p.value = e(p.value, o) : (p = this._heap.insert(s, o), this._values[s] = p);
  }, a.prototype.forEach = function(s, o, p) {
    var u = this._heap, f = this._values, l = [], c = u.extractMinimum();
    for (c && l.push(c); c && c.key <= o; )
      c.key >= s && (r(c.value, 0) || p(c.key, c.value, this)), c = u.extractMinimum(), c && l.push(c);
    for (var h = 0; h < l.length; h++) {
      var d = l[h];
      c = u.insert(d.key, d.value), f[c.key] = c;
    }
  }, a.prototype.swap = function(s, o) {
    var p = this._values[s], u = this._values[o];
    if (!p && u)
      p = this._heap.insert(s, u.value), this._heap.remove(u), this._values[s] = p, this._values[o] = void 0;
    else if (p && !u)
      u = this._heap.insert(o, p.value), this._heap.remove(p), this._values[o] = u, this._values[s] = void 0;
    else if (p && u) {
      var f = p.value;
      p.value = u.value, u.value = f;
    }
  }, a;
}, {
  isClass: !0
}), iF = Us(function(t) {
  return new t(1).exp();
}, {
  hasher: ic
}), aF = Us(function(t) {
  return new t(1).plus(new t(5).sqrt()).div(2);
}, {
  hasher: ic
}), Id = Us(function(t) {
  return t.acos(-1);
}, {
  hasher: ic
}), sF = Us(function(t) {
  return Id(t).times(2);
}, {
  hasher: ic
});
function ic(t) {
  return t[0].precision;
}
function hx(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Lm(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? hx(Object(r), !0).forEach(function(n) {
      xr(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : hx(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var oF = "Unit", uF = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"], ac = /* @__PURE__ */ j(oF, uF, (t) => {
  var {
    on: e,
    config: r,
    addScalar: n,
    subtractScalar: a,
    multiplyScalar: s,
    divideScalar: o,
    pow: p,
    abs: u,
    fix: f,
    round: l,
    equal: c,
    isNumeric: h,
    format: d,
    number: g,
    Complex: v,
    BigNumber: N,
    Fraction: b
  } = t, C = g;
  function x(V, re) {
    if (!(this instanceof x))
      throw new Error("Constructor must be called with the new operator");
    if (!(V == null || h(V) || Mn(V)))
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    if (this.fixPrefix = !1, this.skipAutomaticSimplification = !0, re === void 0)
      this.units = [], this.dimensions = G.map((X) => 0);
    else if (typeof re == "string") {
      var pe = x.parse(re);
      this.units = pe.units, this.dimensions = pe.dimensions;
    } else if (Xr(re) && re.value === null)
      this.fixPrefix = re.fixPrefix, this.skipAutomaticSimplification = re.skipAutomaticSimplification, this.dimensions = re.dimensions.slice(0), this.units = re.units.map((X) => hr({}, X));
    else
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    this.value = this._normalize(V);
  }
  Object.defineProperty(x, "name", {
    value: "Unit"
  }), x.prototype.constructor = x, x.prototype.type = "Unit", x.prototype.isUnit = !0;
  var E, D, A;
  function M() {
    for (; A === " " || A === "	"; )
      T();
  }
  function _(V) {
    return V >= "0" && V <= "9" || V === ".";
  }
  function O(V) {
    return V >= "0" && V <= "9";
  }
  function T() {
    D++, A = E.charAt(D);
  }
  function I(V) {
    D = V, A = E.charAt(D);
  }
  function q() {
    var V = "", re = D;
    if (A === "+" ? T() : A === "-" && (V += A, T()), !_(A))
      return I(re), null;
    if (A === ".") {
      if (V += A, T(), !O(A))
        return I(re), null;
    } else {
      for (; O(A); )
        V += A, T();
      A === "." && (V += A, T());
    }
    for (; O(A); )
      V += A, T();
    if (A === "E" || A === "e") {
      var pe = "", X = D;
      if (pe += A, T(), (A === "+" || A === "-") && (pe += A, T()), !O(A))
        return I(X), V;
      for (V = V + pe; O(A); )
        V += A, T();
    }
    return V;
  }
  function $() {
    for (var V = ""; O(A) || x.isValidAlpha(A); )
      V += A, T();
    var re = V.charAt(0);
    return x.isValidAlpha(re) ? V : null;
  }
  function U(V) {
    return A === V ? (T(), V) : null;
  }
  x.parse = function(V, re) {
    if (re = re || {}, E = V, D = -1, A = "", typeof E != "string")
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    var pe = new x();
    pe.units = [];
    var X = 1, ie = !1;
    T(), M();
    var me = q(), Ae = null;
    if (me) {
      if (r.number === "BigNumber")
        Ae = new N(me);
      else if (r.number === "Fraction")
        try {
          Ae = new b(me);
        } catch {
          Ae = parseFloat(me);
        }
      else
        Ae = parseFloat(me);
      M(), U("*") ? (X = 1, ie = !0) : U("/") && (X = -1, ie = !0);
    }
    for (var Me = [], Q = 1; ; ) {
      for (M(); A === "("; )
        Me.push(X), Q *= X, X = 1, T(), M();
      var ee = void 0;
      if (A) {
        var ye = A;
        if (ee = $(), ee === null)
          throw new SyntaxError('Unexpected "' + ye + '" in "' + E + '" at index ' + D.toString());
      } else
        break;
      var Ee = k(ee);
      if (Ee === null)
        throw new SyntaxError('Unit "' + ee + '" not found.');
      var Ce = X * Q;
      if (M(), U("^")) {
        M();
        var De = q();
        if (De === null)
          throw new SyntaxError('In "' + V + '", "^" must be followed by a floating-point number');
        Ce *= De;
      }
      pe.units.push({
        unit: Ee.unit,
        prefix: Ee.prefix,
        power: Ce
      });
      for (var Oe = 0; Oe < G.length; Oe++)
        pe.dimensions[Oe] += (Ee.unit.dimensions[Oe] || 0) * Ce;
      for (M(); A === ")"; ) {
        if (Me.length === 0)
          throw new SyntaxError('Unmatched ")" in "' + E + '" at index ' + D.toString());
        Q /= Me.pop(), T(), M();
      }
      if (ie = !1, U("*") ? (X = 1, ie = !0) : U("/") ? (X = -1, ie = !0) : X = 1, Ee.unit.base) {
        var Be = Ee.unit.base.key;
        K.auto[Be] = {
          unit: Ee.unit,
          prefix: Ee.prefix
        };
      }
    }
    if (M(), A)
      throw new SyntaxError('Could not parse: "' + V + '"');
    if (ie)
      throw new SyntaxError('Trailing characters: "' + V + '"');
    if (Me.length !== 0)
      throw new SyntaxError('Unmatched "(" in "' + E + '"');
    if (pe.units.length === 0 && !re.allowNoUnits)
      throw new SyntaxError('"' + V + '" contains no units');
    return pe.value = Ae !== void 0 ? pe._normalize(Ae) : null, pe;
  }, x.prototype.clone = function() {
    var V = new x();
    V.fixPrefix = this.fixPrefix, V.skipAutomaticSimplification = this.skipAutomaticSimplification, V.value = nt(this.value), V.dimensions = this.dimensions.slice(0), V.units = [];
    for (var re = 0; re < this.units.length; re++) {
      V.units[re] = {};
      for (var pe in this.units[re])
        We(this.units[re], pe) && (V.units[re][pe] = this.units[re][pe]);
    }
    return V;
  }, x.prototype.valueType = function() {
    return Vt(this.value);
  }, x.prototype._isDerived = function() {
    return this.units.length === 0 ? !1 : this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  }, x.prototype._normalize = function(V) {
    if (V == null || this.units.length === 0)
      return V;
    for (var re = V, pe = x._getNumberConverter(Vt(V)), X = 0; X < this.units.length; X++) {
      var ie = pe(this.units[X].unit.value), me = pe(this.units[X].prefix.value), Ae = pe(this.units[X].power);
      re = s(re, p(s(ie, me), Ae));
    }
    return re;
  }, x.prototype._denormalize = function(V, re) {
    if (V == null || this.units.length === 0)
      return V;
    for (var pe = V, X = x._getNumberConverter(Vt(V)), ie = 0; ie < this.units.length; ie++) {
      var me = X(this.units[ie].unit.value), Ae = X(this.units[ie].prefix.value), Me = X(this.units[ie].power);
      pe = o(pe, p(s(me, Ae), Me));
    }
    return pe;
  };
  var k = Us((V) => {
    if (We(H, V)) {
      var re = H[V], pe = re.prefixes[""];
      return {
        unit: re,
        prefix: pe
      };
    }
    for (var X in H)
      if (We(H, X) && FT(V, X)) {
        var ie = H[X], me = V.length - X.length, Ae = V.substring(0, me), Me = We(ie.prefixes, Ae) ? ie.prefixes[Ae] : void 0;
        if (Me !== void 0)
          return {
            unit: ie,
            prefix: Me
          };
      }
    return null;
  }, {
    hasher: (V) => V[0],
    limit: 100
  });
  x.isValuelessUnit = function(V) {
    return k(V) !== null;
  }, x.prototype.hasBase = function(V) {
    if (typeof V == "string" && (V = P[V]), !V)
      return !1;
    for (var re = 0; re < G.length; re++)
      if (Math.abs((this.dimensions[re] || 0) - (V.dimensions[re] || 0)) > 1e-12)
        return !1;
    return !0;
  }, x.prototype.equalBase = function(V) {
    for (var re = 0; re < G.length; re++)
      if (Math.abs((this.dimensions[re] || 0) - (V.dimensions[re] || 0)) > 1e-12)
        return !1;
    return !0;
  }, x.prototype.equals = function(V) {
    return this.equalBase(V) && c(this.value, V.value);
  }, x.prototype.multiply = function(V) {
    for (var re = this.clone(), pe = Xr(V) ? V : new x(V), X = 0; X < G.length; X++)
      re.dimensions[X] = (this.dimensions[X] || 0) + (pe.dimensions[X] || 0);
    for (var ie = 0; ie < pe.units.length; ie++) {
      var me = Lm({}, pe.units[ie]);
      re.units.push(me);
    }
    if (this.value !== null || pe.value !== null) {
      var Ae = this.value === null ? this._normalize(1) : this.value, Me = pe.value === null ? pe._normalize(1) : pe.value;
      re.value = s(Ae, Me);
    } else
      re.value = null;
    return Xr(V) && (re.skipAutomaticSimplification = !1), L(re);
  }, x.prototype.divideInto = function(V) {
    return new x(V).divide(this);
  }, x.prototype.divide = function(V) {
    for (var re = this.clone(), pe = Xr(V) ? V : new x(V), X = 0; X < G.length; X++)
      re.dimensions[X] = (this.dimensions[X] || 0) - (pe.dimensions[X] || 0);
    for (var ie = 0; ie < pe.units.length; ie++) {
      var me = Lm(Lm({}, pe.units[ie]), {}, {
        power: -pe.units[ie].power
      });
      re.units.push(me);
    }
    if (this.value !== null || pe.value !== null) {
      var Ae = this.value === null ? this._normalize(1) : this.value, Me = pe.value === null ? pe._normalize(1) : pe.value;
      re.value = o(Ae, Me);
    } else
      re.value = null;
    return Xr(V) && (re.skipAutomaticSimplification = !1), L(re);
  }, x.prototype.pow = function(V) {
    for (var re = this.clone(), pe = 0; pe < G.length; pe++)
      re.dimensions[pe] = (this.dimensions[pe] || 0) * V;
    for (var X = 0; X < re.units.length; X++)
      re.units[X].power *= V;
    return re.value !== null ? re.value = p(re.value, V) : re.value = null, re.skipAutomaticSimplification = !1, L(re);
  };
  function L(V) {
    return V.equalBase(P.NONE) && V.value !== null && !r.predictable ? V.value : V;
  }
  x.prototype.abs = function() {
    var V = this.clone();
    if (V.value !== null)
      if (V._isDerived() || V.units.length === 0 || V.units[0].unit.offset === 0)
        V.value = u(V.value);
      else {
        var re = V._numberConverter(), pe = re(V.units[0].unit.value), X = re(V.units[0].unit.offset), ie = s(pe, X);
        V.value = a(u(n(V.value, ie)), ie);
      }
    for (var me in V.units)
      (V.units[me].unit.name === "VA" || V.units[me].unit.name === "VAR") && (V.units[me].unit = H.W);
    return V;
  }, x.prototype.to = function(V) {
    var re = this.value === null ? this._normalize(1) : this.value, pe;
    if (typeof V == "string")
      pe = x.parse(V);
    else if (Xr(V))
      pe = V.clone();
    else
      throw new Error("String or Unit expected as parameter");
    if (!this.equalBase(pe))
      throw new Error("Units do not match ('".concat(pe.toString(), "' != '").concat(this.toString(), "')"));
    if (pe.value !== null)
      throw new Error("Cannot convert to a unit with a value");
    if (this.value === null || this._isDerived() || this.units.length === 0 || pe.units.length === 0 || this.units[0].unit.offset === pe.units[0].unit.offset)
      pe.value = nt(re);
    else {
      var X = x._getNumberConverter(Vt(re)), ie = this.units[0].unit.value, me = this.units[0].unit.offset, Ae = s(ie, me), Me = pe.units[0].unit.value, Q = pe.units[0].unit.offset, ee = s(Me, Q);
      pe.value = n(re, X(a(Ae, ee)));
    }
    return pe.fixPrefix = !0, pe.skipAutomaticSimplification = !0, pe;
  }, x.prototype.toNumber = function(V) {
    return C(this.toNumeric(V));
  }, x.prototype.toNumeric = function(V) {
    var re;
    return V ? re = this.to(V) : re = this.clone(), re._isDerived() || re.units.length === 0 ? re._denormalize(re.value) : re._denormalize(re.value, re.units[0].prefix.value);
  }, x.prototype.toString = function() {
    return this.format();
  }, x.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.units.length > 0 ? this.formatUnits() : null,
      fixPrefix: this.fixPrefix
    };
  }, x.fromJSON = function(V) {
    var re, pe = new x(V.value, (re = V.unit) !== null && re !== void 0 ? re : void 0);
    return pe.fixPrefix = V.fixPrefix || !1, pe;
  }, x.prototype.valueOf = x.prototype.toString, x.prototype.simplify = function() {
    var V = this.clone(), re = [], pe;
    for (var X in ce)
      if (We(ce, X) && V.hasBase(P[X])) {
        pe = X;
        break;
      }
    if (pe === "NONE")
      V.units = [];
    else {
      var ie;
      if (pe && We(ce, pe) && (ie = ce[pe]), ie)
        V.units = [{
          unit: ie.unit,
          prefix: ie.prefix,
          power: 1
        }];
      else {
        for (var me = !1, Ae = 0; Ae < G.length; Ae++) {
          var Me = G[Ae];
          Math.abs(V.dimensions[Ae] || 0) > 1e-12 && (We(ce, Me) ? re.push({
            unit: ce[Me].unit,
            prefix: ce[Me].prefix,
            power: V.dimensions[Ae] || 0
          }) : me = !0);
        }
        re.length < V.units.length && !me && (V.units = re);
      }
    }
    return V;
  }, x.prototype.toSI = function() {
    for (var V = this.clone(), re = [], pe = 0; pe < G.length; pe++) {
      var X = G[pe];
      if (Math.abs(V.dimensions[pe] || 0) > 1e-12)
        if (We(K.si, X))
          re.push({
            unit: K.si[X].unit,
            prefix: K.si[X].prefix,
            power: V.dimensions[pe] || 0
          });
        else
          throw new Error("Cannot express custom unit " + X + " in SI units");
    }
    return V.units = re, V.fixPrefix = !0, V.skipAutomaticSimplification = !0, this.value !== null ? (V.value = null, this.to(V)) : V;
  }, x.prototype.formatUnits = function() {
    for (var V = "", re = "", pe = 0, X = 0, ie = 0; ie < this.units.length; ie++)
      this.units[ie].power > 0 ? (pe++, V += " " + this.units[ie].prefix.name + this.units[ie].unit.name, Math.abs(this.units[ie].power - 1) > 1e-15 && (V += "^" + this.units[ie].power)) : this.units[ie].power < 0 && X++;
    if (X > 0)
      for (var me = 0; me < this.units.length; me++)
        this.units[me].power < 0 && (pe > 0 ? (re += " " + this.units[me].prefix.name + this.units[me].unit.name, Math.abs(this.units[me].power + 1) > 1e-15 && (re += "^" + -this.units[me].power)) : (re += " " + this.units[me].prefix.name + this.units[me].unit.name, re += "^" + this.units[me].power));
    V = V.substr(1), re = re.substr(1), pe > 1 && X > 0 && (V = "(" + V + ")"), X > 1 && pe > 0 && (re = "(" + re + ")");
    var Ae = V;
    return pe > 0 && X > 0 && (Ae += " / "), Ae += re, Ae;
  }, x.prototype.format = function(V) {
    var re = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify(), pe = !1;
    typeof re.value < "u" && re.value !== null && Mn(re.value) && (pe = Math.abs(re.value.re) < 1e-14);
    for (var X in re.units)
      We(re.units, X) && re.units[X].unit && (re.units[X].unit.name === "VA" && pe ? re.units[X].unit = H.VAR : re.units[X].unit.name === "VAR" && !pe && (re.units[X].unit = H.VA));
    re.units.length === 1 && !re.fixPrefix && Math.abs(re.units[0].power - Math.round(re.units[0].power)) < 1e-14 && (re.units[0].prefix = re._bestPrefix());
    var ie = re._denormalize(re.value), me = re.value !== null ? d(ie, V || {}) : "", Ae = re.formatUnits();
    return re.value && Mn(re.value) && (me = "(" + me + ")"), Ae.length > 0 && me.length > 0 && (me += " "), me += Ae, me;
  }, x.prototype._bestPrefix = function() {
    if (this.units.length !== 1)
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14)
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    var V = this.value !== null ? u(this.value) : 0, re = u(this.units[0].unit.value), pe = this.units[0].prefix;
    if (V === 0)
      return pe;
    var X = this.units[0].power, ie = Math.log(V / Math.pow(pe.value * re, X)) / Math.LN10 - 1.2;
    if (ie > -2.200001 && ie < 1.800001) return pe;
    ie = Math.abs(ie);
    var me = this.units[0].unit.prefixes;
    for (var Ae in me)
      if (We(me, Ae)) {
        var Me = me[Ae];
        if (Me.scientific) {
          var Q = Math.abs(Math.log(V / Math.pow(Me.value * re, X)) / Math.LN10 - 1.2);
          (Q < ie || Q === ie && Me.name.length < pe.name.length) && (pe = Me, ie = Q);
        }
      }
    return pe;
  }, x.prototype.splitUnit = function(V) {
    for (var re = this.clone(), pe = [], X = 0; X < V.length && (re = re.to(V[X]), X !== V.length - 1); X++) {
      var ie = re.toNumeric(), me = l(ie), Ae = void 0, Me = c(me, ie);
      Me ? Ae = me : Ae = f(re.toNumeric());
      var Q = new x(Ae, V[X].toString());
      pe.push(Q), re = a(re, Q);
    }
    for (var ee = 0, ye = 0; ye < pe.length; ye++)
      ee = n(ee, pe[ye].value);
    return c(ee, this.value) && (re.value = 0), pe.push(re), pe;
  };
  var R = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      da: {
        name: "da",
        value: 10,
        scientific: !1
      },
      h: {
        name: "h",
        value: 100,
        scientific: !1
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: !0
      },
      R: {
        name: "R",
        value: 1e27,
        scientific: !0
      },
      Q: {
        name: "Q",
        value: 1e30,
        scientific: !0
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: !1
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: !1
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: !0
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: !0
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: !0
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: !0
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: !0
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: !0
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: !0
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: !0
      },
      r: {
        name: "r",
        value: 1e-27,
        scientific: !0
      },
      q: {
        name: "q",
        value: 1e-30,
        scientific: !0
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: !1
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: !1
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: !0
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: !0
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: !0
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: !0
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: !0
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: !0
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: !0
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: !0
      },
      ronna: {
        name: "ronna",
        value: 1e27,
        scientific: !0
      },
      quetta: {
        name: "quetta",
        value: 1e30,
        scientific: !0
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: !1
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: !1
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: !0
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: !0
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: !0
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: !0
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: !0
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: !0
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: !0
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: !0
      },
      ronto: {
        name: "ronto",
        value: 1e-27,
        scientific: !0
      },
      quecto: {
        name: "quecto",
        value: 1e-30,
        scientific: !0
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      da: {
        name: "da",
        value: 100,
        scientific: !1
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: !1
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: !0
      },
      R: {
        name: "R",
        value: 1e54,
        scientific: !0
      },
      Q: {
        name: "Q",
        value: 1e60,
        scientific: !0
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: !1
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: !1
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: !0
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: !0
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: !0
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: !0
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: !0
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: !0
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: !0
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: !0
      },
      r: {
        name: "r",
        value: 1e-54,
        scientific: !0
      },
      q: {
        name: "q",
        value: 1e-60,
        scientific: !0
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: !1
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: !1
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: !0
      },
      R: {
        name: "R",
        value: 1e81,
        scientific: !0
      },
      Q: {
        name: "Q",
        value: 1e90,
        scientific: !0
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: !1
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: !1
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: !0
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: !0
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: !0
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: !0
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: !0
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: !0
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: !0
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: !0
      },
      r: {
        name: "r",
        value: 1e-81,
        scientific: !0
      },
      q: {
        name: "q",
        value: 1e-90,
        scientific: !0
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: !0
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: !0
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: !0
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: !0
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: !0
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: !0
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: !0
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: !0
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: !0
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: !0
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: !0
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: !0
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: !0
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: !0
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: !0
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: !0
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: !0
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: !0
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: !0
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: !0
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: !0
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: !0
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: !0
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: !0
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: !0
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: !0
      }
    }
  };
  R.SHORTLONG = hr({}, R.SHORT, R.LONG), R.BINARY_SHORT = hr({}, R.BINARY_SHORT_SI, R.BINARY_SHORT_IEC), R.BINARY_LONG = hr({}, R.BINARY_LONG_SI, R.BINARY_LONG_IEC);
  var G = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"], P = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var W in P)
    We(P, W) && (P[W].key = W);
  var le = {}, Z = {
    name: "",
    base: le,
    value: 1,
    offset: 0,
    dimensions: G.map((V) => 0)
  }, H = {
    // length
    meter: {
      name: "meter",
      base: P.LENGTH,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: P.LENGTH,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: P.LENGTH,
      prefixes: R.NONE,
      value: 254e-7,
      offset: 0
    },
    // 1/1000 inch
    // Surface
    m2: {
      name: "m2",
      base: P.SURFACE,
      prefixes: R.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 64516e-8,
      offset: 0
    },
    // 645.16 mm2
    sqft: {
      name: "sqft",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 0.09290304,
      offset: 0
    },
    // 0.09290304 m2
    sqyd: {
      name: "sqyd",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 0.83612736,
      offset: 0
    },
    // 0.83612736 m2
    sqmi: {
      name: "sqmi",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    // 2.589988110336 km2
    sqrd: {
      name: "sqrd",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 25.29295,
      offset: 0
    },
    // 25.29295 m2
    sqch: {
      name: "sqch",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 404.6873,
      offset: 0
    },
    // 404.6873 m2
    sqmil: {
      name: "sqmil",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 64516e-14,
      offset: 0
    },
    // 6.4516 * 10^-10 m2
    acre: {
      name: "acre",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 4046.86,
      offset: 0
    },
    // 4046.86 m2
    hectare: {
      name: "hectare",
      base: P.SURFACE,
      prefixes: R.NONE,
      value: 1e4,
      offset: 0
    },
    // 10000 m2
    // Volume
    m3: {
      name: "m3",
      base: P.VOLUME,
      prefixes: R.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: P.VOLUME,
      prefixes: R.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    l: {
      name: "l",
      base: P.VOLUME,
      prefixes: R.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    litre: {
      name: "litre",
      base: P.VOLUME,
      prefixes: R.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 16387064e-12,
      offset: 0
    },
    // 1.6387064e-5 m3
    cuft: {
      name: "cuft",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 0.028316846592,
      offset: 0
    },
    // 28.316 846 592 L
    cuyd: {
      name: "cuyd",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 0.764554857984,
      offset: 0
    },
    // 764.554 857 984 L
    teaspoon: {
      name: "teaspoon",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 5e-6,
      offset: 0
    },
    // 5 mL
    tablespoon: {
      name: "tablespoon",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 15e-6,
      offset: 0
    },
    // 15 mL
    // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: "drop",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    gtt: {
      name: "gtt",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    // Liquid volume
    minim: {
      name: "minim",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 6161152e-14,
      offset: 0
    },
    // 0.06161152 mL
    fluiddram: {
      name: "fluiddram",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    fluidounce: {
      name: "fluidounce",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gill: {
      name: "gill",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cc: {
      name: "cc",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 1e-6,
      offset: 0
    },
    // 1e-6 L
    cup: {
      name: "cup",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pint: {
      name: "pint",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    quart: {
      name: "quart",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gallon: {
      name: "gallon",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    beerbarrel: {
      name: "beerbarrel",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    oilbarrel: {
      name: "oilbarrel",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    hogshead: {
      name: "hogshead",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 0.238481,
      offset: 0
    },
    // 238.4810 L
    // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
    fldr: {
      name: "fldr",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    floz: {
      name: "floz",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gi: {
      name: "gi",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cp: {
      name: "cp",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pt: {
      name: "pt",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    qt: {
      name: "qt",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gal: {
      name: "gal",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    bbl: {
      name: "bbl",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    obl: {
      name: "obl",
      base: P.VOLUME,
      prefixes: R.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
    // Mass
    g: {
      name: "g",
      base: P.MASS,
      prefixes: R.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: P.MASS,
      prefixes: R.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: P.MASS,
      prefixes: R.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: P.MASS,
      prefixes: R.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: P.MASS,
      prefixes: R.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: P.MASS,
      prefixes: R.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: P.MASS,
      prefixes: R.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: P.MASS,
      prefixes: R.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: P.MASS,
      prefixes: R.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: P.MASS,
      prefixes: R.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: P.MASS,
      prefixes: R.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: P.MASS,
      prefixes: R.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: P.MASS,
      prefixes: R.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: P.MASS,
      prefixes: R.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: P.MASS,
      prefixes: R.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: P.MASS,
      prefixes: R.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: P.MASS,
      prefixes: R.NONE,
      value: 45.359237,
      offset: 0
    },
    // Time
    s: {
      name: "s",
      base: P.TIME,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: P.TIME,
      prefixes: R.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: P.TIME,
      prefixes: R.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: P.TIME,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: P.TIME,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: P.TIME,
      prefixes: R.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: P.TIME,
      prefixes: R.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: P.TIME,
      prefixes: R.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: P.TIME,
      prefixes: R.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: P.TIME,
      prefixes: R.NONE,
      value: 2629800,
      // 1/12th of Julian year
      offset: 0
    },
    year: {
      name: "year",
      base: P.TIME,
      prefixes: R.NONE,
      value: 31557600,
      // Julian year
      offset: 0
    },
    decade: {
      name: "decade",
      base: P.TIME,
      prefixes: R.NONE,
      value: 315576e3,
      // Julian decade
      offset: 0
    },
    century: {
      name: "century",
      base: P.TIME,
      prefixes: R.NONE,
      value: 315576e4,
      // Julian century
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: P.TIME,
      prefixes: R.NONE,
      value: 315576e5,
      // Julian millennium
      offset: 0
    },
    // Frequency
    hertz: {
      name: "Hertz",
      base: P.FREQUENCY,
      prefixes: R.LONG,
      value: 1,
      offset: 0,
      reciprocal: !0
    },
    Hz: {
      name: "Hz",
      base: P.FREQUENCY,
      prefixes: R.SHORT,
      value: 1,
      offset: 0,
      reciprocal: !0
    },
    // Angle
    rad: {
      name: "rad",
      base: P.ANGLE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: P.ANGLE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: "deg",
      base: P.ANGLE,
      prefixes: R.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    degree: {
      name: "degree",
      base: P.ANGLE,
      prefixes: R.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: "grad",
      base: P.ANGLE,
      prefixes: R.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: P.ANGLE,
      prefixes: R.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: "cycle",
      base: P.ANGLE,
      prefixes: R.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: "arcsec",
      base: P.ANGLE,
      prefixes: R.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: "arcmin",
      base: P.ANGLE,
      prefixes: R.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // Electric current
    A: {
      name: "A",
      base: P.CURRENT,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: P.CURRENT,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    // Temperature
    // K(C) = °C + 273.15
    // K(F) = (°F + 459.67) * (5 / 9)
    // K(R) = °R * (5 / 9)
    K: {
      name: "K",
      base: P.TEMPERATURE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: P.TEMPERATURE,
      prefixes: R.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: P.TEMPERATURE,
      prefixes: R.SHORT,
      value: new b(5, 9),
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: P.TEMPERATURE,
      prefixes: R.SHORT,
      value: new b(5, 9),
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: P.TEMPERATURE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: P.TEMPERATURE,
      prefixes: R.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: P.TEMPERATURE,
      prefixes: R.LONG,
      value: new b(5, 9),
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: P.TEMPERATURE,
      prefixes: R.LONG,
      value: new b(5, 9),
      offset: 0
    },
    // amount of substance
    mol: {
      name: "mol",
      base: P.AMOUNT_OF_SUBSTANCE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: P.AMOUNT_OF_SUBSTANCE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    // luminous intensity
    cd: {
      name: "cd",
      base: P.LUMINOUS_INTENSITY,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: P.LUMINOUS_INTENSITY,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // Force
    N: {
      name: "N",
      base: P.FORCE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: P.FORCE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: P.FORCE,
      prefixes: R.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: P.FORCE,
      prefixes: R.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: P.FORCE,
      prefixes: R.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: P.FORCE,
      prefixes: R.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: P.FORCE,
      prefixes: R.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: P.FORCE,
      prefixes: R.NONE,
      value: 9.80665,
      offset: 0
    },
    // Energy
    J: {
      name: "J",
      base: P.ENERGY,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: P.ENERGY,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: P.ENERGY,
      prefixes: R.SHORTLONG,
      // Both kiloerg and kerg are acceptable
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: P.ENERGY,
      prefixes: R.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: P.ENERGY,
      prefixes: R.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: P.ENERGY,
      prefixes: R.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: P.ENERGY,
      prefixes: R.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    // Power
    W: {
      name: "W",
      base: P.POWER,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: P.POWER,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: P.POWER,
      prefixes: R.NONE,
      value: 745.6998715386,
      offset: 0
    },
    // Electrical power units
    VAR: {
      name: "VAR",
      base: P.POWER,
      prefixes: R.SHORT,
      value: v.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: P.POWER,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Pressure
    Pa: {
      name: "Pa",
      base: P.PRESSURE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: P.PRESSURE,
      prefixes: R.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: P.PRESSURE,
      prefixes: R.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: P.PRESSURE,
      prefixes: R.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: P.PRESSURE,
      prefixes: R.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: P.PRESSURE,
      prefixes: R.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: P.PRESSURE,
      prefixes: R.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: P.PRESSURE,
      prefixes: R.NONE,
      value: 98.0665,
      offset: 0
    },
    // Electric charge
    coulomb: {
      name: "coulomb",
      base: P.ELECTRIC_CHARGE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: P.ELECTRIC_CHARGE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: "farad",
      base: P.ELECTRIC_CAPACITANCE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: P.ELECTRIC_CAPACITANCE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: "volt",
      base: P.ELECTRIC_POTENTIAL,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: P.ELECTRIC_POTENTIAL,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: "ohm",
      base: P.ELECTRIC_RESISTANCE,
      prefixes: R.SHORTLONG,
      // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: "henry",
      base: P.ELECTRIC_INDUCTANCE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: P.ELECTRIC_INDUCTANCE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: "siemens",
      base: P.ELECTRIC_CONDUCTANCE,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: P.ELECTRIC_CONDUCTANCE,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: "weber",
      base: P.MAGNETIC_FLUX,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: P.MAGNETIC_FLUX,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: "tesla",
      base: P.MAGNETIC_FLUX_DENSITY,
      prefixes: R.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: P.MAGNETIC_FLUX_DENSITY,
      prefixes: R.SHORT,
      value: 1,
      offset: 0
    },
    // Binary
    b: {
      name: "b",
      base: P.BIT,
      prefixes: R.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: P.BIT,
      prefixes: R.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: P.BIT,
      prefixes: R.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: P.BIT,
      prefixes: R.BINARY_LONG,
      value: 8,
      offset: 0
    }
  }, te = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fluiddrams: "fluiddram",
    fluidounces: "fluidounce",
    gills: "gill",
    cups: "cup",
    pints: "pint",
    quarts: "quart",
    gallons: "gallon",
    beerbarrels: "beerbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function be(V) {
    if (V.number === "BigNumber") {
      var re = Id(N);
      H.rad.value = new N(1), H.deg.value = re.div(180), H.grad.value = re.div(200), H.cycle.value = re.times(2), H.arcsec.value = re.div(648e3), H.arcmin.value = re.div(10800);
    } else
      H.rad.value = 1, H.deg.value = Math.PI / 180, H.grad.value = Math.PI / 200, H.cycle.value = Math.PI * 2, H.arcsec.value = Math.PI / 648e3, H.arcmin.value = Math.PI / 10800;
    H.radian.value = H.rad.value, H.degree.value = H.deg.value, H.gradian.value = H.grad.value;
  }
  be(r), e && e("config", function(V, re) {
    V.number !== re.number && be(V);
  });
  var K = {
    si: {
      // Base units
      NONE: {
        unit: Z,
        prefix: R.NONE[""]
      },
      LENGTH: {
        unit: H.m,
        prefix: R.SHORT[""]
      },
      MASS: {
        unit: H.g,
        prefix: R.SHORT.k
      },
      TIME: {
        unit: H.s,
        prefix: R.SHORT[""]
      },
      CURRENT: {
        unit: H.A,
        prefix: R.SHORT[""]
      },
      TEMPERATURE: {
        unit: H.K,
        prefix: R.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: H.cd,
        prefix: R.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: H.mol,
        prefix: R.SHORT[""]
      },
      ANGLE: {
        unit: H.rad,
        prefix: R.SHORT[""]
      },
      BIT: {
        unit: H.bits,
        prefix: R.SHORT[""]
      },
      // Derived units
      FORCE: {
        unit: H.N,
        prefix: R.SHORT[""]
      },
      ENERGY: {
        unit: H.J,
        prefix: R.SHORT[""]
      },
      POWER: {
        unit: H.W,
        prefix: R.SHORT[""]
      },
      PRESSURE: {
        unit: H.Pa,
        prefix: R.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: H.C,
        prefix: R.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: H.F,
        prefix: R.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: H.V,
        prefix: R.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: H.ohm,
        prefix: R.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: H.H,
        prefix: R.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: H.S,
        prefix: R.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: H.Wb,
        prefix: R.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: H.T,
        prefix: R.SHORT[""]
      },
      FREQUENCY: {
        unit: H.Hz,
        prefix: R.SHORT[""]
      }
    }
  };
  K.cgs = JSON.parse(JSON.stringify(K.si)), K.cgs.LENGTH = {
    unit: H.m,
    prefix: R.SHORT.c
  }, K.cgs.MASS = {
    unit: H.g,
    prefix: R.SHORT[""]
  }, K.cgs.FORCE = {
    unit: H.dyn,
    prefix: R.SHORT[""]
  }, K.cgs.ENERGY = {
    unit: H.erg,
    prefix: R.NONE[""]
  }, K.us = JSON.parse(JSON.stringify(K.si)), K.us.LENGTH = {
    unit: H.ft,
    prefix: R.NONE[""]
  }, K.us.MASS = {
    unit: H.lbm,
    prefix: R.NONE[""]
  }, K.us.TEMPERATURE = {
    unit: H.degF,
    prefix: R.NONE[""]
  }, K.us.FORCE = {
    unit: H.lbf,
    prefix: R.NONE[""]
  }, K.us.ENERGY = {
    unit: H.BTU,
    prefix: R.BTU[""]
  }, K.us.POWER = {
    unit: H.hp,
    prefix: R.NONE[""]
  }, K.us.PRESSURE = {
    unit: H.psi,
    prefix: R.NONE[""]
  }, K.auto = JSON.parse(JSON.stringify(K.si));
  var ce = K.auto;
  x.setUnitSystem = function(V) {
    if (We(K, V))
      ce = K[V];
    else
      throw new Error("Unit system " + V + " does not exist. Choices are: " + Object.keys(K).join(", "));
  }, x.getUnitSystem = function() {
    for (var V in K)
      if (We(K, V) && K[V] === ce)
        return V;
  }, x.typeConverters = {
    BigNumber: function(re) {
      return re != null && re.isFraction ? new N(re.n).div(re.d).times(re.s) : new N(re + "");
    },
    Fraction: function(re) {
      return new b(re);
    },
    Complex: function(re) {
      return re;
    },
    number: function(re) {
      return re != null && re.isFraction ? g(re) : re;
    }
  }, x.prototype._numberConverter = function() {
    var V = x.typeConverters[this.valueType()];
    if (V)
      return V;
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  }, x._getNumberConverter = function(V) {
    if (!x.typeConverters[V])
      throw new TypeError('Unsupported type "' + V + '"');
    return x.typeConverters[V];
  };
  for (var de in H)
    if (We(H, de)) {
      var ue = H[de];
      ue.dimensions = ue.base.dimensions;
    }
  for (var ve in te)
    if (We(te, ve)) {
      var he = H[te[ve]], Ne = {};
      for (var we in he)
        We(he, we) && (Ne[we] = he[we]);
      Ne.name = ve, H[ve] = Ne;
    }
  x.isValidAlpha = function(re) {
    return /^[a-zA-Z]$/.test(re);
  };
  function Se(V) {
    for (var re = 0; re < V.length; re++) {
      if (A = V.charAt(re), re === 0 && !x.isValidAlpha(A))
        throw new Error('Invalid unit name (must begin with alpha character): "' + V + '"');
      if (re > 0 && !(x.isValidAlpha(A) || O(A)))
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + V + '"');
    }
  }
  return x.createUnit = function(V, re) {
    if (typeof V != "object")
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    if (re && re.override) {
      for (var pe in V)
        if (We(V, pe) && x.deleteUnit(pe), V[pe].aliases)
          for (var X = 0; X < V[pe].aliases.length; X++)
            x.deleteUnit(V[pe].aliases[X]);
    }
    var ie;
    for (var me in V)
      We(V, me) && (ie = x.createUnitSingle(me, V[me]));
    return ie;
  }, x.createUnitSingle = function(V, re) {
    if ((typeof re > "u" || re === null) && (re = {}), typeof V != "string")
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    if (We(H, V))
      throw new Error('Cannot create unit "' + V + '": a unit with that name already exists');
    Se(V);
    var pe = null, X = [], ie = 0, me, Ae, Me;
    if (re && re.type === "Unit")
      pe = re.clone();
    else if (typeof re == "string")
      re !== "" && (me = re);
    else if (typeof re == "object")
      me = re.definition, Ae = re.prefixes, ie = re.offset, Me = re.baseName, re.aliases && (X = re.aliases.valueOf());
    else
      throw new TypeError('Cannot create unit "' + V + '" from "' + re.toString() + '": expecting "string" or "Unit" or "Object"');
    if (X) {
      for (var Q = 0; Q < X.length; Q++)
        if (We(H, X[Q]))
          throw new Error('Cannot create alias "' + X[Q] + '": a unit with that name already exists');
    }
    if (me && typeof me == "string" && !pe)
      try {
        pe = x.parse(me, {
          allowNoUnits: !0
        });
      } catch (B) {
        throw B.message = 'Could not create unit "' + V + '" from "' + me + '": ' + B.message, B;
      }
    else me && me.type === "Unit" && (pe = me.clone());
    X = X || [], ie = ie || 0, Ae && Ae.toUpperCase ? Ae = R[Ae.toUpperCase()] || R.NONE : Ae = R.NONE;
    var ee = {};
    if (pe) {
      ee = {
        name: V,
        value: pe.value,
        dimensions: pe.dimensions.slice(0),
        prefixes: Ae,
        offset: ie
      };
      var De = !1;
      for (var Oe in P)
        if (We(P, Oe)) {
          for (var Be = !0, Le = 0; Le < G.length; Le++)
            if (Math.abs((ee.dimensions[Le] || 0) - (P[Oe].dimensions[Le] || 0)) > 1e-12) {
              Be = !1;
              break;
            }
          if (Be) {
            De = !0, ee.base = P[Oe];
            break;
          }
        }
      if (!De) {
        Me = Me || V + "_STUFF";
        var Re = {
          dimensions: pe.dimensions.slice(0)
        };
        Re.key = Me, P[Me] = Re, ce[Me] = {
          unit: ee,
          prefix: R.NONE[""]
        }, ee.base = P[Me];
      }
    } else {
      if (Me = Me || V + "_STUFF", G.indexOf(Me) >= 0)
        throw new Error('Cannot create new base unit "' + V + '": a base unit with that name already exists (and cannot be overridden)');
      G.push(Me);
      for (var ye in P)
        We(P, ye) && (P[ye].dimensions[G.length - 1] = 0);
      for (var Ee = {
        dimensions: []
      }, Ce = 0; Ce < G.length; Ce++)
        Ee.dimensions[Ce] = 0;
      Ee.dimensions[G.length - 1] = 1, Ee.key = Me, P[Me] = Ee, ee = {
        name: V,
        value: 1,
        dimensions: P[Me].dimensions.slice(0),
        prefixes: Ae,
        offset: ie,
        base: P[Me]
      }, ce[Me] = {
        unit: ee,
        prefix: R.NONE[""]
      };
    }
    x.UNITS[V] = ee;
    for (var rt = 0; rt < X.length; rt++) {
      var Ke = X[rt], Ze = {};
      for (var Ie in ee)
        We(ee, Ie) && (Ze[Ie] = ee[Ie]);
      Ze.name = Ke, x.UNITS[Ke] = Ze;
    }
    return delete k.cache, new x(null, V);
  }, x.deleteUnit = function(V) {
    delete x.UNITS[V], delete k.cache;
  }, x.PREFIXES = R, x.BASE_DIMENSIONS = G, x.BASE_UNITS = P, x.UNIT_SYSTEMS = K, x.UNITS = H, x;
}, {
  isClass: !0
}), mx = "unit", lF = ["typed", "Unit"], sc = /* @__PURE__ */ j(mx, lF, (t) => {
  var {
    typed: e,
    Unit: r
  } = t;
  return e(mx, {
    Unit: function(a) {
      return a.clone();
    },
    string: function(a) {
      return r.isValuelessUnit(a) ? new r(null, a) : r.parse(a, {
        allowNoUnits: !0
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function(a, s) {
      return new r(a, s);
    },
    "number | BigNumber | Fraction": function(a) {
      return new r(a);
    },
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), dx = "sparse", cF = ["typed", "SparseMatrix"], oc = /* @__PURE__ */ j(dx, cF, (t) => {
  var {
    typed: e,
    SparseMatrix: r
  } = t;
  return e(dx, {
    "": function() {
      return new r([]);
    },
    string: function(a) {
      return new r([], a);
    },
    "Array | Matrix": function(a) {
      return new r(a);
    },
    "Array | Matrix, string": function(a, s) {
      return new r(a, s);
    }
  });
}), vx = "createUnit", fF = ["typed", "Unit"], uc = /* @__PURE__ */ j(vx, fF, (t) => {
  var {
    typed: e,
    Unit: r
  } = t;
  return e(vx, {
    // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
    "Object, Object": function(a, s) {
      return r.createUnit(a, s);
    },
    // Same as above but without the options.
    Object: function(a) {
      return r.createUnit(a, {});
    },
    // Shortcut method for creating one unit.
    "string, Unit | string | Object, Object": function(a, s, o) {
      var p = {};
      return p[a] = s, r.createUnit(p, o);
    },
    // Same as above but without the options.
    "string, Unit | string | Object": function(a, s) {
      var o = {};
      return o[a] = s, r.createUnit(o, {});
    },
    // Without a definition, creates a base unit.
    string: function(a) {
      var s = {};
      return s[a] = {}, r.createUnit(s, {});
    }
  });
}), gx = "acos", pF = ["typed", "config", "Complex"], lc = /* @__PURE__ */ j(gx, pF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(gx, {
    number: function(s) {
      return s >= -1 && s <= 1 || r.predictable ? Math.acos(s) : new n(s, 0).acos();
    },
    Complex: function(s) {
      return s.acos();
    },
    BigNumber: function(s) {
      return s.acos();
    }
  });
}), yx = "acosh", hF = ["typed", "config", "Complex"], cc = /* @__PURE__ */ j(yx, hF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(yx, {
    number: function(s) {
      return s >= 1 || r.predictable ? Aw(s) : s <= -1 ? new n(Math.log(Math.sqrt(s * s - 1) - s), Math.PI) : new n(s, 0).acosh();
    },
    Complex: function(s) {
      return s.acosh();
    },
    BigNumber: function(s) {
      return s.acosh();
    }
  });
}), xx = "acot", mF = ["typed", "BigNumber"], fc = /* @__PURE__ */ j(xx, mF, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(xx, {
    number: Ew,
    Complex: function(a) {
      return a.acot();
    },
    BigNumber: function(a) {
      return new r(1).div(a).atan();
    }
  });
}), bx = "acoth", dF = ["typed", "config", "Complex", "BigNumber"], pc = /* @__PURE__ */ j(bx, dF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: a
  } = t;
  return e(bx, {
    number: function(o) {
      return o >= 1 || o <= -1 || r.predictable ? Sw(o) : new n(o, 0).acoth();
    },
    Complex: function(o) {
      return o.acoth();
    },
    BigNumber: function(o) {
      return new a(1).div(o).atanh();
    }
  });
}), wx = "acsc", vF = ["typed", "config", "Complex", "BigNumber"], hc = /* @__PURE__ */ j(wx, vF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: a
  } = t;
  return e(wx, {
    number: function(o) {
      return o <= -1 || o >= 1 || r.predictable ? Cw(o) : new n(o, 0).acsc();
    },
    Complex: function(o) {
      return o.acsc();
    },
    BigNumber: function(o) {
      return new a(1).div(o).asin();
    }
  });
}), Nx = "acsch", gF = ["typed", "BigNumber"], mc = /* @__PURE__ */ j(Nx, gF, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(Nx, {
    number: Tw,
    Complex: function(a) {
      return a.acsch();
    },
    BigNumber: function(a) {
      return new r(1).div(a).asinh();
    }
  });
}), Dx = "asec", yF = ["typed", "config", "Complex", "BigNumber"], dc = /* @__PURE__ */ j(Dx, yF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: a
  } = t;
  return e(Dx, {
    number: function(o) {
      return o <= -1 || o >= 1 || r.predictable ? _w(o) : new n(o, 0).asec();
    },
    Complex: function(o) {
      return o.asec();
    },
    BigNumber: function(o) {
      return new a(1).div(o).acos();
    }
  });
}), Ax = "asech", xF = ["typed", "config", "Complex", "BigNumber"], vc = /* @__PURE__ */ j(Ax, xF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: a
  } = t;
  return e(Ax, {
    number: function(o) {
      if (o <= 1 && o >= -1 || r.predictable) {
        var p = 1 / o;
        if (p > 0 || r.predictable)
          return Mw(o);
        var u = Math.sqrt(p * p - 1);
        return new n(Math.log(u - p), Math.PI);
      }
      return new n(o, 0).asech();
    },
    Complex: function(o) {
      return o.asech();
    },
    BigNumber: function(o) {
      return new a(1).div(o).acosh();
    }
  });
}), Ex = "asin", bF = ["typed", "config", "Complex"], gc = /* @__PURE__ */ j(Ex, bF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(Ex, {
    number: function(s) {
      return s >= -1 && s <= 1 || r.predictable ? Math.asin(s) : new n(s, 0).asin();
    },
    Complex: function(s) {
      return s.asin();
    },
    BigNumber: function(s) {
      return s.asin();
    }
  });
}), wF = "asinh", NF = ["typed"], yc = /* @__PURE__ */ j(wF, NF, (t) => {
  var {
    typed: e
  } = t;
  return e("asinh", {
    number: Ow,
    Complex: function(n) {
      return n.asinh();
    },
    BigNumber: function(n) {
      return n.asinh();
    }
  });
}), DF = "atan", AF = ["typed"], xc = /* @__PURE__ */ j(DF, AF, (t) => {
  var {
    typed: e
  } = t;
  return e("atan", {
    number: function(n) {
      return Math.atan(n);
    },
    Complex: function(n) {
      return n.atan();
    },
    BigNumber: function(n) {
      return n.atan();
    }
  });
}), Sx = "atan2", EF = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"], bc = /* @__PURE__ */ j(Sx, EF, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    BigNumber: a,
    DenseMatrix: s,
    concat: o
  } = t, p = Un({
    typed: e,
    equalScalar: n
  }), u = rn({
    typed: e
  }), f = Gw({
    typed: e,
    equalScalar: n
  }), l = Pr({
    typed: e,
    equalScalar: n
  }), c = br({
    typed: e,
    DenseMatrix: s
  }), h = Jt({
    typed: e,
    matrix: r,
    concat: o
  });
  return e(Sx, {
    "number, number": Math.atan2,
    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored
    // the imaginary.
    "BigNumber, BigNumber": (d, g) => a.atan2(d, g)
  }, h({
    scalar: "number | BigNumber",
    SS: f,
    DS: u,
    SD: p,
    Ss: l,
    sS: c
  }));
}), Cx = "atanh", SF = ["typed", "config", "Complex"], wc = /* @__PURE__ */ j(Cx, SF, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(Cx, {
    number: function(s) {
      return s <= 1 && s >= -1 || r.predictable ? Fw(s) : new n(s, 0).atanh();
    },
    Complex: function(s) {
      return s.atanh();
    },
    BigNumber: function(s) {
      return s.atanh();
    }
  });
}), ts = /* @__PURE__ */ j("trigUnit", ["typed"], (t) => {
  var {
    typed: e
  } = t;
  return {
    Unit: e.referToSelf((r) => (n) => {
      if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
        throw new TypeError("Unit in function cot is no angle");
      return e.find(r, n.valueType())(n.value);
    })
  };
}), Tx = "cos", CF = ["typed"], Nc = /* @__PURE__ */ j(Tx, CF, (t) => {
  var {
    typed: e
  } = t, r = ts({
    typed: e
  });
  return e(Tx, {
    number: Math.cos,
    "Complex | BigNumber": (n) => n.cos()
  }, r);
}), _x = "cosh", TF = ["typed"], Dc = /* @__PURE__ */ j(_x, TF, (t) => {
  var {
    typed: e
  } = t;
  return e(_x, {
    number: iC,
    "Complex | BigNumber": (r) => r.cosh()
  });
}), Mx = "cot", _F = ["typed", "BigNumber"], Ac = /* @__PURE__ */ j(Mx, _F, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t, n = ts({
    typed: e
  });
  return e(Mx, {
    number: qw,
    Complex: (a) => a.cot(),
    BigNumber: (a) => new r(1).div(a.tan())
  }, n);
}), Ox = "coth", MF = ["typed", "BigNumber"], Ec = /* @__PURE__ */ j(Ox, MF, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(Ox, {
    number: Iw,
    Complex: (n) => n.coth(),
    BigNumber: (n) => new r(1).div(n.tanh())
  });
}), Fx = "csc", OF = ["typed", "BigNumber"], Sc = /* @__PURE__ */ j(Fx, OF, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t, n = ts({
    typed: e
  });
  return e(Fx, {
    number: Bw,
    Complex: (a) => a.csc(),
    BigNumber: (a) => new r(1).div(a.sin())
  }, n);
}), qx = "csch", FF = ["typed", "BigNumber"], Cc = /* @__PURE__ */ j(qx, FF, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(qx, {
    number: Rw,
    Complex: (n) => n.csch(),
    BigNumber: (n) => new r(1).div(n.sinh())
  });
}), Ix = "sec", qF = ["typed", "BigNumber"], Tc = /* @__PURE__ */ j(Ix, qF, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t, n = ts({
    typed: e
  });
  return e(Ix, {
    number: Lw,
    Complex: (a) => a.sec(),
    BigNumber: (a) => new r(1).div(a.cos())
  }, n);
}), Bx = "sech", IF = ["typed", "BigNumber"], _c = /* @__PURE__ */ j(Bx, IF, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(Bx, {
    number: Pw,
    Complex: (n) => n.sech(),
    BigNumber: (n) => new r(1).div(n.cosh())
  });
}), Rx = "sin", BF = ["typed"], Mc = /* @__PURE__ */ j(Rx, BF, (t) => {
  var {
    typed: e
  } = t, r = ts({
    typed: e
  });
  return e(Rx, {
    number: Math.sin,
    "Complex | BigNumber": (n) => n.sin()
  }, r);
}), Lx = "sinh", RF = ["typed"], Oc = /* @__PURE__ */ j(Lx, RF, (t) => {
  var {
    typed: e
  } = t;
  return e(Lx, {
    number: kw,
    "Complex | BigNumber": (r) => r.sinh()
  });
}), Px = "tan", LF = ["typed"], Fc = /* @__PURE__ */ j(Px, LF, (t) => {
  var {
    typed: e
  } = t, r = ts({
    typed: e
  });
  return e(Px, {
    number: Math.tan,
    "Complex | BigNumber": (n) => n.tan()
  }, r);
}), PF = "tanh", kF = ["typed"], qc = /* @__PURE__ */ j(PF, kF, (t) => {
  var {
    typed: e
  } = t;
  return e("tanh", {
    number: sC,
    "Complex | BigNumber": (r) => r.tanh()
  });
}), kx = "setCartesian", $F = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], Ic = /* @__PURE__ */ j(kx, $F, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: a,
    Index: s,
    DenseMatrix: o
  } = t;
  return e(kx, {
    "Array | Matrix, Array | Matrix": function(u, f) {
      var l = [];
      if (n(r(u), new s(0)) !== 0 && n(r(f), new s(0)) !== 0) {
        var c = Lt(Array.isArray(u) ? u : u.toArray()).sort(a), h = Lt(Array.isArray(f) ? f : f.toArray()).sort(a);
        l = [];
        for (var d = 0; d < c.length; d++)
          for (var g = 0; g < h.length; g++)
            l.push([c[d], h[g]]);
      }
      return Array.isArray(u) && Array.isArray(f) ? l : new o(l);
    }
  });
}), $x = "setDifference", zF = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], Bc = /* @__PURE__ */ j($x, zF, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: a,
    Index: s,
    DenseMatrix: o
  } = t;
  return e($x, {
    "Array | Matrix, Array | Matrix": function(u, f) {
      var l;
      if (n(r(u), new s(0)) === 0)
        l = [];
      else {
        if (n(r(f), new s(0)) === 0)
          return Lt(u.toArray());
        var c = za(Lt(Array.isArray(u) ? u : u.toArray()).sort(a)), h = za(Lt(Array.isArray(f) ? f : f.toArray()).sort(a));
        l = [];
        for (var d, g = 0; g < c.length; g++) {
          d = !1;
          for (var v = 0; v < h.length; v++)
            if (a(c[g].value, h[v].value) === 0 && c[g].identifier === h[v].identifier) {
              d = !0;
              break;
            }
          d || l.push(c[g]);
        }
      }
      return Array.isArray(u) && Array.isArray(f) ? au(l) : new o(au(l));
    }
  });
}), zx = "setDistinct", UF = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], Rc = /* @__PURE__ */ j(zx, UF, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: a,
    Index: s,
    DenseMatrix: o
  } = t;
  return e(zx, {
    "Array | Matrix": function(u) {
      var f;
      if (n(r(u), new s(0)) === 0)
        f = [];
      else {
        var l = Lt(Array.isArray(u) ? u : u.toArray()).sort(a);
        f = [], f.push(l[0]);
        for (var c = 1; c < l.length; c++)
          a(l[c], l[c - 1]) !== 0 && f.push(l[c]);
      }
      return Array.isArray(u) ? f : new o(f);
    }
  });
}), Ux = "setIntersect", GF = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], Lc = /* @__PURE__ */ j(Ux, GF, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: a,
    Index: s,
    DenseMatrix: o
  } = t;
  return e(Ux, {
    "Array | Matrix, Array | Matrix": function(u, f) {
      var l;
      if (n(r(u), new s(0)) === 0 || n(r(f), new s(0)) === 0)
        l = [];
      else {
        var c = za(Lt(Array.isArray(u) ? u : u.toArray()).sort(a)), h = za(Lt(Array.isArray(f) ? f : f.toArray()).sort(a));
        l = [];
        for (var d = 0; d < c.length; d++)
          for (var g = 0; g < h.length; g++)
            if (a(c[d].value, h[g].value) === 0 && c[d].identifier === h[g].identifier) {
              l.push(c[d]);
              break;
            }
      }
      return Array.isArray(u) && Array.isArray(f) ? au(l) : new o(au(l));
    }
  });
}), Gx = "setIsSubset", HF = ["typed", "size", "subset", "compareNatural", "Index"], Pc = /* @__PURE__ */ j(Gx, HF, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: a,
    Index: s
  } = t;
  return e(Gx, {
    "Array | Matrix, Array | Matrix": function(p, u) {
      if (n(r(p), new s(0)) === 0)
        return !0;
      if (n(r(u), new s(0)) === 0)
        return !1;
      for (var f = za(Lt(Array.isArray(p) ? p : p.toArray()).sort(a)), l = za(Lt(Array.isArray(u) ? u : u.toArray()).sort(a)), c, h = 0; h < f.length; h++) {
        c = !1;
        for (var d = 0; d < l.length; d++)
          if (a(f[h].value, l[d].value) === 0 && f[h].identifier === l[d].identifier) {
            c = !0;
            break;
          }
        if (c === !1)
          return !1;
      }
      return !0;
    }
  });
}), Hx = "setMultiplicity", QF = ["typed", "size", "subset", "compareNatural", "Index"], kc = /* @__PURE__ */ j(Hx, QF, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: a,
    Index: s
  } = t;
  return e(Hx, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function(p, u) {
      if (n(r(u), new s(0)) === 0)
        return 0;
      for (var f = Lt(Array.isArray(u) ? u : u.toArray()), l = 0, c = 0; c < f.length; c++)
        a(f[c], p) === 0 && l++;
      return l;
    }
  });
}), Qx = "setPowerset", VF = ["typed", "size", "subset", "compareNatural", "Index"], $c = /* @__PURE__ */ j(Qx, VF, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: a,
    Index: s
  } = t;
  return e(Qx, {
    "Array | Matrix": function(f) {
      if (n(r(f), new s(0)) === 0)
        return [];
      for (var l = Lt(Array.isArray(f) ? f : f.toArray()).sort(a), c = [], h = 0; h.toString(2).length <= l.length; )
        c.push(o(l, h.toString(2).split("").reverse())), h++;
      return p(c);
    }
  });
  function o(u, f) {
    for (var l = [], c = 0; c < f.length; c++)
      f[c] === "1" && l.push(u[c]);
    return l;
  }
  function p(u) {
    for (var f = [], l = u.length - 1; l > 0; l--)
      for (var c = 0; c < l; c++)
        u[c].length > u[c + 1].length && (f = u[c], u[c] = u[c + 1], u[c + 1] = f);
    return u;
  }
}), Vx = "setSize", WF = ["typed", "compareNatural"], zc = /* @__PURE__ */ j(Vx, WF, (t) => {
  var {
    typed: e,
    compareNatural: r
  } = t;
  return e(Vx, {
    "Array | Matrix": function(a) {
      return Array.isArray(a) ? Lt(a).length : Lt(a.toArray()).length;
    },
    "Array | Matrix, boolean": function(a, s) {
      if (s === !1 || a.length === 0)
        return Array.isArray(a) ? Lt(a).length : Lt(a.toArray()).length;
      for (var o = Lt(Array.isArray(a) ? a : a.toArray()).sort(r), p = 1, u = 1; u < o.length; u++)
        r(o[u], o[u - 1]) !== 0 && p++;
      return p;
    }
  });
}), Wx = "setSymDifference", jF = ["typed", "size", "concat", "subset", "setDifference", "Index"], Uc = /* @__PURE__ */ j(Wx, jF, (t) => {
  var {
    typed: e,
    size: r,
    concat: n,
    subset: a,
    setDifference: s,
    Index: o
  } = t;
  return e(Wx, {
    "Array | Matrix, Array | Matrix": function(u, f) {
      if (a(r(u), new o(0)) === 0)
        return Lt(f);
      if (a(r(f), new o(0)) === 0)
        return Lt(u);
      var l = Lt(u), c = Lt(f);
      return n(s(l, c), s(c, l));
    }
  });
}), jx = "setUnion", ZF = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"], Gc = /* @__PURE__ */ j(jx, ZF, (t) => {
  var {
    typed: e,
    size: r,
    concat: n,
    subset: a,
    setIntersect: s,
    setSymDifference: o,
    Index: p
  } = t;
  return e(jx, {
    "Array | Matrix, Array | Matrix": function(f, l) {
      if (a(r(f), new p(0)) === 0)
        return Lt(l);
      if (a(r(l), new p(0)) === 0)
        return Lt(f);
      var c = Lt(f), h = Lt(l);
      return n(o(c, h), s(c, h));
    }
  });
}), Zx = "add", JF = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"], Hc = /* @__PURE__ */ j(Zx, JF, (t) => {
  var {
    typed: e,
    matrix: r,
    addScalar: n,
    equalScalar: a,
    DenseMatrix: s,
    SparseMatrix: o,
    concat: p
  } = t, u = Ri({
    typed: e
  }), f = _d({
    typed: e,
    equalScalar: a
  }), l = la({
    typed: e,
    DenseMatrix: s
  }), c = Jt({
    typed: e,
    matrix: r,
    concat: p
  });
  return e(Zx, {
    "any, any": n,
    "any, any, ...any": e.referToSelf((h) => (d, g, v) => {
      for (var N = h(d, g), b = 0; b < v.length; b++)
        N = h(N, v[b]);
      return N;
    })
  }, c({
    elop: n,
    DS: u,
    SS: f,
    Ss: l
  }));
}), Jx = "hypot", YF = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"], Qc = /* @__PURE__ */ j(Jx, YF, (t) => {
  var {
    typed: e,
    abs: r,
    addScalar: n,
    divideScalar: a,
    multiplyScalar: s,
    sqrt: o,
    smaller: p,
    isPositive: u
  } = t;
  return e(Jx, {
    "... number | BigNumber": f,
    Array: f,
    Matrix: (l) => f(Lt(l.toArray()))
  });
  function f(l) {
    for (var c = 0, h = 0, d = 0; d < l.length; d++) {
      if (Mn(l[d]))
        throw new TypeError("Unexpected type of argument to hypot");
      var g = r(l[d]);
      p(h, g) ? (c = s(c, s(a(h, g), a(h, g))), c = n(c, 1), h = g) : c = n(c, u(g) ? s(a(g, h), a(g, h)) : g);
    }
    return s(h, o(c));
  }
}), Yx = "norm", XF = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"], Vc = /* @__PURE__ */ j(Yx, XF, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    pow: a,
    conj: s,
    sqrt: o,
    multiply: p,
    equalScalar: u,
    larger: f,
    smaller: l,
    matrix: c,
    ctranspose: h,
    eigs: d
  } = t;
  return e(Yx, {
    number: Math.abs,
    Complex: function(_) {
      return _.abs();
    },
    BigNumber: function(_) {
      return _.abs();
    },
    boolean: function(_) {
      return Math.abs(_);
    },
    Array: function(_) {
      return A(c(_), 2);
    },
    Matrix: function(_) {
      return A(_, 2);
    },
    "Array, number | BigNumber | string": function(_, O) {
      return A(c(_), O);
    },
    "Matrix, number | BigNumber | string": function(_, O) {
      return A(_, O);
    }
  });
  function g(M) {
    var _ = 0;
    return M.forEach(function(O) {
      var T = r(O);
      f(T, _) && (_ = T);
    }, !0), _;
  }
  function v(M) {
    var _;
    return M.forEach(function(O) {
      var T = r(O);
      (!_ || l(T, _)) && (_ = T);
    }, !0), _ || 0;
  }
  function N(M, _) {
    if (_ === Number.POSITIVE_INFINITY || _ === "inf")
      return g(M);
    if (_ === Number.NEGATIVE_INFINITY || _ === "-inf")
      return v(M);
    if (_ === "fro")
      return A(M, 2);
    if (typeof _ == "number" && !isNaN(_)) {
      if (!u(_, 0)) {
        var O = 0;
        return M.forEach(function(T) {
          O = n(a(r(T), _), O);
        }, !0), a(O, 1 / _);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function b(M) {
    var _ = 0;
    return M.forEach(function(O, T) {
      _ = n(_, p(O, s(O)));
    }), r(o(_));
  }
  function C(M) {
    var _ = [], O = 0;
    return M.forEach(function(T, I) {
      var q = I[1], $ = n(_[q] || 0, r(T));
      f($, O) && (O = $), _[q] = $;
    }, !0), O;
  }
  function x(M) {
    var _ = M.size();
    if (_[0] !== _[1])
      throw new RangeError("Invalid matrix dimensions");
    var O = h(M), T = p(O, M), I = d(T).values.toArray(), q = I[I.length - 1];
    return r(o(q));
  }
  function E(M) {
    var _ = [], O = 0;
    return M.forEach(function(T, I) {
      var q = I[0], $ = n(_[q] || 0, r(T));
      f($, O) && (O = $), _[q] = $;
    }, !0), O;
  }
  function D(M, _) {
    if (_ === 1)
      return C(M);
    if (_ === Number.POSITIVE_INFINITY || _ === "inf")
      return E(M);
    if (_ === "fro")
      return b(M);
    if (_ === 2)
      return x(M);
    throw new Error("Unsupported parameter value " + _);
  }
  function A(M, _) {
    var O = M.size();
    if (O.length === 1)
      return N(M, _);
    if (O.length === 2) {
      if (O[0] && O[1])
        return D(M, _);
      throw new RangeError("Invalid matrix dimensions");
    }
  }
}), Xx = "dot", KF = ["typed", "addScalar", "multiplyScalar", "conj", "size"], Wc = /* @__PURE__ */ j(Xx, KF, (t) => {
  var {
    typed: e,
    addScalar: r,
    multiplyScalar: n,
    conj: a,
    size: s
  } = t;
  return e(Xx, {
    "Array | DenseMatrix, Array | DenseMatrix": p,
    "SparseMatrix, SparseMatrix": u
  });
  function o(l, c) {
    var h = f(l), d = f(c), g, v;
    if (h.length === 1)
      g = h[0];
    else if (h.length === 2 && h[1] === 1)
      g = h[0];
    else
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + h.join(", ") + ")");
    if (d.length === 1)
      v = d[0];
    else if (d.length === 2 && d[1] === 1)
      v = d[0];
    else
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + d.join(", ") + ")");
    if (g !== v) throw new RangeError("Vectors must have equal length (" + g + " != " + v + ")");
    if (g === 0) throw new RangeError("Cannot calculate the dot product of empty vectors");
    return g;
  }
  function p(l, c) {
    var h = o(l, c), d = tt(l) ? l._data : l, g = tt(l) ? l._datatype || l.getDataType() : void 0, v = tt(c) ? c._data : c, N = tt(c) ? c._datatype || c.getDataType() : void 0, b = f(l).length === 2, C = f(c).length === 2, x = r, E = n;
    if (g && N && g === N && typeof g == "string" && g !== "mixed") {
      var D = g;
      x = e.find(r, [D, D]), E = e.find(n, [D, D]);
    }
    if (!b && !C) {
      for (var A = E(a(d[0]), v[0]), M = 1; M < h; M++)
        A = x(A, E(a(d[M]), v[M]));
      return A;
    }
    if (!b && C) {
      for (var _ = E(a(d[0]), v[0][0]), O = 1; O < h; O++)
        _ = x(_, E(a(d[O]), v[O][0]));
      return _;
    }
    if (b && !C) {
      for (var T = E(a(d[0][0]), v[0]), I = 1; I < h; I++)
        T = x(T, E(a(d[I][0]), v[I]));
      return T;
    }
    if (b && C) {
      for (var q = E(a(d[0][0]), v[0][0]), $ = 1; $ < h; $++)
        q = x(q, E(a(d[$][0]), v[$][0]));
      return q;
    }
  }
  function u(l, c) {
    o(l, c);
    for (var h = l._index, d = l._values, g = c._index, v = c._values, N = 0, b = r, C = n, x = 0, E = 0; x < h.length && E < g.length; ) {
      var D = h[x], A = g[E];
      if (D < A) {
        x++;
        continue;
      }
      if (D > A) {
        E++;
        continue;
      }
      D === A && (N = b(N, C(d[x], v[E])), x++, E++);
    }
    return N;
  }
  function f(l) {
    return tt(l) ? l.size() : s(l);
  }
}), eq = "trace", tq = ["typed", "matrix", "add"], jc = /* @__PURE__ */ j(eq, tq, (t) => {
  var {
    typed: e,
    matrix: r,
    add: n
  } = t;
  return e("trace", {
    Array: function(p) {
      return a(r(p));
    },
    SparseMatrix: s,
    DenseMatrix: a,
    any: nt
  });
  function a(o) {
    var p = o._size, u = o._data;
    switch (p.length) {
      case 1:
        if (p[0] === 1)
          return nt(u[0]);
        throw new RangeError("Matrix must be square (size: " + Dt(p) + ")");
      case 2: {
        var f = p[0], l = p[1];
        if (f === l) {
          for (var c = 0, h = 0; h < f; h++)
            c = n(c, u[h][h]);
          return c;
        } else
          throw new RangeError("Matrix must be square (size: " + Dt(p) + ")");
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + Dt(p) + ")");
    }
  }
  function s(o) {
    var p = o._values, u = o._index, f = o._ptr, l = o._size, c = l[0], h = l[1];
    if (c === h) {
      var d = 0;
      if (p.length > 0)
        for (var g = 0; g < h; g++)
          for (var v = f[g], N = f[g + 1], b = v; b < N; b++) {
            var C = u[b];
            if (C === g) {
              d = n(d, p[b]);
              break;
            }
            if (C > g)
              break;
          }
      return d;
    }
    throw new RangeError("Matrix must be square (size: " + Dt(l) + ")");
  }
}), Kx = "index", rq = ["typed", "Index"], Zc = /* @__PURE__ */ j(Kx, rq, (t) => {
  var {
    typed: e,
    Index: r
  } = t;
  return e(Kx, {
    "...number | string | BigNumber | Range | Array | Matrix": function(a) {
      var s = a.map(function(p) {
        return ct(p) ? p.toNumber() : Rt(p) || tt(p) ? p.map(function(u) {
          return ct(u) ? u.toNumber() : u;
        }) : p;
      }), o = new r();
      return r.apply(o, s), o;
    }
  });
}), Ww = /* @__PURE__ */ new Set(["end"]), nq = "Node", iq = ["mathWithTransform"], Jc = /* @__PURE__ */ j(nq, iq, (t) => {
  var {
    mathWithTransform: e
  } = t;
  function r(a) {
    for (var s of [...Ww])
      if (a.has(s))
        throw new Error('Scope contains an illegal symbol, "' + s + '" is a reserved keyword');
  }
  class n {
    get type() {
      return "Node";
    }
    get isNode() {
      return !0;
    }
    /**
     * Evaluate the node
     * @param {Object} [scope]  Scope to read/write variables
     * @return {*}              Returns the result
     */
    evaluate(s) {
      return this.compile().evaluate(s);
    }
    /**
     * Compile the node into an optimized, evauatable JavaScript function
     * @return {{evaluate: function([Object])}} object
     *                Returns an object with a function 'evaluate',
     *                which can be invoked as expr.evaluate([scope: Object]),
     *                where scope is an optional object with
     *                variables.
     */
    compile() {
      var s = this._compile(e, {}), o = {}, p = null;
      function u(f) {
        var l = Ia(f);
        return r(l), s(l, o, p);
      }
      return {
        evaluate: u
      };
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, o) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    /**
     * Create a new Node whose children are the results of calling the
     * provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(s) {
      throw new Error("Cannot run map on a Node interface");
    }
    /**
     * Validate whether an object is a Node, for use with map
     * @param {Node} node
     * @returns {Node} Returns the input if it's a node, else throws an Error
     * @protected
     */
    _ifNode(s) {
      if (!Ut(s))
        throw new TypeError("Callback function must return a Node");
      return s;
    }
    /**
     * Recursively traverse all nodes in a node tree. Executes given callback for
     * this node and each of its child nodes.
     * @param {function(node: Node, path: string, parent: Node)} callback
     *          A callback called for every node in the node tree.
     */
    traverse(s) {
      s(this, null, null);
      function o(p, u) {
        p.forEach(function(f, l, c) {
          u(f, l, c), o(f, u);
        });
      }
      o(this, s);
    }
    /**
     * Recursively transform a node tree via a transform function.
     *
     * For example, to replace all nodes of type SymbolNode having name 'x' with
     * a ConstantNode with value 2:
     *
     *     const res = Node.transform(function (node, path, parent) {
     *       if (node && node.isSymbolNode) && (node.name === 'x')) {
     *         return new ConstantNode(2)
     *       }
     *       else {
     *         return node
     *       }
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *          A mapping function accepting a node, and returning
     *          a replacement for the node or the original node. The "signature"
     *          of the callback must be:
     *          callback(node: Node, index: string, parent: Node) : Node
     * @return {Node} Returns the original node or its replacement
     */
    transform(s) {
      function o(p, u, f) {
        var l = s(p, u, f);
        return l !== p ? l : p.map(o);
      }
      return o(this, null, null);
    }
    /**
     * Find any node in the node tree matching given filter function. For
     * example, to find all nodes of type SymbolNode having name 'x':
     *
     *     const results = Node.filter(function (node) {
     *       return (node && node.isSymbolNode) && (node.name === 'x')
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *            A test function returning true when a node matches, and false
     *            otherwise. Function signature:
     *            callback(node: Node, index: string, parent: Node) : boolean
     * @return {Node[]} nodes
     *            An array with nodes matching given filter criteria
     */
    filter(s) {
      var o = [];
      return this.traverse(function(p, u, f) {
        s(p, u, f) && o.push(p);
      }), o;
    }
    /**
     * Create a shallow clone of this node
     * @return {Node}
     */
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    /**
     * Create a deep clone of this node
     * @return {Node}
     */
    cloneDeep() {
      return this.map(function(s) {
        return s.cloneDeep();
      });
    }
    /**
     * Deep compare this node with another node.
     * @param {Node} other
     * @return {boolean} Returns true when both nodes are of the same type and
     *                   contain the same values (as do their childs)
     */
    equals(s) {
      return s ? this.type === s.type && ia(this, s) : !1;
    }
    /**
     * Get string representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toString(s) {
      var o = this._getCustomString(s);
      return typeof o < "u" ? o : this._toString(s);
    }
    /**
     * Internal function to generate the string output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    /**
     * Get a JSON representation of the node
     * Both .toJSON() and the static .fromJSON(json) should be implemented by all
     * implementations of Node
     * @returns {Object}
     */
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    /**
     * Get HTML representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)" or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toHTML(s) {
      var o = this._getCustomString(s);
      return typeof o < "u" ? o : this._toHTML(s);
    }
    /**
     * Internal function to generate the HTML output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toHTML() {
      throw new Error("_toHTML not implemented for " + this.type);
    }
    /**
     * Get LaTeX representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toTex(s) {
      var o = this._getCustomString(s);
      return typeof o < "u" ? o : this._toTex(s);
    }
    /**
     * Internal function to generate the LaTeX output.
     * This has to be implemented by every Node
     *
     * @param {Object} [options]
     * @throws {Error}
     */
    _toTex(s) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    /**
     * Helper used by `to...` functions.
     */
    _getCustomString(s) {
      if (s && typeof s == "object")
        switch (typeof s.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return s.handler(this, s);
          default:
            throw new TypeError("Object or function expected as callback");
        }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type;
    }
    /**
     * Get the content of the current Node.
     * @return {Node} node
     **/
    getContent() {
      return this;
    }
  }
  return n;
}, {
  isClass: !0,
  isNode: !0
});
function nn(t) {
  return t && t.isIndexError ? new yn(t.index + 1, t.min + 1, t.max !== void 0 ? t.max + 1 : void 0) : t;
}
function jw(t) {
  var {
    subset: e
  } = t;
  return function(n, a) {
    try {
      if (Array.isArray(n))
        return e(n, a);
      if (n && typeof n.subset == "function")
        return n.subset(a);
      if (typeof n == "string")
        return e(n, a);
      if (typeof n == "object") {
        if (!a.isObjectProperty())
          throw new TypeError("Cannot apply a numeric index as object property");
        return Kr(n, a.getObjectProperty());
      } else
        throw new TypeError("Cannot apply index: unsupported type of object");
    } catch (s) {
      throw nn(s);
    }
  };
}
var Io = "AccessorNode", aq = ["subset", "Node"], Yc = /* @__PURE__ */ j(Io, aq, (t) => {
  var {
    subset: e,
    Node: r
  } = t, n = jw({
    subset: e
  });
  function a(o) {
    return !(pi(o) || un(o) || Ct(o) || Wn(o) || ja(o) || kn(o) || mr(o));
  }
  class s extends r {
    /**
     * @constructor AccessorNode
     * @extends {Node}
     * Access an object property or get a matrix subset
     *
     * @param {Node} object                 The object from which to retrieve
     *                                      a property or subset.
     * @param {IndexNode} index             IndexNode containing ranges
     */
    constructor(p, u) {
      if (super(), !Ut(p))
        throw new TypeError('Node expected for parameter "object"');
      if (!qi(u))
        throw new TypeError('IndexNode expected for parameter "index"');
      this.object = p, this.index = u;
    }
    // readonly property name
    get name() {
      return this.index ? this.index.isObjectProperty() ? this.index.getObjectProperty() : "" : this.object.name || "";
    }
    get type() {
      return Io;
    }
    get isAccessorNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(p, u) {
      var f = this.object._compile(p, u), l = this.index._compile(p, u);
      if (this.index.isObjectProperty()) {
        var c = this.index.getObjectProperty();
        return function(d, g, v) {
          return Kr(f(d, g, v), c);
        };
      } else
        return function(d, g, v) {
          var N = f(d, g, v), b = l(d, g, N);
          return n(N, b);
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(p) {
      p(this.object, "object", this), p(this.index, "index", this);
    }
    /**
     * Create a new AccessorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AccessorNode} Returns a transformed copy of the node
     */
    map(p) {
      return new s(this._ifNode(p(this.object, "object", this)), this._ifNode(p(this.index, "index", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AccessorNode}
     */
    clone() {
      return new s(this.object, this.index);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(p) {
      var u = this.object.toString(p);
      return a(this.object) && (u = "(" + u + ")"), u + this.index.toString(p);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(p) {
      var u = this.object.toHTML(p);
      return a(this.object) && (u = '<span class="math-parenthesis math-round-parenthesis">(</span>' + u + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u + this.index.toHTML(p);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(p) {
      var u = this.object.toTex(p);
      return a(this.object) && (u = "\\left(' + object + '\\right)"), u + this.index.toTex(p);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Io,
        object: this.object,
        index: this.index
      };
    }
    /**
     * Instantiate an AccessorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
     *     where mathjs is optional
     * @returns {AccessorNode}
     */
    static fromJSON(p) {
      return new s(p.object, p.index);
    }
  }
  return xr(s, "name", Io), s;
}, {
  isClass: !0,
  isNode: !0
}), Bo = "ArrayNode", sq = ["Node"], Xc = /* @__PURE__ */ j(Bo, sq, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * @constructor ArrayNode
     * @extends {Node}
     * Holds an 1-dimensional array with items
     * @param {Node[]} [items]   1 dimensional array with items
     */
    constructor(a) {
      if (super(), this.items = a || [], !Array.isArray(this.items) || !this.items.every(Ut))
        throw new TypeError("Array containing Nodes expected");
    }
    get type() {
      return Bo;
    }
    get isArrayNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, s) {
      var o = fi(this.items, function(f) {
        return f._compile(a, s);
      }), p = a.config.matrix !== "Array";
      if (p) {
        var u = a.matrix;
        return function(l, c, h) {
          return u(fi(o, function(d) {
            return d(l, c, h);
          }));
        };
      } else
        return function(l, c, h) {
          return fi(o, function(d) {
            return d(l, c, h);
          });
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      for (var s = 0; s < this.items.length; s++) {
        var o = this.items[s];
        a(o, "items[" + s + "]", this);
      }
    }
    /**
     * Create a new ArrayNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ArrayNode} Returns a transformed copy of the node
     */
    map(a) {
      for (var s = [], o = 0; o < this.items.length; o++)
        s[o] = this._ifNode(a(this.items[o], "items[" + o + "]", this));
      return new r(s);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ArrayNode}
     */
    clone() {
      return new r(this.items.slice(0));
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(a) {
      var s = this.items.map(function(o) {
        return o.toString(a);
      });
      return "[" + s.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Bo,
        items: this.items
      };
    }
    /**
     * Instantiate an ArrayNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ArrayNode", items: [...]}`,
     *                       where mathjs is optional
     * @returns {ArrayNode}
     */
    static fromJSON(a) {
      return new r(a.items);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(a) {
      var s = this.items.map(function(o) {
        return o.toHTML(a);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + s.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(a) {
      function s(o, p) {
        var u = o.some(un) && !o.every(un), f = p || u, l = f ? "&" : "\\\\", c = o.map(function(h) {
          return h.items ? s(h.items, !p) : h.toTex(a);
        }).join(l);
        return u || !f || f && !p ? "\\begin{bmatrix}" + c + "\\end{bmatrix}" : c;
      }
      return s(this.items, !1);
    }
  }
  return xr(r, "name", Bo), r;
}, {
  isClass: !0,
  isNode: !0
});
function oq(t) {
  var {
    subset: e,
    matrix: r
  } = t;
  return function(a, s, o) {
    try {
      if (Array.isArray(a)) {
        var p = r(a).subset(s, o).valueOf();
        return p.forEach((u, f) => {
          a[f] = u;
        }), a;
      } else {
        if (a && typeof a.subset == "function")
          return a.subset(s, o);
        if (typeof a == "string")
          return e(a, s, o);
        if (typeof a == "object") {
          if (!s.isObjectProperty())
            throw TypeError("Cannot apply a numeric index as object property");
          return La(a, s.getObjectProperty(), o), a;
        } else
          throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (u) {
      throw nn(u);
    }
  };
}
var Rn = [{
  // assignment
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  // conditional expression
  ConditionalNode: {
    latexLeftParens: !1,
    latexRightParens: !1,
    latexParens: !1
    // conditionals don't need parentheses in LaTeX because
    // they are 2 dimensional
  }
}, {
  // logical or
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical xor
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical and
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise or
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise xor
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise and
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  // relational operators
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitshift operators
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  // unit conversion
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  // range
  RangeNode: {}
}, {
  // addition, subtraction
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  // multiply, divide, modulus
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: !1,
    latexRightParens: !1,
    latexParens: !1
    // fractions don't require parentheses because
    // they're 2 dimensional, so parens aren't needed
    // in LaTeX
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  // Repeat multiplication for implicit multiplication
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  // unary prefix operators
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  // exponentiation
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: !1
    // the exponent doesn't need parentheses in
    // LaTeX because it's 2 dimensional
    // (it's on top)
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  // factorial
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  // matrix transpose
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];
function Ro(t, e) {
  if (!e || e !== "auto") return t;
  for (var r = t; kn(r); ) r = r.content;
  return r;
}
function Qt(t, e, r, n) {
  var a = t;
  e !== "keep" && (a = t.getContent());
  for (var s = a.getIdentifier(), o = null, p = 0; p < Rn.length; p++)
    if (s in Rn[p]) {
      o = p;
      break;
    }
  if (s === "OperatorNode:multiply" && a.implicit && r !== "show") {
    var u = Ro(a.args[0], e);
    !(Ct(u) && n && n.getIdentifier() === "OperatorNode:divide" && zm(Ro(n.args[0], e))) && !(u.getIdentifier() === "OperatorNode:divide" && zm(Ro(u.args[0], e)) && Ct(Ro(u.args[1]))) && (o += 1);
  }
  return o;
}
function Ss(t, e) {
  var r = t;
  e !== "keep" && (r = t.getContent());
  var n = r.getIdentifier(), a = Qt(r, e);
  if (a === null)
    return null;
  var s = Rn[a][n];
  if (We(s, "associativity")) {
    if (s.associativity === "left")
      return "left";
    if (s.associativity === "right")
      return "right";
    throw Error("'" + n + "' has the invalid associativity '" + s.associativity + "'.");
  }
  return null;
}
function Pm(t, e, r) {
  var n = r !== "keep" ? t.getContent() : t, a = r !== "keep" ? t.getContent() : e, s = n.getIdentifier(), o = a.getIdentifier(), p = Qt(n, r);
  if (p === null)
    return null;
  var u = Rn[p][s];
  if (We(u, "associativeWith") && u.associativeWith instanceof Array) {
    for (var f = 0; f < u.associativeWith.length; f++)
      if (u.associativeWith[f] === o)
        return !0;
    return !1;
  }
  return null;
}
function uq(t) {
  var e = "OperatorNode:" + t;
  for (var r of Rn)
    if (e in r)
      return r[e].op;
  return null;
}
var Lo = "AssignmentNode", lq = [
  "subset",
  "?matrix",
  // FIXME: should not be needed at all, should be handled by subset
  "Node"
], Kc = /* @__PURE__ */ j(Lo, lq, (t) => {
  var {
    subset: e,
    matrix: r,
    Node: n
  } = t, a = jw({
    subset: e
  }), s = oq({
    subset: e,
    matrix: r
  });
  function o(u, f, l) {
    f || (f = "keep");
    var c = Qt(u, f, l), h = Qt(u.value, f, l);
    return f === "all" || h !== null && h <= c;
  }
  class p extends n {
    /**
     * @constructor AssignmentNode
     * @extends {Node}
     *
     * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
     * replace a subset of a matrix like `A[2,2]=42`.
     *
     * Syntax:
     *
     *     new AssignmentNode(symbol, value)
     *     new AssignmentNode(object, index, value)
     *
     * Usage:
     *
     *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode('b'),
     *                       new ConstantNode(2))   // a.b=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode(1, 2),
     *                       new ConstantNode(3))  // a[1,2]=3
     *
     * @param {SymbolNode | AccessorNode} object
     *     Object on which to assign a value
     * @param {IndexNode} [index=null]
     *     Index, property name or matrix index. Optional. If not provided
     *     and `object` is a SymbolNode, the property is assigned to the
     *     global scope.
     * @param {Node} value
     *     The value to be assigned
     */
    constructor(f, l, c) {
      if (super(), this.object = f, this.index = c ? l : null, this.value = c || l, !mr(f) && !pi(f))
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      if (mr(f) && f.name === "end")
        throw new Error('Cannot assign to symbol "end"');
      if (this.index && !qi(this.index))
        throw new TypeError('IndexNode expected as "index"');
      if (!Ut(this.value))
        throw new TypeError('Node expected as "value"');
    }
    // class name for typing purposes:
    // readonly property name
    get name() {
      return this.index ? this.index.isObjectProperty() ? this.index.getObjectProperty() : "" : this.object.name || "";
    }
    get type() {
      return Lo;
    }
    get isAssignmentNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(f, l) {
      var c = this.object._compile(f, l), h = this.index ? this.index._compile(f, l) : null, d = this.value._compile(f, l), g = this.object.name;
      if (this.index)
        if (this.index.isObjectProperty()) {
          var v = this.index.getObjectProperty();
          return function(E, D, A) {
            var M = c(E, D, A), _ = d(E, D, A);
            return La(M, v, _), _;
          };
        } else {
          if (mr(this.object))
            return function(E, D, A) {
              var M = c(E, D, A), _ = d(E, D, A), O = h(E, D, M);
              return E.set(g, s(M, O, _)), _;
            };
          var N = this.object.object._compile(f, l);
          if (this.object.index.isObjectProperty()) {
            var b = this.object.index.getObjectProperty();
            return function(E, D, A) {
              var M = N(E, D, A), _ = Kr(M, b), O = h(E, D, _), T = d(E, D, A);
              return La(M, b, s(_, O, T)), T;
            };
          } else {
            var C = this.object.index._compile(f, l);
            return function(E, D, A) {
              var M = N(E, D, A), _ = C(E, D, M), O = a(M, _), T = h(E, D, O), I = d(E, D, A);
              return s(M, _, s(O, T, I)), I;
            };
          }
        }
      else {
        if (!mr(this.object))
          throw new TypeError("SymbolNode expected as object");
        return function(E, D, A) {
          var M = d(E, D, A);
          return E.set(g, M), M;
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(f) {
      f(this.object, "object", this), this.index && f(this.index, "index", this), f(this.value, "value", this);
    }
    /**
     * Create a new AssignmentNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AssignmentNode} Returns a transformed copy of the node
     */
    map(f) {
      var l = this._ifNode(f(this.object, "object", this)), c = this.index ? this._ifNode(f(this.index, "index", this)) : null, h = this._ifNode(f(this.value, "value", this));
      return new p(l, c, h);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AssignmentNode}
     */
    clone() {
      return new p(this.object, this.index, this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(f) {
      var l = this.object.toString(f), c = this.index ? this.index.toString(f) : "", h = this.value.toString(f);
      return o(this, f && f.parenthesis, f && f.implicit) && (h = "(" + h + ")"), l + c + " = " + h;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Lo,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
     *     where mathjs is optional
     * @returns {AssignmentNode}
     */
    static fromJSON(f) {
      return new p(f.object, f.index, f.value);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(f) {
      var l = this.object.toHTML(f), c = this.index ? this.index.toHTML(f) : "", h = this.value.toHTML(f);
      return o(this, f && f.parenthesis, f && f.implicit) && (h = '<span class="math-paranthesis math-round-parenthesis">(</span>' + h + '<span class="math-paranthesis math-round-parenthesis">)</span>'), l + c + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + h;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(f) {
      var l = this.object.toTex(f), c = this.index ? this.index.toTex(f) : "", h = this.value.toTex(f);
      return o(this, f && f.parenthesis, f && f.implicit) && (h = "\\left(".concat(h, "\\right)")), l + c + "=" + h;
    }
  }
  return xr(p, "name", Lo), p;
}, {
  isClass: !0,
  isNode: !0
}), Po = "BlockNode", cq = ["ResultSet", "Node"], ef = /* @__PURE__ */ j(Po, cq, (t) => {
  var {
    ResultSet: e,
    Node: r
  } = t;
  class n extends r {
    /**
     * @constructor BlockNode
     * @extends {Node}
     * Holds a set with blocks
     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
     *            An array with blocks, where a block is constructed as an
     *            Object with properties block, which is a Node, and visible,
     *            which is a boolean. The property visible is optional and
     *            is true by default
     */
    constructor(s) {
      if (super(), !Array.isArray(s)) throw new Error("Array expected");
      this.blocks = s.map(function(o) {
        var p = o && o.node, u = o && o.visible !== void 0 ? o.visible : !0;
        if (!Ut(p)) throw new TypeError('Property "node" must be a Node');
        if (typeof u != "boolean")
          throw new TypeError('Property "visible" must be a boolean');
        return {
          node: p,
          visible: u
        };
      });
    }
    get type() {
      return Po;
    }
    get isBlockNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, o) {
      var p = fi(this.blocks, function(u) {
        return {
          evaluate: u.node._compile(s, o),
          visible: u.visible
        };
      });
      return function(f, l, c) {
        var h = [];
        return Pu(p, function(g) {
          var v = g.evaluate(f, l, c);
          g.visible && h.push(v);
        }), new e(h);
      };
    }
    /**
     * Execute a callback for each of the child blocks of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      for (var o = 0; o < this.blocks.length; o++)
        s(this.blocks[o].node, "blocks[" + o + "].node", this);
    }
    /**
     * Create a new BlockNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {BlockNode} Returns a transformed copy of the node
     */
    map(s) {
      for (var o = [], p = 0; p < this.blocks.length; p++) {
        var u = this.blocks[p], f = this._ifNode(s(u.node, "blocks[" + p + "].node", this));
        o[p] = {
          node: f,
          visible: u.visible
        };
      }
      return new n(o);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {BlockNode}
     */
    clone() {
      var s = this.blocks.map(function(o) {
        return {
          node: o.node,
          visible: o.visible
        };
      });
      return new n(s);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(s) {
      return this.blocks.map(function(o) {
        return o.node.toString(s) + (o.visible ? "" : ";");
      }).join(`
`);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Po,
        blocks: this.blocks
      };
    }
    /**
     * Instantiate an BlockNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
     *     where mathjs is optional
     * @returns {BlockNode}
     */
    static fromJSON(s) {
      return new n(s.blocks);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(s) {
      return this.blocks.map(function(o) {
        return o.node.toHTML(s) + (o.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(s) {
      return this.blocks.map(function(o) {
        return o.node.toTex(s) + (o.visible ? "" : ";");
      }).join(`\\;\\;
`);
    }
  }
  return xr(n, "name", Po), n;
}, {
  isClass: !0,
  isNode: !0
}), ko = "ConditionalNode", fq = ["Node"], tf = /* @__PURE__ */ j(ko, fq, (t) => {
  var {
    Node: e
  } = t;
  function r(a) {
    if (typeof a == "number" || typeof a == "boolean" || typeof a == "string")
      return !!a;
    if (a) {
      if (ct(a))
        return !a.isZero();
      if (Mn(a))
        return !!(a.re || a.im);
      if (Xr(a))
        return !!a.value;
    }
    if (a == null)
      return !1;
    throw new TypeError('Unsupported type of condition "' + Vt(a) + '"');
  }
  class n extends e {
    /**
     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
     *
     * @param {Node} condition   Condition, must result in a boolean
     * @param {Node} trueExpr    Expression evaluated when condition is true
     * @param {Node} falseExpr   Expression evaluated when condition is true
     *
     * @constructor ConditionalNode
     * @extends {Node}
     */
    constructor(s, o, p) {
      if (super(), !Ut(s))
        throw new TypeError("Parameter condition must be a Node");
      if (!Ut(o))
        throw new TypeError("Parameter trueExpr must be a Node");
      if (!Ut(p))
        throw new TypeError("Parameter falseExpr must be a Node");
      this.condition = s, this.trueExpr = o, this.falseExpr = p;
    }
    get type() {
      return ko;
    }
    get isConditionalNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, o) {
      var p = this.condition._compile(s, o), u = this.trueExpr._compile(s, o), f = this.falseExpr._compile(s, o);
      return function(c, h, d) {
        return r(p(c, h, d)) ? u(c, h, d) : f(c, h, d);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      s(this.condition, "condition", this), s(this.trueExpr, "trueExpr", this), s(this.falseExpr, "falseExpr", this);
    }
    /**
     * Create a new ConditionalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ConditionalNode} Returns a transformed copy of the node
     */
    map(s) {
      return new n(this._ifNode(s(this.condition, "condition", this)), this._ifNode(s(this.trueExpr, "trueExpr", this)), this._ifNode(s(this.falseExpr, "falseExpr", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConditionalNode}
     */
    clone() {
      return new n(this.condition, this.trueExpr, this.falseExpr);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(s) {
      var o = s && s.parenthesis ? s.parenthesis : "keep", p = Qt(this, o, s && s.implicit), u = this.condition.toString(s), f = Qt(this.condition, o, s && s.implicit);
      (o === "all" || this.condition.type === "OperatorNode" || f !== null && f <= p) && (u = "(" + u + ")");
      var l = this.trueExpr.toString(s), c = Qt(this.trueExpr, o, s && s.implicit);
      (o === "all" || this.trueExpr.type === "OperatorNode" || c !== null && c <= p) && (l = "(" + l + ")");
      var h = this.falseExpr.toString(s), d = Qt(this.falseExpr, o, s && s.implicit);
      return (o === "all" || this.falseExpr.type === "OperatorNode" || d !== null && d <= p) && (h = "(" + h + ")"), u + " ? " + l + " : " + h;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: ko,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    /**
     * Instantiate an ConditionalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "ConditionalNode",
     *      "condition": ...,
     *      "trueExpr": ...,
     *      "falseExpr": ...}
     *     ```
     *     where mathjs is optional
     * @returns {ConditionalNode}
     */
    static fromJSON(s) {
      return new n(s.condition, s.trueExpr, s.falseExpr);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(s) {
      var o = s && s.parenthesis ? s.parenthesis : "keep", p = Qt(this, o, s && s.implicit), u = this.condition.toHTML(s), f = Qt(this.condition, o, s && s.implicit);
      (o === "all" || this.condition.type === "OperatorNode" || f !== null && f <= p) && (u = '<span class="math-parenthesis math-round-parenthesis">(</span>' + u + '<span class="math-parenthesis math-round-parenthesis">)</span>');
      var l = this.trueExpr.toHTML(s), c = Qt(this.trueExpr, o, s && s.implicit);
      (o === "all" || this.trueExpr.type === "OperatorNode" || c !== null && c <= p) && (l = '<span class="math-parenthesis math-round-parenthesis">(</span>' + l + '<span class="math-parenthesis math-round-parenthesis">)</span>');
      var h = this.falseExpr.toHTML(s), d = Qt(this.falseExpr, o, s && s.implicit);
      return (o === "all" || this.falseExpr.type === "OperatorNode" || d !== null && d <= p) && (h = '<span class="math-parenthesis math-round-parenthesis">(</span>' + h + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u + '<span class="math-operator math-conditional-operator">?</span>' + l + '<span class="math-operator math-conditional-operator">:</span>' + h;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(s) {
      return "\\begin{cases} {" + this.trueExpr.toTex(s) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(s) + "}\\\\{" + this.falseExpr.toTex(s) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  return xr(n, "name", ko), n;
}, {
  isClass: !0,
  isNode: !0
}), id = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e];
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
  }
  return t;
}, pq = {
  "{": "\\{",
  "}": "\\}",
  "\\": "\\textbackslash{}",
  "#": "\\#",
  $: "\\$",
  "%": "\\%",
  "&": "\\&",
  "^": "\\textasciicircum{}",
  _: "\\_",
  "~": "\\textasciitilde{}"
}, hq = {
  "–": "\\--",
  "—": "\\---",
  " ": "~",
  "	": "\\qquad{}",
  "\r\n": "\\newline{}",
  "\n": "\\newline{}"
}, mq = function(e, r) {
  return id({}, e, r);
}, dq = function(t) {
  for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = e.preserveFormatting, n = r === void 0 ? !1 : r, a = e.escapeMapFn, s = a === void 0 ? mq : a, o = String(t), p = "", u = s(id({}, pq), n ? id({}, hq) : {}), f = Object.keys(u), l = function() {
    var h = !1;
    f.forEach(function(d, g) {
      h || o.length >= d.length && o.slice(0, d.length) === d && (p += u[f[g]], o = o.slice(d.length, o.length), h = !0);
    }), h || (p += o.slice(0, 1), o = o.slice(1, o.length));
  }; o; )
    l();
  return p;
};
const vq = /* @__PURE__ */ zs(dq);
var ad = {
  // GREEK LETTERS
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  // logic
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  // other
  i: "i",
  // TODO use \i ??
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
}, Bt = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  // TODO find ideal solution
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  // TODO find ideal solution
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  // TODO how to handle that properly?
  dotMultiply: ".\\cdot",
  // TODO find ideal solution
  dotDivide: ".:",
  // TODO find ideal solution
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
}, eb = {
  // arithmetic
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(Bt.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(Bt.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(Bt.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(Bt.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(Bt.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(Bt.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(Bt.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: void 0
    // use default template
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(Bt.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: void 0
    // use default template
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(Bt.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(Bt.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(Bt.unaryPlus, "\\left(${args[0]}\\right)")
  },
  // bitwise
  bitAnd: {
    2: "\\left(${args[0]}".concat(Bt.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: Bt.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(Bt.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(Bt.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(Bt.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(Bt.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(Bt.rightLogShift, "${args[1]}\\right)")
  },
  // combinatorics
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  // complex
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  // logical
  and: {
    2: "\\left(${args[0]}".concat(Bt.and, "${args[1]}\\right)")
  },
  not: {
    1: Bt.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(Bt.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(Bt.xor, "${args[1]}\\right)")
  },
  // matrix
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(Bt.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(Bt.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(Bt.transpose)
  },
  // probability
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(Bt.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  // relational
  equal: {
    2: "\\left(${args[0]}".concat(Bt.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(Bt.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(Bt.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(Bt.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(Bt.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(Bt.unequal, "${args[1]}\\right)")
  },
  // special
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  // statistics
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  // trigonometry
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  // unit
  to: {
    2: "\\left(${args[0]}".concat(Bt.to, "${args[1]}\\right)")
  },
  // utils
  numeric: function(e, r) {
    return e.args[0].toTex();
  },
  // type
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  bigint: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(ad.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
}, gq = "\\mathrm{${name}}\\left(${args}\\right)", tb = {
  deg: "^\\circ"
};
function sd(t) {
  return vq(t, {
    preserveFormatting: !0
  });
}
function Zw(t, e) {
  return e = typeof e > "u" ? !1 : e, e ? We(tb, t) ? tb[t] : "\\mathrm{" + sd(t) + "}" : We(ad, t) ? ad[t] : sd(t);
}
var $o = "ConstantNode", yq = ["Node"], rf = /* @__PURE__ */ j($o, yq, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * A ConstantNode holds a constant value like a number or string.
     *
     * Usage:
     *
     *     new ConstantNode(2.3)
     *     new ConstantNode('hello')
     *
     * @param {*} value    Value can be any type (number, BigNumber, bigint, string, ...)
     * @constructor ConstantNode
     * @extends {Node}
     */
    constructor(a) {
      super(), this.value = a;
    }
    get type() {
      return $o;
    }
    get isConstantNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, s) {
      var o = this.value;
      return function() {
        return o;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
    }
    /**
     * Create a new ConstantNode with children produced by the given callback.
     * Trivial because there are no children.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ConstantNode} Returns a clone of the node
     */
    map(a) {
      return this.clone();
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConstantNode}
     */
    clone() {
      return new r(this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(a) {
      return Dt(this.value, a);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(a) {
      var s = this._toString(a);
      switch (Vt(this.value)) {
        case "number":
        case "bigint":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + s + "</span>";
        case "string":
          return '<span class="math-string">' + s + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + s + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + s + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + s + "</span>";
        default:
          return '<span class="math-symbol">' + s + "</span>";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: $o,
        value: this.value
      };
    }
    /**
     * Instantiate a ConstantNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", value: 2.3}`,
     *                       where mathjs is optional
     * @returns {ConstantNode}
     */
    static fromJSON(a) {
      return new r(a.value);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(a) {
      var s = this._toString(a), o = Vt(this.value);
      switch (o) {
        case "string":
          return "\\mathtt{" + sd(s) + "}";
        case "number":
        case "BigNumber": {
          var p = o === "BigNumber" ? this.value.isFinite() : isFinite(this.value);
          if (!p)
            return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
          var u = s.toLowerCase().indexOf("e");
          return u !== -1 ? s.substring(0, u) + "\\cdot10^{" + s.substring(u + 1) + "}" : s;
        }
        case "bigint":
          return s.toString();
        case "Fraction":
          return this.value.toLatex();
        default:
          return s;
      }
    }
  }
  return xr(r, "name", $o), r;
}, {
  isClass: !0,
  isNode: !0
}), zo = "FunctionAssignmentNode", xq = ["typed", "Node"], nf = /* @__PURE__ */ j(zo, xq, (t) => {
  var {
    typed: e,
    Node: r
  } = t;
  function n(s, o, p) {
    var u = Qt(s, o, p), f = Qt(s.expr, o, p);
    return o === "all" || f !== null && f <= u;
  }
  class a extends r {
    /**
     * @constructor FunctionAssignmentNode
     * @extends {Node}
     * Function assignment
     *
     * @param {string} name           Function name
     * @param {string[] | Array.<{name: string, type: string}>} params
     *                                Array with function parameter names, or an
     *                                array with objects containing the name
     *                                and type of the parameter
     * @param {Node} expr             The function expression
     */
    constructor(o, p, u) {
      if (super(), typeof o != "string")
        throw new TypeError('String expected for parameter "name"');
      if (!Array.isArray(p))
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      if (!Ut(u))
        throw new TypeError('Node expected for parameter "expr"');
      if (Ww.has(o))
        throw new Error('Illegal function name, "' + o + '" is a reserved keyword');
      var f = /* @__PURE__ */ new Set();
      for (var l of p) {
        var c = typeof l == "string" ? l : l.name;
        if (f.has(c))
          throw new Error('Duplicate parameter name "'.concat(c, '"'));
        f.add(c);
      }
      this.name = o, this.params = p.map(function(h) {
        return h && h.name || h;
      }), this.types = p.map(function(h) {
        return h && h.type || "any";
      }), this.expr = u;
    }
    get type() {
      return zo;
    }
    get isFunctionAssignmentNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(o, p) {
      var u = Object.create(p);
      Pu(this.params, function(g) {
        u[g] = !0;
      });
      var f = this.expr._compile(o, u), l = this.name, c = this.params, h = t1(this.types, ","), d = l + "(" + t1(this.params, ", ") + ")";
      return function(v, N, b) {
        var C = {};
        C[h] = function() {
          for (var E = Object.create(N), D = 0; D < c.length; D++)
            E[c[D]] = arguments[D];
          return f(v, E, b);
        };
        var x = e(l, C);
        return x.syntax = d, v.set(l, x), x;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(o) {
      o(this.expr, "expr", this);
    }
    /**
     * Create a new FunctionAssignmentNode whose children are the results of
     * calling the provided callback function for each child of the original
     * node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
     */
    map(o) {
      var p = this._ifNode(o(this.expr, "expr", this));
      return new a(this.name, this.params.slice(0), p);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionAssignmentNode}
     */
    clone() {
      return new a(this.name, this.params.slice(0), this.expr);
    }
    /**
     * get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(o) {
      var p = o && o.parenthesis ? o.parenthesis : "keep", u = this.expr.toString(o);
      return n(this, p, o && o.implicit) && (u = "(" + u + ")"), this.name + "(" + this.params.join(", ") + ") = " + u;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      var o = this.types;
      return {
        mathjs: zo,
        name: this.name,
        params: this.params.map(function(p, u) {
          return {
            name: p,
            type: o[u]
          };
        }),
        expr: this.expr
      };
    }
    /**
     * Instantiate an FunctionAssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "FunctionAssignmentNode",
     *      name: ..., params: ..., expr: ...}
     *     ```
     *     where mathjs is optional
     * @returns {FunctionAssignmentNode}
     */
    static fromJSON(o) {
      return new a(o.name, o.params, o.expr);
    }
    /**
     * get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(o) {
      for (var p = o && o.parenthesis ? o.parenthesis : "keep", u = [], f = 0; f < this.params.length; f++)
        u.push('<span class="math-symbol math-parameter">' + _n(this.params[f]) + "</span>");
      var l = this.expr.toHTML(o);
      return n(this, p, o && o.implicit) && (l = '<span class="math-parenthesis math-round-parenthesis">(</span>' + l + '<span class="math-parenthesis math-round-parenthesis">)</span>'), '<span class="math-function">' + _n(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + u.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + l;
    }
    /**
     * get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(o) {
      var p = o && o.parenthesis ? o.parenthesis : "keep", u = this.expr.toTex(o);
      return n(this, p, o && o.implicit) && (u = "\\left(".concat(u, "\\right)")), "\\mathrm{" + this.name + "}\\left(" + this.params.map(Zw).join(",") + "\\right)=" + u;
    }
  }
  return xr(a, "name", zo), a;
}, {
  isClass: !0,
  isNode: !0
}), Uo = "IndexNode", bq = ["Node", "size"], af = /* @__PURE__ */ j(Uo, bq, (t) => {
  var {
    Node: e,
    size: r
  } = t;
  class n extends e {
    /**
     * @constructor IndexNode
     * @extends Node
     *
     * Describes a subset of a matrix or an object property.
     * Cannot be used on its own, needs to be used within an AccessorNode or
     * AssignmentNode.
     *
     * @param {Node[]} dimensions
     * @param {boolean} [dotNotation=false]
     *     Optional property describing whether this index was written using dot
     *     notation like `a.b`, or using bracket notation like `a["b"]`
     *     (which is the default). This property is used for string conversion.
     */
    constructor(s, o) {
      if (super(), this.dimensions = s, this.dotNotation = o || !1, !Array.isArray(s) || !s.every(Ut))
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      if (this.dotNotation && !this.isObjectProperty())
        throw new Error("dotNotation only applicable for object properties");
    }
    get type() {
      return Uo;
    }
    get isIndexNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, o) {
      var p = fi(this.dimensions, function(f, l) {
        var c = f.filter((g) => g.isSymbolNode && g.name === "end").length > 0;
        if (c) {
          var h = Object.create(o);
          h.end = !0;
          var d = f._compile(s, h);
          return function(v, N, b) {
            if (!tt(b) && !Rt(b) && !Er(b))
              throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + Vt(b));
            var C = r(b).valueOf(), x = Object.create(N);
            return x.end = C[l], d(v, x, b);
          };
        } else
          return f._compile(s, o);
      }), u = Kr(s, "index");
      return function(l, c, h) {
        var d = fi(p, function(g) {
          return g(l, c, h);
        });
        return u(...d);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      for (var o = 0; o < this.dimensions.length; o++)
        s(this.dimensions[o], "dimensions[" + o + "]", this);
    }
    /**
     * Create a new IndexNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {IndexNode} Returns a transformed copy of the node
     */
    map(s) {
      for (var o = [], p = 0; p < this.dimensions.length; p++)
        o[p] = this._ifNode(s(this.dimensions[p], "dimensions[" + p + "]", this));
      return new n(o, this.dotNotation);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {IndexNode}
     */
    clone() {
      return new n(this.dimensions.slice(0), this.dotNotation);
    }
    /**
     * Test whether this IndexNode contains a single property name
     * @return {boolean}
     */
    isObjectProperty() {
      return this.dimensions.length === 1 && Ct(this.dimensions[0]) && typeof this.dimensions[0].value == "string";
    }
    /**
     * Returns the property name if IndexNode contains a property.
     * If not, returns null.
     * @return {string | null}
     */
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(s) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Uo,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    /**
     * Instantiate an IndexNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
     *     where mathjs is optional
     * @returns {IndexNode}
     */
    static fromJSON(s) {
      return new n(s.dimensions, s.dotNotation);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(s) {
      for (var o = [], p = 0; p < this.dimensions.length; p++)
        o[p] = this.dimensions[p].toHTML();
      return this.dotNotation ? '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + _n(this.getObjectProperty()) + "</span>" : '<span class="math-parenthesis math-square-parenthesis">[</span>' + o.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(s) {
      var o = this.dimensions.map(function(p) {
        return p.toTex(s);
      });
      return this.dotNotation ? "." + this.getObjectProperty() : "_{" + o.join(",") + "}";
    }
  }
  return xr(n, "name", Uo), n;
}, {
  isClass: !0,
  isNode: !0
}), Go = "ObjectNode", wq = ["Node"], sf = /* @__PURE__ */ j(Go, wq, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * @constructor ObjectNode
     * @extends {Node}
     * Holds an object with keys/values
     * @param {Object.<string, Node>} [properties]   object with key/value pairs
     */
    constructor(a) {
      if (super(), this.properties = a || {}, a && (typeof a != "object" || !Object.keys(a).every(function(s) {
        return Ut(a[s]);
      })))
        throw new TypeError("Object containing Nodes expected");
    }
    get type() {
      return Go;
    }
    get isObjectNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, s) {
      var o = {};
      for (var p in this.properties)
        if (We(this.properties, p)) {
          var u = Fa(p), f = JSON.parse(u), l = Kr(this.properties, p);
          o[f] = l._compile(a, s);
        }
      return function(h, d, g) {
        var v = {};
        for (var N in o)
          We(o, N) && (v[N] = o[N](h, d, g));
        return v;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      for (var s in this.properties)
        We(this.properties, s) && a(this.properties[s], "properties[" + Fa(s) + "]", this);
    }
    /**
     * Create a new ObjectNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ObjectNode} Returns a transformed copy of the node
     */
    map(a) {
      var s = {};
      for (var o in this.properties)
        We(this.properties, o) && (s[o] = this._ifNode(a(this.properties[o], "properties[" + Fa(o) + "]", this)));
      return new r(s);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ObjectNode}
     */
    clone() {
      var a = {};
      for (var s in this.properties)
        We(this.properties, s) && (a[s] = this.properties[s]);
      return new r(a);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(a) {
      var s = [];
      for (var o in this.properties)
        We(this.properties, o) && s.push(Fa(o) + ": " + this.properties[o].toString(a));
      return "{" + s.join(", ") + "}";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Go,
        properties: this.properties
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
     *                       where mathjs is optional
     * @returns {ObjectNode}
     */
    static fromJSON(a) {
      return new r(a.properties);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(a) {
      var s = [];
      for (var o in this.properties)
        We(this.properties, o) && s.push('<span class="math-symbol math-property">' + _n(o) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[o].toHTML(a));
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + s.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(a) {
      var s = [];
      for (var o in this.properties)
        We(this.properties, o) && s.push("\\mathbf{" + o + ":} & " + this.properties[o].toTex(a) + "\\\\");
      var p = "\\left\\{\\begin{array}{ll}" + s.join(`
`) + "\\end{array}\\right\\}";
      return p;
    }
  }
  return xr(r, "name", Go), r;
}, {
  isClass: !0,
  isNode: !0
});
function Ts(t, e) {
  return new E2(t, new Cu(e), new Set(Object.keys(e)));
}
var Ho = "OperatorNode", Nq = ["Node"], of = /* @__PURE__ */ j(Ho, Nq, (t) => {
  var {
    Node: e
  } = t;
  function r(s, o) {
    var p = s;
    if (o === "auto")
      for (; kn(p); ) p = p.content;
    return Ct(p) ? !0 : or(p) ? r(p.args[0], o) : !1;
  }
  function n(s, o, p, u, f) {
    var l = Qt(s, o, p), c = Ss(s, o);
    if (o === "all" || u.length > 2 && s.getIdentifier() !== "OperatorNode:add" && s.getIdentifier() !== "OperatorNode:multiply")
      return u.map(function(T) {
        switch (T.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return !1;
          default:
            return !0;
        }
      });
    var h;
    switch (u.length) {
      case 0:
        h = [];
        break;
      case 1:
        {
          var d = Qt(u[0], o, p, s);
          if (f && d !== null) {
            var g, v;
            if (o === "keep" ? (g = u[0].getIdentifier(), v = s.getIdentifier()) : (g = u[0].getContent().getIdentifier(), v = s.getContent().getIdentifier()), Rn[l][v].latexLeftParens === !1) {
              h = [!1];
              break;
            }
            if (Rn[d][g].latexParens === !1) {
              h = [!1];
              break;
            }
          }
          if (d === null) {
            h = [!1];
            break;
          }
          if (d <= l) {
            h = [!0];
            break;
          }
          h = [!1];
        }
        break;
      case 2:
        {
          var N, b = Qt(u[0], o, p, s), C = Pm(s, u[0], o);
          b === null ? N = !1 : b === l && c === "right" && !C || b < l ? N = !0 : N = !1;
          var x, E = Qt(u[1], o, p, s), D = Pm(s, u[1], o);
          if (E === null ? x = !1 : E === l && c === "left" && !D || E < l ? x = !0 : x = !1, f) {
            var A, M, _;
            o === "keep" ? (A = s.getIdentifier(), M = s.args[0].getIdentifier(), _ = s.args[1].getIdentifier()) : (A = s.getContent().getIdentifier(), M = s.args[0].getContent().getIdentifier(), _ = s.args[1].getContent().getIdentifier()), b !== null && (Rn[l][A].latexLeftParens === !1 && (N = !1), Rn[b][M].latexParens === !1 && (N = !1)), E !== null && (Rn[l][A].latexRightParens === !1 && (x = !1), Rn[E][_].latexParens === !1 && (x = !1));
          }
          h = [N, x];
        }
        break;
      default:
        (s.getIdentifier() === "OperatorNode:add" || s.getIdentifier() === "OperatorNode:multiply") && (h = u.map(function(T) {
          var I = Qt(T, o, p, s), q = Pm(s, T, o), $ = Ss(T, o);
          return I === null ? !1 : l === I && c === $ && !q ? !0 : I < l;
        }));
        break;
    }
    if (u.length >= 2 && s.getIdentifier() === "OperatorNode:multiply" && s.implicit && o !== "all" && p === "hide")
      for (var O = 1; O < h.length; ++O)
        r(u[O], o) && !h[O - 1] && (o !== "keep" || !kn(u[O - 1])) && (h[O] = !0);
    return h;
  }
  class a extends e {
    /**
     * @constructor OperatorNode
     * @extends {Node}
     * An operator with two arguments, like 2+3
     *
     * @param {string} op           Operator name, for example '+'
     * @param {string} fn           Function name, for example 'add'
     * @param {Node[]} args         Operator arguments
     * @param {boolean} [implicit]  Is this an implicit multiplication?
     * @param {boolean} [isPercentage] Is this an percentage Operation?
     */
    constructor(o, p, u, f, l) {
      if (super(), typeof o != "string")
        throw new TypeError('string expected for parameter "op"');
      if (typeof p != "string")
        throw new TypeError('string expected for parameter "fn"');
      if (!Array.isArray(u) || !u.every(Ut))
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      this.implicit = f === !0, this.isPercentage = l === !0, this.op = o, this.fn = p, this.args = u || [];
    }
    get type() {
      return Ho;
    }
    get isOperatorNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(o, p) {
      if (typeof this.fn != "string" || !Nd(o, this.fn))
        throw o[this.fn] ? new Error('No access to function "' + this.fn + '"') : new Error("Function " + this.fn + ' missing in provided namespace "math"');
      var u = Kr(o, this.fn), f = fi(this.args, function(g) {
        return g._compile(o, p);
      });
      if (typeof u == "function" && u.rawArgs === !0) {
        var l = this.args;
        return function(v, N, b) {
          return u(l, o, Ts(v, N));
        };
      } else if (f.length === 1) {
        var c = f[0];
        return function(v, N, b) {
          return u(c(v, N, b));
        };
      } else if (f.length === 2) {
        var h = f[0], d = f[1];
        return function(v, N, b) {
          return u(h(v, N, b), d(v, N, b));
        };
      } else
        return function(v, N, b) {
          return u.apply(null, fi(f, function(C) {
            return C(v, N, b);
          }));
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(o) {
      for (var p = 0; p < this.args.length; p++)
        o(this.args[p], "args[" + p + "]", this);
    }
    /**
     * Create a new OperatorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(o) {
      for (var p = [], u = 0; u < this.args.length; u++)
        p[u] = this._ifNode(o(this.args[u], "args[" + u + "]", this));
      return new a(this.op, this.fn, p, this.implicit, this.isPercentage);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {OperatorNode}
     */
    clone() {
      return new a(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    /**
     * Check whether this is an unary OperatorNode:
     * has exactly one argument, like `-a`.
     * @return {boolean}
     *     Returns true when an unary operator node, false otherwise.
     */
    isUnary() {
      return this.args.length === 1;
    }
    /**
     * Check whether this is a binary OperatorNode:
     * has exactly two arguments, like `a + b`.
     * @return {boolean}
     *     Returns true when a binary operator node, false otherwise.
     */
    isBinary() {
      return this.args.length === 2;
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(o) {
      var p = o && o.parenthesis ? o.parenthesis : "keep", u = o && o.implicit ? o.implicit : "hide", f = this.args, l = n(this, p, u, f, !1);
      if (f.length === 1) {
        var c = Ss(this, p), h = f[0].toString(o);
        l[0] && (h = "(" + h + ")");
        var d = /[a-zA-Z]+/.test(this.op);
        return c === "right" ? this.op + (d ? " " : "") + h : c === "left" ? h + (d ? " " : "") + this.op : h + this.op;
      } else if (f.length === 2) {
        var g = f[0].toString(o), v = f[1].toString(o);
        return l[0] && (g = "(" + g + ")"), l[1] && (v = "(" + v + ")"), this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? g + " " + v : g + " " + this.op + " " + v;
      } else if (f.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var N = f.map(function(b, C) {
          return b = b.toString(o), l[C] && (b = "(" + b + ")"), b;
        });
        return this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? N.join(" ") : N.join(" " + this.op + " ");
      } else
        return this.fn + "(" + this.args.join(", ") + ")";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Ho,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "OperatorNode",
     *      "op": "+", "fn": "add", "args": [...],
     *      "implicit": false,
     *      "isPercentage":false}
     *     ```
     *     where mathjs is optional
     * @returns {OperatorNode}
     */
    static fromJSON(o) {
      return new a(o.op, o.fn, o.args, o.implicit, o.isPercentage);
    }
    /**
     * Get HTML representation.
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(o) {
      var p = o && o.parenthesis ? o.parenthesis : "keep", u = o && o.implicit ? o.implicit : "hide", f = this.args, l = n(this, p, u, f, !1);
      if (f.length === 1) {
        var c = Ss(this, p), h = f[0].toHTML(o);
        return l[0] && (h = '<span class="math-parenthesis math-round-parenthesis">(</span>' + h + '<span class="math-parenthesis math-round-parenthesis">)</span>'), c === "right" ? '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + _n(this.op) + "</span>" + h : h + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + _n(this.op) + "</span>";
      } else if (f.length === 2) {
        var d = f[0].toHTML(o), g = f[1].toHTML(o);
        return l[0] && (d = '<span class="math-parenthesis math-round-parenthesis">(</span>' + d + '<span class="math-parenthesis math-round-parenthesis">)</span>'), l[1] && (g = '<span class="math-parenthesis math-round-parenthesis">(</span>' + g + '<span class="math-parenthesis math-round-parenthesis">)</span>'), this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? d + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + g : d + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + _n(this.op) + "</span>" + g;
      } else {
        var v = f.map(function(N, b) {
          return N = N.toHTML(o), l[b] && (N = '<span class="math-parenthesis math-round-parenthesis">(</span>' + N + '<span class="math-parenthesis math-round-parenthesis">)</span>'), N;
        });
        return f.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply") ? this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? v.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>') : v.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + _n(this.op) + "</span>") : '<span class="math-function">' + _n(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + v.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(o) {
      var p = o && o.parenthesis ? o.parenthesis : "keep", u = o && o.implicit ? o.implicit : "hide", f = this.args, l = n(this, p, u, f, !0), c = Bt[this.fn];
      if (c = typeof c > "u" ? this.op : c, f.length === 1) {
        var h = Ss(this, p), d = f[0].toTex(o);
        return l[0] && (d = "\\left(".concat(d, "\\right)")), h === "right" ? c + d : d + c;
      } else if (f.length === 2) {
        var g = f[0], v = g.toTex(o);
        l[0] && (v = "\\left(".concat(v, "\\right)"));
        var N = f[1], b = N.toTex(o);
        l[1] && (b = "\\left(".concat(b, "\\right)"));
        var C;
        switch (p === "keep" ? C = g.getIdentifier() : C = g.getContent().getIdentifier(), this.getIdentifier()) {
          case "OperatorNode:divide":
            return c + "{" + v + "}{" + b + "}";
          case "OperatorNode:pow":
            switch (v = "{" + v + "}", b = "{" + b + "}", C) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                v = "\\left(".concat(v, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && u === "hide")
              return v + "~" + b;
        }
        return v + c + b;
      } else if (f.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var x = f.map(function(E, D) {
          return E = E.toTex(o), l[D] && (E = "\\left(".concat(E, "\\right)")), E;
        });
        return this.getIdentifier() === "OperatorNode:multiply" && this.implicit && u === "hide" ? x.join("~") : x.join(c);
      } else
        return "\\mathrm{" + this.fn + "}\\left(" + f.map(function(E) {
          return E.toTex(o);
        }).join(",") + "\\right)";
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  return xr(a, "name", Ho), a;
}, {
  isClass: !0,
  isNode: !0
}), Qo = "ParenthesisNode", Dq = ["Node"], uf = /* @__PURE__ */ j(Qo, Dq, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * @constructor ParenthesisNode
     * @extends {Node}
     * A parenthesis node describes manual parenthesis from the user input
     * @param {Node} content
     * @extends {Node}
     */
    constructor(a) {
      if (super(), !Ut(a))
        throw new TypeError('Node expected for parameter "content"');
      this.content = a;
    }
    get type() {
      return Qo;
    }
    get isParenthesisNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, s) {
      return this.content._compile(a, s);
    }
    /**
     * Get the content of the current Node.
     * @return {Node} content
     * @override
     **/
    getContent() {
      return this.content.getContent();
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      a(this.content, "content", this);
    }
    /**
     * Create a new ParenthesisNode whose child is the result of calling
     * the provided callback function on the child of this node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ParenthesisNode} Returns a clone of the node
     */
    map(a) {
      var s = a(this.content, "content", this);
      return new r(s);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ParenthesisNode}
     */
    clone() {
      return new r(this.content);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(a) {
      return !a || a && !a.parenthesis || a && a.parenthesis === "keep" ? "(" + this.content.toString(a) + ")" : this.content.toString(a);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Qo,
        content: this.content
      };
    }
    /**
     * Instantiate an ParenthesisNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
     *                       where mathjs is optional
     * @returns {ParenthesisNode}
     */
    static fromJSON(a) {
      return new r(a.content);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(a) {
      return !a || a && !a.parenthesis || a && a.parenthesis === "keep" ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(a) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : this.content.toHTML(a);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(a) {
      return !a || a && !a.parenthesis || a && a.parenthesis === "keep" ? "\\left(".concat(this.content.toTex(a), "\\right)") : this.content.toTex(a);
    }
  }
  return xr(r, "name", Qo), r;
}, {
  isClass: !0,
  isNode: !0
}), Vo = "RangeNode", Aq = ["Node"], lf = /* @__PURE__ */ j(Vo, Aq, (t) => {
  var {
    Node: e
  } = t;
  function r(a, s, o) {
    var p = Qt(a, s, o), u = {}, f = Qt(a.start, s, o);
    if (u.start = f !== null && f <= p || s === "all", a.step) {
      var l = Qt(a.step, s, o);
      u.step = l !== null && l <= p || s === "all";
    }
    var c = Qt(a.end, s, o);
    return u.end = c !== null && c <= p || s === "all", u;
  }
  class n extends e {
    /**
     * @constructor RangeNode
     * @extends {Node}
     * create a range
     * @param {Node} start  included lower-bound
     * @param {Node} end    included upper-bound
     * @param {Node} [step] optional step
     */
    constructor(s, o, p) {
      if (super(), !Ut(s)) throw new TypeError("Node expected");
      if (!Ut(o)) throw new TypeError("Node expected");
      if (p && !Ut(p)) throw new TypeError("Node expected");
      if (arguments.length > 3) throw new Error("Too many arguments");
      this.start = s, this.end = o, this.step = p || null;
    }
    get type() {
      return Vo;
    }
    get isRangeNode() {
      return !0;
    }
    /**
     * Check whether the RangeNode needs the `end` symbol to be defined.
     * This end is the size of the Matrix in current dimension.
     * @return {boolean}
     */
    needsEnd() {
      var s = this.filter(function(o) {
        return mr(o) && o.name === "end";
      });
      return s.length > 0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, o) {
      var p = s.range, u = this.start._compile(s, o), f = this.end._compile(s, o);
      if (this.step) {
        var l = this.step._compile(s, o);
        return function(h, d, g) {
          return p(u(h, d, g), f(h, d, g), l(h, d, g));
        };
      } else
        return function(h, d, g) {
          return p(u(h, d, g), f(h, d, g));
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      s(this.start, "start", this), s(this.end, "end", this), this.step && s(this.step, "step", this);
    }
    /**
     * Create a new RangeNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RangeNode} Returns a transformed copy of the node
     */
    map(s) {
      return new n(this._ifNode(s(this.start, "start", this)), this._ifNode(s(this.end, "end", this)), this.step && this._ifNode(s(this.step, "step", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RangeNode}
     */
    clone() {
      return new n(this.start, this.end, this.step && this.step);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(s) {
      var o = s && s.parenthesis ? s.parenthesis : "keep", p = r(this, o, s && s.implicit), u, f = this.start.toString(s);
      if (p.start && (f = "(" + f + ")"), u = f, this.step) {
        var l = this.step.toString(s);
        p.step && (l = "(" + l + ")"), u += ":" + l;
      }
      var c = this.end.toString(s);
      return p.end && (c = "(" + c + ")"), u += ":" + c, u;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Vo,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    /**
     * Instantiate an RangeNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
     *     where mathjs is optional
     * @returns {RangeNode}
     */
    static fromJSON(s) {
      return new n(s.start, s.end, s.step);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(s) {
      var o = s && s.parenthesis ? s.parenthesis : "keep", p = r(this, o, s && s.implicit), u, f = this.start.toHTML(s);
      if (p.start && (f = '<span class="math-parenthesis math-round-parenthesis">(</span>' + f + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u = f, this.step) {
        var l = this.step.toHTML(s);
        p.step && (l = '<span class="math-parenthesis math-round-parenthesis">(</span>' + l + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u += '<span class="math-operator math-range-operator">:</span>' + l;
      }
      var c = this.end.toHTML(s);
      return p.end && (c = '<span class="math-parenthesis math-round-parenthesis">(</span>' + c + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u += '<span class="math-operator math-range-operator">:</span>' + c, u;
    }
    /**
     * Get LaTeX representation
     * @params {Object} options
     * @return {string} str
     */
    _toTex(s) {
      var o = s && s.parenthesis ? s.parenthesis : "keep", p = r(this, o, s && s.implicit), u = this.start.toTex(s);
      if (p.start && (u = "\\left(".concat(u, "\\right)")), this.step) {
        var f = this.step.toTex(s);
        p.step && (f = "\\left(".concat(f, "\\right)")), u += ":" + f;
      }
      var l = this.end.toTex(s);
      return p.end && (l = "\\left(".concat(l, "\\right)")), u += ":" + l, u;
    }
  }
  return xr(n, "name", Vo), n;
}, {
  isClass: !0,
  isNode: !0
}), Wo = "RelationalNode", Eq = ["Node"], cf = /* @__PURE__ */ j(Wo, Eq, (t) => {
  var {
    Node: e
  } = t, r = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };
  class n extends e {
    /**
     * A node representing a chained conditional expression, such as 'x > y > z'
     *
     * @param {String[]} conditionals
     *     An array of conditional operators used to compare the parameters
     * @param {Node[]} params
     *     The parameters that will be compared
     *
     * @constructor RelationalNode
     * @extends {Node}
     */
    constructor(s, o) {
      if (super(), !Array.isArray(s))
        throw new TypeError("Parameter conditionals must be an array");
      if (!Array.isArray(o))
        throw new TypeError("Parameter params must be an array");
      if (s.length !== o.length - 1)
        throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
      this.conditionals = s, this.params = o;
    }
    get type() {
      return Wo;
    }
    get isRelationalNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, o) {
      var p = this, u = this.params.map((f) => f._compile(s, o));
      return function(l, c, h) {
        for (var d, g = u[0](l, c, h), v = 0; v < p.conditionals.length; v++) {
          d = g, g = u[v + 1](l, c, h);
          var N = Kr(s, p.conditionals[v]);
          if (!N(d, g))
            return !1;
        }
        return !0;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      this.params.forEach((o, p) => s(o, "params[" + p + "]", this), this);
    }
    /**
     * Create a new RelationalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RelationalNode} Returns a transformed copy of the node
     */
    map(s) {
      return new n(this.conditionals.slice(), this.params.map((o, p) => this._ifNode(s(o, "params[" + p + "]", this)), this));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RelationalNode}
     */
    clone() {
      return new n(this.conditionals, this.params);
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(s) {
      for (var o = s && s.parenthesis ? s.parenthesis : "keep", p = Qt(this, o, s && s.implicit), u = this.params.map(function(c, h) {
        var d = Qt(c, o, s && s.implicit);
        return o === "all" || d !== null && d <= p ? "(" + c.toString(s) + ")" : c.toString(s);
      }), f = u[0], l = 0; l < this.conditionals.length; l++)
        f += " " + r[this.conditionals[l]], f += " " + u[l + 1];
      return f;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Wo,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    /**
     * Instantiate a RelationalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
     *     where mathjs is optional
     * @returns {RelationalNode}
     */
    static fromJSON(s) {
      return new n(s.conditionals, s.params);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(s) {
      for (var o = s && s.parenthesis ? s.parenthesis : "keep", p = Qt(this, o, s && s.implicit), u = this.params.map(function(c, h) {
        var d = Qt(c, o, s && s.implicit);
        return o === "all" || d !== null && d <= p ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + c.toHTML(s) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : c.toHTML(s);
      }), f = u[0], l = 0; l < this.conditionals.length; l++)
        f += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + _n(r[this.conditionals[l]]) + "</span>" + u[l + 1];
      return f;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(s) {
      for (var o = s && s.parenthesis ? s.parenthesis : "keep", p = Qt(this, o, s && s.implicit), u = this.params.map(function(c, h) {
        var d = Qt(c, o, s && s.implicit);
        return o === "all" || d !== null && d <= p ? "\\left(" + c.toTex(s) + "\right)" : c.toTex(s);
      }), f = u[0], l = 0; l < this.conditionals.length; l++)
        f += Bt[this.conditionals[l]] + u[l + 1];
      return f;
    }
  }
  return xr(n, "name", Wo), n;
}, {
  isClass: !0,
  isNode: !0
}), Sq = "SymbolNode", Cq = ["math", "?Unit", "Node"], ff = /* @__PURE__ */ j(Sq, Cq, (t) => {
  var {
    math: e,
    Unit: r,
    Node: n
  } = t;
  function a(o) {
    return r ? r.isValuelessUnit(o) : !1;
  }
  class s extends n {
    /**
     * @constructor SymbolNode
     * @extends {Node}
     * A symbol node can hold and resolve a symbol
     * @param {string} name
     * @extends {Node}
     */
    constructor(p) {
      if (super(), typeof p != "string")
        throw new TypeError('String expected for parameter "name"');
      this.name = p;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(p, u) {
      var f = this.name;
      if (u[f] === !0)
        return function(c, h, d) {
          return Kr(h, f);
        };
      if (f in p)
        return function(c, h, d) {
          return c.has(f) ? c.get(f) : Kr(p, f);
        };
      var l = a(f);
      return function(c, h, d) {
        return c.has(f) ? c.get(f) : l ? new r(null, f) : s.onUndefinedSymbol(f);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(p) {
    }
    /**
     * Create a new SymbolNode with children produced by the given callback.
     * Trivial since a SymbolNode has no children
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {SymbolNode} Returns a clone of the node
     */
    map(p) {
      return this.clone();
    }
    /**
     * Throws an error 'Undefined symbol {name}'
     * @param {string} name
     */
    static onUndefinedSymbol(p) {
      throw new Error("Undefined symbol " + p);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {SymbolNode}
     */
    clone() {
      return new s(this.name);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(p) {
      return this.name;
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(p) {
      var u = _n(this.name);
      return u === "true" || u === "false" ? '<span class="math-symbol math-boolean">' + u + "</span>" : u === "i" ? '<span class="math-symbol math-imaginary-symbol">' + u + "</span>" : u === "Infinity" ? '<span class="math-symbol math-infinity-symbol">' + u + "</span>" : u === "NaN" ? '<span class="math-symbol math-nan-symbol">' + u + "</span>" : u === "null" ? '<span class="math-symbol math-null-symbol">' + u + "</span>" : u === "undefined" ? '<span class="math-symbol math-undefined-symbol">' + u + "</span>" : '<span class="math-symbol">' + u + "</span>";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    /**
     * Instantiate a SymbolNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", name: "x"}`,
     *                       where mathjs is optional
     * @returns {SymbolNode}
     */
    static fromJSON(p) {
      return new s(p.name);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(p) {
      var u = !1;
      typeof e[this.name] > "u" && a(this.name) && (u = !0);
      var f = Zw(this.name, u);
      return f[0] === "\\" ? f : " " + f;
    }
  }
  return s;
}, {
  isClass: !0,
  isNode: !0
}), jo = "FunctionNode", Tq = ["math", "Node", "SymbolNode"], pf = /* @__PURE__ */ j(jo, Tq, (t) => {
  var e, {
    math: r,
    Node: n,
    SymbolNode: a
  } = t, s = (u) => Dt(u, {
    truncate: 78
  });
  function o(u, f, l) {
    for (var c = "", h = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi, d = 0, g; (g = h.exec(u)) !== null; )
      if (c += u.substring(d, g.index), d = g.index, g[0] === "$$")
        c += "$", d++;
      else {
        d += g[0].length;
        var v = f[g[1]];
        if (!v)
          throw new ReferenceError("Template: Property " + g[1] + " does not exist.");
        if (g[2] === void 0)
          switch (typeof v) {
            case "string":
              c += v;
              break;
            case "object":
              if (Ut(v))
                c += v.toTex(l);
              else if (Array.isArray(v))
                c += v.map(function(N, b) {
                  if (Ut(N))
                    return N.toTex(l);
                  throw new TypeError("Template: " + g[1] + "[" + b + "] is not a Node.");
                }).join(",");
              else
                throw new TypeError("Template: " + g[1] + " has to be a Node, String or array of Nodes");
              break;
            default:
              throw new TypeError("Template: " + g[1] + " has to be a Node, String or array of Nodes");
          }
        else if (Ut(v[g[2]] && v[g[2]]))
          c += v[g[2]].toTex(l);
        else
          throw new TypeError("Template: " + g[1] + "[" + g[2] + "] is not a Node.");
      }
    return c += u.slice(d), c;
  }
  class p extends n {
    /**
     * @constructor FunctionNode
     * @extends {./Node}
     * invoke a list with arguments on a node
     * @param {./Node | string} fn
     *     Item resolving to a function on which to invoke
     *     the arguments, typically a SymboNode or AccessorNode
     * @param {./Node[]} args
     */
    constructor(f, l) {
      if (super(), typeof f == "string" && (f = new a(f)), !Ut(f)) throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(l) || !l.every(Ut))
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      this.fn = f, this.args = l || [];
    }
    // readonly property name
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return jo;
    }
    get isFunctionNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(f, l) {
      var c = this.args.map((_) => _._compile(f, l));
      if (mr(this.fn)) {
        var h = this.fn.name;
        if (l[h]) {
          var b = this.args;
          return function(O, T, I) {
            var q = Kr(T, h);
            if (typeof q != "function")
              throw new TypeError("Argument '".concat(h, "' was not a function; received: ").concat(s(q)));
            if (q.rawArgs)
              return q(b, f, Ts(O, T));
            var $ = c.map((U) => U(O, T, I));
            return q.apply(q, $);
          };
        } else {
          var d = h in f ? Kr(f, h) : void 0, g = typeof d == "function" && d.rawArgs === !0, v = (_) => {
            var O;
            if (_.has(h))
              O = _.get(h);
            else if (h in f)
              O = Kr(f, h);
            else
              return p.onUndefinedFunction(h);
            if (typeof O == "function")
              return O;
            throw new TypeError("'".concat(h, `' is not a function; its value is:
  `).concat(s(O)));
          };
          if (g) {
            var N = this.args;
            return function(O, T, I) {
              var q = v(O);
              return q(N, f, Ts(O, T));
            };
          } else
            switch (c.length) {
              case 0:
                return function(O, T, I) {
                  var q = v(O);
                  return q();
                };
              case 1:
                return function(O, T, I) {
                  var q = v(O), $ = c[0];
                  return q($(O, T, I));
                };
              case 2:
                return function(O, T, I) {
                  var q = v(O), $ = c[0], U = c[1];
                  return q($(O, T, I), U(O, T, I));
                };
              default:
                return function(O, T, I) {
                  var q = v(O), $ = c.map((U) => U(O, T, I));
                  return q(...$);
                };
            }
        }
      } else if (pi(this.fn) && qi(this.fn.index) && this.fn.index.isObjectProperty()) {
        var C = this.fn.object._compile(f, l), x = this.fn.index.getObjectProperty(), E = this.args;
        return function(O, T, I) {
          var q = C(O, T, I), $ = fC(q, x);
          if ($ != null && $.rawArgs)
            return $(E, f, Ts(O, T));
          var U = c.map((k) => k(O, T, I));
          return $.apply(q, U);
        };
      } else {
        var D = this.fn.toString(), A = this.fn._compile(f, l), M = this.args;
        return function(O, T, I) {
          var q = A(O, T, I);
          if (typeof q != "function")
            throw new TypeError("Expression '".concat(D, "' did not evaluate to a function; value is:") + `
  `.concat(s(q)));
          if (q.rawArgs)
            return q(M, f, Ts(O, T));
          var $ = c.map((U) => U(O, T, I));
          return q.apply(q, $);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(f) {
      f(this.fn, "fn", this);
      for (var l = 0; l < this.args.length; l++)
        f(this.args[l], "args[" + l + "]", this);
    }
    /**
     * Create a new FunctionNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionNode} Returns a transformed copy of the node
     */
    map(f) {
      for (var l = this._ifNode(f(this.fn, "fn", this)), c = [], h = 0; h < this.args.length; h++)
        c[h] = this._ifNode(f(this.args[h], "args[" + h + "]", this));
      return new p(l, c);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionNode}
     */
    clone() {
      return new p(this.fn, this.args.slice(0));
    }
    /**
     * Throws an error 'Undefined function {name}'
     * @param {string} name
     */
    /**
     * Get string representation. (wrapper function)
     * This overrides parts of Node's toString function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toString
     * function.
     *
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toString(f) {
      var l, c = this.fn.toString(f);
      return f && typeof f.handler == "object" && We(f.handler, c) && (l = f.handler[c](this, f)), typeof l < "u" ? l : super.toString(f);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(f) {
      var l = this.args.map(function(h) {
        return h.toString(f);
      }), c = oa(this.fn) ? "(" + this.fn.toString(f) + ")" : this.fn.toString(f);
      return c + "(" + l.join(", ") + ")";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: jo,
        fn: this.fn,
        args: this.args
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     */
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(f) {
      var l = this.args.map(function(c) {
        return c.toHTML(f);
      });
      return '<span class="math-function">' + _n(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + l.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    /**
     * Get LaTeX representation. (wrapper function)
     * This overrides parts of Node's toTex function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toTex
     * function.
     *
     * @param {Object} options
     * @return {string}
     */
    toTex(f) {
      var l;
      return f && typeof f.handler == "object" && We(f.handler, this.name) && (l = f.handler[this.name](this, f)), typeof l < "u" ? l : super.toTex(f);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(f) {
      var l = this.args.map(function(d) {
        return d.toTex(f);
      }), c;
      eb[this.name] && (c = eb[this.name]), r[this.name] && (typeof r[this.name].toTex == "function" || typeof r[this.name].toTex == "object" || typeof r[this.name].toTex == "string") && (c = r[this.name].toTex);
      var h;
      switch (typeof c) {
        case "function":
          h = c(this, f);
          break;
        case "string":
          h = o(c, this, f);
          break;
        case "object":
          switch (typeof c[l.length]) {
            case "function":
              h = c[l.length](this, f);
              break;
            case "string":
              h = o(c[l.length], this, f);
              break;
          }
      }
      return typeof h < "u" ? h : o(gq, this, f);
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  return e = p, xr(p, "name", jo), xr(p, "onUndefinedFunction", function(u) {
    throw new Error("Undefined function " + u);
  }), xr(p, "fromJSON", function(u) {
    return new e(u.fn, u.args);
  }), p;
}, {
  isClass: !0,
  isNode: !0
}), rb = "parse", _q = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"], hf = /* @__PURE__ */ j(rb, _q, (t) => {
  var {
    typed: e,
    numeric: r,
    config: n,
    AccessorNode: a,
    ArrayNode: s,
    AssignmentNode: o,
    BlockNode: p,
    ConditionalNode: u,
    ConstantNode: f,
    FunctionAssignmentNode: l,
    FunctionNode: c,
    IndexNode: h,
    ObjectNode: d,
    OperatorNode: g,
    ParenthesisNode: v,
    RangeNode: N,
    RelationalNode: b,
    SymbolNode: C
  } = t, x = e(rb, {
    string: function(ne) {
      return le(ne, {});
    },
    "Array | Matrix": function(ne) {
      return E(ne, {});
    },
    "string, Object": function(ne, xe) {
      var Te = xe.nodes !== void 0 ? xe.nodes : {};
      return le(ne, Te);
    },
    "Array | Matrix, Object": E
  });
  function E(B) {
    var ne = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, xe = ne.nodes !== void 0 ? ne.nodes : {};
    return Nt(B, function(Te) {
      if (typeof Te != "string") throw new TypeError("String expected");
      return le(Te, xe);
    });
  }
  var D = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  }, A = {
    ",": !0,
    "(": !0,
    ")": !0,
    "[": !0,
    "]": !0,
    "{": !0,
    "}": !0,
    '"': !0,
    "'": !0,
    ";": !0,
    "+": !0,
    "-": !0,
    "*": !0,
    ".*": !0,
    "/": !0,
    "./": !0,
    "%": !0,
    "^": !0,
    ".^": !0,
    "~": !0,
    "!": !0,
    "&": !0,
    "|": !0,
    "^|": !0,
    "=": !0,
    ":": !0,
    "?": !0,
    "==": !0,
    "!=": !0,
    "<": !0,
    ">": !0,
    "<=": !0,
    ">=": !0,
    "<<": !0,
    ">>": !0,
    ">>>": !0
  }, M = {
    mod: !0,
    to: !0,
    in: !0,
    and: !0,
    xor: !0,
    or: !0,
    not: !0
  }, _ = {
    true: !0,
    false: !1,
    null: null,
    undefined: void 0
  }, O = ["NaN", "Infinity"], T = {
    '"': '"',
    "'": "'",
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
    // note that \u is handled separately in parseStringToken()
  };
  function I() {
    return {
      extraNodes: {},
      // current extra nodes, must be careful not to mutate
      expression: "",
      // current expression
      comment: "",
      // last parsed comment
      index: 0,
      // current index in expr
      token: "",
      // current token
      tokenType: D.NULL,
      // type of the token
      nestingLevel: 0,
      // level of nesting inside parameters, used to ignore newline characters
      conditionalLevel: null
      // when a conditional is being parsed, the level of the conditional is stored here
    };
  }
  function q(B, ne) {
    return B.expression.substr(B.index, ne);
  }
  function $(B) {
    return q(B, 1);
  }
  function U(B) {
    B.index++;
  }
  function k(B) {
    return B.expression.charAt(B.index - 1);
  }
  function L(B) {
    return B.expression.charAt(B.index + 1);
  }
  function R(B) {
    for (B.tokenType = D.NULL, B.token = "", B.comment = ""; ; ) {
      if ($(B) === "#")
        for (; $(B) !== `
` && $(B) !== ""; )
          B.comment += $(B), U(B);
      if (x.isWhitespace($(B), B.nestingLevel))
        U(B);
      else
        break;
    }
    if ($(B) === "") {
      B.tokenType = D.DELIMITER;
      return;
    }
    if ($(B) === `
` && !B.nestingLevel) {
      B.tokenType = D.DELIMITER, B.token = $(B), U(B);
      return;
    }
    var ne = $(B), xe = q(B, 2), Te = q(B, 3);
    if (Te.length === 3 && A[Te]) {
      B.tokenType = D.DELIMITER, B.token = Te, U(B), U(B), U(B);
      return;
    }
    if (xe.length === 2 && A[xe]) {
      B.tokenType = D.DELIMITER, B.token = xe, U(B), U(B);
      return;
    }
    if (A[ne]) {
      B.tokenType = D.DELIMITER, B.token = ne, U(B);
      return;
    }
    if (x.isDigitDot(ne)) {
      B.tokenType = D.NUMBER;
      var Pe = q(B, 2);
      if (Pe === "0b" || Pe === "0o" || Pe === "0x") {
        for (B.token += $(B), U(B), B.token += $(B), U(B); x.isHexDigit($(B)); )
          B.token += $(B), U(B);
        if ($(B) === ".")
          for (B.token += ".", U(B); x.isHexDigit($(B)); )
            B.token += $(B), U(B);
        else if ($(B) === "i")
          for (B.token += "i", U(B); x.isDigit($(B)); )
            B.token += $(B), U(B);
        return;
      }
      if ($(B) === ".") {
        if (B.token += $(B), U(B), !x.isDigit($(B))) {
          B.tokenType = D.DELIMITER;
          return;
        }
      } else {
        for (; x.isDigit($(B)); )
          B.token += $(B), U(B);
        x.isDecimalMark($(B), L(B)) && (B.token += $(B), U(B));
      }
      for (; x.isDigit($(B)); )
        B.token += $(B), U(B);
      if ($(B) === "E" || $(B) === "e") {
        if (x.isDigit(L(B)) || L(B) === "-" || L(B) === "+") {
          if (B.token += $(B), U(B), ($(B) === "+" || $(B) === "-") && (B.token += $(B), U(B)), !x.isDigit($(B)))
            throw Ze(B, 'Digit expected, got "' + $(B) + '"');
          for (; x.isDigit($(B)); )
            B.token += $(B), U(B);
          if (x.isDecimalMark($(B), L(B)))
            throw Ze(B, 'Digit expected, got "' + $(B) + '"');
        } else if (L(B) === ".")
          throw U(B), Ze(B, 'Digit expected, got "' + $(B) + '"');
      }
      return;
    }
    if (x.isAlpha($(B), k(B), L(B))) {
      for (; x.isAlpha($(B), k(B), L(B)) || x.isDigit($(B)); )
        B.token += $(B), U(B);
      We(M, B.token) ? B.tokenType = D.DELIMITER : B.tokenType = D.SYMBOL;
      return;
    }
    for (B.tokenType = D.UNKNOWN; $(B) !== ""; )
      B.token += $(B), U(B);
    throw Ze(B, 'Syntax error in part "' + B.token + '"');
  }
  function G(B) {
    do
      R(B);
    while (B.token === `
`);
  }
  function P(B) {
    B.nestingLevel++;
  }
  function W(B) {
    B.nestingLevel--;
  }
  x.isAlpha = function(ne, xe, Te) {
    return x.isValidLatinOrGreek(ne) || x.isValidMathSymbol(ne, Te) || x.isValidMathSymbol(xe, ne);
  }, x.isValidLatinOrGreek = function(ne) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(ne);
  }, x.isValidMathSymbol = function(ne, xe) {
    return /^[\uD835]$/.test(ne) && /^[\uDC00-\uDFFF]$/.test(xe) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(xe);
  }, x.isWhitespace = function(ne, xe) {
    return ne === " " || ne === "	" || ne === `
` && xe > 0;
  }, x.isDecimalMark = function(ne, xe) {
    return ne === "." && xe !== "/" && xe !== "*" && xe !== "^";
  }, x.isDigitDot = function(ne) {
    return ne >= "0" && ne <= "9" || ne === ".";
  }, x.isDigit = function(ne) {
    return ne >= "0" && ne <= "9";
  }, x.isHexDigit = function(ne) {
    return ne >= "0" && ne <= "9" || ne >= "a" && ne <= "f" || ne >= "A" && ne <= "F";
  };
  function le(B, ne) {
    var xe = I();
    hr(xe, {
      expression: B,
      extraNodes: ne
    }), R(xe);
    var Te = Z(xe);
    if (xe.token !== "")
      throw xe.tokenType === D.DELIMITER ? Ie(xe, "Unexpected operator " + xe.token) : Ze(xe, 'Unexpected part "' + xe.token + '"');
    return Te;
  }
  function Z(B) {
    var ne, xe = [], Te;
    for (B.token !== "" && B.token !== `
` && B.token !== ";" && (ne = H(B), B.comment && (ne.comment = B.comment)); B.token === `
` || B.token === ";"; )
      xe.length === 0 && ne && (Te = B.token !== ";", xe.push({
        node: ne,
        visible: Te
      })), R(B), B.token !== `
` && B.token !== ";" && B.token !== "" && (ne = H(B), B.comment && (ne.comment = B.comment), Te = B.token !== ";", xe.push({
        node: ne,
        visible: Te
      }));
    return xe.length > 0 ? new p(xe) : (ne || (ne = new f(void 0), B.comment && (ne.comment = B.comment)), ne);
  }
  function H(B) {
    var ne, xe, Te, Pe, Ge = te(B);
    if (B.token === "=") {
      if (mr(Ge))
        return ne = Ge.name, G(B), Te = H(B), new o(new C(ne), Te);
      if (pi(Ge))
        return G(B), Te = H(B), new o(Ge.object, Ge.index, Te);
      if (Wn(Ge) && mr(Ge.fn) && (Pe = !0, xe = [], ne = Ge.name, Ge.args.forEach(function(Ve, ft) {
        mr(Ve) ? xe[ft] = Ve.name : Pe = !1;
      }), Pe))
        return G(B), Te = H(B), new l(ne, xe, Te);
      throw Ze(B, "Invalid left hand side of assignment operator =");
    }
    return Ge;
  }
  function te(B) {
    for (var ne = be(B); B.token === "?"; ) {
      var xe = B.conditionalLevel;
      B.conditionalLevel = B.nestingLevel, G(B);
      var Te = ne, Pe = H(B);
      if (B.token !== ":") throw Ze(B, "False part of conditional expression expected");
      B.conditionalLevel = null, G(B);
      var Ge = H(B);
      ne = new u(Te, Pe, Ge), B.conditionalLevel = xe;
    }
    return ne;
  }
  function be(B) {
    for (var ne = K(B); B.token === "or"; )
      G(B), ne = new g("or", "or", [ne, K(B)]);
    return ne;
  }
  function K(B) {
    for (var ne = ce(B); B.token === "xor"; )
      G(B), ne = new g("xor", "xor", [ne, ce(B)]);
    return ne;
  }
  function ce(B) {
    for (var ne = de(B); B.token === "and"; )
      G(B), ne = new g("and", "and", [ne, de(B)]);
    return ne;
  }
  function de(B) {
    for (var ne = ue(B); B.token === "|"; )
      G(B), ne = new g("|", "bitOr", [ne, ue(B)]);
    return ne;
  }
  function ue(B) {
    for (var ne = ve(B); B.token === "^|"; )
      G(B), ne = new g("^|", "bitXor", [ne, ve(B)]);
    return ne;
  }
  function ve(B) {
    for (var ne = he(B); B.token === "&"; )
      G(B), ne = new g("&", "bitAnd", [ne, he(B)]);
    return ne;
  }
  function he(B) {
    for (var ne = [Ne(B)], xe = [], Te = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    }; We(Te, B.token); ) {
      var Pe = {
        name: B.token,
        fn: Te[B.token]
      };
      xe.push(Pe), G(B), ne.push(Ne(B));
    }
    return ne.length === 1 ? ne[0] : ne.length === 2 ? new g(xe[0].name, xe[0].fn, ne) : new b(xe.map((Ge) => Ge.fn), ne);
  }
  function Ne(B) {
    var ne, xe, Te, Pe;
    ne = we(B);
    for (var Ge = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    }; We(Ge, B.token); )
      xe = B.token, Te = Ge[xe], G(B), Pe = [ne, we(B)], ne = new g(xe, Te, Pe);
    return ne;
  }
  function we(B) {
    var ne, xe, Te, Pe;
    ne = Se(B);
    for (var Ge = {
      to: "to",
      in: "to"
      // alias of 'to'
    }; We(Ge, B.token); )
      xe = B.token, Te = Ge[xe], G(B), xe === "in" && B.token === "" ? ne = new g("*", "multiply", [ne, new C("in")], !0) : (Pe = [ne, Se(B)], ne = new g(xe, Te, Pe));
    return ne;
  }
  function Se(B) {
    var ne, xe = [];
    if (B.token === ":" ? ne = new f(1) : ne = V(B), B.token === ":" && B.conditionalLevel !== B.nestingLevel) {
      for (xe.push(ne); B.token === ":" && xe.length < 3; )
        G(B), B.token === ")" || B.token === "]" || B.token === "," || B.token === "" ? xe.push(new C("end")) : xe.push(V(B));
      xe.length === 3 ? ne = new N(xe[0], xe[2], xe[1]) : ne = new N(xe[0], xe[1]);
    }
    return ne;
  }
  function V(B) {
    var ne, xe, Te, Pe;
    ne = re(B);
    for (var Ge = {
      "+": "add",
      "-": "subtract"
    }; We(Ge, B.token); ) {
      xe = B.token, Te = Ge[xe], G(B);
      var Ve = re(B);
      Ve.isPercentage ? Pe = [ne, new g("*", "multiply", [ne, Ve])] : Pe = [ne, Ve], ne = new g(xe, Te, Pe);
    }
    return ne;
  }
  function re(B) {
    var ne, xe, Te, Pe;
    ne = pe(B), xe = ne;
    for (var Ge = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide"
    }; We(Ge, B.token); )
      Te = B.token, Pe = Ge[Te], G(B), xe = pe(B), ne = new g(Te, Pe, [ne, xe]);
    return ne;
  }
  function pe(B) {
    var ne, xe;
    for (ne = X(B), xe = ne; B.tokenType === D.SYMBOL || B.token === "in" && Ct(ne) || B.tokenType === D.NUMBER && !Ct(xe) && (!or(xe) || xe.op === "!") || B.token === "("; )
      xe = X(B), ne = new g(
        "*",
        "multiply",
        [ne, xe],
        !0
        /* implicit */
      );
    return ne;
  }
  function X(B) {
    for (var ne = ie(B), xe = ne, Te = []; B.token === "/" && zm(xe); )
      if (Te.push(hr({}, B)), G(B), B.tokenType === D.NUMBER)
        if (Te.push(hr({}, B)), G(B), B.tokenType === D.SYMBOL || B.token === "(")
          hr(B, Te.pop()), Te.pop(), xe = ie(B), ne = new g("/", "divide", [ne, xe]);
        else {
          Te.pop(), hr(B, Te.pop());
          break;
        }
      else {
        hr(B, Te.pop());
        break;
      }
    return ne;
  }
  function ie(B) {
    var ne, xe, Te, Pe;
    ne = me(B);
    for (var Ge = {
      "%": "mod",
      mod: "mod"
    }; We(Ge, B.token); )
      xe = B.token, Te = Ge[xe], G(B), xe === "%" && B.tokenType === D.DELIMITER && B.token !== "(" ? ne = new g("/", "divide", [ne, new f(100)], !1, !0) : (Pe = [ne, me(B)], ne = new g(xe, Te, Pe));
    return ne;
  }
  function me(B) {
    var ne, xe, Te, Pe = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    return We(Pe, B.token) ? (Te = Pe[B.token], ne = B.token, G(B), xe = [me(B)], new g(ne, Te, xe)) : Ae(B);
  }
  function Ae(B) {
    var ne, xe, Te, Pe;
    return ne = Me(B), (B.token === "^" || B.token === ".^") && (xe = B.token, Te = xe === "^" ? "pow" : "dotPow", G(B), Pe = [ne, me(B)], ne = new g(xe, Te, Pe)), ne;
  }
  function Me(B) {
    var ne, xe, Te, Pe;
    ne = Q(B);
    for (var Ge = {
      "!": "factorial",
      "'": "ctranspose"
    }; We(Ge, B.token); )
      xe = B.token, Te = Ge[xe], R(B), Pe = [ne], ne = new g(xe, Te, Pe), ne = ye(B, ne);
    return ne;
  }
  function Q(B) {
    var ne = [];
    if (B.tokenType === D.SYMBOL && We(B.extraNodes, B.token)) {
      var xe = B.extraNodes[B.token];
      if (R(B), B.token === "(") {
        if (ne = [], P(B), R(B), B.token !== ")")
          for (ne.push(H(B)); B.token === ","; )
            R(B), ne.push(H(B));
        if (B.token !== ")")
          throw Ze(B, "Parenthesis ) expected");
        W(B), R(B);
      }
      return new xe(ne);
    }
    return ee(B);
  }
  function ee(B) {
    var ne, xe;
    return B.tokenType === D.SYMBOL || B.tokenType === D.DELIMITER && B.token in M ? (xe = B.token, R(B), We(_, xe) ? ne = new f(_[xe]) : O.includes(xe) ? ne = new f(r(xe, "number")) : ne = new C(xe), ne = ye(B, ne), ne) : Ee(B);
  }
  function ye(B, ne, xe) {
    for (var Te; (B.token === "(" || B.token === "[" || B.token === ".") && !xe; )
      if (Te = [], B.token === "(")
        if (mr(ne) || pi(ne)) {
          if (P(B), R(B), B.token !== ")")
            for (Te.push(H(B)); B.token === ","; )
              R(B), Te.push(H(B));
          if (B.token !== ")")
            throw Ze(B, "Parenthesis ) expected");
          W(B), R(B), ne = new c(ne, Te);
        } else
          return ne;
      else if (B.token === "[") {
        if (P(B), R(B), B.token !== "]")
          for (Te.push(H(B)); B.token === ","; )
            R(B), Te.push(H(B));
        if (B.token !== "]")
          throw Ze(B, "Parenthesis ] expected");
        W(B), R(B), ne = new a(ne, new h(Te));
      } else {
        R(B);
        var Pe = B.tokenType === D.SYMBOL || B.tokenType === D.DELIMITER && B.token in M;
        if (!Pe)
          throw Ze(B, "Property name expected after dot");
        Te.push(new f(B.token)), R(B);
        var Ge = !0;
        ne = new a(ne, new h(Te, Ge));
      }
    return ne;
  }
  function Ee(B) {
    var ne, xe;
    return B.token === '"' || B.token === "'" ? (xe = Ce(B, B.token), ne = new f(xe), ne = ye(B, ne), ne) : De(B);
  }
  function Ce(B, ne) {
    for (var xe = ""; $(B) !== "" && $(B) !== ne; )
      if ($(B) === "\\") {
        U(B);
        var Te = $(B), Pe = T[Te];
        if (Pe !== void 0)
          xe += Pe, B.index += 1;
        else if (Te === "u") {
          var Ge = B.expression.slice(B.index + 1, B.index + 5);
          if (/^[0-9A-Fa-f]{4}$/.test(Ge))
            xe += String.fromCharCode(parseInt(Ge, 16)), B.index += 5;
          else
            throw Ze(B, "Invalid unicode character \\u".concat(Ge));
        } else
          throw Ze(B, "Bad escape character \\".concat(Te));
      } else
        xe += $(B), U(B);
    if (R(B), B.token !== ne)
      throw Ze(B, "End of string ".concat(ne, " expected"));
    return R(B), xe;
  }
  function De(B) {
    var ne, xe, Te, Pe;
    if (B.token === "[") {
      if (P(B), R(B), B.token !== "]") {
        var Ge = Oe(B);
        if (B.token === ";") {
          for (Te = 1, xe = [Ge]; B.token === ";"; )
            R(B), B.token !== "]" && (xe[Te] = Oe(B), Te++);
          if (B.token !== "]")
            throw Ze(B, "End of matrix ] expected");
          W(B), R(B), Pe = xe[0].items.length;
          for (var Ve = 1; Ve < Te; Ve++)
            if (xe[Ve].items.length !== Pe)
              throw Ie(B, "Column dimensions mismatch (" + xe[Ve].items.length + " !== " + Pe + ")");
          ne = new s(xe);
        } else {
          if (B.token !== "]")
            throw Ze(B, "End of matrix ] expected");
          W(B), R(B), ne = Ge;
        }
      } else
        W(B), R(B), ne = new s([]);
      return ye(B, ne);
    }
    return Be(B);
  }
  function Oe(B) {
    for (var ne = [H(B)], xe = 1; B.token === ","; )
      R(B), B.token !== "]" && B.token !== ";" && (ne[xe] = H(B), xe++);
    return new s(ne);
  }
  function Be(B) {
    if (B.token === "{") {
      P(B);
      var ne, xe = {};
      do
        if (R(B), B.token !== "}") {
          if (B.token === '"' || B.token === "'")
            ne = Ce(B, B.token);
          else if (B.tokenType === D.SYMBOL || B.tokenType === D.DELIMITER && B.token in M)
            ne = B.token, R(B);
          else
            throw Ze(B, "Symbol or string expected as object key");
          if (B.token !== ":")
            throw Ze(B, "Colon : expected after object key");
          R(B), xe[ne] = H(B);
        }
      while (B.token === ",");
      if (B.token !== "}")
        throw Ze(B, "Comma , or bracket } expected after object value");
      W(B), R(B);
      var Te = new d(xe);
      return Te = ye(B, Te), Te;
    }
    return Le(B);
  }
  function Le(B) {
    var ne;
    if (B.tokenType === D.NUMBER) {
      ne = B.token, R(B);
      var xe = Ii(ne, n), Te = r(ne, xe);
      return new f(Te);
    }
    return Re(B);
  }
  function Re(B) {
    var ne;
    if (B.token === "(") {
      if (P(B), R(B), ne = H(B), B.token !== ")")
        throw Ze(B, "Parenthesis ) expected");
      return W(B), R(B), ne = new v(ne), ne = ye(B, ne), ne;
    }
    return rt(B);
  }
  function rt(B) {
    throw B.token === "" ? Ze(B, "Unexpected end of expression") : Ze(B, "Value expected");
  }
  function Ke(B) {
    return B.index - B.token.length + 1;
  }
  function Ze(B, ne) {
    var xe = Ke(B), Te = new SyntaxError(ne + " (char " + xe + ")");
    return Te.char = xe, Te;
  }
  function Ie(B, ne) {
    var xe = Ke(B), Te = new SyntaxError(ne + " (char " + xe + ")");
    return Te.char = xe, Te;
  }
  return e.addConversion({
    from: "string",
    to: "Node",
    convert: x
  }), x;
}), nb = "compile", Mq = ["typed", "parse"], mf = /* @__PURE__ */ j(nb, Mq, (t) => {
  var {
    typed: e,
    parse: r
  } = t;
  return e(nb, {
    string: function(a) {
      return r(a).compile();
    },
    "Array | Matrix": function(a) {
      return Nt(a, function(s) {
        return r(s).compile();
      });
    }
  });
}), ib = "evaluate", Oq = ["typed", "parse"], df = /* @__PURE__ */ j(ib, Oq, (t) => {
  var {
    typed: e,
    parse: r
  } = t;
  return e(ib, {
    string: function(a) {
      var s = Os();
      return r(a).compile().evaluate(s);
    },
    "string, Map | Object": function(a, s) {
      return r(a).compile().evaluate(s);
    },
    "Array | Matrix": function(a) {
      var s = Os();
      return Nt(a, function(o) {
        return r(o).compile().evaluate(s);
      });
    },
    "Array | Matrix, Map | Object": function(a, s) {
      return Nt(a, function(o) {
        return r(o).compile().evaluate(s);
      });
    }
  });
}), Fq = "Parser", qq = ["evaluate"], vf = /* @__PURE__ */ j(Fq, qq, (t) => {
  var {
    evaluate: e
  } = t;
  function r() {
    if (!(this instanceof r))
      throw new SyntaxError("Constructor must be called with the new operator");
    Object.defineProperty(this, "scope", {
      value: Os(),
      writable: !1
    });
  }
  return r.prototype.type = "Parser", r.prototype.isParser = !0, r.prototype.evaluate = function(n) {
    return e(n, this.scope);
  }, r.prototype.get = function(n) {
    if (this.scope.has(n))
      return this.scope.get(n);
  }, r.prototype.getAll = function() {
    return mC(this.scope);
  }, r.prototype.getAllAsMap = function() {
    return this.scope;
  }, r.prototype.set = function(n, a) {
    return this.scope.set(n, a), a;
  }, r.prototype.remove = function(n) {
    this.scope.delete(n);
  }, r.prototype.clear = function() {
    this.scope.clear();
  }, r;
}, {
  isClass: !0
}), ab = "parser", Iq = ["typed", "Parser"], gf = /* @__PURE__ */ j(ab, Iq, (t) => {
  var {
    typed: e,
    Parser: r
  } = t;
  return e(ab, {
    "": function() {
      return new r();
    }
  });
}), sb = "lup", Bq = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"], yf = /* @__PURE__ */ j(sb, Bq, (t) => {
  var {
    typed: e,
    matrix: r,
    abs: n,
    addScalar: a,
    divideScalar: s,
    multiplyScalar: o,
    subtractScalar: p,
    larger: u,
    equalScalar: f,
    unaryMinus: l,
    DenseMatrix: c,
    SparseMatrix: h,
    Spa: d
  } = t;
  return e(sb, {
    DenseMatrix: function(b) {
      return g(b);
    },
    SparseMatrix: function(b) {
      return v(b);
    },
    Array: function(b) {
      var C = r(b), x = g(C);
      return {
        L: x.L.valueOf(),
        U: x.U.valueOf(),
        p: x.p
      };
    }
  });
  function g(N) {
    var b = N._size[0], C = N._size[1], x = Math.min(b, C), E = nt(N._data), D = [], A = [b, x], M = [], _ = [x, C], O, T, I, q = [];
    for (O = 0; O < b; O++)
      q[O] = O;
    for (T = 0; T < C; T++) {
      if (T > 0)
        for (O = 0; O < b; O++) {
          var $ = Math.min(O, T), U = 0;
          for (I = 0; I < $; I++)
            U = a(U, o(E[O][I], E[I][T]));
          E[O][T] = p(E[O][T], U);
        }
      var k = T, L = 0, R = 0;
      for (O = T; O < b; O++) {
        var G = E[O][T], P = n(G);
        u(P, L) && (k = O, L = P, R = G);
      }
      if (T !== k && (q[T] = [q[k], q[k] = q[T]][0], c._swapRows(T, k, E)), T < b)
        for (O = T + 1; O < b; O++) {
          var W = E[O][T];
          f(W, 0) || (E[O][T] = s(E[O][T], R));
        }
    }
    for (T = 0; T < C; T++)
      for (O = 0; O < b; O++) {
        if (T === 0 && (O < C && (M[O] = []), D[O] = []), O < T) {
          O < C && (M[O][T] = E[O][T]), T < b && (D[O][T] = 0);
          continue;
        }
        if (O === T) {
          O < C && (M[O][T] = E[O][T]), T < b && (D[O][T] = 1);
          continue;
        }
        O < C && (M[O][T] = 0), T < b && (D[O][T] = E[O][T]);
      }
    var le = new c({
      data: D,
      size: A
    }), Z = new c({
      data: M,
      size: _
    }), H = [];
    for (O = 0, x = q.length; O < x; O++)
      H[q[O]] = O;
    return {
      L: le,
      U: Z,
      p: H,
      toString: function() {
        return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
P: ` + this.p;
      }
    };
  }
  function v(N) {
    var b = N._size[0], C = N._size[1], x = Math.min(b, C), E = N._values, D = N._index, A = N._ptr, M = [], _ = [], O = [], T = [b, x], I = [], q = [], $ = [], U = [x, C], k, L, R, G = [], P = [];
    for (k = 0; k < b; k++)
      G[k] = k, P[k] = k;
    var W = function(H, te) {
      var be = P[H], K = P[te];
      G[be] = te, G[K] = H, P[H] = K, P[te] = be;
    }, le = function() {
      var H = new d();
      L < b && (O.push(M.length), M.push(1), _.push(L)), $.push(I.length);
      var te = A[L], be = A[L + 1];
      for (R = te; R < be; R++)
        k = D[R], H.set(G[k], E[R]);
      L > 0 && H.forEach(0, L - 1, function(ue, ve) {
        h._forEachRow(ue, M, _, O, function(he, Ne) {
          he > ue && H.accumulate(he, l(o(Ne, ve)));
        });
      });
      var K = L, ce = H.get(L), de = n(ce);
      H.forEach(L + 1, b - 1, function(ue, ve) {
        var he = n(ve);
        u(he, de) && (K = ue, de = he, ce = ve);
      }), L !== K && (h._swapRows(L, K, T[1], M, _, O), h._swapRows(L, K, U[1], I, q, $), H.swap(L, K), W(L, K)), H.forEach(0, b - 1, function(ue, ve) {
        ue <= L ? (I.push(ve), q.push(ue)) : (ve = s(ve, ce), f(ve, 0) || (M.push(ve), _.push(ue)));
      });
    };
    for (L = 0; L < C; L++)
      le();
    return $.push(I.length), O.push(M.length), {
      L: new h({
        values: M,
        index: _,
        ptr: O,
        size: T
      }),
      U: new h({
        values: I,
        index: q,
        ptr: $,
        size: U
      }),
      p: G,
      toString: function() {
        return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
P: ` + this.p;
      }
    };
  }
}), ob = "qr", Rq = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"], xf = /* @__PURE__ */ j(ob, Rq, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    identity: a,
    isZero: s,
    equal: o,
    sign: p,
    sqrt: u,
    conj: f,
    unaryMinus: l,
    addScalar: c,
    divideScalar: h,
    multiplyScalar: d,
    subtractScalar: g,
    complex: v
  } = t;
  return hr(e(ob, {
    DenseMatrix: function(E) {
      return b(E);
    },
    SparseMatrix: function(E) {
      return C();
    },
    Array: function(E) {
      var D = r(E), A = b(D);
      return {
        Q: A.Q.valueOf(),
        R: A.R.valueOf()
      };
    }
  }), {
    _denseQRimpl: N
  });
  function N(x) {
    var E = x._size[0], D = x._size[1], A = a([E], "dense"), M = A._data, _ = x.clone(), O = _._data, T, I, q, $ = n([E], "");
    for (q = 0; q < Math.min(D, E); ++q) {
      var U = O[q][q], k = l(o(U, 0) ? 1 : p(U)), L = f(k), R = 0;
      for (T = q; T < E; T++)
        R = c(R, d(O[T][q], f(O[T][q])));
      var G = d(k, u(R));
      if (!s(G)) {
        var P = g(U, G);
        for ($[q] = 1, T = q + 1; T < E; T++)
          $[T] = h(O[T][q], P);
        var W = l(f(h(P, G))), le = void 0;
        for (I = q; I < D; I++) {
          for (le = 0, T = q; T < E; T++)
            le = c(le, d(f($[T]), O[T][I]));
          for (le = d(le, W), T = q; T < E; T++)
            O[T][I] = d(g(O[T][I], d($[T], le)), L);
        }
        for (T = 0; T < E; T++) {
          for (le = 0, I = q; I < E; I++)
            le = c(le, d(M[T][I], $[I]));
          for (le = d(le, W), I = q; I < E; ++I)
            M[T][I] = h(g(M[T][I], d(le, f($[I]))), L);
        }
      }
    }
    return {
      Q: A,
      R: _,
      toString: function() {
        return "Q: " + this.Q.toString() + `
R: ` + this.R.toString();
      }
    };
  }
  function b(x) {
    var E = N(x), D = E.R._data;
    if (x._data.length > 0)
      for (var A = D[0][0].type === "Complex" ? v(0) : 0, M = 0; M < D.length; ++M)
        for (var _ = 0; _ < M && _ < (D[0] || []).length; ++_)
          D[M][_] = A;
    return E;
  }
  function C(x) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});
function Lq(t, e, r, n) {
  t._values;
  for (var a = t._index, s = t._ptr, o = t._size, p = t._datatype, u = o[0], f = o[1], l = null, c = [], h = [], d = 0, g = 0; g < f; g++) {
    h[g] = d;
    for (var v = r ? r[g] : g, N = s[v], b = s[v + 1], C = N; C < b; C++) {
      var x = a[C];
      c[d] = x, d++;
    }
  }
  return h[f] = d, t.createSparseMatrix({
    values: l,
    index: c,
    ptr: h,
    size: [u, f],
    datatype: p
  });
}
function Jw(t, e, r, n, a, s, o) {
  var p = 0;
  for (r[o] = t; p >= 0; ) {
    var u = r[o + p], f = r[n + u];
    f === -1 ? (p--, s[e++] = u) : (r[n + u] = r[a + f], ++p, r[o + p] = f);
  }
  return e;
}
function Pq(t, e) {
  if (!t)
    return null;
  var r = 0, n, a = [], s = [], o = 0, p = e, u = 2 * e;
  for (n = 0; n < e; n++)
    s[o + n] = -1;
  for (n = e - 1; n >= 0; n--)
    t[n] !== -1 && (s[p + n] = s[o + t[n]], s[o + t[n]] = n);
  for (n = 0; n < e; n++)
    t[n] === -1 && (r = Jw(n, r, s, o, p, a, u));
  return a;
}
function kq(t, e) {
  if (!t)
    return null;
  var r = t._index, n = t._ptr, a = t._size, s = a[0], o = a[1], p = [], u = [], f = 0, l = o, c, h;
  for (c = 0; c < s; c++)
    u[l + c] = -1;
  for (var d = 0; d < o; d++) {
    p[d] = -1, u[f + d] = -1;
    for (var g = n[d], v = n[d + 1], N = g; N < v; N++) {
      var b = r[N];
      for (c = u[l + b]; c !== -1 && c < d; c = h)
        h = u[f + c], u[f + c] = d, h === -1 && (p[c] = d);
      u[l + b] = d;
    }
  }
  return p;
}
function $q(t, e, r) {
  for (var n = t._values, a = t._index, s = t._ptr, o = t._size, p = o[1], u = 0, f = 0; f < p; f++) {
    var l = s[f];
    for (s[f] = u; l < s[f + 1]; l++)
      e(a[l], f, n ? n[l] : 1, r) && (a[u] = a[l], n && (n[u] = n[l]), u++);
  }
  return s[p] = u, a.splice(u, a.length - u), n && n.splice(u, n.length - u), u;
}
function Si(t) {
  return -t - 2;
}
var zq = "csAmd", Uq = ["add", "multiply", "transpose"], Gq = /* @__PURE__ */ j(zq, Uq, (t) => {
  var {
    add: e,
    multiply: r,
    transpose: n
  } = t;
  return function(l, c) {
    if (!c || l <= 0 || l > 3)
      return null;
    var h = c._size, d = h[0], g = h[1], v = 0, N = Math.max(16, 10 * Math.sqrt(g));
    N = Math.min(g - 2, N);
    var b = a(l, c, d, g, N);
    $q(b, u, null);
    for (var C = b._index, x = b._ptr, E = x[g], D = [], A = [], M = 0, _ = g + 1, O = 2 * (g + 1), T = 3 * (g + 1), I = 4 * (g + 1), q = 5 * (g + 1), $ = 6 * (g + 1), U = 7 * (g + 1), k = D, L = s(g, x, A, M, T, k, O, U, _, $, I, q), R = o(g, x, A, q, I, $, N, _, T, k, O), G = 0, P, W, le, Z, H, te, be, K, ce, de, ue, ve, he, Ne, we, Se; R < g; ) {
      for (le = -1; G < g && (le = A[T + G]) === -1; G++) ;
      A[O + le] !== -1 && (k[A[O + le]] = -1), A[T + G] = A[O + le];
      var V = A[I + le], re = A[_ + le];
      R += re;
      var pe = 0;
      A[_ + le] = -re;
      var X = x[le], ie = V === 0 ? X : E, me = ie;
      for (Z = 1; Z <= V + 1; Z++) {
        for (Z > V ? (te = le, be = X, K = A[M + le] - V) : (te = C[X++], be = x[te], K = A[M + te]), H = 1; H <= K; H++)
          P = C[be++], !((ce = A[_ + P]) <= 0) && (pe += ce, A[_ + P] = -ce, C[me++] = P, A[O + P] !== -1 && (k[A[O + P]] = k[P]), k[P] !== -1 ? A[O + k[P]] = A[O + P] : A[T + A[q + P]] = A[O + P]);
        te !== le && (x[te] = Si(le), A[$ + te] = 0);
      }
      for (V !== 0 && (E = me), A[q + le] = pe, x[le] = ie, A[M + le] = me - ie, A[I + le] = -2, L = p(L, v, A, $, g), de = ie; de < me; de++)
        if (P = C[de], !((ue = A[I + P]) <= 0)) {
          ce = -A[_ + P];
          var Ae = L - ce;
          for (X = x[P], ve = x[P] + ue - 1; X <= ve; X++)
            te = C[X], A[$ + te] >= L ? A[$ + te] -= ce : A[$ + te] !== 0 && (A[$ + te] = A[q + te] + Ae);
        }
      for (de = ie; de < me; de++) {
        for (P = C[de], ve = x[P], he = ve + A[I + P] - 1, Ne = ve, we = 0, Se = 0, X = ve; X <= he; X++)
          if (te = C[X], A[$ + te] !== 0) {
            var Me = A[$ + te] - L;
            Me > 0 ? (Se += Me, C[Ne++] = te, we += te) : (x[te] = Si(le), A[$ + te] = 0);
          }
        A[I + P] = Ne - ve + 1;
        var Q = Ne, ee = ve + A[M + P];
        for (X = he + 1; X < ee; X++) {
          W = C[X];
          var ye = A[_ + W];
          ye <= 0 || (Se += ye, C[Ne++] = W, we += W);
        }
        Se === 0 ? (x[P] = Si(le), ce = -A[_ + P], pe -= ce, re += ce, R += ce, A[_ + P] = 0, A[I + P] = -1) : (A[q + P] = Math.min(A[q + P], Se), C[Ne] = C[Q], C[Q] = C[ve], C[ve] = le, A[M + P] = Ne - ve + 1, we = (we < 0 ? -we : we) % g, A[O + P] = A[U + we], A[U + we] = P, k[P] = we);
      }
      for (A[q + le] = pe, v = Math.max(v, pe), L = p(L + v, v, A, $, g), de = ie; de < me; de++)
        if (P = C[de], !(A[_ + P] >= 0))
          for (we = k[P], P = A[U + we], A[U + we] = -1; P !== -1 && A[O + P] !== -1; P = A[O + P], L++) {
            for (K = A[M + P], ue = A[I + P], X = x[P] + 1; X <= x[P] + K - 1; X++)
              A[$ + C[X]] = L;
            var Ee = P;
            for (W = A[O + P]; W !== -1; ) {
              var Ce = A[M + W] === K && A[I + W] === ue;
              for (X = x[W] + 1; Ce && X <= x[W] + K - 1; X++)
                A[$ + C[X]] !== L && (Ce = 0);
              Ce ? (x[W] = Si(P), A[_ + P] += A[_ + W], A[_ + W] = 0, A[I + W] = -1, W = A[O + W], A[O + Ee] = W) : (Ee = W, W = A[O + W]);
            }
          }
      for (X = ie, de = ie; de < me; de++)
        P = C[de], !((ce = -A[_ + P]) <= 0) && (A[_ + P] = ce, Se = A[q + P] + pe - ce, Se = Math.min(Se, g - R - ce), A[T + Se] !== -1 && (k[A[T + Se]] = P), A[O + P] = A[T + Se], k[P] = -1, A[T + Se] = P, G = Math.min(G, Se), A[q + P] = Se, C[X++] = P);
      A[_ + le] = re, (A[M + le] = X - ie) === 0 && (x[le] = -1, A[$ + le] = 0), V !== 0 && (E = X);
    }
    for (P = 0; P < g; P++)
      x[P] = Si(x[P]);
    for (W = 0; W <= g; W++)
      A[T + W] = -1;
    for (W = g; W >= 0; W--)
      A[_ + W] > 0 || (A[O + W] = A[T + x[W]], A[T + x[W]] = W);
    for (te = g; te >= 0; te--)
      A[_ + te] <= 0 || x[te] !== -1 && (A[O + te] = A[T + x[te]], A[T + x[te]] = te);
    for (le = 0, P = 0; P <= g; P++)
      x[P] === -1 && (le = Jw(P, le, A, T, O, D, $));
    return D.splice(D.length - 1, 1), D;
  };
  function a(f, l, c, h, d) {
    var g = n(l);
    if (f === 1 && h === c)
      return e(l, g);
    if (f === 2) {
      for (var v = g._index, N = g._ptr, b = 0, C = 0; C < c; C++) {
        var x = N[C];
        if (N[C] = b, !(N[C + 1] - x > d))
          for (var E = N[C + 1]; x < E; x++)
            v[b++] = v[x];
      }
      return N[c] = b, l = n(g), r(g, l);
    }
    return r(g, l);
  }
  function s(f, l, c, h, d, g, v, N, b, C, x, E) {
    for (var D = 0; D < f; D++)
      c[h + D] = l[D + 1] - l[D];
    c[h + f] = 0;
    for (var A = 0; A <= f; A++)
      c[d + A] = -1, g[A] = -1, c[v + A] = -1, c[N + A] = -1, c[b + A] = 1, c[C + A] = 1, c[x + A] = 0, c[E + A] = c[h + A];
    var M = p(0, 0, c, C, f);
    return c[x + f] = -2, l[f] = -1, c[C + f] = 0, M;
  }
  function o(f, l, c, h, d, g, v, N, b, C, x) {
    for (var E = 0, D = 0; D < f; D++) {
      var A = c[h + D];
      if (A === 0)
        c[d + D] = -2, E++, l[D] = -1, c[g + D] = 0;
      else if (A > v)
        c[N + D] = 0, c[d + D] = -1, E++, l[D] = Si(f), c[N + f]++;
      else {
        var M = c[b + A];
        M !== -1 && (C[M] = D), c[x + D] = c[b + A], c[b + A] = D;
      }
    }
    return E;
  }
  function p(f, l, c, h, d) {
    if (f < 2 || f + l < 0) {
      for (var g = 0; g < d; g++)
        c[h + g] !== 0 && (c[h + g] = 1);
      f = 2;
    }
    return f;
  }
  function u(f, l) {
    return f !== l;
  }
});
function Hq(t, e, r, n, a, s, o) {
  var p, u, f = 0, l;
  if (t <= e || r[n + e] <= r[a + t])
    return -1;
  r[a + t] = r[n + e];
  var c = r[s + t];
  if (r[s + t] = e, c === -1)
    f = 1, l = t;
  else {
    for (f = 2, l = c; l !== r[o + l]; l = r[o + l]) ;
    for (p = c; p !== l; p = u)
      u = r[o + p], r[o + p] = l;
  }
  return {
    jleaf: f,
    q: l
  };
}
var Qq = "csCounts", Vq = ["transpose"], Wq = /* @__PURE__ */ j(Qq, Vq, (t) => {
  var {
    transpose: e
  } = t;
  return function(r, n, a, s) {
    if (!r || !n || !a)
      return null;
    var o = r._size, p = o[0], u = o[1], f, l, c, h, d, g, v, N = 4 * u + (s ? u + p + 1 : 0), b = [], C = 0, x = u, E = 2 * u, D = 3 * u, A = 4 * u, M = 5 * u + 1;
    for (c = 0; c < N; c++)
      b[c] = -1;
    var _ = [], O = e(r), T = O._index, I = O._ptr;
    for (c = 0; c < u; c++)
      for (l = a[c], _[l] = b[D + l] === -1 ? 1 : 0; l !== -1 && b[D + l] === -1; l = n[l])
        b[D + l] = c;
    if (s) {
      for (c = 0; c < u; c++)
        b[a[c]] = c;
      for (f = 0; f < p; f++) {
        for (c = u, g = I[f], v = I[f + 1], d = g; d < v; d++)
          c = Math.min(c, b[T[d]]);
        b[M + f] = b[A + c], b[A + c] = f;
      }
    }
    for (f = 0; f < u; f++)
      b[C + f] = f;
    for (c = 0; c < u; c++) {
      for (l = a[c], n[l] !== -1 && _[n[l]]--, h = s ? b[A + c] : l; h !== -1; h = s ? b[M + h] : -1)
        for (d = I[h]; d < I[h + 1]; d++) {
          f = T[d];
          var q = Hq(f, l, b, D, x, E, C);
          q.jleaf >= 1 && _[l]++, q.jleaf === 2 && _[q.q]--;
        }
      n[l] !== -1 && (b[C + l] = n[l]);
    }
    for (l = 0; l < u; l++)
      n[l] !== -1 && (_[n[l]] += _[l]);
    return _;
  };
}), jq = "csSqr", Zq = ["add", "multiply", "transpose"], Jq = /* @__PURE__ */ j(jq, Zq, (t) => {
  var {
    add: e,
    multiply: r,
    transpose: n
  } = t, a = Gq({
    add: e,
    multiply: r,
    transpose: n
  }), s = Wq({
    transpose: n
  });
  return function(u, f, l) {
    var c = f._ptr, h = f._size, d = h[1], g, v = {};
    if (v.q = a(u, f), u && !v.q)
      return null;
    if (l) {
      var N = u ? Lq(f, null, v.q) : f;
      v.parent = kq(N);
      var b = Pq(v.parent, d);
      if (v.cp = s(N, v.parent, b, 1), N && v.parent && v.cp && o(N, v))
        for (v.unz = 0, g = 0; g < d; g++)
          v.unz += v.cp[g];
    } else
      v.unz = 4 * c[d] + d, v.lnz = v.unz;
    return v;
  };
  function o(p, u) {
    var f = p._ptr, l = p._index, c = p._size, h = c[0], d = c[1];
    u.pinv = [], u.leftmost = [];
    var g = u.parent, v = u.pinv, N = u.leftmost, b = [], C = 0, x = h, E = h + d, D = h + 2 * d, A, M, _, O, T;
    for (M = 0; M < d; M++)
      b[x + M] = -1, b[E + M] = -1, b[D + M] = 0;
    for (A = 0; A < h; A++)
      N[A] = -1;
    for (M = d - 1; M >= 0; M--)
      for (O = f[M], T = f[M + 1], _ = O; _ < T; _++)
        N[l[_]] = M;
    for (A = h - 1; A >= 0; A--)
      v[A] = -1, M = N[A], M !== -1 && (b[D + M]++ === 0 && (b[E + M] = A), b[C + A] = b[x + M], b[x + M] = A);
    for (u.lnz = 0, u.m2 = h, M = 0; M < d; M++)
      if (A = b[x + M], u.lnz++, A < 0 && (A = u.m2++), v[A] = M, !(--D[M] <= 0)) {
        u.lnz += b[D + M];
        var I = g[M];
        I !== -1 && (b[D + I] === 0 && (b[E + I] = b[E + M]), b[C + b[E + M]] = b[x + I], b[x + I] = b[C + A], b[D + I] += b[D + M]);
      }
    for (A = 0; A < h; A++)
      v[A] < 0 && (v[A] = M++);
    return !0;
  }
});
function od(t, e) {
  return t[e] < 0;
}
function Yw(t, e) {
  t[e] = Si(t[e]);
}
function ub(t) {
  return t < 0 ? Si(t) : t;
}
function Yq(t, e, r, n, a) {
  var s = e._index, o = e._ptr, p = e._size, u = p[1], f, l, c, h = 0;
  for (n[0] = t; h >= 0; ) {
    t = n[h];
    var d = a ? a[t] : t;
    od(o, t) || (Yw(o, t), n[u + h] = d < 0 ? 0 : ub(o[d]));
    var g = 1;
    for (l = n[u + h], c = d < 0 ? 0 : ub(o[d + 1]); l < c; l++)
      if (f = s[l], !od(o, f)) {
        n[u + h] = l, n[++h] = f, g = 0;
        break;
      }
    g && (h--, n[--r] = t);
  }
  return r;
}
function Xq(t, e, r, n, a) {
  var s = t._ptr, o = t._size, p = e._index, u = e._ptr, f = o[1], l, c, h, d = f;
  for (c = u[r], h = u[r + 1], l = c; l < h; l++) {
    var g = p[l];
    od(s, g) || (d = Yq(g, t, d, n, a));
  }
  for (l = d; l < f; l++)
    Yw(s, n[l]);
  return d;
}
var Kq = "csSpsolve", e4 = ["divideScalar", "multiply", "subtract"], t4 = /* @__PURE__ */ j(Kq, e4, (t) => {
  var {
    divideScalar: e,
    multiply: r,
    subtract: n
  } = t;
  return function(s, o, p, u, f, l, c) {
    var h = s._values, d = s._index, g = s._ptr, v = s._size, N = v[1], b = o._values, C = o._index, x = o._ptr, E, D, A, M, _ = Xq(s, o, p, u, l);
    for (E = _; E < N; E++)
      f[u[E]] = 0;
    for (D = x[p], A = x[p + 1], E = D; E < A; E++)
      f[C[E]] = b[E];
    for (var O = _; O < N; O++) {
      var T = u[O], I = l ? l[T] : T;
      if (!(I < 0))
        for (D = g[I], A = g[I + 1], f[T] = e(f[T], h[c ? D : A - 1]), E = c ? D + 1 : D, M = c ? A : A - 1; E < M; E++) {
          var q = d[E];
          f[q] = n(f[q], r(h[E], f[T]));
        }
    }
    return _;
  };
}), r4 = "csLu", n4 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"], i4 = /* @__PURE__ */ j(r4, n4, (t) => {
  var {
    abs: e,
    divideScalar: r,
    multiply: n,
    subtract: a,
    larger: s,
    largerEq: o,
    SparseMatrix: p
  } = t, u = t4({
    divideScalar: r,
    multiply: n,
    subtract: a
  });
  return function(l, c, h) {
    if (!l)
      return null;
    var d = l._size, g = d[1], v, N = 100, b = 100;
    c && (v = c.q, N = c.lnz || N, b = c.unz || b);
    var C = [], x = [], E = [], D = new p({
      values: C,
      index: x,
      ptr: E,
      size: [g, g]
    }), A = [], M = [], _ = [], O = new p({
      values: A,
      index: M,
      ptr: _,
      size: [g, g]
    }), T = [], I, q, $ = [], U = [];
    for (I = 0; I < g; I++)
      $[I] = 0, T[I] = -1, E[I + 1] = 0;
    N = 0, b = 0;
    for (var k = 0; k < g; k++) {
      E[k] = N, _[k] = b;
      var L = v ? v[k] : k, R = u(D, l, L, U, $, T, 1), G = -1, P = -1;
      for (q = R; q < g; q++)
        if (I = U[q], T[I] < 0) {
          var W = e($[I]);
          s(W, P) && (P = W, G = I);
        } else
          M[b] = T[I], A[b++] = $[I];
      if (G === -1 || P <= 0)
        return null;
      T[L] < 0 && o(e($[L]), n(P, h)) && (G = L);
      var le = $[G];
      for (M[b] = k, A[b++] = le, T[G] = k, x[N] = G, C[N++] = 1, q = R; q < g; q++)
        I = U[q], T[I] < 0 && (x[N] = I, C[N++] = r($[I], le)), $[I] = 0;
    }
    for (E[g] = N, _[g] = b, q = 0; q < N; q++)
      x[q] = T[x[q]];
    return C.splice(N, C.length - N), x.splice(N, x.length - N), A.splice(b, A.length - b), M.splice(b, M.length - b), {
      L: D,
      U: O,
      pinv: T
    };
  };
}), lb = "slu", a4 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"], bf = /* @__PURE__ */ j(lb, a4, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    multiply: a,
    transpose: s,
    divideScalar: o,
    subtract: p,
    larger: u,
    largerEq: f,
    SparseMatrix: l
  } = t, c = Jq({
    add: n,
    multiply: a,
    transpose: s
  }), h = i4({
    abs: r,
    divideScalar: o,
    multiply: a,
    subtract: p,
    larger: u,
    largerEq: f,
    SparseMatrix: l
  });
  return e(lb, {
    "SparseMatrix, number, number": function(g, v, N) {
      if (!Xe(v) || v < 0 || v > 3)
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      if (N < 0 || N > 1)
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      var b = c(v, g, !1), C = h(g, b, N);
      return {
        L: C.L,
        U: C.U,
        p: C.pinv,
        q: b.q,
        toString: function() {
          return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
p: ` + this.p.toString() + (this.q ? `
q: ` + this.q.toString() : "") + `
`;
        }
      };
    }
  });
});
function cb(t, e) {
  var r, n = e.length, a = [];
  if (t)
    for (r = 0; r < n; r++)
      a[t[r]] = e[r];
  else
    for (r = 0; r < n; r++)
      a[r] = e[r];
  return a;
}
var fb = "lusolve", s4 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"], wf = /* @__PURE__ */ j(fb, s4, (t) => {
  var {
    typed: e,
    matrix: r,
    lup: n,
    slu: a,
    usolve: s,
    lsolve: o,
    DenseMatrix: p
  } = t, u = to({
    DenseMatrix: p
  });
  return e(fb, {
    "Array, Array | Matrix": function(h, d) {
      h = r(h);
      var g = n(h), v = l(g.L, g.U, g.p, null, d);
      return v.valueOf();
    },
    "DenseMatrix, Array | Matrix": function(h, d) {
      var g = n(h);
      return l(g.L, g.U, g.p, null, d);
    },
    "SparseMatrix, Array | Matrix": function(h, d) {
      var g = n(h);
      return l(g.L, g.U, g.p, null, d);
    },
    "SparseMatrix, Array | Matrix, number, number": function(h, d, g, v) {
      var N = a(h, g, v);
      return l(N.L, N.U, N.p, N.q, d);
    },
    "Object, Array | Matrix": function(h, d) {
      return l(h.L, h.U, h.p, h.q, d);
    }
  });
  function f(c) {
    if (tt(c))
      return c;
    if (Rt(c))
      return r(c);
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function l(c, h, d, g, v) {
    c = f(c), h = f(h), d && (v = u(c, v, !0), v._data = cb(d, v._data));
    var N = o(c, v), b = s(h, N);
    return g && (b._data = cb(g, b._data)), b;
  }
}), pb = "polynomialRoot", o4 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"], Nf = /* @__PURE__ */ j(pb, o4, (t) => {
  var {
    typed: e,
    isZero: r,
    equalScalar: n,
    add: a,
    subtract: s,
    multiply: o,
    divide: p,
    sqrt: u,
    unaryMinus: f,
    cbrt: l,
    typeOf: c,
    im: h,
    re: d
  } = t;
  return e(pb, {
    "number|Complex, ...number|Complex": (g, v) => {
      for (var N = [g, ...v]; N.length > 0 && r(N[N.length - 1]); )
        N.pop();
      if (N.length < 2)
        throw new RangeError("Polynomial [".concat(g, ", ").concat(v, "] must have a non-zero non-constant coefficient"));
      switch (N.length) {
        case 2:
          return [f(p(N[0], N[1]))];
        case 3: {
          var [b, C, x] = N, E = o(2, x), D = o(C, C), A = o(4, x, b);
          if (n(D, A)) return [p(f(C), E)];
          var M = u(s(D, A));
          return [p(s(M, C), E), p(s(f(M), C), E)];
        }
        case 4: {
          var [_, O, T, I] = N, q = f(o(3, I)), $ = o(T, T), U = o(3, I, O), k = a(o(2, T, T, T), o(27, I, I, _)), L = o(9, I, T, O);
          if (n($, U) && n(k, L))
            return [p(T, q)];
          var R = s($, U), G = s(k, L), P = a(o(18, I, T, O, _), o(T, T, O, O)), W = a(o(4, T, T, T, _), o(4, I, O, O, O), o(27, I, I, _, _));
          if (n(P, W))
            return [
              p(s(o(4, I, T, O), a(o(9, I, I, _), o(T, T, T))), o(I, R)),
              // simple root
              p(s(o(9, I, _), o(T, O)), o(2, R))
              // double root
            ];
          var le;
          n($, U) ? le = G : le = p(a(G, u(s(o(G, G), o(4, R, R, R)))), 2);
          var Z = !0, H = l(le, Z).toArray().map((te) => p(a(T, te, p(R, te)), q));
          return H.map((te) => c(te) === "Complex" && n(d(te), d(te) + h(te)) ? d(te) : te);
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(N));
      }
    }
  });
}), u4 = "Help", l4 = ["evaluate"], Df = /* @__PURE__ */ j(u4, l4, (t) => {
  var {
    evaluate: e
  } = t;
  function r(n) {
    if (!(this instanceof r))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (!n) throw new Error('Argument "doc" missing');
    this.doc = n;
  }
  return r.prototype.type = "Help", r.prototype.isHelp = !0, r.prototype.toString = function() {
    var n = this.doc || {}, a = `
`;
    if (n.name && (a += "Name: " + n.name + `

`), n.category && (a += "Category: " + n.category + `

`), n.description && (a += `Description:
    ` + n.description + `

`), n.syntax && (a += `Syntax:
    ` + n.syntax.join(`
    `) + `

`), n.examples) {
      a += `Examples:
`;
      for (var s = !1, o = e("config()"), p = {
        config: (c) => (s = !0, e("config(newConfig)", {
          newConfig: c
        }))
      }, u = 0; u < n.examples.length; u++) {
        var f = n.examples[u];
        a += "    " + f + `
`;
        var l = void 0;
        try {
          l = e(f, p);
        } catch (c) {
          l = c;
        }
        l !== void 0 && !Au(l) && (a += "        " + Dt(l, {
          precision: 14
        }) + `
`);
      }
      a += `
`, s && e("config(originalConfig)", {
        originalConfig: o
      });
    }
    return n.mayThrow && n.mayThrow.length && (a += "Throws: " + n.mayThrow.join(", ") + `

`), n.seealso && n.seealso.length && (a += "See also: " + n.seealso.join(", ") + `
`), a;
  }, r.prototype.toJSON = function() {
    var n = nt(this.doc);
    return n.mathjs = "Help", n;
  }, r.fromJSON = function(n) {
    var a = {};
    return Object.keys(n).filter((s) => s !== "mathjs").forEach((s) => {
      a[s] = n[s];
    }), new r(a);
  }, r.prototype.valueOf = r.prototype.toString, r;
}, {
  isClass: !0
}), c4 = "Chain", f4 = ["?on", "math", "typed"], Af = /* @__PURE__ */ j(c4, f4, (t) => {
  var {
    on: e,
    math: r,
    typed: n
  } = t;
  function a(f) {
    if (!(this instanceof a))
      throw new SyntaxError("Constructor must be called with the new operator");
    Eu(f) ? this.value = f.value : this.value = f;
  }
  a.prototype.type = "Chain", a.prototype.isChain = !0, a.prototype.done = function() {
    return this.value;
  }, a.prototype.valueOf = function() {
    return this.value;
  }, a.prototype.toString = function() {
    return Dt(this.value);
  }, a.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  }, a.fromJSON = function(f) {
    return new a(f.value);
  };
  function s(f, l) {
    typeof l == "function" && (a.prototype[f] = p(l));
  }
  function o(f, l) {
    Jo(a.prototype, f, function() {
      var h = l();
      if (typeof h == "function")
        return p(h);
    });
  }
  function p(f) {
    return function() {
      if (arguments.length === 0)
        return new a(f(this.value));
      for (var l = [this.value], c = 0; c < arguments.length; c++)
        l[c + 1] = arguments[c];
      if (n.isTypedFunction(f)) {
        var h = n.resolve(f, l);
        if (h.params.length === 1)
          throw new Error("chain function " + f.name + " cannot match rest parameter between chain value and additional arguments.");
        return new a(h.implementation.apply(f, l));
      }
      return new a(f.apply(f, l));
    };
  }
  a.createProxy = function(f, l) {
    if (typeof f == "string")
      s(f, l);
    else {
      var c = function(g) {
        We(f, g) && u[g] === void 0 && o(g, () => f[g]);
      };
      for (var h in f)
        c(h);
    }
  };
  var u = {
    expression: !0,
    docs: !0,
    type: !0,
    classes: !0,
    json: !0,
    error: !0,
    isChain: !0
    // conflicts with the property isChain of a Chain instance
  };
  return a.createProxy(r), e && e("import", function(f, l, c) {
    c || o(f, l);
  }), a;
}, {
  isClass: !0
}), hb = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
}, p4 = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
}, h4 = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
}, m4 = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
}, d4 = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
}, v4 = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
}, g4 = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
}, y4 = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
}, x4 = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
}, b4 = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
}, w4 = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
}, mb = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
}, N4 = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
}, D4 = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
}, A4 = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
}, E4 = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
}, S4 = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
}, C4 = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "bigint", "complex", "fraction", "index", "matrix", "string", "unit"]
}, T4 = {
  name: "bigint",
  category: "Construction",
  syntax: ["bigint(x)"],
  description: "Create a bigint, an integer with an arbitrary number of digits, from a number or string.",
  examples: ["123123123123123123 # a large number will lose digits", 'bigint("123123123123123123")', 'bignumber(["1", "3", "5"])'],
  seealso: ["boolean", "bignumber", "number", "complex", "fraction", "index", "matrix", "string", "unit"]
}, _4 = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
}, M4 = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
}, O4 = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
}, F4 = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
}, q4 = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
}, I4 = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
}, B4 = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "bigint", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
}, R4 = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
}, L4 = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
}, P4 = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
}, k4 = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
}, $4 = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
}, z4 = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
}, U4 = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
  seealso: []
}, G4 = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
}, H4 = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
}, Q4 = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
}, V4 = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
}, W4 = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
}, j4 = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
}, Z4 = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
  seealso: ["cbrt", "sqrt"]
}, J4 = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
}, Y4 = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
}, X4 = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
}, K4 = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
}, eI = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
}, tI = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
}, rI = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
}, nI = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
}, iI = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
}, aI = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
}, sI = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
}, oI = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
}, uI = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
}, lI = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
  seealso: ["floor", "fix", "round"]
}, cI = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
}, fI = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
}, pI = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
}, hI = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
}, mI = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
}, dI = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
  seealso: ["expm", "expm1", "pow", "log"]
}, vI = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
}, gI = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
}, yI = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
  seealso: ["ceil", "floor", "round"]
}, xI = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
  seealso: ["ceil", "fix", "round"]
}, bI = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
}, wI = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenusa of a list with values. ",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
}, NI = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)",
  examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
  seealso: ["gcd", "xgcd"]
}, DI = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
}, AI = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
}, EI = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
}, SI = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
}, CI = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
}, TI = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
}, _I = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
}, MI = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
}, OI = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
}, FI = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
}, qI = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
}, II = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)", "round(unit, valuelessUnit)", "round(unit, n, valuelessUnit)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)", "round(3.241cm, 2, cm)", "round([3.2, 3.8, -4.7])"],
  seealso: ["ceil", "floor", "fix"]
}, BI = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
}, RI = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
}, LI = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
}, PI = {
  name: "sylvester",
  category: "Algebra",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
  seealso: ["schur", "lyap"]
}, kI = {
  name: "schur",
  category: "Algebra",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU'",
  examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
  seealso: ["lyap", "sylvester"]
}, $I = {
  name: "lyap",
  category: "Algebra",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
  examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
  seealso: ["schur", "sylvester"]
}, zI = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
}, UI = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
}, GI = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
}, HI = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
}, QI = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
}, VI = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
}, WI = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
}, jI = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
}, ZI = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
}, JI = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
}, YI = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
}, XI = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
}, KI = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
}, e5 = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
}, t5 = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
}, r5 = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
}, n5 = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
}, i5 = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
}, a5 = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
}, s5 = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
}, o5 = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
  seealso: []
}, u5 = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
}, l5 = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
}, c5 = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
}, f5 = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
}, p5 = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
}, h5 = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
}, m5 = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
}, d5 = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
}, v5 = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, g5 = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
}, y5 = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
}, x5 = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
}, b5 = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, w5 = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, N5 = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
  seealso: ["subtract", "partitionSelect"]
}, D5 = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
}, A5 = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])", "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"],
  seealso: ["inv"]
}, E5 = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
}, S5 = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
}, C5 = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
}, T5 = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
}, _5 = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, M5 = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, O5 = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore–Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
}, F5 = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
}, q5 = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
  examples: ["map([1, 2, 3], square)"],
  seealso: ["filter", "forEach"]
}, I5 = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
}, B5 = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
}, R5 = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
}, L5 = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, P5 = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
  seealso: ["sort"]
}, k5 = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, $5 = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
  seealso: ["size", "squeeze", "resize"]
}, z5 = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
}, U5 = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
}, G5 = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
}, H5 = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
}, Q5 = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
}, V5 = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
}, W5 = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
}, j5 = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
}, Z5 = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
}, J5 = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
}, Y5 = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
}, X5 = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
}, K5 = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
}, eB = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
}, tB = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
}, rB = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
}, nB = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
}, iB = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
}, aB = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
}, sB = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
}, oB = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
}, uB = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
}, lB = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
}, cB = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
}, fB = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
}, pB = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
}, hB = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
}, mB = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
}, dB = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
}, vB = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
}, gB = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
}, yB = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
}, xB = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
}, bB = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
}, wB = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
}, NB = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
}, DB = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
}, AB = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
}, EB = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
}, SB = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
}, CB = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
}, TB = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
}, _B = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
}, MB = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
}, OB = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
}, FB = {
  name: "zpk2tf",
  category: "Signal",
  syntax: ["zpk2tf(z, p, k)"],
  description: "Compute the transfer function of a zero-pole-gain model.",
  examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
  seealso: []
}, qB = {
  name: "freqz",
  category: "Signal",
  syntax: ["freqz(b, a)", "freqz(b, a, w)"],
  description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
  examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
  seealso: []
}, IB = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
}, BB = {
  name: "zeta",
  category: "Special",
  syntax: ["zeta(s)"],
  description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
  examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
  seealso: []
}, RB = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
}, LB = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
}, PB = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
}, kB = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
}, $B = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
}, zB = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
}, UB = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
}, GB = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: `Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. 

In case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.`,
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
}, HB = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
}, QB = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
}, VB = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
}, WB = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
}, jB = {
  name: "corr",
  category: "Statistics",
  syntax: ["corr(A,B)"],
  description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
  examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
}, ZB = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
}, JB = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
}, YB = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
}, XB = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
}, KB = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
}, e8 = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
}, t8 = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
}, r8 = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
}, n8 = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
}, i8 = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
}, a8 = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
}, s8 = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
}, o8 = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
}, u8 = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
}, l8 = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
}, c8 = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
}, f8 = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
}, p8 = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
}, h8 = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
}, m8 = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
}, d8 = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
}, v8 = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
}, g8 = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
}, y8 = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
}, x8 = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
}, b8 = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
}, w8 = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
}, N8 = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
}, D8 = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
}, A8 = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
}, E8 = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
}, S8 = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
}, C8 = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
}, T8 = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
}, _8 = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
}, M8 = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
}, O8 = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
}, F8 = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
}, q8 = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "bigint")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
  seealso: ["number", "bigint", "fraction", "bignumber", "string", "format"]
}, I8 = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
}, B8 = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
  seealso: ["format"]
}, R8 = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
}, L8 = {
  name: "solveODE",
  category: "Numeric",
  syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
  description: "Numerical Integration of Ordinary Differential Equations.",
  examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
  seealso: ["derivative", "simplifyCore"]
}, Xw = {
  // construction functions
  bignumber: C4,
  bigint: T4,
  boolean: _4,
  complex: M4,
  createUnit: O4,
  fraction: F4,
  index: q4,
  matrix: I4,
  number: B4,
  sparse: R4,
  splitUnit: L4,
  string: P4,
  unit: k4,
  // constants
  e: hb,
  E: hb,
  false: p4,
  i: h4,
  Infinity: m4,
  LN2: v4,
  LN10: d4,
  LOG2E: y4,
  LOG10E: g4,
  NaN: x4,
  null: b4,
  pi: mb,
  PI: mb,
  phi: w4,
  SQRT1_2: N4,
  SQRT2: D4,
  tau: A4,
  true: E4,
  version: S4,
  // physical constants
  // TODO: more detailed docs for physical constants
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Borh magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  // josephson: {description: 'Josephson constant', examples: ['josephson']},
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Borh radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro's number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  // functions - algebra
  derivative: G4,
  lsolve: Q4,
  lsolveAll: V4,
  lup: W4,
  lusolve: j4,
  leafCount: H4,
  polynomialRoot: Z4,
  resolve: X4,
  simplify: K4,
  simplifyConstant: eI,
  simplifyCore: tI,
  symbolicEqual: nI,
  rationalize: Y4,
  slu: rI,
  usolve: iI,
  usolveAll: aI,
  qr: J4,
  // functions - arithmetic
  abs: sI,
  add: oI,
  cbrt: uI,
  ceil: lI,
  cube: cI,
  divide: fI,
  dotDivide: pI,
  dotMultiply: hI,
  dotPow: mI,
  exp: dI,
  expm: vI,
  expm1: gI,
  fix: yI,
  floor: xI,
  gcd: bI,
  hypot: wI,
  lcm: DI,
  log: AI,
  log2: CI,
  log1p: SI,
  log10: EI,
  mod: TI,
  multiply: _I,
  norm: MI,
  nthRoot: OI,
  nthRoots: FI,
  pow: qI,
  round: II,
  sign: BI,
  sqrt: RI,
  sqrtm: LI,
  square: zI,
  subtract: UI,
  unaryMinus: GI,
  unaryPlus: HI,
  xgcd: QI,
  invmod: NI,
  // functions - bitwise
  bitAnd: VI,
  bitNot: WI,
  bitOr: jI,
  bitXor: ZI,
  leftShift: JI,
  rightArithShift: YI,
  rightLogShift: XI,
  // functions - combinatorics
  bellNumbers: KI,
  catalan: e5,
  composition: t5,
  stirlingS2: r5,
  // functions - core
  config: $4,
  import: z4,
  typed: U4,
  // functions - complex
  arg: n5,
  conj: i5,
  re: s5,
  im: a5,
  // functions - expression
  evaluate: o5,
  help: u5,
  // functions - geometry
  distance: l5,
  intersect: c5,
  // functions - logical
  and: f5,
  not: p5,
  or: h5,
  xor: m5,
  // functions - matrix
  concat: v5,
  count: g5,
  cross: y5,
  column: d5,
  ctranspose: x5,
  det: b5,
  diag: w5,
  diff: N5,
  dot: D5,
  getMatrixDataType: T5,
  identity: _5,
  filter: E5,
  flatten: S5,
  forEach: C5,
  inv: M5,
  pinv: O5,
  eigs: A5,
  kron: F5,
  matrixFromFunction: B5,
  matrixFromRows: R5,
  matrixFromColumns: I5,
  map: q5,
  ones: L5,
  partitionSelect: P5,
  range: k5,
  resize: z5,
  reshape: $5,
  rotate: U5,
  rotationMatrix: G5,
  row: H5,
  size: Q5,
  sort: V5,
  squeeze: W5,
  subset: j5,
  trace: Z5,
  transpose: J5,
  zeros: Y5,
  fft: X5,
  ifft: K5,
  sylvester: PI,
  schur: kI,
  lyap: $I,
  // functions - numeric
  solveODE: L8,
  // functions - probability
  combinations: eB,
  combinationsWithRep: tB,
  // distribution: distributionDocs,
  factorial: rB,
  gamma: nB,
  kldivergence: aB,
  lgamma: iB,
  multinomial: sB,
  permutations: oB,
  pickRandom: uB,
  random: lB,
  randomInt: cB,
  // functions - relational
  compare: fB,
  compareNatural: pB,
  compareText: hB,
  deepEqual: mB,
  equal: dB,
  equalText: vB,
  larger: gB,
  largerEq: yB,
  smaller: xB,
  smallerEq: bB,
  unequal: wB,
  // functions - set
  setCartesian: NB,
  setDifference: DB,
  setDistinct: AB,
  setIntersect: EB,
  setIsSubset: SB,
  setMultiplicity: CB,
  setPowerset: TB,
  setSize: _B,
  setSymDifference: MB,
  setUnion: OB,
  // functions - signal
  zpk2tf: FB,
  freqz: qB,
  // functions - special
  erf: IB,
  zeta: BB,
  // functions - statistics
  cumsum: QB,
  mad: RB,
  max: LB,
  mean: PB,
  median: kB,
  min: $B,
  mode: zB,
  prod: UB,
  quantileSeq: GB,
  std: HB,
  sum: VB,
  variance: WB,
  corr: jB,
  // functions - trigonometry
  acos: ZB,
  acosh: JB,
  acot: YB,
  acoth: XB,
  acsc: KB,
  acsch: e8,
  asec: t8,
  asech: r8,
  asin: n8,
  asinh: i8,
  atan: a8,
  atanh: o8,
  atan2: s8,
  cos: u8,
  cosh: l8,
  cot: c8,
  coth: f8,
  csc: p8,
  csch: h8,
  sec: m8,
  sech: d8,
  sin: v8,
  sinh: g8,
  tan: y8,
  tanh: x8,
  // functions - units
  to: b8,
  // functions - utils
  clone: N8,
  format: D8,
  bin: w8,
  oct: I8,
  hex: E8,
  isNaN: C8,
  isInteger: S8,
  isNegative: T8,
  isNumeric: _8,
  hasNumericValue: A8,
  isPositive: M8,
  isPrime: O8,
  isZero: F8,
  print: B8,
  typeOf: R8,
  numeric: q8
}, db = "help", P8 = ["typed", "mathWithTransform", "Help"], Ef = /* @__PURE__ */ j(db, P8, (t) => {
  var {
    typed: e,
    mathWithTransform: r,
    Help: n
  } = t;
  return e(db, {
    any: function(s) {
      var o, p = s;
      if (typeof s != "string") {
        for (o in r)
          if (We(r, o) && s === r[o]) {
            p = o;
            break;
          }
      }
      var u = Kr(Xw, p);
      if (!u) {
        var f = typeof p == "function" ? p.name : p;
        throw new Error('No documentation found on "' + f + '"');
      }
      return new n(u);
    }
  });
}), vb = "chain", k8 = ["typed", "Chain"], Sf = /* @__PURE__ */ j(vb, k8, (t) => {
  var {
    typed: e,
    Chain: r
  } = t;
  return e(vb, {
    "": function() {
      return new r();
    },
    any: function(a) {
      return new r(a);
    }
  });
}), gb = "det", $8 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"], Cf = /* @__PURE__ */ j(gb, $8, (t) => {
  var {
    typed: e,
    matrix: r,
    subtractScalar: n,
    multiply: a,
    divideScalar: s,
    isZero: o,
    unaryMinus: p
  } = t;
  return e(gb, {
    any: function(l) {
      return nt(l);
    },
    "Array | Matrix": function(l) {
      var c;
      switch (tt(l) ? c = l.size() : Array.isArray(l) ? (l = r(l), c = l.size()) : c = [], c.length) {
        case 0:
          return nt(l);
        case 1:
          if (c[0] === 1)
            return nt(l.valueOf()[0]);
          if (c[0] === 0)
            return 1;
          throw new RangeError("Matrix must be square (size: " + Dt(c) + ")");
        case 2: {
          var h = c[0], d = c[1];
          if (h === d)
            return u(l.clone().valueOf(), h);
          if (d === 0)
            return 1;
          throw new RangeError("Matrix must be square (size: " + Dt(c) + ")");
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + Dt(c) + ")");
      }
    }
  });
  function u(f, l, c) {
    if (l === 1)
      return nt(f[0][0]);
    if (l === 2)
      return n(a(f[0][0], f[1][1]), a(f[1][0], f[0][1]));
    for (var h = !1, d = new Array(l).fill(0).map((M, _) => _), g = 0; g < l; g++) {
      var v = d[g];
      if (o(f[v][g])) {
        var N = void 0;
        for (N = g + 1; N < l; N++)
          if (!o(f[d[N]][g])) {
            v = d[N], d[N] = d[g], d[g] = v, h = !h;
            break;
          }
        if (N === l) return f[v][g];
      }
      for (var b = f[v][g], C = g === 0 ? 1 : f[d[g - 1]][g - 1], x = g + 1; x < l; x++)
        for (var E = d[x], D = g + 1; D < l; D++)
          f[E][D] = s(n(a(f[E][D], b), a(f[E][g], f[v][D])), C);
    }
    var A = f[d[l - 1]][l - 1];
    return h ? p(A) : A;
  }
}), yb = "inv", z8 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"], Tf = /* @__PURE__ */ j(yb, z8, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    addScalar: a,
    multiply: s,
    unaryMinus: o,
    det: p,
    identity: u,
    abs: f
  } = t;
  return e(yb, {
    "Array | Matrix": function(h) {
      var d = tt(h) ? h.size() : gt(h);
      switch (d.length) {
        case 1:
          if (d[0] === 1)
            return tt(h) ? r([n(1, h.valueOf()[0])]) : [n(1, h[0])];
          throw new RangeError("Matrix must be square (size: " + Dt(d) + ")");
        case 2: {
          var g = d[0], v = d[1];
          if (g === v)
            return tt(h) ? r(l(h.valueOf(), g, v), h.storage()) : l(h, g, v);
          throw new RangeError("Matrix must be square (size: " + Dt(d) + ")");
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + Dt(d) + ")");
      }
    },
    any: function(h) {
      return n(1, h);
    }
  });
  function l(c, h, d) {
    var g, v, N, b, C;
    if (h === 1) {
      if (b = c[0][0], b === 0)
        throw Error("Cannot calculate inverse, determinant is zero");
      return [[n(1, b)]];
    } else if (h === 2) {
      var x = p(c);
      if (x === 0)
        throw Error("Cannot calculate inverse, determinant is zero");
      return [[n(c[1][1], x), n(o(c[0][1]), x)], [n(o(c[1][0]), x), n(c[0][0], x)]];
    } else {
      var E = c.concat();
      for (g = 0; g < h; g++)
        E[g] = E[g].concat();
      for (var D = u(h).valueOf(), A = 0; A < d; A++) {
        var M = f(E[A][A]), _ = A;
        for (g = A + 1; g < h; )
          f(E[g][A]) > M && (M = f(E[g][A]), _ = g), g++;
        if (M === 0)
          throw Error("Cannot calculate inverse, determinant is zero");
        g = _, g !== A && (C = E[A], E[A] = E[g], E[g] = C, C = D[A], D[A] = D[g], D[g] = C);
        var O = E[A], T = D[A];
        for (g = 0; g < h; g++) {
          var I = E[g], q = D[g];
          if (g !== A) {
            if (I[A] !== 0) {
              for (N = n(o(I[A]), O[A]), v = A; v < d; v++)
                I[v] = a(I[v], s(N, O[v]));
              for (v = 0; v < d; v++)
                q[v] = a(q[v], s(N, T[v]));
            }
          } else {
            for (N = O[A], v = A; v < d; v++)
              I[v] = n(I[v], N);
            for (v = 0; v < d; v++)
              q[v] = n(q[v], N);
          }
        }
      }
      return D;
    }
  }
}), xb = "pinv", U8 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"], _f = /* @__PURE__ */ j(xb, U8, (t) => {
  var {
    typed: e,
    matrix: r,
    inv: n,
    deepEqual: a,
    equal: s,
    dotDivide: o,
    dot: p,
    ctranspose: u,
    divideScalar: f,
    multiply: l,
    add: c,
    Complex: h
  } = t;
  return e(xb, {
    "Array | Matrix": function(x) {
      var E = tt(x) ? x.size() : gt(x);
      switch (E.length) {
        case 1:
          return b(x) ? u(x) : E[0] === 1 ? n(x) : o(u(x), p(x, x));
        case 2: {
          if (b(x)) return u(x);
          var D = E[0], A = E[1];
          if (D === A)
            try {
              return n(x);
            } catch (M) {
              if (!(M instanceof Error && M.message.match(/Cannot calculate inverse, determinant is zero/))) throw M;
            }
          return tt(x) ? r(d(x.valueOf(), D, A), x.storage()) : d(x, D, A);
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + Dt(E) + ")");
      }
    },
    any: function(x) {
      return s(x, 0) ? nt(x) : f(1, x);
    }
  });
  function d(C, x, E) {
    var {
      C: D,
      F: A
    } = v(C, x, E), M = l(n(l(u(D), D)), u(D)), _ = l(u(A), n(l(A, u(A))));
    return l(_, M);
  }
  function g(C, x, E) {
    for (var D = nt(C), A = 0, M = 0; M < x; M++) {
      if (E <= A)
        return D;
      for (var _ = M; N(D[_][A]); )
        if (_++, x === _ && (_ = M, A++, E === A))
          return D;
      [D[_], D[M]] = [D[M], D[_]];
      for (var O = D[M][A], T = 0; T < E; T++)
        D[M][T] = o(D[M][T], O);
      for (var I = 0; I < x; I++)
        if (I !== M) {
          O = D[I][A];
          for (var q = 0; q < E; q++)
            D[I][q] = c(D[I][q], l(-1, l(O, D[M][q])));
        }
      A++;
    }
    return D;
  }
  function v(C, x, E) {
    var D = g(C, x, E), A = C.map((_, O) => _.filter((T, I) => I < x && !N(p(D[I], D[I])))), M = D.filter((_, O) => !N(p(D[O], D[O])));
    return {
      C: A,
      F: M
    };
  }
  function N(C) {
    return s(c(C, h(1, 1)), c(0, h(1, 1)));
  }
  function b(C) {
    return a(c(C, h(1, 1)), c(l(C, 0), h(1, 1)));
  }
});
function G8(t) {
  var {
    addScalar: e,
    subtract: r,
    flatten: n,
    multiply: a,
    multiplyScalar: s,
    divideScalar: o,
    sqrt: p,
    abs: u,
    bignumber: f,
    diag: l,
    size: c,
    reshape: h,
    inv: d,
    qr: g,
    usolve: v,
    usolveAll: N,
    equal: b,
    complex: C,
    larger: x,
    smaller: E,
    matrixFromColumns: D,
    dot: A
  } = t;
  function M(Z, H, te, be) {
    var K = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, ce = _(Z, H, te, be, K);
    O(Z, H, te, be, K, ce);
    var {
      values: de,
      C: ue
    } = T(Z, H, te, be, K);
    if (K) {
      var ve = I(Z, H, ue, ce, de, te, be);
      return {
        values: de,
        eigenvectors: ve
      };
    }
    return {
      values: de
    };
  }
  function _(Z, H, te, be, K) {
    var ce = be === "BigNumber", de = be === "Complex", ue = ce ? f(0) : 0, ve = ce ? f(1) : de ? C(1) : 1, he = ce ? f(1) : 1, Ne = ce ? f(10) : 2, we = s(Ne, Ne), Se;
    K && (Se = Array(H).fill(ve));
    for (var V = !1; !V; ) {
      V = !0;
      for (var re = 0; re < H; re++) {
        for (var pe = ue, X = ue, ie = 0; ie < H; ie++)
          re !== ie && (pe = e(pe, u(Z[ie][re])), X = e(X, u(Z[re][ie])));
        if (!b(pe, 0) && !b(X, 0)) {
          for (var me = he, Ae = pe, Me = o(X, Ne), Q = s(X, Ne); E(Ae, Me); )
            Ae = s(Ae, we), me = s(me, Ne);
          for (; x(Ae, Q); )
            Ae = o(Ae, we), me = o(me, Ne);
          var ee = E(o(e(Ae, X), me), s(e(pe, X), 0.95));
          if (ee) {
            V = !1;
            for (var ye = o(1, me), Ee = 0; Ee < H; Ee++)
              re !== Ee && (Z[re][Ee] = s(Z[re][Ee], ye), Z[Ee][re] = s(Z[Ee][re], me));
            K && (Se[re] = s(Se[re], ye));
          }
        }
      }
    }
    return K ? l(Se) : null;
  }
  function O(Z, H, te, be, K, ce) {
    var de = be === "BigNumber", ue = be === "Complex", ve = de ? f(0) : ue ? C(0) : 0;
    de && (te = f(te));
    for (var he = 0; he < H - 2; he++) {
      for (var Ne = 0, we = ve, Se = he + 1; Se < H; Se++) {
        var V = Z[Se][he];
        E(u(we), u(V)) && (we = V, Ne = Se);
      }
      if (!E(u(we), te)) {
        if (Ne !== he + 1) {
          var re = Z[Ne];
          Z[Ne] = Z[he + 1], Z[he + 1] = re;
          for (var pe = 0; pe < H; pe++) {
            var X = Z[pe][Ne];
            Z[pe][Ne] = Z[pe][he + 1], Z[pe][he + 1] = X;
          }
          if (K) {
            var ie = ce[Ne];
            ce[Ne] = ce[he + 1], ce[he + 1] = ie;
          }
        }
        for (var me = he + 2; me < H; me++) {
          var Ae = o(Z[me][he], we);
          if (Ae !== 0) {
            for (var Me = 0; Me < H; Me++)
              Z[me][Me] = r(Z[me][Me], s(Ae, Z[he + 1][Me]));
            for (var Q = 0; Q < H; Q++)
              Z[Q][he + 1] = e(Z[Q][he + 1], s(Ae, Z[Q][me]));
            if (K)
              for (var ee = 0; ee < H; ee++)
                ce[me][ee] = r(ce[me][ee], s(Ae, ce[he + 1][ee]));
          }
        }
      }
    }
    return ce;
  }
  function T(Z, H, te, be, K) {
    var ce = be === "BigNumber", de = be === "Complex", ue = ce ? f(1) : de ? C(1) : 1;
    ce && (te = f(te));
    for (var ve = nt(Z), he = [], Ne = H, we = [], Se = K ? l(Array(H).fill(ue)) : void 0, V = K ? l(Array(Ne).fill(ue)) : void 0, re = 0; re <= 100; ) {
      re += 1;
      for (var pe = ve[Ne - 1][Ne - 1], X = 0; X < Ne; X++)
        ve[X][X] = r(ve[X][X], pe);
      var {
        Q: ie,
        R: me
      } = g(ve);
      ve = a(me, ie);
      for (var Ae = 0; Ae < Ne; Ae++)
        ve[Ae][Ae] = e(ve[Ae][Ae], pe);
      if (K && (V = a(V, ie)), Ne === 1 || E(u(ve[Ne - 1][Ne - 2]), te)) {
        re = 0, he.push(ve[Ne - 1][Ne - 1]), K && (we.unshift([[1]]), U(V, H), Se = a(Se, V), Ne > 1 && (V = l(Array(Ne - 1).fill(ue)))), Ne -= 1, ve.pop();
        for (var Me = 0; Me < Ne; Me++)
          ve[Me].pop();
      } else if (Ne === 2 || E(u(ve[Ne - 2][Ne - 3]), te)) {
        re = 0;
        var Q = q(ve[Ne - 2][Ne - 2], ve[Ne - 2][Ne - 1], ve[Ne - 1][Ne - 2], ve[Ne - 1][Ne - 1]);
        he.push(...Q), K && (we.unshift($(ve[Ne - 2][Ne - 2], ve[Ne - 2][Ne - 1], ve[Ne - 1][Ne - 2], ve[Ne - 1][Ne - 1], Q[0], Q[1], te, be)), U(V, H), Se = a(Se, V), Ne > 2 && (V = l(Array(Ne - 2).fill(ue)))), Ne -= 2, ve.pop(), ve.pop();
        for (var ee = 0; ee < Ne; ee++)
          ve[ee].pop(), ve[ee].pop();
      }
      if (Ne === 0)
        break;
    }
    if (he.sort((Ce, De) => +r(u(Ce), u(De))), re > 100) {
      var ye = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + he.join(", "));
      throw ye.values = he, ye.vectors = [], ye;
    }
    var Ee = K ? a(Se, k(we, H)) : void 0;
    return {
      values: he,
      C: Ee
    };
  }
  function I(Z, H, te, be, K, ce, de) {
    var ue = d(te), ve = a(ue, Z, te), he = de === "BigNumber", Ne = de === "Complex", we = he ? f(0) : Ne ? C(0) : 0, Se = he ? f(1) : Ne ? C(1) : 1, V = [], re = [];
    for (var pe of K) {
      var X = L(V, pe, b);
      X === -1 ? (V.push(pe), re.push(1)) : re[X] += 1;
    }
    for (var ie = [], me = V.length, Ae = Array(H).fill(we), Me = l(Array(H).fill(Se)), Q = function() {
      var Ee = V[ee], Ce = r(ve, a(Ee, Me)), De = N(Ce, Ae);
      for (De.shift(); De.length < re[ee]; ) {
        var Oe = R(Ce, H, De, ce, de);
        if (Oe === null)
          break;
        De.push(Oe);
      }
      var Be = a(d(be), te);
      De = De.map((Le) => a(Be, Le)), ie.push(...De.map((Le) => ({
        value: Ee,
        vector: n(Le)
      })));
    }, ee = 0; ee < me; ee++)
      Q();
    return ie;
  }
  function q(Z, H, te, be) {
    var K = e(Z, be), ce = r(s(Z, be), s(H, te)), de = s(K, 0.5), ue = s(p(r(s(K, K), s(4, ce))), 0.5);
    return [e(de, ue), r(de, ue)];
  }
  function $(Z, H, te, be, K, ce, de, ue) {
    var ve = ue === "BigNumber", he = ue === "Complex", Ne = ve ? f(0) : he ? C(0) : 0, we = ve ? f(1) : he ? C(1) : 1;
    if (E(u(te), de))
      return [[we, Ne], [Ne, we]];
    if (x(u(r(K, ce)), de))
      return [[r(K, be), r(ce, be)], [te, te]];
    var Se = r(Z, K), V = r(be, K);
    return E(u(H), de) && E(u(V), de) ? [[Se, we], [te, Ne]] : [[H, Ne], [V, we]];
  }
  function U(Z, H) {
    for (var te = 0; te < Z.length; te++)
      Z[te].push(...Array(H - Z[te].length).fill(0));
    for (var be = Z.length; be < H; be++)
      Z.push(Array(H).fill(0)), Z[be][be] = 1;
    return Z;
  }
  function k(Z, H) {
    for (var te = [], be = 0; be < H; be++)
      te[be] = Array(H).fill(0);
    var K = 0;
    for (var ce of Z) {
      for (var de = ce.length, ue = 0; ue < de; ue++)
        for (var ve = 0; ve < de; ve++)
          te[K + ue][K + ve] = ce[ue][ve];
      K += de;
    }
    return te;
  }
  function L(Z, H, te) {
    for (var be = 0; be < Z.length; be++)
      if (te(Z[be], H))
        return be;
    return -1;
  }
  function R(Z, H, te, be, K) {
    for (var ce = K === "BigNumber" ? f(1e3) : 1e3, de, ue = 0; ue < 5; ++ue) {
      de = G(H, te, K);
      try {
        de = v(Z, de);
      } catch {
        continue;
      }
      if (x(W(de), ce))
        break;
    }
    if (ue >= 5)
      return null;
    for (ue = 0; ; ) {
      var ve = v(Z, de);
      if (E(W(P(de, [ve])), be))
        break;
      if (++ue >= 10)
        return null;
      de = le(ve);
    }
    return de;
  }
  function G(Z, H, te) {
    var be = te === "BigNumber", K = te === "Complex", ce = Array(Z).fill(0).map((de) => 2 * Math.random() - 1);
    return be && (ce = ce.map((de) => f(de))), K && (ce = ce.map((de) => C(de))), ce = P(ce, H), le(ce, te);
  }
  function P(Z, H) {
    var te = c(Z);
    for (var be of H)
      be = h(be, te), Z = r(Z, a(o(A(be, Z), A(be, be)), be));
    return Z;
  }
  function W(Z) {
    return u(p(A(Z, Z)));
  }
  function le(Z, H) {
    var te = H === "BigNumber", be = H === "Complex", K = te ? f(1) : be ? C(1) : 1;
    return a(o(K, W(Z)), Z);
  }
  return M;
}
function H8(t) {
  var {
    config: e,
    addScalar: r,
    subtract: n,
    abs: a,
    atan: s,
    cos: o,
    sin: p,
    multiplyScalar: u,
    inv: f,
    bignumber: l,
    multiply: c,
    add: h
  } = t;
  function d(O, T) {
    var I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.relTol, q = arguments.length > 3 ? arguments[3] : void 0, $ = arguments.length > 4 ? arguments[4] : void 0;
    if (q === "number")
      return g(O, I, $);
    if (q === "BigNumber")
      return v(O, I, $);
    throw TypeError("Unsupported data type: " + q);
  }
  function g(O, T, I) {
    var q = O.length, $ = Math.abs(T / q), U, k;
    if (I) {
      k = new Array(q);
      for (var L = 0; L < q; L++)
        k[L] = Array(q).fill(0), k[L][L] = 1;
    }
    for (var R = A(O); Math.abs(R[1]) >= Math.abs($); ) {
      var G = R[0][0], P = R[0][1];
      U = N(O[G][G], O[P][P], O[G][P]), O = D(O, U, G, P), I && (k = C(k, U, G, P)), R = A(O);
    }
    for (var W = Array(q).fill(0), le = 0; le < q; le++)
      W[le] = O[le][le];
    return _(nt(W), k, I);
  }
  function v(O, T, I) {
    var q = O.length, $ = a(T / q), U, k;
    if (I) {
      k = new Array(q);
      for (var L = 0; L < q; L++)
        k[L] = Array(q).fill(0), k[L][L] = 1;
    }
    for (var R = M(O); a(R[1]) >= a($); ) {
      var G = R[0][0], P = R[0][1];
      U = b(O[G][G], O[P][P], O[G][P]), O = E(O, U, G, P), I && (k = x(k, U, G, P)), R = M(O);
    }
    for (var W = Array(q).fill(0), le = 0; le < q; le++)
      W[le] = O[le][le];
    return _(nt(W), k, I);
  }
  function N(O, T, I) {
    var q = T - O;
    return Math.abs(q) <= e.relTol ? Math.PI / 4 : 0.5 * Math.atan(2 * I / (T - O));
  }
  function b(O, T, I) {
    var q = n(T, O);
    return a(q) <= e.relTol ? l(-1).acos().div(4) : u(0.5, s(c(2, I, f(q))));
  }
  function C(O, T, I, q) {
    for (var $ = O.length, U = Math.cos(T), k = Math.sin(T), L = Array($).fill(0), R = Array($).fill(0), G = 0; G < $; G++)
      L[G] = U * O[G][I] - k * O[G][q], R[G] = k * O[G][I] + U * O[G][q];
    for (var P = 0; P < $; P++)
      O[P][I] = L[P], O[P][q] = R[P];
    return O;
  }
  function x(O, T, I, q) {
    for (var $ = O.length, U = o(T), k = p(T), L = Array($).fill(l(0)), R = Array($).fill(l(0)), G = 0; G < $; G++)
      L[G] = n(u(U, O[G][I]), u(k, O[G][q])), R[G] = r(u(k, O[G][I]), u(U, O[G][q]));
    for (var P = 0; P < $; P++)
      O[P][I] = L[P], O[P][q] = R[P];
    return O;
  }
  function E(O, T, I, q) {
    for (var $ = O.length, U = l(o(T)), k = l(p(T)), L = u(U, U), R = u(k, k), G = Array($).fill(l(0)), P = Array($).fill(l(0)), W = c(l(2), U, k, O[I][q]), le = r(n(u(L, O[I][I]), W), u(R, O[q][q])), Z = h(u(R, O[I][I]), W, u(L, O[q][q])), H = 0; H < $; H++)
      G[H] = n(u(U, O[I][H]), u(k, O[q][H])), P[H] = r(u(k, O[I][H]), u(U, O[q][H]));
    O[I][I] = le, O[q][q] = Z, O[I][q] = l(0), O[q][I] = l(0);
    for (var te = 0; te < $; te++)
      te !== I && te !== q && (O[I][te] = G[te], O[te][I] = G[te], O[q][te] = P[te], O[te][q] = P[te]);
    return O;
  }
  function D(O, T, I, q) {
    for (var $ = O.length, U = Math.cos(T), k = Math.sin(T), L = U * U, R = k * k, G = Array($).fill(0), P = Array($).fill(0), W = L * O[I][I] - 2 * U * k * O[I][q] + R * O[q][q], le = R * O[I][I] + 2 * U * k * O[I][q] + L * O[q][q], Z = 0; Z < $; Z++)
      G[Z] = U * O[I][Z] - k * O[q][Z], P[Z] = k * O[I][Z] + U * O[q][Z];
    O[I][I] = W, O[q][q] = le, O[I][q] = 0, O[q][I] = 0;
    for (var H = 0; H < $; H++)
      H !== I && H !== q && (O[I][H] = G[H], O[H][I] = G[H], O[q][H] = P[H], O[H][q] = P[H]);
    return O;
  }
  function A(O) {
    for (var T = O.length, I = 0, q = [0, 1], $ = 0; $ < T; $++)
      for (var U = $ + 1; U < T; U++)
        Math.abs(I) < Math.abs(O[$][U]) && (I = Math.abs(O[$][U]), q = [$, U]);
    return [q, I];
  }
  function M(O) {
    for (var T = O.length, I = 0, q = [0, 1], $ = 0; $ < T; $++)
      for (var U = $ + 1; U < T; U++)
        a(I) < a(O[$][U]) && (I = a(O[$][U]), q = [$, U]);
    return [q, I];
  }
  function _(O, T, I) {
    var q = O.length, $ = Array(q), U;
    if (I) {
      U = Array(q);
      for (var k = 0; k < q; k++)
        U[k] = Array(q);
    }
    for (var L = 0; L < q; L++) {
      for (var R = 0, G = O[0], P = 0; P < O.length; P++)
        a(O[P]) < a(G) && (R = P, G = O[R]);
      if ($[L] = O.splice(R, 1)[0], I)
        for (var W = 0; W < q; W++)
          U[L][W] = T[W][R], T[W].splice(R, 1);
    }
    if (!I) return {
      values: $
    };
    var le = U.map((Z, H) => ({
      value: $[H],
      vector: Z
    }));
    return {
      values: $,
      eigenvectors: le
    };
  }
  return d;
}
var Q8 = "eigs", V8 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"], Mf = /* @__PURE__ */ j(Q8, V8, (t) => {
  var {
    config: e,
    typed: r,
    matrix: n,
    addScalar: a,
    subtract: s,
    equal: o,
    abs: p,
    atan: u,
    cos: f,
    sin: l,
    multiplyScalar: c,
    divideScalar: h,
    inv: d,
    bignumber: g,
    multiply: v,
    add: N,
    larger: b,
    column: C,
    flatten: x,
    number: E,
    complex: D,
    sqrt: A,
    diag: M,
    size: _,
    reshape: O,
    qr: T,
    usolve: I,
    usolveAll: q,
    im: $,
    re: U,
    smaller: k,
    matrixFromColumns: L,
    dot: R
  } = t, G = H8({
    config: e,
    addScalar: a,
    subtract: s,
    column: C,
    flatten: x,
    equal: o,
    abs: p,
    atan: u,
    cos: f,
    sin: l,
    multiplyScalar: c,
    inv: d,
    bignumber: g,
    complex: D,
    multiply: v,
    add: N
  }), P = G8({
    config: e,
    addScalar: a,
    subtract: s,
    multiply: v,
    multiplyScalar: c,
    flatten: x,
    divideScalar: h,
    sqrt: A,
    abs: p,
    bignumber: g,
    diag: M,
    size: _,
    reshape: O,
    qr: T,
    inv: d,
    usolve: I,
    usolveAll: q,
    equal: o,
    complex: D,
    larger: b,
    smaller: k,
    matrixFromColumns: L,
    dot: R
  });
  return r("eigs", {
    // The conversion to matrix in the first two implementations,
    // just to convert back to an array right away in
    // computeValuesAndVectors, is unfortunate, and should perhaps be
    // streamlined. It is done because the Matrix object carries some
    // type information about its entries, and so constructing the matrix
    // is a roundabout way of doing type detection.
    Array: function(ce) {
      return W(n(ce));
    },
    "Array, number|BigNumber": function(ce, de) {
      return W(n(ce), {
        precision: de
      });
    },
    "Array, Object"(K, ce) {
      return W(n(K), ce);
    },
    Matrix: function(ce) {
      return W(ce, {
        matricize: !0
      });
    },
    "Matrix, number|BigNumber": function(ce, de) {
      return W(ce, {
        precision: de,
        matricize: !0
      });
    },
    "Matrix, Object": function(ce, de) {
      var ue = {
        matricize: !0
      };
      return hr(ue, de), W(ce, ue);
    }
  });
  function W(K) {
    var ce, de = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ue = "eigenvectors" in de ? de.eigenvectors : !0, ve = (ce = de.precision) !== null && ce !== void 0 ? ce : e.relTol, he = le(K, ve, ue);
    return de.matricize && (he.values = n(he.values), ue && (he.eigenvectors = he.eigenvectors.map((Ne) => {
      var {
        value: we,
        vector: Se
      } = Ne;
      return {
        value: we,
        vector: n(Se)
      };
    }))), ue && Object.defineProperty(he, "vectors", {
      enumerable: !1,
      // to make sure that the eigenvectors can still be
      // converted to string.
      get: () => {
        throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
      }
    }), he;
  }
  function le(K, ce, de) {
    var ue = K.toArray(), ve = K.size();
    if (ve.length !== 2 || ve[0] !== ve[1])
      throw new RangeError("Matrix must be square (size: ".concat(Dt(ve), ")"));
    var he = ve[0];
    if (H(ue, he, ce) && (te(ue, he), Z(ue, he, ce))) {
      var Ne = be(K, ue, he);
      return G(ue, he, ce, Ne, de);
    }
    var we = be(K, ue, he);
    return P(ue, he, ce, we, de);
  }
  function Z(K, ce, de) {
    for (var ue = 0; ue < ce; ue++)
      for (var ve = ue; ve < ce; ve++)
        if (b(g(p(s(K[ue][ve], K[ve][ue]))), de))
          return !1;
    return !0;
  }
  function H(K, ce, de) {
    for (var ue = 0; ue < ce; ue++)
      for (var ve = 0; ve < ce; ve++)
        if (b(g(p($(K[ue][ve]))), de))
          return !1;
    return !0;
  }
  function te(K, ce) {
    for (var de = 0; de < ce; de++)
      for (var ue = 0; ue < ce; ue++)
        K[de][ue] = U(K[de][ue]);
  }
  function be(K, ce, de) {
    var ue = K.datatype();
    if (ue === "number" || ue === "BigNumber" || ue === "Complex")
      return ue;
    for (var ve = !1, he = !1, Ne = !1, we = 0; we < de; we++)
      for (var Se = 0; Se < de; Se++) {
        var V = ce[we][Se];
        if (ht(V) || Fi(V))
          ve = !0;
        else if (ct(V))
          he = !0;
        else if (Mn(V))
          Ne = !0;
        else
          throw TypeError("Unsupported type in Matrix: " + Vt(V));
      }
    if (he && Ne && console.warn("Complex BigNumbers not supported, this operation will lose precission."), Ne) {
      for (var re = 0; re < de; re++)
        for (var pe = 0; pe < de; pe++)
          ce[re][pe] = D(ce[re][pe]);
      return "Complex";
    }
    if (he) {
      for (var X = 0; X < de; X++)
        for (var ie = 0; ie < de; ie++)
          ce[X][ie] = g(ce[X][ie]);
      return "BigNumber";
    }
    if (ve) {
      for (var me = 0; me < de; me++)
        for (var Ae = 0; Ae < de; Ae++)
          ce[me][Ae] = E(ce[me][Ae]);
      return "number";
    } else
      throw TypeError("Matrix contains unsupported types only.");
  }
}), bb = "expm", W8 = ["typed", "abs", "add", "identity", "inv", "multiply"], Of = /* @__PURE__ */ j(bb, W8, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    identity: a,
    inv: s,
    multiply: o
  } = t;
  return e(bb, {
    Matrix: function(c) {
      var h = c.size();
      if (h.length !== 2 || h[0] !== h[1])
        throw new RangeError("Matrix must be square (size: " + Dt(h) + ")");
      for (var d = h[0], g = 1e-15, v = p(c), N = u(v, g), b = N.q, C = N.j, x = o(c, Math.pow(2, -C)), E = a(d), D = a(d), A = 1, M = x, _ = -1, O = 1; O <= b; O++)
        O > 1 && (M = o(M, x), _ = -_), A = A * (b - O + 1) / ((2 * b - O + 1) * O), E = n(E, o(A, M)), D = n(D, o(A * _, M));
      for (var T = o(s(D), E), I = 0; I < C; I++)
        T = o(T, T);
      return oi(c) ? c.createSparseMatrix(T) : T;
    }
  });
  function p(l) {
    for (var c = l.size()[0], h = 0, d = 0; d < c; d++) {
      for (var g = 0, v = 0; v < c; v++)
        g += r(l.get([d, v]));
      h = Math.max(g, h);
    }
    return h;
  }
  function u(l, c) {
    for (var h = 30, d = 0; d < h; d++)
      for (var g = 0; g <= d; g++) {
        var v = d - g;
        if (f(l, g, v) < c)
          return {
            q: g,
            j: v
          };
      }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function f(l, c, h) {
    for (var d = 1, g = 2; g <= c; g++)
      d *= g;
    for (var v = d, N = c + 1; N <= 2 * c; N++)
      v *= N;
    var b = v * (2 * c + 1);
    return 8 * Math.pow(l / Math.pow(2, h), 2 * c) * d * d / (v * b);
  }
}), wb = "sqrtm", j8 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"], Ff = /* @__PURE__ */ j(wb, j8, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    multiply: a,
    map: s,
    sqrt: o,
    subtract: p,
    inv: u,
    size: f,
    max: l,
    identity: c
  } = t, h = 1e3, d = 1e-6;
  function g(v) {
    var N, b = 0, C = v, x = c(f(v));
    do {
      var E = C;
      if (C = a(0.5, n(E, u(x))), x = a(0.5, n(x, u(E))), N = l(r(p(C, E))), N > d && ++b > h)
        throw new Error("computing square root of matrix: iterative method could not converge");
    } while (N > d);
    return C;
  }
  return e(wb, {
    "Array | Matrix": function(N) {
      var b = tt(N) ? N.size() : gt(N);
      switch (b.length) {
        case 1:
          if (b[0] === 1)
            return s(N, o);
          throw new RangeError("Matrix must be square (size: " + Dt(b) + ")");
        case 2: {
          var C = b[0], x = b[1];
          if (C === x)
            return g(N);
          throw new RangeError("Matrix must be square (size: " + Dt(b) + ")");
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + Dt(b) + ")");
      }
    }
  });
}), Nb = "sylvester", Z8 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"], qf = /* @__PURE__ */ j(Nb, Z8, (t) => {
  var {
    typed: e,
    schur: r,
    matrixFromColumns: n,
    matrix: a,
    multiply: s,
    range: o,
    concat: p,
    transpose: u,
    index: f,
    subset: l,
    add: c,
    subtract: h,
    identity: d,
    lusolve: g,
    abs: v
  } = t;
  return e(Nb, {
    "Matrix, Matrix, Matrix": N,
    "Array, Matrix, Matrix": function(C, x, E) {
      return N(a(C), x, E);
    },
    "Array, Array, Matrix": function(C, x, E) {
      return N(a(C), a(x), E);
    },
    "Array, Matrix, Array": function(C, x, E) {
      return N(a(C), x, a(E));
    },
    "Matrix, Array, Matrix": function(C, x, E) {
      return N(C, a(x), E);
    },
    "Matrix, Array, Array": function(C, x, E) {
      return N(C, a(x), a(E));
    },
    "Matrix, Matrix, Array": function(C, x, E) {
      return N(C, x, a(E));
    },
    "Array, Array, Array": function(C, x, E) {
      return N(a(C), a(x), a(E)).toArray();
    }
  });
  function N(b, C, x) {
    for (var E = C.size()[0], D = b.size()[0], A = r(b), M = A.T, _ = A.U, O = r(s(-1, C)), T = O.T, I = O.U, q = s(s(u(_), x), I), $ = o(0, D), U = [], k = (Ne, we) => p(Ne, we, 1), L = (Ne, we) => p(Ne, we, 0), R = 0; R < E; R++)
      if (R < E - 1 && v(l(T, f(R + 1, R))) > 1e-5) {
        for (var G = L(l(q, f($, R)), l(q, f($, R + 1))), P = 0; P < R; P++)
          G = c(G, L(s(U[P], l(T, f(P, R))), s(U[P], l(T, f(P, R + 1)))));
        var W = s(d(D), s(-1, l(T, f(R, R)))), le = s(d(D), s(-1, l(T, f(R + 1, R)))), Z = s(d(D), s(-1, l(T, f(R, R + 1)))), H = s(d(D), s(-1, l(T, f(R + 1, R + 1)))), te = L(k(c(M, W), le), k(Z, c(M, H))), be = g(te, G);
        U[R] = be.subset(f(o(0, D), 0)), U[R + 1] = be.subset(f(o(D, 2 * D), 0)), R++;
      } else {
        for (var K = l(q, f($, R)), ce = 0; ce < R; ce++)
          K = c(K, s(U[ce], l(T, f(ce, R))));
        var de = l(T, f(R, R)), ue = h(M, s(de, d(D)));
        U[R] = g(ue, K);
      }
    var ve = a(n(...U)), he = s(_, s(ve, u(I)));
    return he;
  }
}), Db = "schur", J8 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"], If = /* @__PURE__ */ j(Db, J8, (t) => {
  var {
    typed: e,
    matrix: r,
    identity: n,
    multiply: a,
    qr: s,
    norm: o,
    subtract: p
  } = t;
  return e(Db, {
    Array: function(l) {
      var c = u(r(l));
      return {
        U: c.U.valueOf(),
        T: c.T.valueOf()
      };
    },
    Matrix: function(l) {
      return u(l);
    }
  });
  function u(f) {
    var l = f.size()[0], c = f, h = n(l), d = 0, g;
    do {
      g = c;
      var v = s(c), N = v.Q, b = v.R;
      if (c = a(b, N), h = a(h, N), d++ > 100)
        break;
    } while (o(p(c, g)) > 1e-4);
    return {
      U: h,
      T: c
    };
  }
}), Ab = "lyap", Y8 = ["typed", "matrix", "sylvester", "multiply", "transpose"], Bf = /* @__PURE__ */ j(Ab, Y8, (t) => {
  var {
    typed: e,
    matrix: r,
    sylvester: n,
    multiply: a,
    transpose: s
  } = t;
  return e(Ab, {
    "Matrix, Matrix": function(p, u) {
      return n(p, s(p), a(-1, u));
    },
    "Array, Matrix": function(p, u) {
      return n(r(p), s(r(p)), a(-1, u));
    },
    "Matrix, Array": function(p, u) {
      return n(p, s(r(p)), r(a(-1, u)));
    },
    "Array, Array": function(p, u) {
      return n(r(p), s(r(p)), r(a(-1, u))).toArray();
    }
  });
}), X8 = "divide", K8 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"], Rf = /* @__PURE__ */ j(X8, K8, (t) => {
  var {
    typed: e,
    matrix: r,
    multiply: n,
    equalScalar: a,
    divideScalar: s,
    inv: o
  } = t, p = Pr({
    typed: e,
    equalScalar: a
  }), u = zn({
    typed: e
  });
  return e("divide", d2({
    // we extend the signatures of divideScalar with signatures dealing with matrices
    "Array | Matrix, Array | Matrix": function(l, c) {
      return n(l, o(c));
    },
    "DenseMatrix, any": function(l, c) {
      return u(l, c, s, !1);
    },
    "SparseMatrix, any": function(l, c) {
      return p(l, c, s, !1);
    },
    "Array, any": function(l, c) {
      return u(r(l), c, s, !1).valueOf();
    },
    "any, Array | Matrix": function(l, c) {
      return n(l, o(c));
    }
  }, s.signatures));
}), Eb = "distance", e7 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"], Lf = /* @__PURE__ */ j(Eb, e7, (t) => {
  var {
    typed: e,
    addScalar: r,
    subtractScalar: n,
    multiplyScalar: a,
    divideScalar: s,
    deepEqual: o,
    sqrt: p,
    abs: u
  } = t;
  return e(Eb, {
    "Array, Array, Array": function(D, A, M) {
      if (D.length === 2 && A.length === 2 && M.length === 2) {
        if (!l(D))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        if (!l(A))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        if (!l(M))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        if (o(A, M))
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        var _ = n(M[1], A[1]), O = n(A[0], M[0]), T = n(a(M[0], A[1]), a(A[0], M[1]));
        return N(D[0], D[1], _, O, T);
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    "Object, Object, Object": function(D, A, M) {
      if (Object.keys(D).length === 2 && Object.keys(A).length === 2 && Object.keys(M).length === 2) {
        if (!l(D))
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        if (!l(A))
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        if (!l(M))
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        if (o(g(A), g(M)))
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        if ("pointX" in D && "pointY" in D && "lineOnePtX" in A && "lineOnePtY" in A && "lineTwoPtX" in M && "lineTwoPtY" in M) {
          var _ = n(M.lineTwoPtY, A.lineOnePtY), O = n(A.lineOnePtX, M.lineTwoPtX), T = n(a(M.lineTwoPtX, A.lineOnePtY), a(A.lineOnePtX, M.lineTwoPtY));
          return N(D.pointX, D.pointY, _, O, T);
        } else
          throw new TypeError("Key names do not match");
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    "Array, Array": function(D, A) {
      if (D.length === 2 && A.length === 3) {
        if (!l(D))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        if (!c(A))
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        return N(D[0], D[1], A[0], A[1], A[2]);
      } else if (D.length === 3 && A.length === 6) {
        if (!c(D))
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        if (!d(A))
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        return b(D[0], D[1], D[2], A[0], A[1], A[2], A[3], A[4], A[5]);
      } else if (D.length === A.length && D.length > 0) {
        if (!h(D))
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        if (!h(A))
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        return C(D, A);
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    "Object, Object": function(D, A) {
      if (Object.keys(D).length === 2 && Object.keys(A).length === 3) {
        if (!l(D))
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        if (!c(A))
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        if ("pointX" in D && "pointY" in D && "xCoeffLine" in A && "yCoeffLine" in A && "constant" in A)
          return N(D.pointX, D.pointY, A.xCoeffLine, A.yCoeffLine, A.constant);
        throw new TypeError("Key names do not match");
      } else if (Object.keys(D).length === 3 && Object.keys(A).length === 6) {
        if (!c(D))
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        if (!d(A))
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        if ("pointX" in D && "pointY" in D && "x0" in A && "y0" in A && "z0" in A && "a" in A && "b" in A && "c" in A)
          return b(D.pointX, D.pointY, D.pointZ, A.x0, A.y0, A.z0, A.a, A.b, A.c);
        throw new TypeError("Key names do not match");
      } else if (Object.keys(D).length === 2 && Object.keys(A).length === 2) {
        if (!l(D))
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        if (!l(A))
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        if ("pointOneX" in D && "pointOneY" in D && "pointTwoX" in A && "pointTwoY" in A)
          return C([D.pointOneX, D.pointOneY], [A.pointTwoX, A.pointTwoY]);
        throw new TypeError("Key names do not match");
      } else if (Object.keys(D).length === 3 && Object.keys(A).length === 3) {
        if (!c(D))
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        if (!c(A))
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        if ("pointOneX" in D && "pointOneY" in D && "pointOneZ" in D && "pointTwoX" in A && "pointTwoY" in A && "pointTwoZ" in A)
          return C([D.pointOneX, D.pointOneY, D.pointOneZ], [A.pointTwoX, A.pointTwoY, A.pointTwoZ]);
        throw new TypeError("Key names do not match");
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    Array: function(D) {
      if (!v(D))
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      return x(D);
    }
  });
  function f(E) {
    return typeof E == "number" || ct(E);
  }
  function l(E) {
    return E.constructor !== Array && (E = g(E)), f(E[0]) && f(E[1]);
  }
  function c(E) {
    return E.constructor !== Array && (E = g(E)), f(E[0]) && f(E[1]) && f(E[2]);
  }
  function h(E) {
    return Array.isArray(E) || (E = g(E)), E.every(f);
  }
  function d(E) {
    return E.constructor !== Array && (E = g(E)), f(E[0]) && f(E[1]) && f(E[2]) && f(E[3]) && f(E[4]) && f(E[5]);
  }
  function g(E) {
    for (var D = Object.keys(E), A = [], M = 0; M < D.length; M++)
      A.push(E[D[M]]);
    return A;
  }
  function v(E) {
    if (E[0].length === 2 && f(E[0][0]) && f(E[0][1])) {
      if (E.some((D) => D.length !== 2 || !f(D[0]) || !f(D[1])))
        return !1;
    } else if (E[0].length === 3 && f(E[0][0]) && f(E[0][1]) && f(E[0][2])) {
      if (E.some((D) => D.length !== 3 || !f(D[0]) || !f(D[1]) || !f(D[2])))
        return !1;
    } else
      return !1;
    return !0;
  }
  function N(E, D, A, M, _) {
    var O = u(r(r(a(A, E), a(M, D)), _)), T = p(r(a(A, A), a(M, M)));
    return s(O, T);
  }
  function b(E, D, A, M, _, O, T, I, q) {
    var $ = [n(a(n(_, D), q), a(n(O, A), I)), n(a(n(O, A), T), a(n(M, E), q)), n(a(n(M, E), I), a(n(_, D), T))];
    $ = p(r(r(a($[0], $[0]), a($[1], $[1])), a($[2], $[2])));
    var U = p(r(r(a(T, T), a(I, I)), a(q, q)));
    return s($, U);
  }
  function C(E, D) {
    for (var A = E.length, M = 0, _ = 0, O = 0; O < A; O++)
      _ = n(E[O], D[O]), M = r(a(_, _), M);
    return p(M);
  }
  function x(E) {
    for (var D = [], A = [], M = [], _ = 0; _ < E.length - 1; _++)
      for (var O = _ + 1; O < E.length; O++)
        E[0].length === 2 ? (A = [E[_][0], E[_][1]], M = [E[O][0], E[O][1]]) : E[0].length === 3 && (A = [E[_][0], E[_][1], E[_][2]], M = [E[O][0], E[O][1], E[O][2]]), D.push(C(A, M));
    return D;
  }
}), t7 = "intersect", r7 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"], Pf = /* @__PURE__ */ j(t7, r7, (t) => {
  var {
    typed: e,
    config: r,
    abs: n,
    add: a,
    addScalar: s,
    matrix: o,
    multiply: p,
    multiplyScalar: u,
    divideScalar: f,
    subtract: l,
    smaller: c,
    equalScalar: h,
    flatten: d,
    isZero: g,
    isNumeric: v
  } = t;
  return e("intersect", {
    "Array, Array, Array": N,
    "Array, Array, Array, Array": b,
    "Matrix, Matrix, Matrix": function(I, q, $) {
      var U = N(I.valueOf(), q.valueOf(), $.valueOf());
      return U === null ? null : o(U);
    },
    "Matrix, Matrix, Matrix, Matrix": function(I, q, $, U) {
      var k = b(I.valueOf(), q.valueOf(), $.valueOf(), U.valueOf());
      return k === null ? null : o(k);
    }
  });
  function N(T, I, q) {
    if (T = C(T), I = C(I), q = C(q), !E(T))
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    if (!E(I))
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    if (!D(q))
      throw new TypeError("Array with 4 numbers expected as third argument");
    return O(T[0], T[1], T[2], I[0], I[1], I[2], q[0], q[1], q[2], q[3]);
  }
  function b(T, I, q, $) {
    if (T = C(T), I = C(I), q = C(q), $ = C($), T.length === 2) {
      if (!x(T))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      if (!x(I))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      if (!x(q))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      if (!x($))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      return A(T, I, q, $);
    } else if (T.length === 3) {
      if (!E(T))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      if (!E(I))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      if (!E(q))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      if (!E($))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      return _(T[0], T[1], T[2], I[0], I[1], I[2], q[0], q[1], q[2], $[0], $[1], $[2]);
    } else
      throw new TypeError("Arrays with two or thee dimensional points expected");
  }
  function C(T) {
    return T.length === 1 ? T[0] : T.length > 1 && Array.isArray(T[0]) && T.every((I) => Array.isArray(I) && I.length === 1) ? d(T) : T;
  }
  function x(T) {
    return T.length === 2 && v(T[0]) && v(T[1]);
  }
  function E(T) {
    return T.length === 3 && v(T[0]) && v(T[1]) && v(T[2]);
  }
  function D(T) {
    return T.length === 4 && v(T[0]) && v(T[1]) && v(T[2]) && v(T[3]);
  }
  function A(T, I, q, $) {
    var U = T, k = q, L = l(U, I), R = l(k, $), G = l(u(L[0], R[1]), u(R[0], L[1]));
    if (g(G) || c(n(G), r.relTol))
      return null;
    var P = u(R[0], U[1]), W = u(R[1], U[0]), le = u(R[0], k[1]), Z = u(R[1], k[0]), H = f(s(l(l(P, W), le), Z), G);
    return a(p(L, H), U);
  }
  function M(T, I, q, $, U, k, L, R, G, P, W, le) {
    var Z = u(l(T, I), l(q, $)), H = u(l(U, k), l(L, R)), te = u(l(G, P), l(W, le));
    return s(s(Z, H), te);
  }
  function _(T, I, q, $, U, k, L, R, G, P, W, le) {
    var Z = M(T, L, P, L, I, R, W, R, q, G, le, G), H = M(P, L, $, T, W, R, U, I, le, G, k, q), te = M(T, L, $, T, I, R, U, I, q, G, k, q), be = M(P, L, P, L, W, R, W, R, le, G, le, G), K = M($, T, $, T, U, I, U, I, k, q, k, q), ce = l(u(Z, H), u(te, be)), de = l(u(K, be), u(H, H));
    if (g(de)) return null;
    var ue = f(ce, de), ve = f(s(Z, u(ue, H)), be), he = s(T, u(ue, l($, T))), Ne = s(I, u(ue, l(U, I))), we = s(q, u(ue, l(k, q))), Se = s(L, u(ve, l(P, L))), V = s(R, u(ve, l(W, R))), re = s(G, u(ve, l(le, G)));
    return h(he, Se) && h(Ne, V) && h(we, re) ? [he, Ne, we] : null;
  }
  function O(T, I, q, $, U, k, L, R, G, P) {
    var W = u(T, L), le = u($, L), Z = u(I, R), H = u(U, R), te = u(q, G), be = u(k, G), K = l(l(l(P, W), Z), te), ce = l(l(l(s(s(le, H), be), W), Z), te), de = f(K, ce), ue = s(T, u(de, l($, T))), ve = s(I, u(de, l(U, I))), he = s(q, u(de, l(k, q)));
    return [ue, ve, he];
  }
}), Sb = "sum", n7 = ["typed", "config", "add", "numeric"], ao = /* @__PURE__ */ j(Sb, n7, (t) => {
  var {
    typed: e,
    config: r,
    add: n,
    numeric: a
  } = t;
  return e(Sb, {
    // sum([a, b, c, d, ...])
    "Array | Matrix": s,
    // sum([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": o,
    // sum(a, b, c, d, ...)
    "...": function(u) {
      if (Za(u))
        throw new TypeError("Scalar values expected in function sum");
      return s(u);
    }
  });
  function s(p) {
    var u;
    return hi(p, function(f) {
      try {
        u = u === void 0 ? f : n(u, f);
      } catch (l) {
        throw tn(l, "sum", f);
      }
    }), u === void 0 && (u = a(0, r.number)), typeof u == "string" && (u = a(u, Ii(u, r))), u;
  }
  function o(p, u) {
    try {
      var f = zu(p, u, n);
      return f;
    } catch (l) {
      throw tn(l, "sum");
    }
  }
}), Zo = "cumsum", i7 = ["typed", "add", "unaryPlus"], so = /* @__PURE__ */ j(Zo, i7, (t) => {
  var {
    typed: e,
    add: r,
    unaryPlus: n
  } = t;
  return e(Zo, {
    // sum([a, b, c, d, ...])
    Array: a,
    Matrix: function(f) {
      return f.create(a(f.valueOf()));
    },
    // sum([a, b, c, d, ...], dim)
    "Array, number | BigNumber": o,
    "Matrix, number | BigNumber": function(f, l) {
      return f.create(o(f.valueOf(), l));
    },
    // cumsum(a, b, c, d, ...)
    "...": function(f) {
      if (Za(f))
        throw new TypeError("All values expected to be scalar in function cumsum");
      return a(f);
    }
  });
  function a(u) {
    try {
      return s(u);
    } catch (f) {
      throw tn(f, Zo);
    }
  }
  function s(u) {
    if (u.length === 0)
      return [];
    for (var f = [n(u[0])], l = 1; l < u.length; ++l)
      f.push(r(f[l - 1], u[l]));
    return f;
  }
  function o(u, f) {
    var l = gt(u);
    if (f < 0 || f >= l.length)
      throw new yn(f, l.length);
    try {
      return p(u, f);
    } catch (c) {
      throw tn(c, Zo);
    }
  }
  function p(u, f) {
    var l, c, h;
    if (f <= 0) {
      var d = u[0][0];
      if (Array.isArray(d)) {
        for (h = Y2(u), c = [], l = 0; l < h.length; l++)
          c[l] = p(h[l], f - 1);
        return c;
      } else
        return s(u);
    } else {
      for (c = [], l = 0; l < u.length; l++)
        c[l] = p(u[l], f - 1);
      return c;
    }
  }
}), Cb = "mean", a7 = ["typed", "add", "divide"], oo = /* @__PURE__ */ j(Cb, a7, (t) => {
  var {
    typed: e,
    add: r,
    divide: n
  } = t;
  return e(Cb, {
    // mean([a, b, c, d, ...])
    "Array | Matrix": s,
    // mean([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": a,
    // mean(a, b, c, d, ...)
    "...": function(p) {
      if (Za(p))
        throw new TypeError("Scalar values expected in function mean");
      return s(p);
    }
  });
  function a(o, p) {
    try {
      var u = zu(o, p, r), f = Array.isArray(o) ? gt(o) : o.size();
      return n(u, f[p]);
    } catch (l) {
      throw tn(l, "mean");
    }
  }
  function s(o) {
    var p, u = 0;
    if (hi(o, function(f) {
      try {
        p = p === void 0 ? f : r(p, f), u++;
      } catch (l) {
        throw tn(l, "mean", f);
      }
    }), u === 0)
      throw new Error("Cannot calculate the mean of an empty array");
    return n(p, u);
  }
}), Tb = "median", s7 = ["typed", "add", "divide", "compare", "partitionSelect"], kf = /* @__PURE__ */ j(Tb, s7, (t) => {
  var {
    typed: e,
    add: r,
    divide: n,
    compare: a,
    partitionSelect: s
  } = t;
  function o(f) {
    try {
      f = Lt(f.valueOf());
      var l = f.length;
      if (l === 0)
        throw new Error("Cannot calculate median of an empty array");
      if (l % 2 === 0) {
        for (var c = l / 2 - 1, h = s(f, c + 1), d = f[c], g = 0; g < c; ++g)
          a(f[g], d) > 0 && (d = f[g]);
        return u(d, h);
      } else {
        var v = s(f, (l - 1) / 2);
        return p(v);
      }
    } catch (N) {
      throw tn(N, "median");
    }
  }
  var p = e({
    "number | BigNumber | Complex | Unit": function(l) {
      return l;
    }
  }), u = e({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function(l, c) {
      return n(r(l, c), 2);
    }
  });
  return e(Tb, {
    // median([a, b, c, d, ...])
    "Array | Matrix": o,
    // median([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(l, c) {
      throw new Error("median(A, dim) is not yet supported");
    },
    // median(a, b, c, d, ...)
    "...": function(l) {
      if (Za(l))
        throw new TypeError("Scalar values expected in function median");
      return o(l);
    }
  });
}), _b = "mad", o7 = ["typed", "abs", "map", "median", "subtract"], $f = /* @__PURE__ */ j(_b, o7, (t) => {
  var {
    typed: e,
    abs: r,
    map: n,
    median: a,
    subtract: s
  } = t;
  return e(_b, {
    // mad([a, b, c, d, ...])
    "Array | Matrix": o,
    // mad(a, b, c, d, ...)
    "...": function(u) {
      return o(u);
    }
  });
  function o(p) {
    if (p = Lt(p.valueOf()), p.length === 0)
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    try {
      var u = a(p);
      return a(n(p, function(f) {
        return r(s(f, u));
      }));
    } catch (f) {
      throw f instanceof TypeError && f.message.includes("median") ? new TypeError(f.message.replace("median", "mad")) : tn(f, "mad");
    }
  }
}), km = "unbiased", Mb = "variance", u7 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"], uo = /* @__PURE__ */ j(Mb, u7, (t) => {
  var {
    typed: e,
    add: r,
    subtract: n,
    multiply: a,
    divide: s,
    apply: o,
    isNaN: p
  } = t;
  return e(Mb, {
    // variance([a, b, c, d, ...])
    "Array | Matrix": function(c) {
      return u(c, km);
    },
    // variance([a, b, c, d, ...], normalization)
    "Array | Matrix, string": u,
    // variance([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": function(c, h) {
      return f(c, h, km);
    },
    // variance([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": f,
    // variance(a, b, c, d, ...)
    "...": function(c) {
      return u(c, km);
    }
  });
  function u(l, c) {
    var h, d = 0;
    if (l.length === 0)
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    if (hi(l, function(N) {
      try {
        h = h === void 0 ? N : r(h, N), d++;
      } catch (b) {
        throw tn(b, "variance", N);
      }
    }), d === 0) throw new Error("Cannot calculate variance of an empty array");
    var g = s(h, d);
    if (h = void 0, hi(l, function(N) {
      var b = n(N, g);
      h = h === void 0 ? a(b, b) : r(h, a(b, b));
    }), p(h))
      return h;
    switch (c) {
      case "uncorrected":
        return s(h, d);
      case "biased":
        return s(h, d + 1);
      case "unbiased": {
        var v = ct(h) ? h.mul(0) : 0;
        return d === 1 ? v : s(h, d - 1);
      }
      default:
        throw new Error('Unknown normalization "' + c + '". Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function f(l, c, h) {
    try {
      if (l.length === 0)
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      return o(l, c, (d) => u(d, h));
    } catch (d) {
      throw tn(d, "variance");
    }
  }
}), Ob = "quantileSeq", l7 = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"], lo = /* @__PURE__ */ j(Ob, l7, (t) => {
  var {
    typed: e,
    bignumber: r,
    add: n,
    subtract: a,
    divide: s,
    multiply: o,
    partitionSelect: p,
    compare: u,
    isInteger: f,
    smaller: l,
    smallerEq: c,
    larger: h
  } = t, d = Ka({
    typed: e,
    isInteger: f
  });
  return e(Ob, {
    "Array | Matrix, number | BigNumber": (C, x) => v(C, x, !1),
    "Array | Matrix, number | BigNumber, number": (C, x, E) => g(C, x, !1, E, v),
    "Array | Matrix, number | BigNumber, boolean": v,
    "Array | Matrix, number | BigNumber, boolean, number": (C, x, E, D) => g(C, x, E, D, v),
    "Array | Matrix, Array | Matrix": (C, x) => N(C, x, !1),
    "Array | Matrix, Array | Matrix, number": (C, x, E) => g(C, x, !1, E, N),
    "Array | Matrix, Array | Matrix, boolean": N,
    "Array | Matrix, Array | Matrix, boolean, number": (C, x, E, D) => g(C, x, E, D, N)
  });
  function g(C, x, E, D, A) {
    return d(C, D, (M) => A(M, x, E));
  }
  function v(C, x, E) {
    var D, A = C.valueOf();
    if (l(x, 0))
      throw new Error("N/prob must be non-negative");
    if (c(x, 1))
      return ht(x) ? b(A, x, E) : r(b(A, x, E));
    if (h(x, 1)) {
      if (!f(x))
        throw new Error("N must be a positive integer");
      if (h(x, 4294967295))
        throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
      var M = n(x, 1);
      D = [];
      for (var _ = 0; l(_, x); _++) {
        var O = s(_ + 1, M);
        D.push(b(A, O, E));
      }
      return ht(x) ? D : r(D);
    }
  }
  function N(C, x, E) {
    for (var D = C.valueOf(), A = x.valueOf(), M = [], _ = 0; _ < A.length; ++_)
      M.push(b(D, A[_], E));
    return M;
  }
  function b(C, x, E) {
    var D = Lt(C), A = D.length;
    if (A === 0)
      throw new Error("Cannot calculate quantile of an empty sequence");
    var M = ht(x) ? x * (A - 1) : x.times(A - 1), _ = ht(x) ? Math.floor(M) : M.floor().toNumber(), O = ht(x) ? M % 1 : M.minus(_);
    if (f(M))
      return E ? D[M] : p(D, ht(x) ? M : M.valueOf());
    var T, I;
    if (E)
      T = D[_], I = D[_ + 1];
    else {
      I = p(D, _ + 1), T = D[_];
      for (var q = 0; q < _; ++q)
        u(D[q], T) > 0 && (T = D[q]);
    }
    return n(o(T, a(1, O)), o(I, O));
  }
}), Fb = "std", c7 = ["typed", "map", "sqrt", "variance"], co = /* @__PURE__ */ j(Fb, c7, (t) => {
  var {
    typed: e,
    map: r,
    sqrt: n,
    variance: a
  } = t;
  return e(Fb, {
    // std([a, b, c, d, ...])
    "Array | Matrix": s,
    // std([a, b, c, d, ...], normalization)
    "Array | Matrix, string": s,
    // std([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": s,
    // std([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": s,
    // std(a, b, c, d, ...)
    "...": function(p) {
      return s(p);
    }
  });
  function s(o, p) {
    if (o.length === 0)
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    try {
      var u = a.apply(null, arguments);
      return cn(u) ? r(u, n) : n(u);
    } catch (f) {
      throw f instanceof TypeError && f.message.includes(" variance") ? new TypeError(f.message.replace(" variance", " std")) : f;
    }
  }
}), qb = "corr", f7 = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"], zf = /* @__PURE__ */ j(qb, f7, (t) => {
  var {
    typed: e,
    matrix: r,
    sqrt: n,
    sum: a,
    add: s,
    subtract: o,
    multiply: p,
    pow: u,
    divide: f
  } = t;
  return e(qb, {
    "Array, Array": function(d, g) {
      return l(d, g);
    },
    "Matrix, Matrix": function(d, g) {
      var v = l(d.toArray(), g.toArray());
      return Array.isArray(v) ? r(v) : v;
    }
  });
  function l(h, d) {
    var g = [];
    if (Array.isArray(h[0]) && Array.isArray(d[0])) {
      if (h.length !== d.length)
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
      for (var v = 0; v < h.length; v++) {
        if (h[v].length !== d[v].length)
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
        g.push(c(h[v], d[v]));
      }
      return g;
    } else {
      if (h.length !== d.length)
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
      return c(h, d);
    }
  }
  function c(h, d) {
    var g = h.length, v = a(h), N = a(d), b = h.reduce((A, M, _) => s(A, p(M, d[_])), 0), C = a(h.map((A) => u(A, 2))), x = a(d.map((A) => u(A, 2))), E = o(p(g, b), p(v, N)), D = n(p(o(p(g, C), u(v, 2)), o(p(g, x), u(N, 2))));
    return f(E, D);
  }
}), Ib = "combinations", p7 = ["typed"], Uf = /* @__PURE__ */ j(Ib, p7, (t) => {
  var {
    typed: e
  } = t;
  return e(Ib, {
    "number, number": bw,
    "BigNumber, BigNumber": function(n, a) {
      var s = n.constructor, o, p, u = n.minus(a), f = new s(1);
      if (!Bb(n) || !Bb(a))
        throw new TypeError("Positive integer value expected in function combinations");
      if (a.gt(n))
        throw new TypeError("k must be less than n in function combinations");
      if (o = f, a.lt(u))
        for (p = f; p.lte(u); p = p.plus(f))
          o = o.times(a.plus(p)).dividedBy(p);
      else
        for (p = f; p.lte(a); p = p.plus(f))
          o = o.times(u.plus(p)).dividedBy(p);
      return o;
    }
    // TODO: implement support for collection in combinations
  });
});
function Bb(t) {
  return t.isInteger() && t.gte(0);
}
var Rb = "combinationsWithRep", h7 = ["typed"], Gf = /* @__PURE__ */ j(Rb, h7, (t) => {
  var {
    typed: e
  } = t;
  return e(Rb, {
    "number, number": function(n, a) {
      if (!Xe(n) || n < 0)
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      if (!Xe(a) || a < 0)
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      if (n < 1)
        throw new TypeError("k must be less than or equal to n + k - 1");
      if (a < n - 1) {
        var s = li(n, n + a - 1);
        return s / li(1, a);
      }
      var o = li(a + 1, n + a - 1);
      return o / li(1, n - 1);
    },
    "BigNumber, BigNumber": function(n, a) {
      var s = n.constructor, o, p, u = new s(1), f = n.minus(u);
      if (!Lb(n) || !Lb(a))
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      if (n.lt(u))
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      if (o = u, a.lt(f))
        for (p = u; p.lte(f); p = p.plus(u))
          o = o.times(a.plus(p)).dividedBy(p);
      else
        for (p = u; p.lte(a); p = p.plus(u))
          o = o.times(f.plus(p)).dividedBy(p);
      return o;
    }
  });
});
function Lb(t) {
  return t.isInteger() && t.gte(0);
}
var Pb = "gamma", m7 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"], Hf = /* @__PURE__ */ j(Pb, m7, (t) => {
  var {
    typed: e,
    config: r,
    multiplyScalar: n,
    pow: a,
    BigNumber: s,
    Complex: o
  } = t;
  function p(f) {
    if (f.im === 0)
      return uu(f.re);
    if (f.re < 0.5) {
      var l = new o(1 - f.re, -f.im), c = new o(Math.PI * f.re, Math.PI * f.im);
      return new o(Math.PI).div(c.sin()).div(p(l));
    }
    f = new o(f.re - 1, f.im);
    for (var h = new o(Ba[0], 0), d = 1; d < Ba.length; ++d) {
      var g = new o(Ba[d], 0);
      h = h.add(g.div(f.add(d)));
    }
    var v = new o(f.re + Nw + 0.5, f.im), N = Math.sqrt(2 * Math.PI), b = v.pow(f.add(0.5)), C = v.neg().exp();
    return h.mul(N).mul(b).mul(C);
  }
  return e(Pb, {
    number: uu,
    Complex: p,
    BigNumber: function(l) {
      if (l.isInteger())
        return l.isNegative() || l.isZero() ? new s(1 / 0) : u(l.minus(1));
      if (!l.isFinite())
        return new s(l.isNegative() ? NaN : 1 / 0);
      throw new Error("Integer BigNumber expected");
    }
  });
  function u(f) {
    if (f < 8)
      return new s([1, 1, 2, 6, 24, 120, 720, 5040][f]);
    var l = r.precision + (Math.log(f.toNumber()) | 0), c = s.clone({
      precision: l
    });
    if (f % 2 === 1)
      return f.times(u(new s(f - 1)));
    for (var h = f, d = new c(f), g = f.toNumber(); h > 2; )
      h -= 2, g += h, d = d.times(g);
    return new s(d.toPrecision(s.precision));
  }
}), kb = "lgamma", d7 = ["Complex", "typed"], Qf = /* @__PURE__ */ j(kb, d7, (t) => {
  var {
    Complex: e,
    typed: r
  } = t, n = 7, a = 7, s = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return r(kb, {
    number: lu,
    Complex: o,
    BigNumber: function() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function o(f) {
    var l = 6.283185307179586, c = 1.1447298858494002, h = 0.1;
    if (f.isNaN())
      return new e(NaN, NaN);
    if (f.im === 0)
      return new e(lu(f.re), 0);
    if (f.re >= n || Math.abs(f.im) >= a)
      return p(f);
    if (f.re <= h) {
      var d = oC(l, f.im) * Math.floor(0.5 * f.re + 0.25), g = f.mul(Math.PI).sin().log(), v = o(new e(1 - f.re, -f.im));
      return new e(c, d).sub(g).sub(v);
    } else return f.im >= 0 ? u(f) : u(f.conjugate()).conjugate();
  }
  function p(f) {
    for (var l = f.sub(0.5).mul(f.log()).sub(f).add(Dw), c = new e(1, 0).div(f), h = c.div(f), d = s[0], g = s[1], v = 2 * h.re, N = h.re * h.re + h.im * h.im, b = 2; b < 8; b++) {
      var C = g;
      g = -N * d + s[b], d = v * d + C;
    }
    var x = c.mul(h.mul(d).add(g));
    return l.add(x);
  }
  function u(f) {
    var l = 0, c = 0, h = f;
    for (f = f.add(1); f.re <= n; ) {
      h = h.mul(f);
      var d = h.im < 0 ? 1 : 0;
      d !== 0 && c === 0 && l++, c = d, f = f.add(1);
    }
    return p(f).sub(h.log()).sub(new e(0, l * 2 * Math.PI * 1));
  }
}), $b = "factorial", v7 = ["typed", "gamma"], Vf = /* @__PURE__ */ j($b, v7, (t) => {
  var {
    typed: e,
    gamma: r
  } = t;
  return e($b, {
    number: function(a) {
      if (a < 0)
        throw new Error("Value must be non-negative");
      return r(a + 1);
    },
    BigNumber: function(a) {
      if (a.isNegative())
        throw new Error("Value must be non-negative");
      return r(a.plus(1));
    },
    "Array | Matrix": e.referToSelf((n) => (a) => Nt(a, n))
  });
}), zb = "kldivergence", g7 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"], Wf = /* @__PURE__ */ j(zb, g7, (t) => {
  var {
    typed: e,
    matrix: r,
    divide: n,
    sum: a,
    multiply: s,
    map: o,
    dotDivide: p,
    log: u,
    isNumeric: f
  } = t;
  return e(zb, {
    "Array, Array": function(h, d) {
      return l(r(h), r(d));
    },
    "Matrix, Array": function(h, d) {
      return l(h, r(d));
    },
    "Array, Matrix": function(h, d) {
      return l(r(h), d);
    },
    "Matrix, Matrix": function(h, d) {
      return l(h, d);
    }
  });
  function l(c, h) {
    var d = h.size().length, g = c.size().length;
    if (d > 1)
      throw new Error("first object must be one dimensional");
    if (g > 1)
      throw new Error("second object must be one dimensional");
    if (d !== g)
      throw new Error("Length of two vectors must be equal");
    var v = a(c);
    if (v === 0)
      throw new Error("Sum of elements in first object must be non zero");
    var N = a(h);
    if (N === 0)
      throw new Error("Sum of elements in second object must be non zero");
    var b = n(c, a(c)), C = n(h, a(h)), x = a(s(b, o(p(b, C), (E) => u(E))));
    return f(x) ? x : Number.NaN;
  }
}), Ub = "multinomial", y7 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"], jf = /* @__PURE__ */ j(Ub, y7, (t) => {
  var {
    typed: e,
    add: r,
    divide: n,
    multiply: a,
    factorial: s,
    isInteger: o,
    isPositive: p
  } = t;
  return e(Ub, {
    "Array | Matrix": function(f) {
      var l = 0, c = 1;
      return hi(f, function(h) {
        if (!o(h) || !p(h))
          throw new TypeError("Positive integer value expected in function multinomial");
        l = r(l, h), c = a(c, s(h));
      }), n(s(l), c);
    }
  });
}), Gb = "permutations", x7 = ["typed", "factorial"], Zf = /* @__PURE__ */ j(Gb, x7, (t) => {
  var {
    typed: e,
    factorial: r
  } = t;
  return e(Gb, {
    "number | BigNumber": r,
    "number, number": function(a, s) {
      if (!Xe(a) || a < 0)
        throw new TypeError("Positive integer value expected in function permutations");
      if (!Xe(s) || s < 0)
        throw new TypeError("Positive integer value expected in function permutations");
      if (s > a)
        throw new TypeError("second argument k must be less than or equal to first argument n");
      return li(a - s + 1, a);
    },
    "BigNumber, BigNumber": function(a, s) {
      var o, p;
      if (!Hb(a) || !Hb(s))
        throw new TypeError("Positive integer value expected in function permutations");
      if (s.gt(a))
        throw new TypeError("second argument k must be less than or equal to first argument n");
      var u = a.mul(0).add(1);
      for (o = u, p = a.minus(s).plus(1); p.lte(a); p = p.plus(1))
        o = o.times(p);
      return o;
    }
    // TODO: implement support for collection in permutations
  });
});
function Hb(t) {
  return t.isInteger() && t.gte(0);
}
var Bd = { exports: {} };
Bd.exports;
(function(t) {
  (function(e, r, n) {
    function a(u) {
      var f = this, l = p();
      f.next = function() {
        var c = 2091639 * f.s0 + f.c * 23283064365386963e-26;
        return f.s0 = f.s1, f.s1 = f.s2, f.s2 = c - (f.c = c | 0);
      }, f.c = 1, f.s0 = l(" "), f.s1 = l(" "), f.s2 = l(" "), f.s0 -= l(u), f.s0 < 0 && (f.s0 += 1), f.s1 -= l(u), f.s1 < 0 && (f.s1 += 1), f.s2 -= l(u), f.s2 < 0 && (f.s2 += 1), l = null;
    }
    function s(u, f) {
      return f.c = u.c, f.s0 = u.s0, f.s1 = u.s1, f.s2 = u.s2, f;
    }
    function o(u, f) {
      var l = new a(u), c = f && f.state, h = l.next;
      return h.int32 = function() {
        return l.next() * 4294967296 | 0;
      }, h.double = function() {
        return h() + (h() * 2097152 | 0) * 11102230246251565e-32;
      }, h.quick = h, c && (typeof c == "object" && s(c, l), h.state = function() {
        return s(l, {});
      }), h;
    }
    function p() {
      var u = 4022871197, f = function(l) {
        l = String(l);
        for (var c = 0; c < l.length; c++) {
          u += l.charCodeAt(c);
          var h = 0.02519603282416938 * u;
          u = h >>> 0, h -= u, h *= u, u = h >>> 0, h -= u, u += h * 4294967296;
        }
        return (u >>> 0) * 23283064365386963e-26;
      };
      return f;
    }
    r && r.exports ? r.exports = o : this.alea = o;
  })(
    ua,
    t
  );
})(Bd);
var b7 = Bd.exports, Rd = { exports: {} };
Rd.exports;
(function(t) {
  (function(e, r, n) {
    function a(p) {
      var u = this, f = "";
      u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.next = function() {
        var c = u.x ^ u.x << 11;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w ^= u.w >>> 19 ^ c ^ c >>> 8;
      }, p === (p | 0) ? u.x = p : f += p;
      for (var l = 0; l < f.length + 64; l++)
        u.x ^= f.charCodeAt(l) | 0, u.next();
    }
    function s(p, u) {
      return u.x = p.x, u.y = p.y, u.z = p.z, u.w = p.w, u;
    }
    function o(p, u) {
      var f = new a(p), l = u && u.state, c = function() {
        return (f.next() >>> 0) / 4294967296;
      };
      return c.double = function() {
        do
          var h = f.next() >>> 11, d = (f.next() >>> 0) / 4294967296, g = (h + d) / (1 << 21);
        while (g === 0);
        return g;
      }, c.int32 = f.next, c.quick = c, l && (typeof l == "object" && s(l, f), c.state = function() {
        return s(f, {});
      }), c;
    }
    r && r.exports ? r.exports = o : this.xor128 = o;
  })(
    ua,
    t
  );
})(Rd);
var w7 = Rd.exports, Ld = { exports: {} };
Ld.exports;
(function(t) {
  (function(e, r, n) {
    function a(p) {
      var u = this, f = "";
      u.next = function() {
        var c = u.x ^ u.x >>> 2;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w = u.v, (u.d = u.d + 362437 | 0) + (u.v = u.v ^ u.v << 4 ^ (c ^ c << 1)) | 0;
      }, u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.v = 0, p === (p | 0) ? u.x = p : f += p;
      for (var l = 0; l < f.length + 64; l++)
        u.x ^= f.charCodeAt(l) | 0, l == f.length && (u.d = u.x << 10 ^ u.x >>> 4), u.next();
    }
    function s(p, u) {
      return u.x = p.x, u.y = p.y, u.z = p.z, u.w = p.w, u.v = p.v, u.d = p.d, u;
    }
    function o(p, u) {
      var f = new a(p), l = u && u.state, c = function() {
        return (f.next() >>> 0) / 4294967296;
      };
      return c.double = function() {
        do
          var h = f.next() >>> 11, d = (f.next() >>> 0) / 4294967296, g = (h + d) / (1 << 21);
        while (g === 0);
        return g;
      }, c.int32 = f.next, c.quick = c, l && (typeof l == "object" && s(l, f), c.state = function() {
        return s(f, {});
      }), c;
    }
    r && r.exports ? r.exports = o : this.xorwow = o;
  })(
    ua,
    t
  );
})(Ld);
var N7 = Ld.exports, Pd = { exports: {} };
Pd.exports;
(function(t) {
  (function(e, r, n) {
    function a(p) {
      var u = this;
      u.next = function() {
        var l = u.x, c = u.i, h, d;
        return h = l[c], h ^= h >>> 7, d = h ^ h << 24, h = l[c + 1 & 7], d ^= h ^ h >>> 10, h = l[c + 3 & 7], d ^= h ^ h >>> 3, h = l[c + 4 & 7], d ^= h ^ h << 7, h = l[c + 7 & 7], h = h ^ h << 13, d ^= h ^ h << 9, l[c] = d, u.i = c + 1 & 7, d;
      };
      function f(l, c) {
        var h, d = [];
        if (c === (c | 0))
          d[0] = c;
        else
          for (c = "" + c, h = 0; h < c.length; ++h)
            d[h & 7] = d[h & 7] << 15 ^ c.charCodeAt(h) + d[h + 1 & 7] << 13;
        for (; d.length < 8; ) d.push(0);
        for (h = 0; h < 8 && d[h] === 0; ++h) ;
        for (h == 8 ? d[7] = -1 : d[h], l.x = d, l.i = 0, h = 256; h > 0; --h)
          l.next();
      }
      f(u, p);
    }
    function s(p, u) {
      return u.x = p.x.slice(), u.i = p.i, u;
    }
    function o(p, u) {
      p == null && (p = +/* @__PURE__ */ new Date());
      var f = new a(p), l = u && u.state, c = function() {
        return (f.next() >>> 0) / 4294967296;
      };
      return c.double = function() {
        do
          var h = f.next() >>> 11, d = (f.next() >>> 0) / 4294967296, g = (h + d) / (1 << 21);
        while (g === 0);
        return g;
      }, c.int32 = f.next, c.quick = c, l && (l.x && s(l, f), c.state = function() {
        return s(f, {});
      }), c;
    }
    r && r.exports ? r.exports = o : this.xorshift7 = o;
  })(
    ua,
    t
  );
})(Pd);
var D7 = Pd.exports, kd = { exports: {} };
kd.exports;
(function(t) {
  (function(e, r, n) {
    function a(p) {
      var u = this;
      u.next = function() {
        var l = u.w, c = u.X, h = u.i, d, g;
        return u.w = l = l + 1640531527 | 0, g = c[h + 34 & 127], d = c[h = h + 1 & 127], g ^= g << 13, d ^= d << 17, g ^= g >>> 15, d ^= d >>> 12, g = c[h] = g ^ d, u.i = h, g + (l ^ l >>> 16) | 0;
      };
      function f(l, c) {
        var h, d, g, v, N, b = [], C = 128;
        for (c === (c | 0) ? (d = c, c = null) : (c = c + "\0", d = 0, C = Math.max(C, c.length)), g = 0, v = -32; v < C; ++v)
          c && (d ^= c.charCodeAt((v + 32) % c.length)), v === 0 && (N = d), d ^= d << 10, d ^= d >>> 15, d ^= d << 4, d ^= d >>> 13, v >= 0 && (N = N + 1640531527 | 0, h = b[v & 127] ^= d + N, g = h == 0 ? g + 1 : 0);
        for (g >= 128 && (b[(c && c.length || 0) & 127] = -1), g = 127, v = 4 * 128; v > 0; --v)
          d = b[g + 34 & 127], h = b[g = g + 1 & 127], d ^= d << 13, h ^= h << 17, d ^= d >>> 15, h ^= h >>> 12, b[g] = d ^ h;
        l.w = N, l.X = b, l.i = g;
      }
      f(u, p);
    }
    function s(p, u) {
      return u.i = p.i, u.w = p.w, u.X = p.X.slice(), u;
    }
    function o(p, u) {
      p == null && (p = +/* @__PURE__ */ new Date());
      var f = new a(p), l = u && u.state, c = function() {
        return (f.next() >>> 0) / 4294967296;
      };
      return c.double = function() {
        do
          var h = f.next() >>> 11, d = (f.next() >>> 0) / 4294967296, g = (h + d) / (1 << 21);
        while (g === 0);
        return g;
      }, c.int32 = f.next, c.quick = c, l && (l.X && s(l, f), c.state = function() {
        return s(f, {});
      }), c;
    }
    r && r.exports ? r.exports = o : this.xor4096 = o;
  })(
    ua,
    // window object or global
    t
  );
})(kd);
var A7 = kd.exports, $d = { exports: {} };
$d.exports;
(function(t) {
  (function(e, r, n) {
    function a(p) {
      var u = this, f = "";
      u.next = function() {
        var c = u.b, h = u.c, d = u.d, g = u.a;
        return c = c << 25 ^ c >>> 7 ^ h, h = h - d | 0, d = d << 24 ^ d >>> 8 ^ g, g = g - c | 0, u.b = c = c << 20 ^ c >>> 12 ^ h, u.c = h = h - d | 0, u.d = d << 16 ^ h >>> 16 ^ g, u.a = g - c | 0;
      }, u.a = 0, u.b = 0, u.c = -1640531527, u.d = 1367130551, p === Math.floor(p) ? (u.a = p / 4294967296 | 0, u.b = p | 0) : f += p;
      for (var l = 0; l < f.length + 20; l++)
        u.b ^= f.charCodeAt(l) | 0, u.next();
    }
    function s(p, u) {
      return u.a = p.a, u.b = p.b, u.c = p.c, u.d = p.d, u;
    }
    function o(p, u) {
      var f = new a(p), l = u && u.state, c = function() {
        return (f.next() >>> 0) / 4294967296;
      };
      return c.double = function() {
        do
          var h = f.next() >>> 11, d = (f.next() >>> 0) / 4294967296, g = (h + d) / (1 << 21);
        while (g === 0);
        return g;
      }, c.int32 = f.next, c.quick = c, l && (typeof l == "object" && s(l, f), c.state = function() {
        return s(f, {});
      }), c;
    }
    r && r.exports ? r.exports = o : this.tychei = o;
  })(
    ua,
    t
  );
})($d);
var E7 = $d.exports, Kw = { exports: {} };
const S7 = {}, C7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: S7
}, Symbol.toStringTag, { value: "Module" })), T7 = /* @__PURE__ */ mT(C7);
(function(t) {
  (function(e, r, n) {
    var a = 256, s = 6, o = 52, p = "random", u = n.pow(a, s), f = n.pow(2, o), l = f * 2, c = a - 1, h;
    function d(E, D, A) {
      var M = [];
      D = D == !0 ? { entropy: !0 } : D || {};
      var _ = b(N(
        D.entropy ? [E, x(r)] : E ?? C(),
        3
      ), M), O = new g(M), T = function() {
        for (var I = O.g(s), q = u, $ = 0; I < f; )
          I = (I + $) * a, q *= a, $ = O.g(1);
        for (; I >= l; )
          I /= 2, q /= 2, $ >>>= 1;
        return (I + $) / q;
      };
      return T.int32 = function() {
        return O.g(4) | 0;
      }, T.quick = function() {
        return O.g(4) / 4294967296;
      }, T.double = T, b(x(O.S), r), (D.pass || A || function(I, q, $, U) {
        return U && (U.S && v(U, O), I.state = function() {
          return v(O, {});
        }), $ ? (n[p] = I, q) : I;
      })(
        T,
        _,
        "global" in D ? D.global : this == n,
        D.state
      );
    }
    function g(E) {
      var D, A = E.length, M = this, _ = 0, O = M.i = M.j = 0, T = M.S = [];
      for (A || (E = [A++]); _ < a; )
        T[_] = _++;
      for (_ = 0; _ < a; _++)
        T[_] = T[O = c & O + E[_ % A] + (D = T[_])], T[O] = D;
      (M.g = function(I) {
        for (var q, $ = 0, U = M.i, k = M.j, L = M.S; I--; )
          q = L[U = c & U + 1], $ = $ * a + L[c & (L[U] = L[k = c & k + q]) + (L[k] = q)];
        return M.i = U, M.j = k, $;
      })(a);
    }
    function v(E, D) {
      return D.i = E.i, D.j = E.j, D.S = E.S.slice(), D;
    }
    function N(E, D) {
      var A = [], M = typeof E, _;
      if (D && M == "object")
        for (_ in E)
          try {
            A.push(N(E[_], D - 1));
          } catch {
          }
      return A.length ? A : M == "string" ? E : E + "\0";
    }
    function b(E, D) {
      for (var A = E + "", M, _ = 0; _ < A.length; )
        D[c & _] = c & (M ^= D[c & _] * 19) + A.charCodeAt(_++);
      return x(D);
    }
    function C() {
      try {
        var E;
        return h && (E = h.randomBytes) ? E = E(a) : (E = new Uint8Array(a), (e.crypto || e.msCrypto).getRandomValues(E)), x(E);
      } catch {
        var D = e.navigator, A = D && D.plugins;
        return [+/* @__PURE__ */ new Date(), e, A, e.screen, x(r)];
      }
    }
    function x(E) {
      return String.fromCharCode.apply(0, E);
    }
    if (b(n.random(), r), t.exports) {
      t.exports = d;
      try {
        h = T7;
      } catch {
      }
    } else
      n["seed" + p] = d;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self < "u" ? self : ua,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(Kw);
var _7 = Kw.exports, M7 = b7, O7 = w7, F7 = N7, q7 = D7, I7 = A7, B7 = E7, ca = _7;
ca.alea = M7;
ca.xor128 = O7;
ca.xorwow = F7;
ca.xorshift7 = q7;
ca.xor4096 = I7;
ca.tychei = B7;
var R7 = ca;
const eN = /* @__PURE__ */ zs(R7);
var L7 = /* @__PURE__ */ eN(Date.now());
function Ua(t) {
  var e;
  function r(a) {
    e = a === null ? L7 : eN(String(a));
  }
  r(t);
  function n() {
    return e();
  }
  return n;
}
var Qb = "pickRandom", P7 = ["typed", "config", "?on"], Jf = /* @__PURE__ */ j(Qb, P7, (t) => {
  var {
    typed: e,
    config: r,
    on: n
  } = t, a = Ua(r.randomSeed);
  return n && n("config", function(o, p) {
    o.randomSeed !== p.randomSeed && (a = Ua(o.randomSeed));
  }), e(Qb, {
    "Array | Matrix": function(p) {
      return s(p, {});
    },
    "Array | Matrix, Object": function(p, u) {
      return s(p, u);
    },
    "Array | Matrix, number": function(p, u) {
      return s(p, {
        number: u
      });
    },
    "Array | Matrix, Array | Matrix": function(p, u) {
      return s(p, {
        weights: u
      });
    },
    "Array | Matrix, Array | Matrix, number": function(p, u, f) {
      return s(p, {
        number: f,
        weights: u
      });
    },
    "Array | Matrix, number, Array | Matrix": function(p, u, f) {
      return s(p, {
        number: u,
        weights: f
      });
    }
  });
  function s(o, p) {
    var {
      number: u,
      weights: f,
      elementWise: l = !0
    } = p, c = typeof u > "u";
    c && (u = 1);
    var h = tt(o) ? o.create : tt(f) ? f.create : null;
    o = o.valueOf(), f && (f = f.valueOf()), l === !0 && (o = Lt(o), f = Lt(f));
    var d = 0;
    if (typeof f < "u") {
      if (f.length !== o.length)
        throw new Error("Weights must have the same length as possibles");
      for (var g = 0, v = f.length; g < v; g++) {
        if (!ht(f[g]) || f[g] < 0)
          throw new Error("Weights must be an array of positive numbers");
        d += f[g];
      }
    }
    for (var N = o.length, b = [], C; b.length < u; ) {
      if (typeof f > "u")
        C = o[Math.floor(a() * N)];
      else
        for (var x = a() * d, E = 0, D = o.length; E < D; E++)
          if (x -= f[E], x < 0) {
            C = o[E];
            break;
          }
      b.push(C);
    }
    return c ? b[0] : h ? h(b) : b;
  }
});
function zd(t, e) {
  var r = [];
  if (t = t.slice(0), t.length > 1)
    for (var n = 0, a = t.shift(); n < a; n++)
      r.push(zd(t, e));
  else
    for (var s = 0, o = t.shift(); s < o; s++)
      r.push(e());
  return r;
}
var Vb = "random", k7 = ["typed", "config", "?on"], Yf = /* @__PURE__ */ j(Vb, k7, (t) => {
  var {
    typed: e,
    config: r,
    on: n
  } = t, a = Ua(r.randomSeed);
  return n && n("config", function(p, u) {
    p.randomSeed !== u.randomSeed && (a = Ua(p.randomSeed));
  }), e(Vb, {
    "": () => o(0, 1),
    number: (p) => o(0, p),
    "number, number": (p, u) => o(p, u),
    "Array | Matrix": (p) => s(p, 0, 1),
    "Array | Matrix, number": (p, u) => s(p, 0, u),
    "Array | Matrix, number, number": (p, u, f) => s(p, u, f)
  });
  function s(p, u, f) {
    var l = zd(p.valueOf(), () => o(u, f));
    return tt(p) ? p.create(l) : l;
  }
  function o(p, u) {
    return p + a() * (u - p);
  }
}), Wb = "randomInt", $7 = ["typed", "config", "?on"], Xf = /* @__PURE__ */ j(Wb, $7, (t) => {
  var {
    typed: e,
    config: r,
    on: n
  } = t, a = Ua(r.randomSeed);
  return n && n("config", function(p, u) {
    p.randomSeed !== u.randomSeed && (a = Ua(p.randomSeed));
  }), e(Wb, {
    "": () => o(0, 1),
    number: (p) => o(0, p),
    "number, number": (p, u) => o(p, u),
    "Array | Matrix": (p) => s(p, 0, 1),
    "Array | Matrix, number": (p, u) => s(p, 0, u),
    "Array | Matrix, number, number": (p, u, f) => s(p, u, f)
  });
  function s(p, u, f) {
    var l = zd(p.valueOf(), () => o(u, f));
    return tt(p) ? p.create(l) : l;
  }
  function o(p, u) {
    return Math.floor(p + a() * (u - p));
  }
}), jb = "stirlingS2", z7 = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"], Kf = /* @__PURE__ */ j(jb, z7, (t) => {
  var {
    typed: e,
    addScalar: r,
    subtractScalar: n,
    multiplyScalar: a,
    divideScalar: s,
    pow: o,
    factorial: p,
    combinations: u,
    isNegative: f,
    isInteger: l,
    number: c,
    bignumber: h,
    larger: d
  } = t, g = [], v = [];
  return e(jb, {
    "number | BigNumber, number | BigNumber": function(b, C) {
      if (!l(b) || f(b) || !l(C) || f(C))
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      if (d(C, b))
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      var x = !(ht(b) && ht(C)), E = x ? v : g, D = x ? h : c, A = c(b), M = c(C);
      if (E[A] && E[A].length > M)
        return E[A][M];
      for (var _ = 0; _ <= A; ++_)
        if (E[_] || (E[_] = [D(_ === 0 ? 1 : 0)]), _ !== 0)
          for (var O = E[_], T = E[_ - 1], I = O.length; I <= _ && I <= M; ++I)
            I === _ ? O[I] = 1 : O[I] = r(a(D(I), T[I]), T[I - 1]);
      return E[A][M];
    }
  });
}), Zb = "bellNumbers", U7 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"], ep = /* @__PURE__ */ j(Zb, U7, (t) => {
  var {
    typed: e,
    addScalar: r,
    isNegative: n,
    isInteger: a,
    stirlingS2: s
  } = t;
  return e(Zb, {
    "number | BigNumber": function(p) {
      if (!a(p) || n(p))
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      for (var u = 0, f = 0; f <= p; f++)
        u = r(u, s(p, f));
      return u;
    }
  });
}), Jb = "catalan", G7 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"], tp = /* @__PURE__ */ j(Jb, G7, (t) => {
  var {
    typed: e,
    addScalar: r,
    divideScalar: n,
    multiplyScalar: a,
    combinations: s,
    isNegative: o,
    isInteger: p
  } = t;
  return e(Jb, {
    "number | BigNumber": function(f) {
      if (!p(f) || o(f))
        throw new TypeError("Non-negative integer value expected in function catalan");
      return n(s(a(f, 2), f), r(f, 1));
    }
  });
}), Yb = "composition", H7 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"], rp = /* @__PURE__ */ j(Yb, H7, (t) => {
  var {
    typed: e,
    addScalar: r,
    combinations: n,
    isPositive: a,
    isNegative: s,
    isInteger: o,
    larger: p
  } = t;
  return e(Yb, {
    "number | BigNumber, number | BigNumber": function(f, l) {
      if (!o(f) || !a(f) || !o(l) || !a(l))
        throw new TypeError("Positive integer value expected in function composition");
      if (p(l, f))
        throw new TypeError("k must be less than or equal to n in function composition");
      return n(r(f, -1), r(l, -1));
    }
  });
}), Xb = "leafCount", Q7 = ["parse", "typed"], np = /* @__PURE__ */ j(Xb, Q7, (t) => {
  var {
    parse: e,
    typed: r
  } = t;
  function n(a) {
    var s = 0;
    return a.forEach((o) => {
      s += n(o);
    }), s || 1;
  }
  return r(Xb, {
    Node: function(s) {
      return n(s);
    }
  });
});
function Kb(t) {
  return Ct(t) || or(t) && t.isUnary() && Ct(t.args[0]);
}
function xu(t) {
  return !!(Ct(t) || (Wn(t) || or(t)) && t.args.every(xu) || kn(t) && xu(t.content));
}
function e2(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function $m(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? e2(Object(r), !0).forEach(function(n) {
      xr(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : e2(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var V7 = "simplifyUtil", W7 = ["FunctionNode", "OperatorNode", "SymbolNode"], Ud = /* @__PURE__ */ j(V7, W7, (t) => {
  var {
    FunctionNode: e,
    OperatorNode: r,
    SymbolNode: n
  } = t, a = !0, s = !1, o = "defaultF", p = {
    /*      */
    add: {
      trivial: a,
      total: a,
      commutative: a,
      associative: a
    },
    /**/
    unaryPlus: {
      trivial: a,
      total: a,
      commutative: a,
      associative: a
    },
    /* */
    subtract: {
      trivial: s,
      total: a,
      commutative: s,
      associative: s
    },
    /* */
    multiply: {
      trivial: a,
      total: a,
      commutative: a,
      associative: a
    },
    /*   */
    divide: {
      trivial: s,
      total: a,
      commutative: s,
      associative: s
    },
    /*    */
    paren: {
      trivial: a,
      total: a,
      commutative: a,
      associative: s
    },
    /* */
    defaultF: {
      trivial: s,
      total: a,
      commutative: s,
      associative: s
    }
  }, u = {
    divide: {
      total: s
    },
    log: {
      total: s
    }
  }, f = {
    subtract: {
      total: s
    },
    abs: {
      trivial: a
    },
    log: {
      total: a
    }
  };
  function l(x, E) {
    var D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : p, A = o;
    if (typeof x == "string" ? A = x : or(x) ? A = x.fn.toString() : Wn(x) ? A = x.name : kn(x) && (A = "paren"), We(D, A)) {
      var M = D[A];
      if (We(M, E))
        return M[E];
      if (We(p, A))
        return p[A][E];
    }
    if (We(D, o)) {
      var _ = D[o];
      return We(_, E) ? _[E] : p[o][E];
    }
    if (We(p, A)) {
      var O = p[A];
      if (We(O, E))
        return O[E];
    }
    return p[o][E];
  }
  function c(x) {
    var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p;
    return l(x, "commutative", E);
  }
  function h(x) {
    var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p;
    return l(x, "associative", E);
  }
  function d(x, E) {
    var D = $m({}, x);
    for (var A in E)
      We(x, A) ? D[A] = $m($m({}, E[A]), x[A]) : D[A] = E[A];
    return D;
  }
  function g(x, E) {
    if (!x.args || x.args.length === 0)
      return x;
    x.args = v(x, E);
    for (var D = 0; D < x.args.length; D++)
      g(x.args[D], E);
  }
  function v(x, E) {
    var D, A = [], M = function _(O) {
      for (var T = 0; T < O.args.length; T++) {
        var I = O.args[T];
        or(I) && D === I.op ? _(I) : A.push(I);
      }
    };
    return h(x, E) ? (D = x.op, M(x), A) : x.args;
  }
  function N(x, E) {
    if (!(!x.args || x.args.length === 0)) {
      for (var D = C(x), A = x.args.length, M = 0; M < A; M++)
        N(x.args[M], E);
      if (A > 2 && h(x, E)) {
        for (var _ = x.args.pop(); x.args.length > 0; )
          _ = D([x.args.pop(), _]);
        x.args = _.args;
      }
    }
  }
  function b(x, E) {
    if (!(!x.args || x.args.length === 0)) {
      for (var D = C(x), A = x.args.length, M = 0; M < A; M++)
        b(x.args[M], E);
      if (A > 2 && h(x, E)) {
        for (var _ = x.args.shift(); x.args.length > 0; )
          _ = D([_, x.args.shift()]);
        x.args = _.args;
      }
    }
  }
  function C(x) {
    return or(x) ? function(E) {
      try {
        return new r(x.op, x.fn, E, x.implicit);
      } catch (D) {
        return console.error(D), [];
      }
    } : function(E) {
      return new e(new n(x.name), E);
    };
  }
  return {
    createMakeNodeFunction: C,
    hasProperty: l,
    isCommutative: c,
    isAssociative: h,
    mergeContext: d,
    flatten: g,
    allChildren: v,
    unflattenr: N,
    unflattenl: b,
    defaultContext: p,
    realContext: u,
    positiveContext: f
  };
}), j7 = "simplify", Z7 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"], ip = /* @__PURE__ */ j(j7, Z7, (t) => {
  var {
    config: e,
    typed: r,
    parse: n,
    add: a,
    subtract: s,
    multiply: o,
    divide: p,
    pow: u,
    isZero: f,
    equal: l,
    resolve: c,
    simplifyConstant: h,
    simplifyCore: d,
    fraction: g,
    bignumber: v,
    mathWithTransform: N,
    matrix: b,
    AccessorNode: C,
    ArrayNode: x,
    ConstantNode: E,
    FunctionNode: D,
    IndexNode: A,
    ObjectNode: M,
    OperatorNode: _,
    ParenthesisNode: O,
    SymbolNode: T
  } = t, {
    hasProperty: I,
    isCommutative: q,
    isAssociative: $,
    mergeContext: U,
    flatten: k,
    unflattenr: L,
    unflattenl: R,
    createMakeNodeFunction: G,
    defaultContext: P,
    realContext: W,
    positiveContext: le
  } = Ud({
    FunctionNode: D,
    OperatorNode: _,
    SymbolNode: T
  });
  r.addConversion({
    from: "Object",
    to: "Map",
    convert: Ia
  });
  var Z = r("simplify", {
    Node: ue,
    "Node, Map": (X, ie) => ue(X, !1, ie),
    "Node, Map, Object": (X, ie, me) => ue(X, !1, ie, me),
    "Node, Array": ue,
    "Node, Array, Map": ue,
    "Node, Array, Map, Object": ue
  });
  r.removeConversion({
    from: "Object",
    to: "Map",
    convert: Ia
  }), Z.defaultContext = P, Z.realContext = W, Z.positiveContext = le;
  function H(X) {
    return X.transform(function(ie, me, Ae) {
      return kn(ie) ? H(ie.content) : ie;
    });
  }
  var te = {
    true: !0,
    false: !0,
    e: !0,
    i: !0,
    Infinity: !0,
    LN2: !0,
    LN10: !0,
    LOG2E: !0,
    LOG10E: !0,
    NaN: !0,
    phi: !0,
    pi: !0,
    SQRT1_2: !0,
    SQRT2: !0,
    tau: !0
    // null: false,
    // undefined: false,
    // version: false,
  };
  Z.rules = [
    d,
    // { l: 'n+0', r: 'n' },     // simplifyCore
    // { l: 'n^0', r: '1' },     // simplifyCore
    // { l: '0*n', r: '0' },     // simplifyCore
    // { l: 'n/n', r: '1'},      // simplifyCore
    // { l: 'n^1', r: 'n' },     // simplifyCore
    // { l: '+n1', r:'n1' },     // simplifyCore
    // { l: 'n--n1', r:'n+n1' }, // simplifyCore
    {
      l: "log(e)",
      r: "1"
    },
    // temporary rules
    // Note initially we tend constants to the right because like-term
    // collection prefers the left, and we would rather collect nonconstants
    {
      s: "n-n1 -> n+-n1",
      // temporarily replace 'subtract' so we can further flatten the 'add' operator
      assuming: {
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "n-n -> 0",
      // partial alternative when we can't always subtract
      assuming: {
        subtract: {
          total: !1
        }
      }
    },
    {
      s: "-(cl*v) -> v * (-cl)",
      // make non-constant terms positive
      assuming: {
        multiply: {
          commutative: !0
        },
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "-(cl*v) -> (-cl) * v",
      // non-commutative version, part 1
      assuming: {
        multiply: {
          commutative: !1
        },
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "-(v*cl) -> v * (-cl)",
      // non-commutative version, part 2
      assuming: {
        multiply: {
          commutative: !1
        },
        subtract: {
          total: !0
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    // finish making non-constant terms positive
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: !0
    },
    // expand negations to achieve as much sign cancellation as possible
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    // temporarily replace 'divide' so we can further flatten the 'multiply' operator
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: !0
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    // expand nested exponentiation
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: !0
        }
      }
      // 1/(1/n) = n needs 1/n to exist
    },
    // collect like factors; into a sum, only do this for nonconstants
    {
      l: " vd   * ( vd   * n1 + n2)",
      r: "vd^2       * n1 +  vd   * n2"
    },
    {
      s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
      assuming: {
        divide: {
          total: !0
        }
      }
      // v*1/v = v^(1+-1) needs 1/v
    },
    {
      s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: !0
        }
      }
    },
    {
      s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: !0
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: !0
        }
      }
      // n*1/n = n^(-1+1) needs 1/n
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: !0
        }
      }
      // ditto for n^2*1/n^2
    },
    // Unfortunately, to deal with more complicated cancellations, it
    // becomes necessary to simplify constants twice per pass. It's not
    // terribly expensive compared to matching rules, so this should not
    // pose a performance problem.
    h,
    // First: before collecting like terms
    // collect like terms
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: !0
        }
      }
      // 2 = 1 + 1 needs to exist
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "vd*n + vd",
      r: "vd*(n+1)"
    },
    // NOTE: leftmost position is special:
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    // All sub-monomials tried there.
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    // noncommutative additional cases (term collection & factoring)
    {
      s: "n*vd + vd -> (n+1)*vd",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "vd + n*vd -> (1+n)*vd",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n^n1 * n -> n^(n1+1)",
      assuming: {
        divide: {
          total: !0
        },
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      l: "n*cd + cd",
      r: "(n+1)*cd"
    },
    {
      s: "cd*n + cd -> cd*(n+1)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "cd + cd*n -> cd*(1+n)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    h,
    // Second: before returning expressions to "standard form"
    // make factors positive (and undo 'make non-constant terms positive')
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      // in case * non-commutative
      assuming: {
        subtract: {
          total: !0
        },
        multiply: {
          commutative: !1
        }
      }
    },
    // final ordering of constants
    {
      s: "ce+ve -> ve+ce",
      assuming: {
        add: {
          commutative: !0
        }
      },
      imposeContext: {
        add: {
          commutative: !1
        }
      }
    },
    {
      s: "vd*cd -> cd*vd",
      assuming: {
        multiply: {
          commutative: !0
        }
      },
      imposeContext: {
        multiply: {
          commutative: !1
        }
      }
    },
    // undo temporary rules
    // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
    {
      l: "n+-n1",
      r: "n-n1"
    },
    // undo replace 'subtract'
    {
      l: "n+-(n1)",
      r: "n-(n1)"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      // undo replace 'divide'; for * commutative
      assuming: {
        multiply: {
          commutative: !0
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: !0
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: !0
        }
      }
      // o.w. / not conventional
    },
    {
      l: "n^1",
      r: "n"
    },
    // can be produced by power cancellation
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      // '*' before '/'
      assuming: {
        multiply: {
          associative: !0
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      // '-' before '+'
      assuming: {
        addition: {
          associative: !0,
          commutative: !0
        }
      }
    },
    // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
    // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
    // simplifyConstant can leave an extra factor of 1, which can always
    // be eliminated, since the identity always commutes
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: !0
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: !0
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function be(X, ie) {
    var me = {};
    if (X.s) {
      var Ae = X.s.split("->");
      if (Ae.length === 2)
        me.l = Ae[0], me.r = Ae[1];
      else
        throw SyntaxError("Could not parse rule: " + X.s);
    } else
      me.l = X.l, me.r = X.r;
    me.l = H(n(me.l)), me.r = H(n(me.r));
    for (var Me of ["imposeContext", "repeat", "assuming"])
      Me in X && (me[Me] = X[Me]);
    if (X.evaluate && (me.evaluate = n(X.evaluate)), $(me.l, ie)) {
      var Q = !q(me.l, ie), ee;
      Q && (ee = de());
      var ye = G(me.l), Ee = de();
      me.expanded = {}, me.expanded.l = ye([me.l, Ee]), k(me.expanded.l, ie), L(me.expanded.l, ie), me.expanded.r = ye([me.r, Ee]), Q && (me.expandedNC1 = {}, me.expandedNC1.l = ye([ee, me.l]), me.expandedNC1.r = ye([ee, me.r]), me.expandedNC2 = {}, me.expandedNC2.l = ye([ee, me.expanded.l]), me.expandedNC2.r = ye([ee, me.expanded.r]));
    }
    return me;
  }
  function K(X, ie) {
    for (var me = [], Ae = 0; Ae < X.length; Ae++) {
      var Me = X[Ae], Q = void 0, ee = typeof Me;
      switch (ee) {
        case "string":
          Me = {
            s: Me
          };
        case "object":
          Q = be(Me, ie);
          break;
        case "function":
          Q = Me;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + ee);
      }
      me.push(Q);
    }
    return me;
  }
  var ce = 0;
  function de() {
    return new T("_p" + ce++);
  }
  function ue(X, ie) {
    var me = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Os(), Ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, Me = Ae.consoleDebug;
    ie = K(ie || Z.rules, Ae.context);
    var Q = c(X, me);
    Q = H(Q);
    for (var ee = {}, ye = Q.toString({
      parenthesis: "all"
    }); !ee[ye]; ) {
      ee[ye] = !0, ce = 0;
      var Ee = ye;
      Me && console.log("Working on: ", ye);
      for (var Ce = 0; Ce < ie.length; Ce++) {
        var De = "";
        if (typeof ie[Ce] == "function" ? (Q = ie[Ce](Q, Ae), Me && (De = ie[Ce].name)) : (k(Q, Ae.context), Q = he(Q, ie[Ce], Ae.context), Me && (De = "".concat(ie[Ce].l.toString(), " -> ").concat(ie[Ce].r.toString()))), Me) {
          var Oe = Q.toString({
            parenthesis: "all"
          });
          Oe !== Ee && (console.log("Applying", De, "produced", Oe), Ee = Oe);
        }
        R(Q, Ae.context);
      }
      ye = Q.toString({
        parenthesis: "all"
      });
    }
    return Q;
  }
  function ve(X, ie, me) {
    var Ae = X;
    if (X)
      for (var Me = 0; Me < X.length; ++Me) {
        var Q = he(X[Me], ie, me);
        Q !== X[Me] && (Ae === X && (Ae = X.slice()), Ae[Me] = Q);
      }
    return Ae;
  }
  function he(X, ie, me) {
    if (ie.assuming) {
      for (var Ae in ie.assuming)
        for (var Me in ie.assuming[Ae])
          if (I(Ae, Me, me) !== ie.assuming[Ae][Me])
            return X;
    }
    var Q = U(ie.imposeContext, me), ee = X;
    if (ee instanceof _ || ee instanceof D) {
      var ye = ve(ee.args, ie, me);
      ye !== ee.args && (ee = ee.clone(), ee.args = ye);
    } else if (ee instanceof O) {
      if (ee.content) {
        var Ee = he(ee.content, ie, me);
        Ee !== ee.content && (ee = new O(Ee));
      }
    } else if (ee instanceof x) {
      var Ce = ve(ee.items, ie, me);
      Ce !== ee.items && (ee = new x(Ce));
    } else if (ee instanceof C) {
      var De = ee.object;
      ee.object && (De = he(ee.object, ie, me));
      var Oe = ee.index;
      ee.index && (Oe = he(ee.index, ie, me)), (De !== ee.object || Oe !== ee.index) && (ee = new C(De, Oe));
    } else if (ee instanceof A) {
      var Be = ve(ee.dimensions, ie, me);
      Be !== ee.dimensions && (ee = new A(Be));
    } else if (ee instanceof M) {
      var Le = !1, Re = {};
      for (var rt in ee.properties)
        Re[rt] = he(ee.properties[rt], ie, me), Re[rt] !== ee.properties[rt] && (Le = !0);
      Le && (ee = new M(Re));
    }
    var Ke = ie.r, Ze = re(ie.l, ee, Q)[0];
    if (!Ze && ie.expanded && (Ke = ie.expanded.r, Ze = re(ie.expanded.l, ee, Q)[0]), !Ze && ie.expandedNC1 && (Ke = ie.expandedNC1.r, Ze = re(ie.expandedNC1.l, ee, Q)[0], Ze || (Ke = ie.expandedNC2.r, Ze = re(ie.expandedNC2.l, ee, Q)[0])), Ze) {
      var Ie = ee.implicit;
      ee = Ke.clone(), Ie && "implicit" in Ke && (ee.implicit = !0), ee = ee.transform(function(B) {
        return B.isSymbolNode && We(Ze.placeholders, B.name) ? Ze.placeholders[B.name].clone() : B;
      });
    }
    return ie.repeat && ee !== X && (ee = he(ee, ie, me)), ee;
  }
  function Ne(X, ie) {
    var me = [], Ae, Me, Q = G(X);
    if (q(X, ie))
      for (var ee = 0; ee < X.args.length; ee++)
        Me = X.args.slice(0), Me.splice(ee, 1), Ae = Me.length === 1 ? Me[0] : Q(Me), me.push(Q([X.args[ee], Ae]));
    else
      for (var ye = 1; ye < X.args.length; ye++) {
        var Ee = X.args[0];
        ye > 1 && (Ee = Q(X.args.slice(0, ye))), Me = X.args.slice(ye), Ae = Me.length === 1 ? Me[0] : Q(Me), me.push(Q([Ee, Ae]));
      }
    return me;
  }
  function we(X, ie) {
    var me = {
      placeholders: {}
    };
    if (!X.placeholders && !ie.placeholders)
      return me;
    if (X.placeholders) {
      if (!ie.placeholders)
        return X;
    } else return ie;
    for (var Ae in X.placeholders)
      if (We(X.placeholders, Ae) && (me.placeholders[Ae] = X.placeholders[Ae], We(ie.placeholders, Ae) && !pe(X.placeholders[Ae], ie.placeholders[Ae])))
        return null;
    for (var Me in ie.placeholders)
      We(ie.placeholders, Me) && (me.placeholders[Me] = ie.placeholders[Me]);
    return me;
  }
  function Se(X, ie) {
    var me = [];
    if (X.length === 0 || ie.length === 0)
      return me;
    for (var Ae, Me = 0; Me < X.length; Me++)
      for (var Q = 0; Q < ie.length; Q++)
        Ae = we(X[Me], ie[Q]), Ae && me.push(Ae);
    return me;
  }
  function V(X) {
    if (X.length === 0)
      return X;
    for (var ie = X.reduce(Se), me = [], Ae = {}, Me = 0; Me < ie.length; Me++) {
      var Q = JSON.stringify(ie[Me]);
      Ae[Q] || (Ae[Q] = !0, me.push(ie[Me]));
    }
    return me;
  }
  function re(X, ie, me, Ae) {
    var Me = [{
      placeholders: {}
    }];
    if (X instanceof _ && ie instanceof _ || X instanceof D && ie instanceof D) {
      if (X instanceof _) {
        if (X.op !== ie.op || X.fn !== ie.fn)
          return [];
      } else if (X instanceof D && X.name !== ie.name)
        return [];
      if (ie.args.length === 1 && X.args.length === 1 || !$(ie, me) && ie.args.length === X.args.length || Ae) {
        for (var Q = [], ee = 0; ee < X.args.length; ee++) {
          var ye = re(X.args[ee], ie.args[ee], me);
          if (ye.length === 0)
            break;
          Q.push(ye);
        }
        if (Q.length !== X.args.length) {
          if (!q(ie, me) || // exact match in order needed
          X.args.length === 1)
            return [];
          if (X.args.length > 2)
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          var Ee = re(X.args[0], ie.args[1], me);
          if (Ee.length === 0)
            return [];
          var Ce = re(X.args[1], ie.args[0], me);
          if (Ce.length === 0)
            return [];
          Q = [Ee, Ce];
        }
        Me = V(Q);
      } else if (ie.args.length >= 2 && X.args.length === 2) {
        for (var De = Ne(ie, me), Oe = [], Be = 0; Be < De.length; Be++) {
          var Le = re(X, De[Be], me, !0);
          Oe = Oe.concat(Le);
        }
        return Oe;
      } else {
        if (X.args.length > 2)
          throw Error("Unexpected non-binary associative function: " + X.toString());
        return [];
      }
    } else if (X instanceof T) {
      if (X.name.length === 0)
        throw new Error("Symbol in rule has 0 length...!?");
      if (te[X.name]) {
        if (X.name !== ie.name)
          return [];
      } else
        switch (X.name[1] >= "a" && X.name[1] <= "z" ? X.name.substring(0, 2) : X.name[0]) {
          case "n":
          case "_p":
            Me[0].placeholders[X.name] = ie;
            break;
          case "c":
          case "cl":
            if (Ct(ie))
              Me[0].placeholders[X.name] = ie;
            else
              return [];
            break;
          case "v":
            if (!Ct(ie))
              Me[0].placeholders[X.name] = ie;
            else
              return [];
            break;
          case "vl":
            if (mr(ie))
              Me[0].placeholders[X.name] = ie;
            else
              return [];
            break;
          case "cd":
            if (Kb(ie))
              Me[0].placeholders[X.name] = ie;
            else
              return [];
            break;
          case "vd":
            if (!Kb(ie))
              Me[0].placeholders[X.name] = ie;
            else
              return [];
            break;
          case "ce":
            if (xu(ie))
              Me[0].placeholders[X.name] = ie;
            else
              return [];
            break;
          case "ve":
            if (!xu(ie))
              Me[0].placeholders[X.name] = ie;
            else
              return [];
            break;
          default:
            throw new Error("Invalid symbol in rule: " + X.name);
        }
    } else if (X instanceof E) {
      if (!l(X.value, ie.value))
        return [];
    } else
      return [];
    return Me;
  }
  function pe(X, ie) {
    if (X instanceof E && ie instanceof E) {
      if (!l(X.value, ie.value))
        return !1;
    } else if (X instanceof T && ie instanceof T) {
      if (X.name !== ie.name)
        return !1;
    } else if (X instanceof _ && ie instanceof _ || X instanceof D && ie instanceof D) {
      if (X instanceof _) {
        if (X.op !== ie.op || X.fn !== ie.fn)
          return !1;
      } else if (X instanceof D && X.name !== ie.name)
        return !1;
      if (X.args.length !== ie.args.length)
        return !1;
      for (var me = 0; me < X.args.length; me++)
        if (!pe(X.args[me], ie.args[me]))
          return !1;
    } else
      return !1;
    return !0;
  }
  return Z;
}), J7 = "simplifyConstant", Y7 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"], ap = /* @__PURE__ */ j(J7, Y7, (t) => {
  var {
    typed: e,
    config: r,
    mathWithTransform: n,
    matrix: a,
    fraction: s,
    bignumber: o,
    AccessorNode: p,
    ArrayNode: u,
    ConstantNode: f,
    FunctionNode: l,
    IndexNode: c,
    ObjectNode: h,
    OperatorNode: d,
    SymbolNode: g
  } = t, {
    isCommutative: v,
    isAssociative: N,
    allChildren: b,
    createMakeNodeFunction: C
  } = Ud({
    FunctionNode: l,
    OperatorNode: d,
    SymbolNode: g
  }), x = e("simplifyConstant", {
    Node: (k) => M(U(k, {})),
    "Node, Object": function(L, R) {
      return M(U(L, R));
    }
  });
  function E(k) {
    return Fi(k) ? k.valueOf() : k instanceof Array ? k.map(E) : tt(k) ? a(E(k.valueOf())) : k;
  }
  function D(k, L, R) {
    try {
      return n[k].apply(null, L);
    } catch {
      return L = L.map(E), O(n[k].apply(null, L), R);
    }
  }
  var A = e({
    Fraction: I,
    number: function(L) {
      return L < 0 ? T(new f(-L)) : new f(L);
    },
    BigNumber: function(L) {
      return L < 0 ? T(new f(-L)) : new f(L);
    },
    bigint: function(L) {
      return L < 0n ? T(new f(-L)) : new f(L);
    },
    Complex: function(L) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function(L) {
      return new f(L);
    },
    Matrix: function(L) {
      return new u(L.valueOf().map((R) => A(R)));
    }
  });
  function M(k) {
    return Ut(k) ? k : A(k);
  }
  function _(k, L) {
    var R = L && L.exactFractions !== !1;
    if (R && isFinite(k) && s) {
      var G = s(k), P = L && typeof L.fractionsLimit == "number" ? L.fractionsLimit : 1 / 0;
      if (G.valueOf() === k && G.n < P && G.d < P)
        return G;
    }
    return k;
  }
  var O = e({
    "string, Object": function(L, R) {
      var G = Ii(L, r);
      if (G === "BigNumber")
        return o === void 0 && Od(), o(L);
      if (G === "bigint")
        return BigInt(L);
      if (G === "Fraction")
        return s === void 0 && Hw(), s(L);
      var P = parseFloat(L);
      return _(P, R);
    },
    "Fraction, Object": function(L, R) {
      return L;
    },
    // we don't need options here
    "BigNumber, Object": function(L, R) {
      return L;
    },
    // we don't need options here
    "number, Object": function(L, R) {
      return _(L, R);
    },
    "bigint, Object": function(L, R) {
      return L;
    },
    "Complex, Object": function(L, R) {
      return L.im !== 0 ? L : _(L.re, R);
    },
    "Matrix, Object": function(L, R) {
      return a(_(L.valueOf()));
    },
    "Array, Object": function(L, R) {
      return L.map(_);
    }
  });
  function T(k) {
    return new d("-", "unaryMinus", [k]);
  }
  function I(k) {
    var L, R = k.s * k.n;
    return R < 0 ? L = new d("-", "unaryMinus", [new f(-R)]) : L = new f(R), k.d === 1 ? L : new d("/", "divide", [L, new f(k.d)]);
  }
  function q(k, L, R) {
    if (!qi(L))
      return new p(M(k), M(L));
    if (un(k) || tt(k)) {
      for (var G = Array.from(L.dimensions); G.length > 0; )
        if (Ct(G[0]) && typeof G[0].value != "string") {
          var P = O(G.shift().value, R);
          un(k) ? k = k.items[P - 1] : (k = k.valueOf()[P - 1], k instanceof Array && (k = a(k)));
        } else if (G.length > 1 && Ct(G[1]) && typeof G[1].value != "string") {
          var W = O(G[1].value, R), le = [], Z = un(k) ? k.items : k.valueOf();
          for (var H of Z)
            if (un(H))
              le.push(H.items[W - 1]);
            else if (tt(k))
              le.push(H[W - 1]);
            else
              break;
          if (le.length === Z.length)
            un(k) ? k = new u(le) : k = a(le), G.splice(1, 1);
          else
            break;
        } else
          break;
      return G.length === L.dimensions.length ? new p(M(k), L) : G.length > 0 ? (L = new c(G), new p(M(k), L)) : k;
    }
    if (ja(k) && L.dimensions.length === 1 && Ct(L.dimensions[0])) {
      var te = L.dimensions[0].value;
      return te in k.properties ? k.properties[te] : new f();
    }
    return new p(M(k), L);
  }
  function $(k, L, R, G) {
    var P = L.shift(), W = L.reduce((le, Z) => {
      if (!Ut(Z)) {
        var H = le.pop();
        if (Ut(H))
          return [H, Z];
        try {
          return le.push(D(k, [H, Z], G)), le;
        } catch {
          le.push(H);
        }
      }
      le.push(M(le.pop()));
      var te = le.length === 1 ? le[0] : R(le);
      return [R([te, M(Z)])];
    }, [P]);
    return W.length === 1 ? W[0] : R([W[0], A(W[1])]);
  }
  function U(k, L) {
    switch (k.type) {
      case "SymbolNode":
        return k;
      case "ConstantNode":
        switch (typeof k.value) {
          case "number":
            return O(k.value, L);
          case "bigint":
            return O(k.value, L);
          case "string":
            return k.value;
          default:
            if (!isNaN(k.value)) return O(k.value, L);
        }
        return k;
      case "FunctionNode":
        if (n[k.name] && n[k.name].rawArgs)
          return k;
        {
          var R = ["add", "multiply"];
          if (!R.includes(k.name)) {
            var G = k.args.map((he) => U(he, L));
            if (!G.some(Ut))
              try {
                return D(k.name, G, L);
              } catch {
              }
            if (k.name === "size" && G.length === 1 && un(G[0])) {
              for (var P = [], W = G[0]; un(W); )
                P.push(W.items.length), W = W.items[0];
              return a(P);
            }
            return new l(k.name, G.map(M));
          }
        }
      case "OperatorNode": {
        var le = k.fn.toString(), Z, H, te = C(k);
        if (or(k) && k.isUnary())
          Z = [U(k.args[0], L)], Ut(Z[0]) ? H = te(Z) : H = D(le, Z, L);
        else if (N(k, L.context))
          if (Z = b(k, L.context), Z = Z.map((he) => U(he, L)), v(le, L.context)) {
            for (var be = [], K = [], ce = 0; ce < Z.length; ce++)
              Ut(Z[ce]) ? K.push(Z[ce]) : be.push(Z[ce]);
            be.length > 1 ? (H = $(le, be, te, L), K.unshift(H), H = $(le, K, te, L)) : H = $(le, Z, te, L);
          } else
            H = $(le, Z, te, L);
        else
          Z = k.args.map((he) => U(he, L)), H = $(le, Z, te, L);
        return H;
      }
      case "ParenthesisNode":
        return U(k.content, L);
      case "AccessorNode":
        return q(U(k.object, L), U(k.index, L), L);
      case "ArrayNode": {
        var de = k.items.map((he) => U(he, L));
        return de.some(Ut) ? new u(de.map(M)) : a(de);
      }
      case "IndexNode":
        return new c(k.dimensions.map((he) => x(he, L)));
      case "ObjectNode": {
        var ue = {};
        for (var ve in k.properties)
          ue[ve] = x(k.properties[ve], L);
        return new h(ue);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(k.type));
    }
  }
  return x;
}), t2 = "simplifyCore", X7 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"], sp = /* @__PURE__ */ j(t2, X7, (t) => {
  var {
    typed: e,
    parse: r,
    equal: n,
    isZero: a,
    add: s,
    subtract: o,
    multiply: p,
    divide: u,
    pow: f,
    AccessorNode: l,
    ArrayNode: c,
    ConstantNode: h,
    FunctionNode: d,
    IndexNode: g,
    ObjectNode: v,
    OperatorNode: N,
    ParenthesisNode: b,
    SymbolNode: C
  } = t, x = new h(0), E = new h(1), D = new h(!0), A = new h(!1);
  function M(I) {
    return or(I) && ["and", "not", "or"].includes(I.op);
  }
  var {
    hasProperty: _,
    isCommutative: O
  } = Ud({
    FunctionNode: d,
    OperatorNode: N,
    SymbolNode: C
  });
  function T(I) {
    var q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $ = q ? q.context : void 0;
    if (_(I, "trivial", $)) {
      if (Wn(I) && I.args.length === 1)
        return T(I.args[0], q);
      var U = !1, k = 0;
      if (I.forEach((K) => {
        ++k, k === 1 && (U = T(K, q));
      }), k === 1)
        return U;
    }
    var L = I;
    if (Wn(L)) {
      var R = uq(L.name);
      if (R) {
        if (L.args.length > 2 && _(L, "associative", $))
          for (; L.args.length > 2; ) {
            var G = L.args.pop(), P = L.args.pop();
            L.args.push(new N(R, L.name, [G, P]));
          }
        L = new N(R, L.name, L.args);
      } else
        return new d(T(L.fn), L.args.map((K) => T(K, q)));
    }
    if (or(L) && L.isUnary()) {
      var W = T(L.args[0], q);
      if (L.op === "~" && or(W) && W.isUnary() && W.op === "~" || L.op === "not" && or(W) && W.isUnary() && W.op === "not" && M(W.args[0]))
        return W.args[0];
      var le = !0;
      if (L.op === "-" && or(W) && (W.isBinary() && W.fn === "subtract" && (L = new N("-", "subtract", [W.args[1], W.args[0]]), le = !1), W.isUnary() && W.op === "-"))
        return W.args[0];
      if (le) return new N(L.op, L.fn, [W]);
    }
    if (or(L) && L.isBinary()) {
      var Z = T(L.args[0], q), H = T(L.args[1], q);
      if (L.op === "+") {
        if (Ct(Z) && a(Z.value))
          return H;
        if (Ct(H) && a(H.value))
          return Z;
        or(H) && H.isUnary() && H.op === "-" && (H = H.args[0], L = new N("-", "subtract", [Z, H]));
      }
      if (L.op === "-")
        return or(H) && H.isUnary() && H.op === "-" ? T(new N("+", "add", [Z, H.args[0]]), q) : Ct(Z) && a(Z.value) ? T(new N("-", "unaryMinus", [H])) : Ct(H) && a(H.value) ? Z : new N(L.op, L.fn, [Z, H]);
      if (L.op === "*") {
        if (Ct(Z)) {
          if (a(Z.value))
            return x;
          if (n(Z.value, 1))
            return H;
        }
        if (Ct(H)) {
          if (a(H.value))
            return x;
          if (n(H.value, 1))
            return Z;
          if (O(L, $))
            return new N(L.op, L.fn, [H, Z], L.implicit);
        }
        return new N(L.op, L.fn, [Z, H], L.implicit);
      }
      if (L.op === "/")
        return Ct(Z) && a(Z.value) ? x : Ct(H) && n(H.value, 1) ? Z : new N(L.op, L.fn, [Z, H]);
      if (L.op === "^" && Ct(H)) {
        if (a(H.value))
          return E;
        if (n(H.value, 1))
          return Z;
      }
      if (L.op === "and") {
        if (Ct(Z))
          if (Z.value) {
            if (M(H)) return H;
            if (Ct(H))
              return H.value ? D : A;
          } else
            return A;
        if (Ct(H))
          if (H.value) {
            if (M(Z)) return Z;
          } else
            return A;
      }
      if (L.op === "or") {
        if (Ct(Z)) {
          if (Z.value)
            return D;
          if (M(H)) return H;
        }
        if (Ct(H)) {
          if (H.value)
            return D;
          if (M(Z)) return Z;
        }
      }
      return new N(L.op, L.fn, [Z, H]);
    }
    if (or(L))
      return new N(L.op, L.fn, L.args.map((K) => T(K, q)));
    if (un(L))
      return new c(L.items.map((K) => T(K, q)));
    if (pi(L))
      return new l(T(L.object, q), T(L.index, q));
    if (qi(L))
      return new g(L.dimensions.map((K) => T(K, q)));
    if (ja(L)) {
      var te = {};
      for (var be in L.properties)
        te[be] = T(L.properties[be], q);
      return new v(te);
    }
    return L;
  }
  return e(t2, {
    Node: T,
    "Node,Object": T
  });
}), K7 = "resolve", eR = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"], op = /* @__PURE__ */ j(K7, eR, (t) => {
  var {
    typed: e,
    parse: r,
    ConstantNode: n,
    FunctionNode: a,
    OperatorNode: s,
    ParenthesisNode: o
  } = t;
  function p(u, f) {
    var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
    if (!f)
      return u;
    if (mr(u)) {
      if (l.has(u.name)) {
        var c = Array.from(l).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(c, "}"));
      }
      var h = f.get(u.name);
      if (Ut(h)) {
        var d = new Set(l);
        return d.add(u.name), p(h, f, d);
      } else return typeof h == "number" ? r(String(h)) : h !== void 0 ? new n(h) : u;
    } else if (or(u)) {
      var g = u.args.map(function(N) {
        return p(N, f, l);
      });
      return new s(u.op, u.fn, g, u.implicit);
    } else {
      if (kn(u))
        return new o(p(u.content, f, l));
      if (Wn(u)) {
        var v = u.args.map(function(N) {
          return p(N, f, l);
        });
        return new a(u.name, v);
      }
    }
    return u.map((N) => p(N, f, l));
  }
  return e("resolve", {
    Node: p,
    "Node, Map | null | undefined": p,
    "Node, Object": (u, f) => p(u, Ia(f)),
    // For arrays and matrices, we map `self` rather than `_resolve`
    // because resolve is fairly expensive anyway, and this way
    // we get nice error messages if one entry in the array has wrong type.
    "Array | Matrix": e.referToSelf((u) => (f) => f.map((l) => u(l))),
    "Array | Matrix, null | undefined": e.referToSelf((u) => (f) => f.map((l) => u(l))),
    "Array, Object": e.referTo("Array,Map", (u) => (f, l) => u(f, Ia(l))),
    "Matrix, Object": e.referTo("Matrix,Map", (u) => (f, l) => u(f, Ia(l))),
    "Array | Matrix, Map": e.referToSelf((u) => (f, l) => f.map((c) => u(c, l)))
  });
}), r2 = "symbolicEqual", tR = ["parse", "simplify", "typed", "OperatorNode"], up = /* @__PURE__ */ j(r2, tR, (t) => {
  var {
    parse: e,
    simplify: r,
    typed: n,
    OperatorNode: a
  } = t;
  function s(o, p) {
    var u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, f = new a("-", "subtract", [o, p]), l = r(f, {}, u);
    return Ct(l) && !l.value;
  }
  return n(r2, {
    "Node, Node": s,
    "Node, Node, Object": s
  });
}), n2 = "derivative", rR = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"], lp = /* @__PURE__ */ j(n2, rR, (t) => {
  var {
    typed: e,
    config: r,
    parse: n,
    simplify: a,
    equal: s,
    isZero: o,
    numeric: p,
    ConstantNode: u,
    FunctionNode: f,
    OperatorNode: l,
    ParenthesisNode: c,
    SymbolNode: h
  } = t;
  function d(x, E) {
    var D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      simplify: !0
    }, A = {};
    N(A, x, E.name);
    var M = b(x, A);
    return D.simplify ? a(M) : M;
  }
  e.addConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: n
  });
  var g = e(n2, {
    "Node, SymbolNode": d,
    "Node, SymbolNode, Object": d
    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
      let res = expr
      for (let i = 0; i < order; i++) {
        let constNodes = {}
        constTag(constNodes, expr, variable.name)
        res = _derivative(res, constNodes)
      }
      return res
    }
    */
  });
  e.removeConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: n
  }), g._simplify = !0, g.toTex = function(x) {
    return v.apply(null, x.args);
  };
  var v = e("_derivTex", {
    "Node, SymbolNode": function(E, D) {
      return Ct(E) && Vt(E.value) === "string" ? v(n(E.value).toString(), D.toString(), 1) : v(E.toTex(), D.toString(), 1);
    },
    "Node, ConstantNode": function(E, D) {
      if (Vt(D.value) === "string")
        return v(E, n(D.value));
      throw new Error("The second parameter to 'derivative' is a non-string constant");
    },
    "Node, SymbolNode, ConstantNode": function(E, D, A) {
      return v(E.toString(), D.name, A.value);
    },
    "string, string, number": function(E, D, A) {
      var M;
      return A === 1 ? M = "{d\\over d" + D + "}" : M = "{d^{" + A + "}\\over d" + D + "^{" + A + "}}", M + "\\left[".concat(E, "\\right]");
    }
  }), N = e("constTag", {
    "Object, ConstantNode, string": function(E, D) {
      return E[D] = !0, !0;
    },
    "Object, SymbolNode, string": function(E, D, A) {
      return D.name !== A ? (E[D] = !0, !0) : !1;
    },
    "Object, ParenthesisNode, string": function(E, D, A) {
      return N(E, D.content, A);
    },
    "Object, FunctionAssignmentNode, string": function(E, D, A) {
      return D.params.includes(A) ? N(E, D.expr, A) : (E[D] = !0, !0);
    },
    "Object, FunctionNode | OperatorNode, string": function(E, D, A) {
      if (D.args.length > 0) {
        for (var M = N(E, D.args[0], A), _ = 1; _ < D.args.length; ++_)
          M = N(E, D.args[_], A) && M;
        if (M)
          return E[D] = !0, !0;
      }
      return !1;
    }
  }), b = e("_derivative", {
    "ConstantNode, Object": function(E) {
      return C(0);
    },
    "SymbolNode, Object": function(E, D) {
      return D[E] !== void 0 ? C(0) : C(1);
    },
    "ParenthesisNode, Object": function(E, D) {
      return new c(b(E.content, D));
    },
    "FunctionAssignmentNode, Object": function(E, D) {
      return D[E] !== void 0 ? C(0) : b(E.expr, D);
    },
    "FunctionNode, Object": function(E, D) {
      if (D[E] !== void 0)
        return C(0);
      var A = E.args[0], M, _ = !1, O = !1, T;
      switch (E.name) {
        case "cbrt":
          _ = !0, T = new l("*", "multiply", [C(3), new l("^", "pow", [A, new l("/", "divide", [C(2), C(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (E.args.length === 1)
            _ = !0, T = new l("*", "multiply", [C(2), new f("sqrt", [A])]);
          else if (E.args.length === 2)
            return M = new l("/", "divide", [C(1), E.args[1]]), D[M] = D[E.args[1]], b(new l("^", "pow", [A, M]), D);
          break;
        case "log10":
          M = C(10);
        case "log":
          if (!M && E.args.length === 1)
            T = A.clone(), _ = !0;
          else if (E.args.length === 1 && M || E.args.length === 2 && D[E.args[1]] !== void 0)
            T = new l("*", "multiply", [A.clone(), new f("log", [M || E.args[1]])]), _ = !0;
          else if (E.args.length === 2)
            return b(new l("/", "divide", [new f("log", [A]), new f("log", [E.args[1]])]), D);
          break;
        case "pow":
          if (E.args.length === 2)
            return D[M] = D[E.args[1]], b(new l("^", "pow", [A, E.args[1]]), D);
          break;
        case "exp":
          T = new f("exp", [A.clone()]);
          break;
        case "sin":
          T = new f("cos", [A.clone()]);
          break;
        case "cos":
          T = new l("-", "unaryMinus", [new f("sin", [A.clone()])]);
          break;
        case "tan":
          T = new l("^", "pow", [new f("sec", [A.clone()]), C(2)]);
          break;
        case "sec":
          T = new l("*", "multiply", [E, new f("tan", [A.clone()])]);
          break;
        case "csc":
          O = !0, T = new l("*", "multiply", [E, new f("cot", [A.clone()])]);
          break;
        case "cot":
          O = !0, T = new l("^", "pow", [new f("csc", [A.clone()]), C(2)]);
          break;
        case "asin":
          _ = !0, T = new f("sqrt", [new l("-", "subtract", [C(1), new l("^", "pow", [A.clone(), C(2)])])]);
          break;
        case "acos":
          _ = !0, O = !0, T = new f("sqrt", [new l("-", "subtract", [C(1), new l("^", "pow", [A.clone(), C(2)])])]);
          break;
        case "atan":
          _ = !0, T = new l("+", "add", [new l("^", "pow", [A.clone(), C(2)]), C(1)]);
          break;
        case "asec":
          _ = !0, T = new l("*", "multiply", [new f("abs", [A.clone()]), new f("sqrt", [new l("-", "subtract", [new l("^", "pow", [A.clone(), C(2)]), C(1)])])]);
          break;
        case "acsc":
          _ = !0, O = !0, T = new l("*", "multiply", [new f("abs", [A.clone()]), new f("sqrt", [new l("-", "subtract", [new l("^", "pow", [A.clone(), C(2)]), C(1)])])]);
          break;
        case "acot":
          _ = !0, O = !0, T = new l("+", "add", [new l("^", "pow", [A.clone(), C(2)]), C(1)]);
          break;
        case "sinh":
          T = new f("cosh", [A.clone()]);
          break;
        case "cosh":
          T = new f("sinh", [A.clone()]);
          break;
        case "tanh":
          T = new l("^", "pow", [new f("sech", [A.clone()]), C(2)]);
          break;
        case "sech":
          O = !0, T = new l("*", "multiply", [E, new f("tanh", [A.clone()])]);
          break;
        case "csch":
          O = !0, T = new l("*", "multiply", [E, new f("coth", [A.clone()])]);
          break;
        case "coth":
          O = !0, T = new l("^", "pow", [new f("csch", [A.clone()]), C(2)]);
          break;
        case "asinh":
          _ = !0, T = new f("sqrt", [new l("+", "add", [new l("^", "pow", [A.clone(), C(2)]), C(1)])]);
          break;
        case "acosh":
          _ = !0, T = new f("sqrt", [new l("-", "subtract", [new l("^", "pow", [A.clone(), C(2)]), C(1)])]);
          break;
        case "atanh":
          _ = !0, T = new l("-", "subtract", [C(1), new l("^", "pow", [A.clone(), C(2)])]);
          break;
        case "asech":
          _ = !0, O = !0, T = new l("*", "multiply", [A.clone(), new f("sqrt", [new l("-", "subtract", [C(1), new l("^", "pow", [A.clone(), C(2)])])])]);
          break;
        case "acsch":
          _ = !0, O = !0, T = new l("*", "multiply", [new f("abs", [A.clone()]), new f("sqrt", [new l("+", "add", [new l("^", "pow", [A.clone(), C(2)]), C(1)])])]);
          break;
        case "acoth":
          _ = !0, O = !0, T = new l("-", "subtract", [C(1), new l("^", "pow", [A.clone(), C(2)])]);
          break;
        case "abs":
          T = new l("/", "divide", [new f(new h("abs"), [A.clone()]), A.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Cannot process function "' + E.name + '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported');
      }
      var I, q;
      _ ? (I = "/", q = "divide") : (I = "*", q = "multiply");
      var $ = b(A, D);
      return O && ($ = new l("-", "unaryMinus", [$])), new l(I, q, [$, T]);
    },
    "OperatorNode, Object": function(E, D) {
      if (D[E] !== void 0)
        return C(0);
      if (E.op === "+")
        return new l(E.op, E.fn, E.args.map(function(k) {
          return b(k, D);
        }));
      if (E.op === "-") {
        if (E.isUnary())
          return new l(E.op, E.fn, [b(E.args[0], D)]);
        if (E.isBinary())
          return new l(E.op, E.fn, [b(E.args[0], D), b(E.args[1], D)]);
      }
      if (E.op === "*") {
        var A = E.args.filter(function(k) {
          return D[k] !== void 0;
        });
        if (A.length > 0) {
          var M = E.args.filter(function(k) {
            return D[k] === void 0;
          }), _ = M.length === 1 ? M[0] : new l("*", "multiply", M), O = A.concat(b(_, D));
          return new l("*", "multiply", O);
        }
        return new l("+", "add", E.args.map(function(k) {
          return new l("*", "multiply", E.args.map(function(L) {
            return L === k ? b(L, D) : L.clone();
          }));
        }));
      }
      if (E.op === "/" && E.isBinary()) {
        var T = E.args[0], I = E.args[1];
        return D[I] !== void 0 ? new l("/", "divide", [b(T, D), I]) : D[T] !== void 0 ? new l("*", "multiply", [new l("-", "unaryMinus", [T]), new l("/", "divide", [b(I, D), new l("^", "pow", [I.clone(), C(2)])])]) : new l("/", "divide", [new l("-", "subtract", [new l("*", "multiply", [b(T, D), I.clone()]), new l("*", "multiply", [T.clone(), b(I, D)])]), new l("^", "pow", [I.clone(), C(2)])]);
      }
      if (E.op === "^" && E.isBinary()) {
        var q = E.args[0], $ = E.args[1];
        if (D[q] !== void 0)
          return Ct(q) && (o(q.value) || s(q.value, 1)) ? C(0) : new l("*", "multiply", [E, new l("*", "multiply", [new f("log", [q.clone()]), b($.clone(), D)])]);
        if (D[$] !== void 0) {
          if (Ct($)) {
            if (o($.value))
              return C(0);
            if (s($.value, 1))
              return b(q, D);
          }
          var U = new l("^", "pow", [q.clone(), new l("-", "subtract", [$, C(1)])]);
          return new l("*", "multiply", [$.clone(), new l("*", "multiply", [b(q, D), U])]);
        }
        return new l("*", "multiply", [new l("^", "pow", [q.clone(), $.clone()]), new l("+", "add", [new l("*", "multiply", [b(q, D), new l("/", "divide", [$.clone(), q.clone()])]), new l("*", "multiply", [b($, D), new f("log", [q.clone()])])])]);
      }
      throw new Error('Cannot process operator "' + E.op + '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported');
    }
  });
  function C(x, E) {
    return new u(p(x, Ii(String(x), r)));
  }
  return g;
}), i2 = "rationalize", nR = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"], cp = /* @__PURE__ */ j(i2, nR, (t) => {
  var {
    config: e,
    typed: r,
    equal: n,
    isZero: a,
    add: s,
    subtract: o,
    multiply: p,
    divide: u,
    pow: f,
    parse: l,
    simplifyConstant: c,
    simplifyCore: h,
    simplify: d,
    fraction: g,
    bignumber: v,
    mathWithTransform: N,
    matrix: b,
    AccessorNode: C,
    ArrayNode: x,
    ConstantNode: E,
    FunctionNode: D,
    IndexNode: A,
    ObjectNode: M,
    OperatorNode: _,
    SymbolNode: O,
    ParenthesisNode: T
  } = t;
  function I(L) {
    var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, P = $(), W = q(L, R, !0, P.firstRules), le = W.variables.length, Z = {
      exactFractions: !1
    }, H = {
      exactFractions: !0
    };
    if (L = W.expression, le >= 1) {
      L = U(L);
      var te, be, K = !0, ce = !1;
      L = d(L, P.firstRules, {}, Z);
      for (var de; be = K ? P.distrDivRules : P.sucDivRules, L = d(L, be, {}, H), K = !K, de = L.toString(), de !== te; )
        ce = !0, te = de;
      ce && (L = d(L, P.firstRulesAgain, {}, Z)), L = d(L, P.finalRules, {}, Z);
    }
    var ue = [], ve = {};
    return L.type === "OperatorNode" && L.isBinary() && L.op === "/" ? (le === 1 && (L.args[0] = k(L.args[0], ue), L.args[1] = k(L.args[1])), G && (ve.numerator = L.args[0], ve.denominator = L.args[1])) : (le === 1 && (L = k(L, ue)), G && (ve.numerator = L, ve.denominator = null)), G ? (ve.coefficients = ue, ve.variables = W.variables, ve.expression = L, ve) : L;
  }
  return r(i2, {
    Node: I,
    "Node, boolean": (L, R) => I(L, {}, R),
    "Node, Object": I,
    "Node, Object, boolean": I
  });
  function q(L, R, G, P) {
    var W = [], le = d(L, P, R, {
      exactFractions: !1
    });
    G = !!G;
    var Z = "+-*" + (G ? "/" : "");
    te(le);
    var H = {};
    return H.expression = le, H.variables = W, H;
    function te(be) {
      var K = be.type;
      if (K === "FunctionNode")
        throw new Error("There is an unsolved function call");
      if (K === "OperatorNode")
        if (be.op === "^") {
          if (be.args[1].type !== "ConstantNode" || !Xe(parseFloat(be.args[1].value)))
            throw new Error("There is a non-integer exponent");
          te(be.args[0]);
        } else {
          if (!Z.includes(be.op))
            throw new Error("Operator " + be.op + " invalid in polynomial expression");
          for (var ce = 0; ce < be.args.length; ce++)
            te(be.args[ce]);
        }
      else if (K === "SymbolNode") {
        var de = be.name, ue = W.indexOf(de);
        ue === -1 && W.push(de);
      } else if (K === "ParenthesisNode")
        te(be.content);
      else if (K !== "ConstantNode")
        throw new Error("type " + K + " is not allowed in polynomial expression");
    }
  }
  function $() {
    var L = [
      h,
      // sCore
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      c,
      // sConstant
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ], R = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      // Unary division
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      // Unary multiplication
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      // '--' elimination
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      // Subtraction turn into add with un�ry minus
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      // Distributive 1
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      // Distributive 2
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      // Joining constants
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      // Joining constants
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      // Joining constants
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      // Joining constants
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "-v*-c",
        r: "c*v"
      },
      // Inversion constant and variable 1
      {
        l: "-v*c",
        r: "-c*v"
      },
      // Inversion constant and variable 2
      {
        l: "v*-c",
        r: "-c*v"
      },
      // Inversion constant and variable 3
      {
        l: "v*c",
        r: "c*v"
      },
      // Inversion constant and variable 4
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      // Unary propagation
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      // Unary propagation
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      // Unary propagation
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      // Unary propagation
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      // Power to Power
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      // Division and Unary
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ], G = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      // Sum of fractions
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      // Sum fraction with number 1
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ], P = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      // Division simplification
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ], W = {};
    return W.firstRules = L.concat(R, P), W.distrDivRules = G, W.sucDivRules = P, W.firstRulesAgain = L.concat(R), W.finalRules = [
      h,
      // simplify.rules[0]
      {
        l: "n*-n",
        r: "-n^2"
      },
      // Joining multiply with power 1
      {
        l: "n*n",
        r: "n^2"
      },
      // Joining multiply with power 2
      c,
      // simplify.rules[14] old 3rd index in oldRules
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 3
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 4
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      // Joining multiply with power 5
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      // Joining multiply with power 6
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 7
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      // Joining division with power 1
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      // Joining division with power 2
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      // Joining division with power 3
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 4
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 5
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      // Solving useless parenthesis 1
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      // Solving useless unary 2
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      // Solving +- together (new!)
      {
        l: "v*c",
        r: "c*v"
      },
      // inversion constant with variable
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
      // Power to Power
    ], W;
  }
  function U(L, R, G) {
    var P = L.type, W = arguments.length > 1;
    if (P === "OperatorNode" && L.isBinary()) {
      var le = !1, Z;
      if (L.op === "^" && (L.args[0].type === "ParenthesisNode" || L.args[0].type === "OperatorNode") && L.args[1].type === "ConstantNode" && (Z = parseFloat(L.args[1].value), le = Z >= 2 && Xe(Z)), le) {
        if (Z > 2) {
          var H = L.args[0], te = new _("^", "pow", [L.args[0].cloneDeep(), new E(Z - 1)]);
          L = new _("*", "multiply", [H, te]);
        } else
          L = new _("*", "multiply", [L.args[0], L.args[0].cloneDeep()]);
        W && (G === "content" ? R.content = L : R.args[G] = L);
      }
    }
    if (P === "ParenthesisNode")
      U(L.content, L, "content");
    else if (P !== "ConstantNode" && P !== "SymbolNode")
      for (var be = 0; be < L.args.length; be++)
        U(L.args[be], L, be);
    if (!W)
      return L;
  }
  function k(L, R) {
    R === void 0 && (R = []), R[0] = 0;
    var G = {};
    G.cte = 1, G.oper = "+", G.fire = "";
    var P = 0, W = "";
    de(L, null, G), P = R.length - 1;
    for (var le = !0, Z, H = P; H >= 0; H--)
      if (R[H] !== 0) {
        var te = new E(le ? R[H] : Math.abs(R[H])), be = R[H] < 0 ? "-" : "+";
        if (H > 0) {
          var K = new O(W);
          if (H > 1) {
            var ce = new E(H);
            K = new _("^", "pow", [K, ce]);
          }
          R[H] === -1 && le ? te = new _("-", "unaryMinus", [K]) : Math.abs(R[H]) === 1 ? te = K : te = new _("*", "multiply", [te, K]);
        }
        le ? Z = te : be === "+" ? Z = new _("+", "add", [Z, te]) : Z = new _("-", "subtract", [Z, te]), le = !1;
      }
    if (le)
      return new E(0);
    return Z;
    function de(ue, ve, he) {
      var Ne = ue.type;
      if (Ne === "FunctionNode")
        throw new Error("There is an unsolved function call");
      if (Ne === "OperatorNode") {
        if (!"+-*^".includes(ue.op)) throw new Error("Operator " + ue.op + " invalid");
        if (ve !== null) {
          if ((ue.fn === "unaryMinus" || ue.fn === "pow") && ve.fn !== "add" && ve.fn !== "subtract" && ve.fn !== "multiply")
            throw new Error("Invalid " + ue.op + " placing");
          if ((ue.fn === "subtract" || ue.fn === "add" || ue.fn === "multiply") && ve.fn !== "add" && ve.fn !== "subtract")
            throw new Error("Invalid " + ue.op + " placing");
          if ((ue.fn === "subtract" || ue.fn === "add" || ue.fn === "unaryMinus") && he.noFil !== 0)
            throw new Error("Invalid " + ue.op + " placing");
        }
        (ue.op === "^" || ue.op === "*") && (he.fire = ue.op);
        for (var we = 0; we < ue.args.length; we++)
          ue.fn === "unaryMinus" && (he.oper = "-"), (ue.op === "+" || ue.fn === "subtract") && (he.fire = "", he.cte = 1, he.oper = we === 0 ? "+" : ue.op), he.noFil = we, de(ue.args[we], ue, he);
      } else if (Ne === "SymbolNode") {
        if (ue.name !== W && W !== "")
          throw new Error("There is more than one variable");
        if (W = ue.name, ve === null) {
          R[1] = 1;
          return;
        }
        if (ve.op === "^" && he.noFil !== 0)
          throw new Error("In power the variable should be the first parameter");
        if (ve.op === "*" && he.noFil !== 1)
          throw new Error("In multiply the variable should be the second parameter");
        (he.fire === "" || he.fire === "*") && (P < 1 && (R[1] = 0), R[1] += he.cte * (he.oper === "+" ? 1 : -1), P = Math.max(1, P));
      } else if (Ne === "ConstantNode") {
        var Se = parseFloat(ue.value);
        if (ve === null) {
          R[0] = Se;
          return;
        }
        if (ve.op === "^") {
          if (he.noFil !== 1) throw new Error("Constant cannot be powered");
          if (!Xe(Se) || Se <= 0)
            throw new Error("Non-integer exponent is not allowed");
          for (var V = P + 1; V < Se; V++) R[V] = 0;
          Se > P && (R[Se] = 0), R[Se] += he.cte * (he.oper === "+" ? 1 : -1), P = Math.max(Se, P);
          return;
        }
        he.cte = Se, he.fire === "" && (R[0] += he.cte * (he.oper === "+" ? 1 : -1));
      } else
        throw new Error("Type " + Ne + " is not allowed");
    }
  }
}), a2 = "zpk2tf", iR = ["typed", "add", "multiply", "Complex", "number"], fp = /* @__PURE__ */ j(a2, iR, (t) => {
  var {
    typed: e,
    add: r,
    multiply: n,
    Complex: a,
    number: s
  } = t;
  return e(a2, {
    "Array,Array,number": function(f, l, c) {
      return o(f, l, c);
    },
    "Array,Array": function(f, l) {
      return o(f, l, 1);
    },
    "Matrix,Matrix,number": function(f, l, c) {
      return o(f.valueOf(), l.valueOf(), c);
    },
    "Matrix,Matrix": function(f, l) {
      return o(f.valueOf(), l.valueOf(), 1);
    }
  });
  function o(u, f, l) {
    u.some((C) => C.type === "BigNumber") && (u = u.map((C) => s(C))), f.some((C) => C.type === "BigNumber") && (f = f.map((C) => s(C)));
    for (var c = [a(1, 0)], h = [a(1, 0)], d = 0; d < u.length; d++) {
      var g = u[d];
      typeof g == "number" && (g = a(g, 0)), c = p(c, [a(1, 0), a(-g.re, -g.im)]);
    }
    for (var v = 0; v < f.length; v++) {
      var N = f[v];
      typeof N == "number" && (N = a(N, 0)), h = p(h, [a(1, 0), a(-N.re, -N.im)]);
    }
    for (var b = 0; b < c.length; b++)
      c[b] = n(c[b], l);
    return [c, h];
  }
  function p(u, f) {
    for (var l = [], c = 0; c < u.length + f.length - 1; c++) {
      l[c] = a(0, 0);
      for (var h = 0; h < u.length; h++)
        c - h >= 0 && c - h < f.length && (l[c] = r(l[c], n(u[h], f[c - h])));
    }
    return l;
  }
}), s2 = "freqz", aR = ["typed", "add", "multiply", "Complex", "divide", "matrix"], pp = /* @__PURE__ */ j(s2, aR, (t) => {
  var {
    typed: e,
    add: r,
    multiply: n,
    Complex: a,
    divide: s,
    matrix: o
  } = t;
  return e(s2, {
    "Array, Array": function(l, c) {
      var h = u(512);
      return p(l, c, h);
    },
    "Array, Array, Array": function(l, c, h) {
      return p(l, c, h);
    },
    "Array, Array, number": function(l, c, h) {
      if (h < 0)
        throw new Error("w must be a positive number");
      var d = u(h);
      return p(l, c, d);
    },
    "Matrix, Matrix": function(l, c) {
      var h = u(512), {
        w: d,
        h: g
      } = p(l.valueOf(), c.valueOf(), h);
      return {
        w: o(d),
        h: o(g)
      };
    },
    "Matrix, Matrix, Matrix": function(l, c, h) {
      var {
        h: d
      } = p(l.valueOf(), c.valueOf(), h.valueOf());
      return {
        h: o(d),
        w: o(h)
      };
    },
    "Matrix, Matrix, number": function(l, c, h) {
      if (h < 0)
        throw new Error("w must be a positive number");
      var d = u(h), {
        h: g
      } = p(l.valueOf(), c.valueOf(), d);
      return {
        h: o(g),
        w: o(d)
      };
    }
  });
  function p(f, l, c) {
    for (var h = [], d = [], g = 0; g < c.length; g++) {
      for (var v = a(0, 0), N = a(0, 0), b = 0; b < f.length; b++)
        v = r(v, n(f[b], a(Math.cos(-b * c[g]), Math.sin(-b * c[g]))));
      for (var C = 0; C < l.length; C++)
        N = r(N, n(l[C], a(Math.cos(-C * c[g]), Math.sin(-C * c[g]))));
      h.push(v), d.push(N);
    }
    for (var x = [], E = 0; E < h.length; E++)
      x.push(s(h[E], d[E]));
    return {
      h: x,
      w: c
    };
  }
  function u(f) {
    for (var l = [], c = 0; c < f; c++)
      l.push(c / f * Math.PI);
    return l;
  }
}), sR = "reviver", oR = ["classes"], hp = /* @__PURE__ */ j(sR, oR, (t) => {
  var {
    classes: e
  } = t;
  return function(n, a) {
    var s = e[a && a.mathjs];
    return s && typeof s.fromJSON == "function" ? s.fromJSON(a) : a;
  };
}), uR = "replacer", lR = [], mp = /* @__PURE__ */ j(uR, lR, () => function(e, r) {
  return typeof r == "number" && (!isFinite(r) || isNaN(r)) ? {
    mathjs: "number",
    value: String(r)
  } : typeof r == "bigint" ? {
    mathjs: "bigint",
    value: String(r)
  } : r;
}), cR = "13.0.0", dp = /* @__PURE__ */ j("true", [], () => !0), vp = /* @__PURE__ */ j("false", [], () => !1), gp = /* @__PURE__ */ j("null", [], () => null), yp = /* @__PURE__ */ xn("Infinity", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(1 / 0) : 1 / 0;
}), xp = /* @__PURE__ */ xn("NaN", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(NaN) : NaN;
}), bp = /* @__PURE__ */ xn("pi", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? Id(r) : VT;
}), wp = /* @__PURE__ */ xn("tau", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? sF(r) : WT;
}), Np = /* @__PURE__ */ xn("e", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? iF(r) : jT;
}), Dp = /* @__PURE__ */ xn("phi", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? aF(r) : ZT;
}), Ap = /* @__PURE__ */ xn("LN2", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(2).ln() : Math.LN2;
}), Ep = /* @__PURE__ */ xn("LN10", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(10).ln() : Math.LN10;
}), Sp = /* @__PURE__ */ xn("LOG2E", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(1).div(new r(2).ln()) : Math.LOG2E;
}), Cp = /* @__PURE__ */ xn("LOG10E", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(1).div(new r(10).ln()) : Math.LOG10E;
}), Tp = /* @__PURE__ */ xn(
  // eslint-disable-line camelcase
  "SQRT1_2",
  ["config", "?BigNumber"],
  (t) => {
    var {
      config: e,
      BigNumber: r
    } = t;
    return e.number === "BigNumber" ? new r("0.5").sqrt() : Math.SQRT1_2;
  }
), _p = /* @__PURE__ */ xn("SQRT2", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(2).sqrt() : Math.SQRT2;
}), Mp = /* @__PURE__ */ xn("i", ["Complex"], (t) => {
  var {
    Complex: e
  } = t;
  return e.I;
}), Gd = /* @__PURE__ */ j("PI", ["pi"], (t) => {
  var {
    pi: e
  } = t;
  return e;
}), Hd = /* @__PURE__ */ j("E", ["e"], (t) => {
  var {
    e
  } = t;
  return e;
}), Op = /* @__PURE__ */ j("version", [], () => cR);
function xn(t, e, r) {
  return j(t, e, r, {
    recreateOnConfigChange: !0
  });
}
var Fp = /* @__PURE__ */ dt("speedOfLight", "299792458", "m s^-1"), qp = /* @__PURE__ */ dt("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2"), Ip = /* @__PURE__ */ dt("planckConstant", "6.62607015e-34", "J s"), Bp = /* @__PURE__ */ dt("reducedPlanckConstant", "1.0545718176461565e-34", "J s"), Rp = /* @__PURE__ */ dt("magneticConstant", "1.25663706212e-6", "N A^-2"), Lp = /* @__PURE__ */ dt("electricConstant", "8.8541878128e-12", "F m^-1"), Pp = /* @__PURE__ */ dt("vacuumImpedance", "376.730313667", "ohm"), kp = /* @__PURE__ */ dt("coulomb", "8.987551792261171e9", "N m^2 C^-2"), $p = /* @__PURE__ */ dt("elementaryCharge", "1.602176634e-19", "C"), zp = /* @__PURE__ */ dt("bohrMagneton", "9.2740100783e-24", "J T^-1"), Up = /* @__PURE__ */ dt("conductanceQuantum", "7.748091729863649e-5", "S"), Gp = /* @__PURE__ */ dt("inverseConductanceQuantum", "12906.403729652257", "ohm"), Hp = /* @__PURE__ */ dt("magneticFluxQuantum", "2.0678338484619295e-15", "Wb"), Qp = /* @__PURE__ */ dt("nuclearMagneton", "5.0507837461e-27", "J T^-1"), Vp = /* @__PURE__ */ dt("klitzing", "25812.807459304513", "ohm"), Wp = /* @__PURE__ */ dt("bohrRadius", "5.29177210903e-11", "m"), jp = /* @__PURE__ */ dt("classicalElectronRadius", "2.8179403262e-15", "m"), Zp = /* @__PURE__ */ dt("electronMass", "9.1093837015e-31", "kg"), Jp = /* @__PURE__ */ dt("fermiCoupling", "1.1663787e-5", "GeV^-2"), Yp = Th("fineStructure", 0.0072973525693), Xp = /* @__PURE__ */ dt("hartreeEnergy", "4.3597447222071e-18", "J"), Kp = /* @__PURE__ */ dt("protonMass", "1.67262192369e-27", "kg"), eh = /* @__PURE__ */ dt("deuteronMass", "3.3435830926e-27", "kg"), th = /* @__PURE__ */ dt("neutronMass", "1.6749271613e-27", "kg"), rh = /* @__PURE__ */ dt("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1"), nh = /* @__PURE__ */ dt("rydberg", "10973731.568160", "m^-1"), ih = /* @__PURE__ */ dt("thomsonCrossSection", "6.6524587321e-29", "m^2"), ah = Th("weakMixingAngle", 0.2229), sh = Th("efimovFactor", 22.7), oh = /* @__PURE__ */ dt("atomicMass", "1.66053906660e-27", "kg"), uh = /* @__PURE__ */ dt("avogadro", "6.02214076e23", "mol^-1"), lh = /* @__PURE__ */ dt("boltzmann", "1.380649e-23", "J K^-1"), ch = /* @__PURE__ */ dt("faraday", "96485.33212331001", "C mol^-1"), fh = /* @__PURE__ */ dt("firstRadiation", "3.7417718521927573e-16", "W m^2"), ph = /* @__PURE__ */ dt("loschmidt", "2.686780111798444e25", "m^-3"), hh = /* @__PURE__ */ dt("gasConstant", "8.31446261815324", "J K^-1 mol^-1"), mh = /* @__PURE__ */ dt("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1"), dh = /* @__PURE__ */ dt("molarVolume", "0.022413969545014137", "m^3 mol^-1"), vh = Th("sackurTetrode", -1.16487052358), gh = /* @__PURE__ */ dt("secondRadiation", "0.014387768775039337", "m K"), yh = /* @__PURE__ */ dt("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4"), xh = /* @__PURE__ */ dt("wienDisplacement", "2.897771955e-3", "m K"), bh = /* @__PURE__ */ dt("molarMass", "0.99999999965e-3", "kg mol^-1"), wh = /* @__PURE__ */ dt("molarMassC12", "11.9999999958e-3", "kg mol^-1"), Nh = /* @__PURE__ */ dt("gravity", "9.80665", "m s^-2"), Dh = /* @__PURE__ */ dt("planckLength", "1.616255e-35", "m"), Ah = /* @__PURE__ */ dt("planckMass", "2.176435e-8", "kg"), Eh = /* @__PURE__ */ dt("planckTime", "5.391245e-44", "s"), Sh = /* @__PURE__ */ dt("planckCharge", "1.87554603778e-18", "C"), Ch = /* @__PURE__ */ dt("planckTemperature", "1.416785e+32", "K");
function dt(t, e, r) {
  var n = ["config", "Unit", "BigNumber"];
  return j(t, n, (a) => {
    var {
      config: s,
      Unit: o,
      BigNumber: p
    } = a, u = s.number === "BigNumber" ? new p(e) : parseFloat(e), f = new o(u, r);
    return f.fixPrefix = !0, f;
  });
}
function Th(t, e) {
  var r = ["config", "BigNumber"];
  return j(t, r, (n) => {
    var {
      config: a,
      BigNumber: s
    } = n;
    return a.number === "BigNumber" ? new s(e) : e;
  });
}
var fR = "apply", pR = ["typed", "isInteger"], _h = /* @__PURE__ */ j(fR, pR, (t) => {
  var {
    typed: e,
    isInteger: r
  } = t, n = Ka({
    typed: e,
    isInteger: r
  });
  return e("apply", {
    "...any": function(s) {
      var o = s[1];
      ht(o) ? s[1] = o - 1 : ct(o) && (s[1] = o.minus(1));
      try {
        return n.apply(null, s);
      } catch (p) {
        throw nn(p);
      }
    }
  });
}, {
  isTransformFunction: !0
}), hR = "column", mR = ["typed", "Index", "matrix", "range"], Mh = /* @__PURE__ */ j(hR, mR, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: a
  } = t, s = Zs({
    typed: e,
    Index: r,
    matrix: n,
    range: a
  });
  return e("column", {
    "...any": function(p) {
      var u = p.length - 1, f = p[u];
      ht(f) && (p[u] = f - 1);
      try {
        return s.apply(null, p);
      } catch (l) {
        throw nn(l);
      }
    }
  });
}, {
  isTransformFunction: !0
});
function Qd(t, e, r) {
  var n = t.filter(function(u) {
    return mr(u) && !(u.name in e) && !r.has(u.name);
  })[0];
  if (!n)
    throw new Error('No undefined variable found in inline expression "' + t + '"');
  var a = n.name, s = /* @__PURE__ */ new Map(), o = new E2(r, s, /* @__PURE__ */ new Set([a])), p = t.compile();
  return function(f) {
    return s.set(a, f), p.evaluate(o);
  };
}
var dR = "filter", vR = ["typed"], Oh = /* @__PURE__ */ j(dR, vR, (t) => {
  var {
    typed: e
  } = t;
  function r(a, s, o) {
    var p, u;
    return a[0] && (p = a[0].compile().evaluate(o)), a[1] && (mr(a[1]) || oa(a[1]) ? u = a[1].compile().evaluate(o) : u = Qd(a[1], s, o)), n(p, u);
  }
  r.rawArgs = !0;
  var n = e("filter", {
    "Array, function": o2,
    "Matrix, function": function(s, o) {
      return s.create(o2(s.toArray(), o));
    },
    "Array, RegExp": iu,
    "Matrix, RegExp": function(s, o) {
      return s.create(iu(s.toArray(), o));
    }
  });
  return r;
}, {
  isTransformFunction: !0
});
function o2(t, e) {
  return W2(t, function(r, n, a) {
    return es(e, r, [n + 1], a, "filter");
  });
}
var gR = "forEach", yR = ["typed"], Fh = /* @__PURE__ */ j(gR, yR, (t) => {
  var {
    typed: e
  } = t;
  function r(a, s, o) {
    var p, u;
    return a[0] && (p = a[0].compile().evaluate(o)), a[1] && (mr(a[1]) || oa(a[1]) ? u = a[1].compile().evaluate(o) : u = Qd(a[1], s, o)), n(p, u);
  }
  r.rawArgs = !0;
  var n = e("forEach", {
    "Array | Matrix, function": function(s, o) {
      var p = function u(f, l) {
        if (Array.isArray(f))
          Pu(f, function(c, h) {
            u(c, l.concat(h + 1));
          });
        else
          return es(o, f, l, s, "forEach");
      };
      p(s.valueOf(), []);
    }
  });
  return r;
}, {
  isTransformFunction: !0
}), xR = "index", bR = ["Index", "getMatrixDataType"], qh = /* @__PURE__ */ j(xR, bR, (t) => {
  var {
    Index: e,
    getMatrixDataType: r
  } = t;
  return function() {
    for (var a = [], s = 0, o = arguments.length; s < o; s++) {
      var p = arguments[s];
      if (ks(p))
        p.start--, p.end -= p.step > 0 ? 0 : 2;
      else if (p && p.isSet === !0)
        p = p.map(function(f) {
          return f - 1;
        });
      else if (Rt(p) || tt(p))
        r(p) !== "boolean" && (p = p.map(function(f) {
          return f - 1;
        }));
      else if (ht(p))
        p--;
      else if (ct(p))
        p = p.toNumber() - 1;
      else if (typeof p != "string") throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      a[s] = p;
    }
    var u = new e();
    return e.apply(u, a), u;
  };
}, {
  isTransformFunction: !0
}), wR = "map", NR = ["typed"], Ih = /* @__PURE__ */ j(wR, NR, (t) => {
  var {
    typed: e
  } = t;
  function r(a, s, o) {
    var p, u;
    return a[0] && (p = a[0].compile().evaluate(o)), a[1] && (mr(a[1]) || oa(a[1]) ? u = a[1].compile().evaluate(o) : u = Qd(a[1], s, o)), n(p, u);
  }
  r.rawArgs = !0;
  var n = e("map", {
    "Array, function": function(s, o) {
      return u2(s, o, s);
    },
    "Matrix, function": function(s, o) {
      return s.create(u2(s.valueOf(), o, s));
    }
  });
  return r;
}, {
  isTransformFunction: !0
});
function u2(t, e, r) {
  function n(a, s) {
    return Array.isArray(a) ? fi(a, function(o, p) {
      return n(o, s.concat(p + 1));
    }) : es(e, a, s, r, "map");
  }
  return n(t, []);
}
function Li(t) {
  if (t.length === 2 && cn(t[0])) {
    t = t.slice();
    var e = t[1];
    ht(e) ? t[1] = e - 1 : ct(e) && (t[1] = e.minus(1));
  }
  return t;
}
var DR = "max", AR = ["typed", "config", "numeric", "larger"], Bh = /* @__PURE__ */ j(DR, AR, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    larger: a
  } = t, s = no({
    typed: e,
    config: r,
    numeric: n,
    larger: a
  });
  return e("max", {
    "...any": function(p) {
      p = Li(p);
      try {
        return s.apply(null, p);
      } catch (u) {
        throw nn(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), ER = "mean", SR = ["typed", "add", "divide"], Rh = /* @__PURE__ */ j(ER, SR, (t) => {
  var {
    typed: e,
    add: r,
    divide: n
  } = t, a = oo({
    typed: e,
    add: r,
    divide: n
  });
  return e("mean", {
    "...any": function(o) {
      o = Li(o);
      try {
        return a.apply(null, o);
      } catch (p) {
        throw nn(p);
      }
    }
  });
}, {
  isTransformFunction: !0
}), CR = "min", TR = ["typed", "config", "numeric", "smaller"], Lh = /* @__PURE__ */ j(CR, TR, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    smaller: a
  } = t, s = io({
    typed: e,
    config: r,
    numeric: n,
    smaller: a
  });
  return e("min", {
    "...any": function(p) {
      p = Li(p);
      try {
        return s.apply(null, p);
      } catch (u) {
        throw nn(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), _R = "range", MR = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"], Ph = /* @__PURE__ */ j(_R, MR, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    bignumber: a,
    smaller: s,
    smallerEq: o,
    larger: p,
    largerEq: u,
    add: f,
    isPositive: l
  } = t, c = Ys({
    typed: e,
    config: r,
    matrix: n,
    bignumber: a,
    smaller: s,
    smallerEq: o,
    larger: p,
    largerEq: u,
    add: f,
    isPositive: l
  });
  return e("range", {
    "...any": function(d) {
      var g = d.length - 1, v = d[g];
      return typeof v != "boolean" && d.push(!0), c.apply(null, d);
    }
  });
}, {
  isTransformFunction: !0
}), OR = "row", FR = ["typed", "Index", "matrix", "range"], kh = /* @__PURE__ */ j(OR, FR, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: a
  } = t, s = Xs({
    typed: e,
    Index: r,
    matrix: n,
    range: a
  });
  return e("row", {
    "...any": function(p) {
      var u = p.length - 1, f = p[u];
      ht(f) && (p[u] = f - 1);
      try {
        return s.apply(null, p);
      } catch (l) {
        throw nn(l);
      }
    }
  });
}, {
  isTransformFunction: !0
}), qR = "subset", IR = ["typed", "matrix", "zeros", "add"], $h = /* @__PURE__ */ j(qR, IR, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    add: a
  } = t, s = Ks({
    typed: e,
    matrix: r,
    zeros: n,
    add: a
  });
  return e("subset", {
    "...any": function(p) {
      try {
        return s.apply(null, p);
      } catch (u) {
        throw nn(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), BR = "concat", RR = ["typed", "matrix", "isInteger"], zh = /* @__PURE__ */ j(BR, RR, (t) => {
  var {
    typed: e,
    matrix: r,
    isInteger: n
  } = t, a = js({
    typed: e,
    matrix: r,
    isInteger: n
  });
  return e("concat", {
    "...any": function(o) {
      var p = o.length - 1, u = o[p];
      ht(u) ? o[p] = u - 1 : ct(u) && (o[p] = u.minus(1));
      try {
        return a.apply(null, o);
      } catch (f) {
        throw nn(f);
      }
    }
  });
}, {
  isTransformFunction: !0
}), l2 = "diff", LR = ["typed", "matrix", "subtract", "number", "bignumber"], Uh = /* @__PURE__ */ j(l2, LR, (t) => {
  var {
    typed: e,
    matrix: r,
    subtract: n,
    number: a,
    bignumber: s
  } = t, o = Js({
    typed: e,
    matrix: r,
    subtract: n,
    number: a,
    bignumber: s
  });
  return e(l2, {
    "...any": function(u) {
      u = Li(u);
      try {
        return o.apply(null, u);
      } catch (f) {
        throw nn(f);
      }
    }
  });
}, {
  isTransformFunction: !0
}), PR = "std", kR = ["typed", "map", "sqrt", "variance"], Gh = /* @__PURE__ */ j(PR, kR, (t) => {
  var {
    typed: e,
    map: r,
    sqrt: n,
    variance: a
  } = t, s = co({
    typed: e,
    map: r,
    sqrt: n,
    variance: a
  });
  return e("std", {
    "...any": function(p) {
      p = Li(p);
      try {
        return s.apply(null, p);
      } catch (u) {
        throw nn(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), c2 = "sum", $R = ["typed", "config", "add", "numeric"], Hh = /* @__PURE__ */ j(c2, $R, (t) => {
  var {
    typed: e,
    config: r,
    add: n,
    numeric: a
  } = t, s = ao({
    typed: e,
    config: r,
    add: n,
    numeric: a
  });
  return e(c2, {
    "...any": function(p) {
      p = Li(p);
      try {
        return s.apply(null, p);
      } catch (u) {
        throw nn(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), zR = "quantileSeq", UR = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"], Qh = /* @__PURE__ */ j(zR, UR, (t) => {
  var {
    typed: e,
    bignumber: r,
    add: n,
    subtract: a,
    divide: s,
    multiply: o,
    partitionSelect: p,
    compare: u,
    isInteger: f,
    smaller: l,
    smallerEq: c,
    larger: h
  } = t, d = lo({
    typed: e,
    bignumber: r,
    add: n,
    subtract: a,
    divide: s,
    multiply: o,
    partitionSelect: p,
    compare: u,
    isInteger: f,
    smaller: l,
    smallerEq: c,
    larger: h
  });
  return e("quantileSeq", {
    "Array | Matrix, number | BigNumber": d,
    "Array | Matrix, number | BigNumber, number": (v, N, b) => d(v, N, g(b)),
    "Array | Matrix, number | BigNumber, boolean": d,
    "Array | Matrix, number | BigNumber, boolean, number": (v, N, b, C) => d(v, N, b, g(C)),
    "Array | Matrix, Array | Matrix": d,
    "Array | Matrix, Array | Matrix, number": (v, N, b) => d(v, N, g(b)),
    "Array | Matrix, Array | Matrix, boolean": d,
    "Array | Matrix, Array | Matrix, boolean, number": (v, N, b, C) => d(v, N, b, g(C))
  });
  function g(v) {
    return Li([[], v])[1];
  }
}, {
  isTransformFunction: !0
}), f2 = "cumsum", GR = ["typed", "add", "unaryPlus"], Vh = /* @__PURE__ */ j(f2, GR, (t) => {
  var {
    typed: e,
    add: r,
    unaryPlus: n
  } = t, a = so({
    typed: e,
    add: r,
    unaryPlus: n
  });
  return e(f2, {
    "...any": function(o) {
      if (o.length === 2 && cn(o[0])) {
        var p = o[1];
        ht(p) ? o[1] = p - 1 : ct(p) && (o[1] = p.minus(1));
      }
      try {
        return a.apply(null, o);
      } catch (u) {
        throw nn(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), p2 = "variance", HR = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"], Wh = /* @__PURE__ */ j(p2, HR, (t) => {
  var {
    typed: e,
    add: r,
    subtract: n,
    multiply: a,
    divide: s,
    apply: o,
    isNaN: p
  } = t, u = uo({
    typed: e,
    add: r,
    subtract: n,
    multiply: a,
    divide: s,
    apply: o,
    isNaN: p
  });
  return e(p2, {
    "...any": function(l) {
      l = Li(l);
      try {
        return u.apply(null, l);
      } catch (c) {
        throw nn(c);
      }
    }
  });
}, {
  isTransformFunction: !0
}), h2 = "print", QR = ["typed", "matrix", "zeros", "add"], jh = /* @__PURE__ */ j(h2, QR, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    add: a
  } = t, s = eo({
    typed: e,
    matrix: r,
    zeros: n,
    add: a
  });
  return e(h2, {
    "string, Object | Array": function(u, f) {
      return s(o(u), f);
    },
    "string, Object | Array, number | Object": function(u, f, l) {
      return s(o(u), f, l);
    }
  });
  function o(p) {
    return p.replace(Vw, (u) => {
      var f = u.slice(1).split("."), l = f.map(function(c) {
        return !isNaN(c) && c.length > 0 ? parseInt(c) - 1 : c;
      });
      return "$" + l.join(".");
    });
  }
}, {
  isTransformFunction: !0
}), VR = "and", WR = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"], Zh = /* @__PURE__ */ j(VR, WR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    not: s,
    concat: o
  } = t, p = ro({
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    not: s,
    concat: o
  });
  function u(f, l, c) {
    var h = f[0].compile().evaluate(c);
    if (!cn(h) && !p(h, !0))
      return !1;
    var d = f[1].compile().evaluate(c);
    return p(h, d);
  }
  return u.rawArgs = !0, u;
}, {
  isTransformFunction: !0
}), jR = "or", ZR = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Jh = /* @__PURE__ */ j(jR, ZR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: a,
    concat: s
  } = t, o = Ws({
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: a,
    concat: s
  });
  function p(u, f, l) {
    var c = u[0].compile().evaluate(l);
    if (!cn(c) && o(c, !1))
      return !0;
    var h = u[1].compile().evaluate(l);
    return o(c, h);
  }
  return p.rawArgs = !0, p;
}, {
  isTransformFunction: !0
}), JR = "bitAnd", YR = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"], Yh = /* @__PURE__ */ j(JR, YR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    not: s,
    concat: o
  } = t, p = Qs({
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: a,
    not: s,
    concat: o
  });
  function u(f, l, c) {
    var h = f[0].compile().evaluate(c);
    if (!cn(h)) {
      if (isNaN(h))
        return NaN;
      if (h === 0 || h === !1)
        return 0;
    }
    var d = f[1].compile().evaluate(c);
    return p(h, d);
  }
  return u.rawArgs = !0, u;
}, {
  isTransformFunction: !0
}), XR = "bitOr", KR = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Xh = /* @__PURE__ */ j(XR, KR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: a,
    concat: s
  } = t, o = Vs({
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: a,
    concat: s
  });
  function p(u, f, l) {
    var c = u[0].compile().evaluate(l);
    if (!cn(c)) {
      if (isNaN(c))
        return NaN;
      if (c === -1)
        return -1;
      if (c === !0)
        return 1;
    }
    var h = u[1].compile().evaluate(l);
    return o(c, h);
  }
  return p.rawArgs = !0, p;
}, {
  isTransformFunction: !0
});
const e6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createAbs: p0,
  createAccessorNode: Yc,
  createAcos: lc,
  createAcosh: cc,
  createAcot: fc,
  createAcoth: pc,
  createAcsc: hc,
  createAcsch: mc,
  createAdd: Hc,
  createAddScalar: h0,
  createAnd: ro,
  createAndTransform: Zh,
  createApply: Ka,
  createApplyTransform: _h,
  createArg: k0,
  createArrayNode: Xc,
  createAsec: dc,
  createAsech: vc,
  createAsin: gc,
  createAsinh: yc,
  createAssignmentNode: Kc,
  createAtan: xc,
  createAtan2: bc,
  createAtanh: wc,
  createAtomicMass: oh,
  createAvogadro: uh,
  createBellNumbers: ep,
  createBigNumberClass: qu,
  createBigint: Ku,
  createBignumber: r0,
  createBin: bl,
  createBitAnd: Qs,
  createBitAndTransform: Yh,
  createBitNot: L0,
  createBitOr: Vs,
  createBitOrTransform: Xh,
  createBitXor: P0,
  createBlockNode: ef,
  createBohrMagneton: zp,
  createBohrRadius: Wp,
  createBoltzmann: lh,
  createBoolean: t0,
  createCatalan: tp,
  createCbrt: d0,
  createCeil: v0,
  createChain: Sf,
  createChainClass: Af,
  createClassicalElectronRadius: jp,
  createClone: $u,
  createColumn: Zs,
  createColumnTransform: Mh,
  createCombinations: Uf,
  createCombinationsWithRep: Gf,
  createCompare: zl,
  createCompareNatural: Ul,
  createCompareText: Gl,
  createCompile: mf,
  createComplex: n0,
  createComplexClass: Iu,
  createComposition: rp,
  createConcat: js,
  createConcatTransform: zh,
  createConditionalNode: tf,
  createConductanceQuantum: Up,
  createConj: $0,
  createConstantNode: rf,
  createCorr: zf,
  createCos: Nc,
  createCosh: Dc,
  createCot: Ac,
  createCoth: Ec,
  createCoulomb: kp,
  createCount: Q0,
  createCreateUnit: uc,
  createCross: V0,
  createCsc: Sc,
  createCsch: Cc,
  createCtranspose: cl,
  createCube: g0,
  createCumSum: so,
  createCumSumTransform: Vh,
  createDeepEqual: Jl,
  createDenseMatrixClass: ku,
  createDerivative: lp,
  createDet: Cf,
  createDeuteronMass: eh,
  createDiag: W0,
  createDiff: Js,
  createDiffTransform: Uh,
  createDistance: Lf,
  createDivide: Rf,
  createDivideScalar: Sl,
  createDot: Wc,
  createDotDivide: ql,
  createDotMultiply: R0,
  createDotPow: Fl,
  createE: Np,
  createEfimovFactor: sh,
  createEigs: Mf,
  createElectricConstant: Lp,
  createElectronMass: Zp,
  createElementaryCharge: $p,
  createEqual: Hl,
  createEqualScalar: Ju,
  createEqualText: Ql,
  createErf: dl,
  createEvaluate: df,
  createExp: y0,
  createExpm: Of,
  createExpm1: x0,
  createFactorial: Vf,
  createFalse: vp,
  createFaraday: ch,
  createFermiCoupling: Jp,
  createFft: pl,
  createFibonacciHeapClass: rc,
  createFilter: j0,
  createFilterTransform: Oh,
  createFineStructure: Yp,
  createFirstRadiation: fh,
  createFix: b0,
  createFlatten: Z0,
  createFloor: Gs,
  createForEach: J0,
  createForEachTransform: Fh,
  createFormat: xl,
  createFraction: i0,
  createFractionClass: Bu,
  createFreqz: pp,
  createFunctionAssignmentNode: nf,
  createFunctionNode: pf,
  createGamma: Hf,
  createGasConstant: hh,
  createGcd: N0,
  createGetMatrixDataType: Y0,
  createGravitationConstant: qp,
  createGravity: Nh,
  createHartreeEnergy: Xp,
  createHasNumericValue: Qu,
  createHelp: Ef,
  createHelpClass: Df,
  createHex: Nl,
  createHypot: Qc,
  createI: Mp,
  createIdentity: X0,
  createIfft: hl,
  createIm: z0,
  createImmutableDenseMatrixClass: ec,
  createIndex: Zc,
  createIndexClass: tc,
  createIndexNode: af,
  createIndexTransform: qh,
  createInfinity: yp,
  createIntersect: Pf,
  createInv: Tf,
  createInverseConductanceQuantum: Gp,
  createInvmod: B0,
  createIsInteger: Uu,
  createIsNaN: ju,
  createIsNegative: Gu,
  createIsNumeric: Hu,
  createIsPositive: Vu,
  createIsPrime: Al,
  createIsZero: Wu,
  createKldivergence: Wf,
  createKlitzing: Vp,
  createKron: K0,
  createLN10: Ep,
  createLN2: Ap,
  createLOG10E: Cp,
  createLOG2E: Sp,
  createLarger: jl,
  createLargerEq: Zl,
  createLcm: A0,
  createLeafCount: np,
  createLeftShift: Pl,
  createLgamma: Qf,
  createLog: _l,
  createLog10: E0,
  createLog1p: Ml,
  createLog2: S0,
  createLoschmidt: ph,
  createLsolve: Il,
  createLsolveAll: Rl,
  createLup: yf,
  createLusolve: wf,
  createLyap: Bf,
  createMad: $f,
  createMagneticConstant: Rp,
  createMagneticFluxQuantum: Hp,
  createMap: tl,
  createMapTransform: Ih,
  createMatrix: a0,
  createMatrixClass: Lu,
  createMatrixFromColumns: u0,
  createMatrixFromFunction: s0,
  createMatrixFromRows: o0,
  createMax: no,
  createMaxTransform: Bh,
  createMean: oo,
  createMeanTransform: Rh,
  createMedian: kf,
  createMin: io,
  createMinTransform: Lh,
  createMod: Hs,
  createMode: gl,
  createMolarMass: bh,
  createMolarMassC12: wh,
  createMolarPlanckConstant: mh,
  createMolarVolume: dh,
  createMultinomial: jf,
  createMultiply: T0,
  createMultiplyScalar: C0,
  createNaN: xp,
  createNeutronMass: th,
  createNode: Jc,
  createNorm: Vc,
  createNot: G0,
  createNthRoot: _0,
  createNthRoots: Ol,
  createNuclearMagneton: Qp,
  createNull: gp,
  createNumber: Xu,
  createNumeric: El,
  createObjectNode: sf,
  createOct: wl,
  createOnes: rl,
  createOperatorNode: of,
  createOr: Ws,
  createOrTransform: Jh,
  createParenthesisNode: uf,
  createParse: hf,
  createParser: gf,
  createParserClass: vf,
  createPartitionSelect: Xl,
  createPermutations: Zf,
  createPhi: Dp,
  createPi: bp,
  createPickRandom: Jf,
  createPinv: _f,
  createPlanckCharge: Sh,
  createPlanckConstant: Ip,
  createPlanckLength: Dh,
  createPlanckMass: Ah,
  createPlanckTemperature: Ch,
  createPlanckTime: Eh,
  createPolynomialRoot: Nf,
  createPow: Cl,
  createPrint: eo,
  createPrintTransform: jh,
  createProd: yl,
  createProtonMass: Kp,
  createQr: xf,
  createQuantileSeq: lo,
  createQuantileSeqTransform: Qh,
  createQuantumOfCirculation: rh,
  createRandom: Yf,
  createRandomInt: Xf,
  createRange: Ys,
  createRangeClass: Ru,
  createRangeNode: lf,
  createRangeTransform: Ph,
  createRationalize: cp,
  createRe: U0,
  createReducedPlanckConstant: Bp,
  createRelationalNode: cf,
  createReplacer: mp,
  createReshape: nl,
  createResize: il,
  createResolve: op,
  createResultSet: _u,
  createReviver: hp,
  createRightArithShift: kl,
  createRightLogShift: $l,
  createRotate: al,
  createRotationMatrix: sl,
  createRound: Tl,
  createRow: Xs,
  createRowTransform: kh,
  createRydberg: nh,
  createSQRT1_2: Tp,
  createSQRT2: _p,
  createSackurTetrode: vh,
  createSchur: If,
  createSec: Tc,
  createSech: _c,
  createSecondRadiation: gh,
  createSetCartesian: Ic,
  createSetDifference: Bc,
  createSetDistinct: Rc,
  createSetIntersect: Lc,
  createSetIsSubset: Pc,
  createSetMultiplicity: kc,
  createSetPowerset: $c,
  createSetSize: zc,
  createSetSymDifference: Uc,
  createSetUnion: Gc,
  createSign: M0,
  createSimplify: ip,
  createSimplifyConstant: ap,
  createSimplifyCore: sp,
  createSin: Mc,
  createSinh: Oc,
  createSize: ol,
  createSlu: bf,
  createSmaller: Vl,
  createSmallerEq: Wl,
  createSolveODE: ml,
  createSort: Kl,
  createSpaClass: nc,
  createSparse: oc,
  createSparseMatrixClass: Yu,
  createSpeedOfLight: Fp,
  createSplitUnit: l0,
  createSqrt: O0,
  createSqrtm: Ff,
  createSquare: F0,
  createSqueeze: ul,
  createStd: co,
  createStdTransform: Gh,
  createStefanBoltzmann: yh,
  createStirlingS2: Kf,
  createString: e0,
  createSubset: Ks,
  createSubsetTransform: $h,
  createSubtract: q0,
  createSubtractScalar: m0,
  createSum: ao,
  createSumTransform: Hh,
  createSylvester: qf,
  createSymbolNode: ff,
  createSymbolicEqual: up,
  createTan: Fc,
  createTanh: qc,
  createTau: wp,
  createThomsonCrossSection: ih,
  createTo: Dl,
  createTrace: jc,
  createTranspose: ll,
  createTrue: dp,
  createTypeOf: Zu,
  createTyped: Tu,
  createUnaryMinus: c0,
  createUnaryPlus: f0,
  createUnequal: Yl,
  createUnitClass: ac,
  createUnitFunction: sc,
  createUppercaseE: Hd,
  createUppercasePi: Gd,
  createUsolve: Bl,
  createUsolveAll: Ll,
  createVacuumImpedance: Pp,
  createVariance: uo,
  createVarianceTransform: Wh,
  createVersion: Op,
  createWeakMixingAngle: ah,
  createWienDisplacement: xh,
  createXgcd: I0,
  createXor: H0,
  createZeros: fl,
  createZeta: vl,
  createZpk2tf: fp
}, Symbol.toStringTag, { value: "Module" }));
var He = /* @__PURE__ */ qu({
  config: qe
}), Ft = /* @__PURE__ */ Iu({}), ud = /* @__PURE__ */ Np({
  BigNumber: He,
  config: qe
}), tN = /* @__PURE__ */ vp({}), rN = /* @__PURE__ */ Yp({
  BigNumber: He,
  config: qe
}), Pi = /* @__PURE__ */ Bu({}), Vd = /* @__PURE__ */ Mp({
  Complex: Ft
}), nN = /* @__PURE__ */ yp({
  BigNumber: He,
  config: qe
}), iN = /* @__PURE__ */ Ep({
  BigNumber: He,
  config: qe
}), aN = /* @__PURE__ */ Cp({
  BigNumber: He,
  config: qe
}), rs = /* @__PURE__ */ Lu({}), sN = /* @__PURE__ */ xp({
  BigNumber: He,
  config: qe
}), oN = /* @__PURE__ */ gp({}), uN = /* @__PURE__ */ Dp({
  BigNumber: He,
  config: qe
}), lN = /* @__PURE__ */ Ru({}), Wd = /* @__PURE__ */ _u({}), cN = /* @__PURE__ */ Tp({
  BigNumber: He,
  config: qe
}), fN = /* @__PURE__ */ vh({
  BigNumber: He,
  config: qe
}), jd = /* @__PURE__ */ wp({
  BigNumber: He,
  config: qe
}), pN = /* @__PURE__ */ dp({}), hN = /* @__PURE__ */ Op({}), yt = /* @__PURE__ */ ku({
  Matrix: rs
}), mN = /* @__PURE__ */ sh({
  BigNumber: He,
  config: qe
}), dN = /* @__PURE__ */ Ap({
  BigNumber: He,
  config: qe
}), Oi = /* @__PURE__ */ bp({
  BigNumber: He,
  config: qe
}), vN = /* @__PURE__ */ mp({}), gN = /* @__PURE__ */ _p({
  BigNumber: He,
  config: qe
}), se = /* @__PURE__ */ Tu({
  BigNumber: He,
  Complex: Ft,
  DenseMatrix: yt,
  Fraction: Pi
}), yN = /* @__PURE__ */ ah({
  BigNumber: He,
  config: qe
}), $t = /* @__PURE__ */ p0({
  typed: se
}), Zd = /* @__PURE__ */ lc({
  Complex: Ft,
  config: qe,
  typed: se
}), xN = /* @__PURE__ */ fc({
  BigNumber: He,
  typed: se
}), bN = /* @__PURE__ */ hc({
  BigNumber: He,
  Complex: Ft,
  config: qe,
  typed: se
}), vr = /* @__PURE__ */ h0({
  typed: se
}), Rs = /* @__PURE__ */ k0({
  typed: se
}), wN = /* @__PURE__ */ vc({
  BigNumber: He,
  Complex: Ft,
  config: qe,
  typed: se
}), NN = /* @__PURE__ */ yc({
  typed: se
}), Jd = /* @__PURE__ */ xc({
  typed: se
}), DN = /* @__PURE__ */ wc({
  Complex: Ft,
  config: qe,
  typed: se
}), AN = /* @__PURE__ */ Ku({
  typed: se
}), EN = /* @__PURE__ */ L0({
  typed: se
}), SN = /* @__PURE__ */ t0({
  typed: se
}), CN = /* @__PURE__ */ $u({
  typed: se
}), fo = /* @__PURE__ */ Uf({
  typed: se
}), Wt = /* @__PURE__ */ n0({
  Complex: Ft,
  typed: se
}), Yn = /* @__PURE__ */ $0({
  typed: se
}), Kh = /* @__PURE__ */ Nc({
  typed: se
}), TN = /* @__PURE__ */ Ac({
  BigNumber: He,
  typed: se
}), Yd = /* @__PURE__ */ Sc({
  BigNumber: He,
  typed: se
}), _N = /* @__PURE__ */ g0({
  typed: se
}), wt = /* @__PURE__ */ Ju({
  config: qe,
  typed: se
}), MN = /* @__PURE__ */ dl({
  typed: se
}), Xd = /* @__PURE__ */ y0({
  typed: se
}), ON = /* @__PURE__ */ x0({
  Complex: Ft,
  typed: se
}), FN = /* @__PURE__ */ j0({
  typed: se
}), qN = /* @__PURE__ */ J0({
  typed: se
}), ns = /* @__PURE__ */ xl({
  typed: se
}), em = /* @__PURE__ */ Y0({
  typed: se
}), IN = /* @__PURE__ */ Nl({
  format: ns,
  typed: se
}), Ga = /* @__PURE__ */ z0({
  typed: se
}), en = /* @__PURE__ */ Uu({
  typed: se
}), di = /* @__PURE__ */ Gu({
  config: qe,
  typed: se
}), ki = /* @__PURE__ */ Vu({
  config: qe,
  typed: se
}), On = /* @__PURE__ */ Wu({
  equalScalar: wt,
  typed: se
}), BN = /* @__PURE__ */ Sp({
  BigNumber: He,
  config: qe
}), RN = /* @__PURE__ */ Qf({
  Complex: Ft,
  typed: se
}), LN = /* @__PURE__ */ E0({
  Complex: Ft,
  config: qe,
  typed: se
}), vi = /* @__PURE__ */ S0({
  Complex: Ft,
  config: qe,
  typed: se
}), $i = /* @__PURE__ */ tl({
  typed: se
}), ar = /* @__PURE__ */ C0({
  typed: se
}), Ls = /* @__PURE__ */ G0({
  typed: se
}), Xn = /* @__PURE__ */ Xu({
  typed: se
}), PN = /* @__PURE__ */ wl({
  format: ns,
  typed: se
}), kN = /* @__PURE__ */ Jf({
  config: qe,
  typed: se
}), $N = /* @__PURE__ */ eo({
  typed: se
}), zN = /* @__PURE__ */ Yf({
  config: qe,
  typed: se
}), Ha = /* @__PURE__ */ U0({
  typed: se
}), UN = /* @__PURE__ */ Tc({
  BigNumber: He,
  typed: se
}), Kd = /* @__PURE__ */ M0({
  BigNumber: He,
  Fraction: Pi,
  complex: Wt,
  typed: se
}), po = /* @__PURE__ */ Mc({
  typed: se
}), Kn = /* @__PURE__ */ Yu({
  Matrix: rs,
  equalScalar: wt,
  typed: se
}), GN = /* @__PURE__ */ l0({
  typed: se
}), HN = /* @__PURE__ */ F0({
  typed: se
}), QN = /* @__PURE__ */ e0({
  typed: se
}), bn = /* @__PURE__ */ m0({
  typed: se
}), VN = /* @__PURE__ */ Fc({
  typed: se
}), ev = /* @__PURE__ */ Zu({
  typed: se
}), WN = /* @__PURE__ */ cc({
  Complex: Ft,
  config: qe,
  typed: se
}), jN = /* @__PURE__ */ mc({
  BigNumber: He,
  typed: se
}), tm = /* @__PURE__ */ Ka({
  isInteger: en,
  typed: se
}), ZN = /* @__PURE__ */ dc({
  BigNumber: He,
  Complex: Ft,
  config: qe,
  typed: se
}), ln = /* @__PURE__ */ r0({
  BigNumber: He,
  typed: se
}), JN = /* @__PURE__ */ Gf({
  typed: se
}), YN = /* @__PURE__ */ Dc({
  typed: se
}), XN = /* @__PURE__ */ Cc({
  BigNumber: He,
  typed: se
}), is = /* @__PURE__ */ ju({
  typed: se
}), KN = /* @__PURE__ */ Al({
  typed: se
}), eD = /* @__PURE__ */ Xf({
  config: qe,
  typed: se
}), tD = /* @__PURE__ */ _c({
  BigNumber: He,
  typed: se
}), rD = /* @__PURE__ */ Oc({
  typed: se
}), nD = /* @__PURE__ */ oc({
  SparseMatrix: Kn,
  typed: se
}), dr = /* @__PURE__ */ O0({
  Complex: Ft,
  config: qe,
  typed: se
}), iD = /* @__PURE__ */ qc({
  typed: se
}), Gn = /* @__PURE__ */ c0({
  typed: se
}), aD = /* @__PURE__ */ pc({
  BigNumber: He,
  Complex: Ft,
  config: qe,
  typed: se
}), sD = /* @__PURE__ */ bl({
  format: ns,
  typed: se
}), oD = /* @__PURE__ */ Ec({
  BigNumber: He,
  typed: se
}), fa = /* @__PURE__ */ i0({
  Fraction: Pi,
  typed: se
}), zi = /* @__PURE__ */ Hu({
  typed: se
}), ze = /* @__PURE__ */ a0({
  DenseMatrix: yt,
  Matrix: rs,
  SparseMatrix: Kn,
  typed: se
}), uD = /* @__PURE__ */ s0({
  isZero: On,
  matrix: ze,
  typed: se
}), lD = /* @__PURE__ */ gl({
  isNaN: is,
  isNumeric: zi,
  typed: se
}), gn = /* @__PURE__ */ El({
  bignumber: ln,
  fraction: fa,
  number: Xn
}), tv = /* @__PURE__ */ yl({
  config: qe,
  multiplyScalar: ar,
  numeric: gn,
  typed: se
}), rv = /* @__PURE__ */ nl({
  isInteger: en,
  matrix: ze,
  typed: se
}), Tr = /* @__PURE__ */ ol({
  matrix: ze,
  config: qe,
  typed: se
}), cD = /* @__PURE__ */ ul({
  matrix: ze,
  typed: se
}), as = /* @__PURE__ */ ll({
  matrix: ze,
  typed: se
}), nv = /* @__PURE__ */ I0({
  BigNumber: He,
  config: qe,
  matrix: ze,
  typed: se
}), yr = /* @__PURE__ */ fl({
  BigNumber: He,
  config: qe,
  matrix: ze,
  typed: se
}), fD = /* @__PURE__ */ gc({
  Complex: Ft,
  config: qe,
  typed: se
}), iv = /* @__PURE__ */ d0({
  BigNumber: He,
  Complex: Ft,
  Fraction: Pi,
  config: qe,
  isNegative: di,
  matrix: ze,
  typed: se,
  unaryMinus: Gn
}), Tt = /* @__PURE__ */ js({
  isInteger: en,
  matrix: ze,
  typed: se
}), pD = /* @__PURE__ */ Q0({
  prod: tv,
  size: Tr,
  typed: se
}), ss = /* @__PURE__ */ cl({
  conj: Yn,
  transpose: as,
  typed: se
}), av = /* @__PURE__ */ W0({
  DenseMatrix: yt,
  SparseMatrix: Kn,
  matrix: ze,
  typed: se
}), rr = /* @__PURE__ */ Sl({
  numeric: gn,
  typed: se
}), os = /* @__PURE__ */ ql({
  DenseMatrix: yt,
  concat: Tt,
  divideScalar: rr,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), wn = /* @__PURE__ */ Hl({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), us = /* @__PURE__ */ Z0({
  matrix: ze,
  typed: se
}), hD = /* @__PURE__ */ Qu({
  isNumeric: zi,
  typed: se
}), gi = /* @__PURE__ */ X0({
  BigNumber: He,
  DenseMatrix: yt,
  SparseMatrix: Kn,
  config: qe,
  matrix: ze,
  typed: se
}), mD = /* @__PURE__ */ K0({
  matrix: ze,
  multiplyScalar: ar,
  typed: se
}), ho = /* @__PURE__ */ Zl({
  DenseMatrix: yt,
  concat: Tt,
  config: qe,
  matrix: ze,
  typed: se
}), dD = /* @__PURE__ */ Pl({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se,
  zeros: yr
}), sv = /* @__PURE__ */ Il({
  DenseMatrix: yt,
  divideScalar: rr,
  equalScalar: wt,
  matrix: ze,
  multiplyScalar: ar,
  subtractScalar: bn,
  typed: se
}), rm = /* @__PURE__ */ u0({
  flatten: us,
  matrix: ze,
  size: Tr,
  typed: se
}), vD = /* @__PURE__ */ _0({
  BigNumber: He,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), gD = /* @__PURE__ */ rl({
  BigNumber: He,
  config: qe,
  matrix: ze,
  typed: se
}), nm = /* @__PURE__ */ xf({
  addScalar: vr,
  complex: Wt,
  conj: Yn,
  divideScalar: rr,
  equal: wn,
  identity: gi,
  isZero: On,
  matrix: ze,
  multiplyScalar: ar,
  sign: Kd,
  sqrt: dr,
  subtractScalar: bn,
  typed: se,
  unaryMinus: Gn,
  zeros: yr
}), yD = /* @__PURE__ */ il({
  config: qe,
  matrix: ze
}), xD = /* @__PURE__ */ kl({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se,
  zeros: yr
}), kt = /* @__PURE__ */ Tl({
  BigNumber: He,
  DenseMatrix: yt,
  config: qe,
  equalScalar: wt,
  matrix: ze,
  typed: se,
  zeros: yr
}), Qr = /* @__PURE__ */ Vl({
  DenseMatrix: yt,
  concat: Tt,
  config: qe,
  matrix: ze,
  typed: se
}), Xt = /* @__PURE__ */ q0({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  subtractScalar: bn,
  typed: se,
  unaryMinus: Gn
}), bD = /* @__PURE__ */ Dl({
  concat: Tt,
  matrix: ze,
  typed: se
}), im = /* @__PURE__ */ f0({
  config: qe,
  numeric: gn,
  typed: se
}), am = /* @__PURE__ */ Bl({
  DenseMatrix: yt,
  divideScalar: rr,
  equalScalar: wt,
  matrix: ze,
  multiplyScalar: ar,
  subtractScalar: bn,
  typed: se
}), wD = /* @__PURE__ */ H0({
  DenseMatrix: yt,
  concat: Tt,
  matrix: ze,
  typed: se
}), ut = /* @__PURE__ */ Hc({
  DenseMatrix: yt,
  SparseMatrix: Kn,
  addScalar: vr,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), ov = /* @__PURE__ */ bc({
  BigNumber: He,
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), ND = /* @__PURE__ */ Qs({
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), DD = /* @__PURE__ */ Vs({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), AD = /* @__PURE__ */ P0({
  DenseMatrix: yt,
  concat: Tt,
  matrix: ze,
  typed: se
}), ED = /* @__PURE__ */ tp({
  addScalar: vr,
  combinations: fo,
  divideScalar: rr,
  isInteger: en,
  isNegative: di,
  multiplyScalar: ar,
  typed: se
}), Ui = /* @__PURE__ */ zl({
  BigNumber: He,
  DenseMatrix: yt,
  Fraction: Pi,
  concat: Tt,
  config: qe,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), uv = /* @__PURE__ */ Gl({
  concat: Tt,
  matrix: ze,
  typed: se
}), SD = /* @__PURE__ */ so({
  add: ut,
  typed: se,
  unaryPlus: im
}), sm = /* @__PURE__ */ Jl({
  equal: wn,
  typed: se
}), CD = /* @__PURE__ */ Js({
  matrix: ze,
  number: Xn,
  subtract: Xt,
  typed: se
}), TD = /* @__PURE__ */ Lf({
  abs: $t,
  addScalar: vr,
  deepEqual: sm,
  divideScalar: rr,
  multiplyScalar: ar,
  sqrt: dr,
  subtractScalar: bn,
  typed: se
}), mo = /* @__PURE__ */ Wc({
  addScalar: vr,
  conj: Yn,
  multiplyScalar: ar,
  size: Tr,
  typed: se
}), _D = /* @__PURE__ */ Ql({
  compareText: uv,
  isZero: On,
  typed: se
}), lv = /* @__PURE__ */ Gs({
  DenseMatrix: yt,
  config: qe,
  equalScalar: wt,
  matrix: ze,
  round: kt,
  typed: se,
  zeros: yr
}), MD = /* @__PURE__ */ N0({
  BigNumber: He,
  DenseMatrix: yt,
  concat: Tt,
  config: qe,
  equalScalar: wt,
  matrix: ze,
  round: kt,
  typed: se,
  zeros: yr
}), OD = /* @__PURE__ */ Qc({
  abs: $t,
  addScalar: vr,
  divideScalar: rr,
  isPositive: ki,
  multiplyScalar: ar,
  smaller: Qr,
  sqrt: dr,
  typed: se
}), cv = /* @__PURE__ */ ec({
  DenseMatrix: yt,
  smaller: Qr
}), Rr = /* @__PURE__ */ tc({
  ImmutableDenseMatrix: cv,
  getMatrixDataType: em
}), Vr = /* @__PURE__ */ jl({
  DenseMatrix: yt,
  concat: Tt,
  config: qe,
  matrix: ze,
  typed: se
}), vo = /* @__PURE__ */ _l({
  Complex: Ft,
  config: qe,
  divideScalar: rr,
  typed: se
}), FD = /* @__PURE__ */ Rl({
  DenseMatrix: yt,
  divideScalar: rr,
  equalScalar: wt,
  matrix: ze,
  multiplyScalar: ar,
  subtractScalar: bn,
  typed: se
}), qD = /* @__PURE__ */ o0({
  flatten: us,
  matrix: ze,
  size: Tr,
  typed: se
}), fv = /* @__PURE__ */ io({
  config: qe,
  numeric: gn,
  smaller: Qr,
  typed: se
}), pv = /* @__PURE__ */ Hs({
  DenseMatrix: yt,
  concat: Tt,
  config: qe,
  equalScalar: wt,
  matrix: ze,
  round: kt,
  typed: se,
  zeros: yr
}), it = /* @__PURE__ */ T0({
  addScalar: vr,
  dot: mo,
  equalScalar: wt,
  matrix: ze,
  multiplyScalar: ar,
  typed: se
}), ID = /* @__PURE__ */ Ol({
  Complex: Ft,
  config: qe,
  divideScalar: rr,
  typed: se
}), BD = /* @__PURE__ */ Ws({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), go = /* @__PURE__ */ Xl({
  compare: Ui,
  isNaN: is,
  isNumeric: zi,
  typed: se
}), RD = /* @__PURE__ */ $l({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se,
  zeros: yr
}), hv = /* @__PURE__ */ bf({
  SparseMatrix: Kn,
  abs: $t,
  add: ut,
  divideScalar: rr,
  larger: Vr,
  largerEq: ho,
  multiply: it,
  subtract: Xt,
  transpose: as,
  typed: se
}), hn = /* @__PURE__ */ Ks({
  add: ut,
  matrix: ze,
  typed: se,
  zeros: yr
}), om = /* @__PURE__ */ ao({
  add: ut,
  config: qe,
  numeric: gn,
  typed: se
}), mv = /* @__PURE__ */ jc({
  add: ut,
  matrix: ze,
  typed: se
}), dv = /* @__PURE__ */ Ll({
  DenseMatrix: yt,
  divideScalar: rr,
  equalScalar: wt,
  matrix: ze,
  multiplyScalar: ar,
  subtractScalar: bn,
  typed: se
}), LD = /* @__PURE__ */ fp({
  Complex: Ft,
  add: ut,
  multiply: it,
  number: Xn,
  typed: se
}), um = /* @__PURE__ */ v0({
  DenseMatrix: yt,
  config: qe,
  equalScalar: wt,
  matrix: ze,
  round: kt,
  typed: se,
  zeros: yr
}), Hn = /* @__PURE__ */ Ul({
  compare: Ui,
  typed: se
}), PD = /* @__PURE__ */ rp({
  addScalar: vr,
  combinations: fo,
  isInteger: en,
  isNegative: di,
  isPositive: ki,
  larger: Vr,
  typed: se
}), kD = /* @__PURE__ */ V0({
  matrix: ze,
  multiply: it,
  subtract: Xt,
  typed: se
}), lm = /* @__PURE__ */ Cf({
  divideScalar: rr,
  isZero: On,
  matrix: ze,
  multiply: it,
  subtractScalar: bn,
  typed: se,
  unaryMinus: Gn
}), $D = /* @__PURE__ */ R0({
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  multiplyScalar: ar,
  typed: se
}), vv = /* @__PURE__ */ rc({
  larger: Vr,
  smaller: Qr
}), gv = /* @__PURE__ */ b0({
  Complex: Ft,
  DenseMatrix: yt,
  ceil: um,
  equalScalar: wt,
  floor: lv,
  matrix: ze,
  typed: se,
  zeros: yr
}), yv = /* @__PURE__ */ Zc({
  Index: Rr,
  typed: se
}), zD = /* @__PURE__ */ Pf({
  abs: $t,
  add: ut,
  addScalar: vr,
  config: qe,
  divideScalar: rr,
  equalScalar: wt,
  flatten: us,
  isNumeric: zi,
  isZero: On,
  matrix: ze,
  multiply: it,
  multiplyScalar: ar,
  smaller: Qr,
  subtract: Xt,
  typed: se
}), UD = /* @__PURE__ */ B0({
  BigNumber: He,
  add: ut,
  config: qe,
  equal: wn,
  isInteger: en,
  mod: pv,
  smaller: Qr,
  typed: se,
  xgcd: nv
}), GD = /* @__PURE__ */ A0({
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), HD = /* @__PURE__ */ Ml({
  Complex: Ft,
  config: qe,
  divideScalar: rr,
  log: vo,
  typed: se
}), yo = /* @__PURE__ */ no({
  config: qe,
  larger: Vr,
  numeric: gn,
  typed: se
}), QD = /* @__PURE__ */ Ic({
  DenseMatrix: yt,
  Index: Rr,
  compareNatural: Hn,
  size: Tr,
  subset: hn,
  typed: se
}), VD = /* @__PURE__ */ Rc({
  DenseMatrix: yt,
  Index: Rr,
  compareNatural: Hn,
  size: Tr,
  subset: hn,
  typed: se
}), WD = /* @__PURE__ */ Pc({
  Index: Rr,
  compareNatural: Hn,
  size: Tr,
  subset: hn,
  typed: se
}), jD = /* @__PURE__ */ $c({
  Index: Rr,
  compareNatural: Hn,
  size: Tr,
  subset: hn,
  typed: se
}), aa = /* @__PURE__ */ Wl({
  DenseMatrix: yt,
  concat: Tt,
  config: qe,
  matrix: ze,
  typed: se
}), ZD = /* @__PURE__ */ Kl({
  compare: Ui,
  compareNatural: Hn,
  matrix: ze,
  typed: se
}), JD = /* @__PURE__ */ Yl({
  DenseMatrix: yt,
  concat: Tt,
  config: qe,
  equalScalar: wt,
  matrix: ze,
  typed: se
}), YD = /* @__PURE__ */ ro({
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  not: Ls,
  typed: se,
  zeros: yr
}), sa = /* @__PURE__ */ Ys({
  bignumber: ln,
  matrix: ze,
  add: ut,
  config: qe,
  isPositive: ki,
  larger: Vr,
  largerEq: ho,
  smaller: Qr,
  smallerEq: aa,
  typed: se
}), XD = /* @__PURE__ */ Xs({
  Index: Rr,
  matrix: ze,
  range: sa,
  typed: se
}), xv = /* @__PURE__ */ Bc({
  DenseMatrix: yt,
  Index: Rr,
  compareNatural: Hn,
  size: Tr,
  subset: hn,
  typed: se
}), KD = /* @__PURE__ */ kc({
  Index: Rr,
  compareNatural: Hn,
  size: Tr,
  subset: hn,
  typed: se
}), bv = /* @__PURE__ */ Uc({
  Index: Rr,
  concat: Tt,
  setDifference: xv,
  size: Tr,
  subset: hn,
  typed: se
}), wv = /* @__PURE__ */ nc({
  FibonacciHeap: vv,
  addScalar: vr,
  equalScalar: wt
}), Nv = /* @__PURE__ */ Zs({
  Index: Rr,
  matrix: ze,
  range: sa,
  typed: se
}), Gi = /* @__PURE__ */ Tf({
  abs: $t,
  addScalar: vr,
  det: lm,
  divideScalar: rr,
  identity: gi,
  matrix: ze,
  multiply: it,
  typed: se,
  unaryMinus: Gn
}), Dv = /* @__PURE__ */ yf({
  DenseMatrix: yt,
  Spa: wv,
  SparseMatrix: Kn,
  abs: $t,
  addScalar: vr,
  divideScalar: rr,
  equalScalar: wt,
  larger: Vr,
  matrix: ze,
  multiplyScalar: ar,
  subtractScalar: bn,
  typed: se,
  unaryMinus: Gn
}), eA = /* @__PURE__ */ _f({
  Complex: Ft,
  add: ut,
  ctranspose: ss,
  deepEqual: sm,
  divideScalar: rr,
  dot: mo,
  dotDivide: os,
  equal: wn,
  inv: Gi,
  matrix: ze,
  multiply: it,
  typed: se
}), _t = /* @__PURE__ */ Cl({
  Complex: Ft,
  config: qe,
  fraction: fa,
  identity: gi,
  inv: Gi,
  matrix: ze,
  multiply: it,
  number: Xn,
  typed: se
}), Av = /* @__PURE__ */ Lc({
  DenseMatrix: yt,
  Index: Rr,
  compareNatural: Hn,
  size: Tr,
  subset: hn,
  typed: se
}), tA = /* @__PURE__ */ Gc({
  Index: Rr,
  concat: Tt,
  setIntersect: Av,
  setSymDifference: bv,
  size: Tr,
  subset: hn,
  typed: se
}), rA = /* @__PURE__ */ Ff({
  abs: $t,
  add: ut,
  identity: gi,
  inv: Gi,
  map: $i,
  max: yo,
  multiply: it,
  size: Tr,
  sqrt: dr,
  subtract: Xt,
  typed: se
}), st = /* @__PURE__ */ ac({
  BigNumber: He,
  Complex: Ft,
  Fraction: Pi,
  abs: $t,
  addScalar: vr,
  config: qe,
  divideScalar: rr,
  equal: wn,
  fix: gv,
  format: ns,
  isNumeric: zi,
  multiplyScalar: ar,
  number: Xn,
  pow: _t,
  round: kt,
  subtractScalar: bn
}), nA = /* @__PURE__ */ Pp({
  BigNumber: He,
  Unit: st,
  config: qe
}), iA = /* @__PURE__ */ xh({
  BigNumber: He,
  Unit: st,
  config: qe
}), aA = /* @__PURE__ */ oh({
  BigNumber: He,
  Unit: st,
  config: qe
}), sA = /* @__PURE__ */ zp({
  BigNumber: He,
  Unit: st,
  config: qe
}), oA = /* @__PURE__ */ lh({
  BigNumber: He,
  Unit: st,
  config: qe
}), uA = /* @__PURE__ */ Up({
  BigNumber: He,
  Unit: st,
  config: qe
}), lA = /* @__PURE__ */ kp({
  BigNumber: He,
  Unit: st,
  config: qe
}), cA = /* @__PURE__ */ eh({
  BigNumber: He,
  Unit: st,
  config: qe
}), fA = /* @__PURE__ */ Fl({
  DenseMatrix: yt,
  concat: Tt,
  equalScalar: wt,
  matrix: ze,
  pow: _t,
  typed: se
}), pA = /* @__PURE__ */ Lp({
  BigNumber: He,
  Unit: st,
  config: qe
}), hA = /* @__PURE__ */ $p({
  BigNumber: He,
  Unit: st,
  config: qe
}), mA = /* @__PURE__ */ Of({
  abs: $t,
  add: ut,
  identity: gi,
  inv: Gi,
  multiply: it,
  typed: se
}), dA = /* @__PURE__ */ ch({
  BigNumber: He,
  Unit: st,
  config: qe
}), Ev = /* @__PURE__ */ pl({
  addScalar: vr,
  ceil: um,
  conj: Yn,
  divideScalar: rr,
  dotDivide: os,
  exp: Xd,
  i: Vd,
  log2: vi,
  matrix: ze,
  multiplyScalar: ar,
  pow: _t,
  tau: jd,
  typed: se
}), cm = /* @__PURE__ */ Hf({
  BigNumber: He,
  Complex: Ft,
  config: qe,
  multiplyScalar: ar,
  pow: _t,
  typed: se
}), vA = /* @__PURE__ */ qp({
  BigNumber: He,
  Unit: st,
  config: qe
}), gA = /* @__PURE__ */ Xp({
  BigNumber: He,
  Unit: st,
  config: qe
}), yA = /* @__PURE__ */ hl({
  conj: Yn,
  dotDivide: os,
  fft: Ev,
  typed: se
}), xA = /* @__PURE__ */ Vp({
  BigNumber: He,
  Unit: st,
  config: qe
}), bA = /* @__PURE__ */ ph({
  BigNumber: He,
  Unit: st,
  config: qe
}), wA = /* @__PURE__ */ Rp({
  BigNumber: He,
  Unit: st,
  config: qe
}), NA = /* @__PURE__ */ bh({
  BigNumber: He,
  Unit: st,
  config: qe
}), DA = /* @__PURE__ */ mh({
  BigNumber: He,
  Unit: st,
  config: qe
}), AA = /* @__PURE__ */ th({
  BigNumber: He,
  Unit: st,
  config: qe
}), EA = /* @__PURE__ */ Qp({
  BigNumber: He,
  Unit: st,
  config: qe
}), SA = /* @__PURE__ */ Sh({
  BigNumber: He,
  Unit: st,
  config: qe
}), CA = /* @__PURE__ */ Dh({
  BigNumber: He,
  Unit: st,
  config: qe
}), TA = /* @__PURE__ */ Ch({
  BigNumber: He,
  Unit: st,
  config: qe
}), _A = /* @__PURE__ */ Kp({
  BigNumber: He,
  Unit: st,
  config: qe
}), MA = /* @__PURE__ */ rh({
  BigNumber: He,
  Unit: st,
  config: qe
}), OA = /* @__PURE__ */ Bp({
  BigNumber: He,
  Unit: st,
  config: qe
}), FA = /* @__PURE__ */ nh({
  BigNumber: He,
  Unit: st,
  config: qe
}), qA = /* @__PURE__ */ gh({
  BigNumber: He,
  Unit: st,
  config: qe
}), IA = /* @__PURE__ */ Fp({
  BigNumber: He,
  Unit: st,
  config: qe
}), BA = /* @__PURE__ */ yh({
  BigNumber: He,
  Unit: st,
  config: qe
}), RA = /* @__PURE__ */ ih({
  BigNumber: He,
  Unit: st,
  config: qe
}), LA = /* @__PURE__ */ uh({
  BigNumber: He,
  Unit: st,
  config: qe
}), PA = /* @__PURE__ */ Wp({
  BigNumber: He,
  Unit: st,
  config: qe
}), kA = /* @__PURE__ */ uc({
  Unit: st,
  typed: se
}), ur = /* @__PURE__ */ Rf({
  divideScalar: rr,
  equalScalar: wt,
  inv: Gi,
  matrix: ze,
  multiply: it,
  typed: se
}), $A = /* @__PURE__ */ Zp({
  BigNumber: He,
  Unit: st,
  config: qe
}), ls = /* @__PURE__ */ Vf({
  gamma: cm,
  typed: se
}), zA = /* @__PURE__ */ fh({
  BigNumber: He,
  Unit: st,
  config: qe
}), UA = /* @__PURE__ */ Nh({
  BigNumber: He,
  Unit: st,
  config: qe
}), GA = /* @__PURE__ */ Gp({
  BigNumber: He,
  Unit: st,
  config: qe
}), Sv = /* @__PURE__ */ wf({
  DenseMatrix: yt,
  lsolve: sv,
  lup: Dv,
  matrix: ze,
  slu: hv,
  typed: se,
  usolve: am
}), HA = /* @__PURE__ */ Hp({
  BigNumber: He,
  Unit: st,
  config: qe
}), QA = /* @__PURE__ */ wh({
  BigNumber: He,
  Unit: st,
  config: qe
}), VA = /* @__PURE__ */ jf({
  add: ut,
  divide: ur,
  factorial: ls,
  isInteger: en,
  isPositive: ki,
  multiply: it,
  typed: se
}), WA = /* @__PURE__ */ Zf({
  factorial: ls,
  typed: se
}), jA = /* @__PURE__ */ Ah({
  BigNumber: He,
  Unit: st,
  config: qe
}), ZA = /* @__PURE__ */ Nf({
  add: ut,
  cbrt: iv,
  divide: ur,
  equalScalar: wt,
  im: Ga,
  isZero: On,
  multiply: it,
  re: Ha,
  sqrt: dr,
  subtract: Xt,
  typeOf: ev,
  typed: se,
  unaryMinus: Gn
}), JA = /* @__PURE__ */ zc({
  compareNatural: Hn,
  typed: se
}), YA = /* @__PURE__ */ ml({
  abs: $t,
  add: ut,
  bignumber: ln,
  divide: ur,
  isNegative: di,
  isPositive: ki,
  larger: Vr,
  map: $i,
  matrix: ze,
  max: yo,
  multiply: it,
  smaller: Qr,
  subtract: Xt,
  typed: se,
  unaryMinus: Gn
}), Cv = /* @__PURE__ */ Kf({
  bignumber: ln,
  addScalar: vr,
  combinations: fo,
  divideScalar: rr,
  factorial: ls,
  isInteger: en,
  isNegative: di,
  larger: Vr,
  multiplyScalar: ar,
  number: Xn,
  pow: _t,
  subtractScalar: bn,
  typed: se
}), XA = /* @__PURE__ */ sc({
  Unit: st,
  typed: se
}), KA = /* @__PURE__ */ ep({
  addScalar: vr,
  isInteger: en,
  isNegative: di,
  stirlingS2: Cv,
  typed: se
}), Tv = /* @__PURE__ */ Mf({
  abs: $t,
  add: ut,
  addScalar: vr,
  atan: Jd,
  bignumber: ln,
  column: Nv,
  complex: Wt,
  config: qe,
  cos: Kh,
  diag: av,
  divideScalar: rr,
  dot: mo,
  equal: wn,
  flatten: us,
  im: Ga,
  inv: Gi,
  larger: Vr,
  matrix: ze,
  matrixFromColumns: rm,
  multiply: it,
  multiplyScalar: ar,
  number: Xn,
  qr: nm,
  re: Ha,
  reshape: rv,
  sin: po,
  size: Tr,
  smaller: Qr,
  sqrt: dr,
  subtract: Xt,
  typed: se,
  usolve: am,
  usolveAll: dv
}), eE = /* @__PURE__ */ Jp({
  BigNumber: He,
  Unit: st,
  config: qe
}), tE = /* @__PURE__ */ hh({
  BigNumber: He,
  Unit: st,
  config: qe
}), rE = /* @__PURE__ */ Wf({
  divide: ur,
  dotDivide: os,
  isNumeric: zi,
  log: vo,
  map: $i,
  matrix: ze,
  multiply: it,
  sum: om,
  typed: se
}), _v = /* @__PURE__ */ oo({
  add: ut,
  divide: ur,
  typed: se
}), nE = /* @__PURE__ */ dh({
  BigNumber: He,
  Unit: st,
  config: qe
}), iE = /* @__PURE__ */ Ip({
  BigNumber: He,
  Unit: st,
  config: qe
}), aE = /* @__PURE__ */ lo({
  bignumber: ln,
  add: ut,
  compare: Ui,
  divide: ur,
  isInteger: en,
  larger: Vr,
  multiply: it,
  partitionSelect: go,
  smaller: Qr,
  smallerEq: aa,
  subtract: Xt,
  typed: se
}), fm = /* @__PURE__ */ uo({
  add: ut,
  apply: tm,
  divide: ur,
  isNaN: is,
  multiply: it,
  subtract: Xt,
  typed: se
}), sE = /* @__PURE__ */ jp({
  BigNumber: He,
  Unit: st,
  config: qe
}), Mv = /* @__PURE__ */ kf({
  add: ut,
  compare: Ui,
  divide: ur,
  partitionSelect: go,
  typed: se
}), oE = /* @__PURE__ */ zf({
  add: ut,
  divide: ur,
  matrix: ze,
  mean: _v,
  multiply: it,
  pow: _t,
  sqrt: dr,
  subtract: Xt,
  sum: om,
  typed: se
}), uE = /* @__PURE__ */ pp({
  Complex: Ft,
  add: ut,
  divide: ur,
  matrix: ze,
  multiply: it,
  typed: se
}), lE = /* @__PURE__ */ $f({
  abs: $t,
  map: $i,
  median: Mv,
  subtract: Xt,
  typed: se
}), cE = /* @__PURE__ */ co({
  map: $i,
  sqrt: dr,
  typed: se,
  variance: fm
}), fE = /* @__PURE__ */ vl({
  BigNumber: He,
  Complex: Ft,
  add: ut,
  config: qe,
  divide: ur,
  equal: wn,
  factorial: ls,
  gamma: cm,
  isNegative: di,
  multiply: it,
  pi: Oi,
  pow: _t,
  sin: po,
  smallerEq: aa,
  subtract: Xt,
  typed: se
}), pm = /* @__PURE__ */ Vc({
  abs: $t,
  add: ut,
  conj: Yn,
  ctranspose: ss,
  eigs: Tv,
  equalScalar: wt,
  larger: Vr,
  matrix: ze,
  multiply: it,
  pow: _t,
  smaller: Qr,
  sqrt: dr,
  typed: se
}), Ov = /* @__PURE__ */ sl({
  BigNumber: He,
  DenseMatrix: yt,
  SparseMatrix: Kn,
  addScalar: vr,
  config: qe,
  cos: Kh,
  matrix: ze,
  multiplyScalar: ar,
  norm: pm,
  sin: po,
  typed: se,
  unaryMinus: Gn
}), pE = /* @__PURE__ */ Eh({
  BigNumber: He,
  Unit: st,
  config: qe
}), Fv = /* @__PURE__ */ If({
  identity: gi,
  matrix: ze,
  multiply: it,
  norm: pm,
  qr: nm,
  subtract: Xt,
  typed: se
}), hE = /* @__PURE__ */ al({
  multiply: it,
  rotationMatrix: Ov,
  typed: se
}), qv = /* @__PURE__ */ qf({
  abs: $t,
  add: ut,
  concat: Tt,
  identity: gi,
  index: yv,
  lusolve: Sv,
  matrix: ze,
  matrixFromColumns: rm,
  multiply: it,
  range: sa,
  schur: Fv,
  subset: hn,
  subtract: Xt,
  transpose: as,
  typed: se
}), mE = /* @__PURE__ */ Bf({
  matrix: ze,
  multiply: it,
  sylvester: qv,
  transpose: as,
  typed: se
}), cs = {}, fs = {}, dE = {}, kr = Jc({
  mathWithTransform: fs
}), pa = sf({
  Node: kr
}), ei = of({
  Node: kr
}), Hi = uf({
  Node: kr
}), Iv = cf({
  Node: kr
}), ha = Xc({
  Node: kr
}), Bv = ef({
  Node: kr,
  ResultSet: Wd
}), Rv = tf({
  Node: kr
}), yi = rf({
  Node: kr
}), Lv = lf({
  Node: kr
}), vE = hp({
  classes: dE
}), hm = Af({
  math: cs,
  typed: se
}), Pv = nf({
  Node: kr,
  typed: se
}), gE = Sf({
  Chain: hm,
  typed: se
}), ma = af({
  Node: kr,
  size: Tr
}), da = Yc({
  Node: kr,
  subset: hn
}), kv = Kc({
  matrix: ze,
  Node: kr,
  subset: hn
}), xi = ff({
  Unit: st,
  Node: kr,
  math: cs
}), bi = pf({
  Node: kr,
  SymbolNode: xi,
  math: cs
}), Et = hf({
  AccessorNode: da,
  ArrayNode: ha,
  AssignmentNode: kv,
  BlockNode: Bv,
  ConditionalNode: Rv,
  ConstantNode: yi,
  FunctionAssignmentNode: Pv,
  FunctionNode: bi,
  IndexNode: ma,
  ObjectNode: pa,
  OperatorNode: ei,
  ParenthesisNode: Hi,
  RangeNode: Lv,
  RelationalNode: Iv,
  SymbolNode: xi,
  config: qe,
  numeric: gn,
  typed: se
}), $v = op({
  ConstantNode: yi,
  FunctionNode: bi,
  OperatorNode: ei,
  ParenthesisNode: Hi,
  parse: Et,
  typed: se
}), mm = ap({
  bignumber: ln,
  fraction: fa,
  AccessorNode: da,
  ArrayNode: ha,
  ConstantNode: yi,
  FunctionNode: bi,
  IndexNode: ma,
  ObjectNode: pa,
  OperatorNode: ei,
  SymbolNode: xi,
  config: qe,
  mathWithTransform: fs,
  matrix: ze,
  typed: se
}), yE = mf({
  parse: Et,
  typed: se
}), dm = sp({
  AccessorNode: da,
  ArrayNode: ha,
  ConstantNode: yi,
  FunctionNode: bi,
  IndexNode: ma,
  ObjectNode: pa,
  OperatorNode: ei,
  ParenthesisNode: Hi,
  SymbolNode: xi,
  add: ut,
  divide: ur,
  equal: wn,
  isZero: On,
  multiply: it,
  parse: Et,
  pow: _t,
  subtract: Xt,
  typed: se
}), Br = df({
  parse: Et,
  typed: se
}), zv = Df({
  evaluate: Br
}), Uv = vf({
  evaluate: Br
}), xo = ip({
  bignumber: ln,
  fraction: fa,
  AccessorNode: da,
  ArrayNode: ha,
  ConstantNode: yi,
  FunctionNode: bi,
  IndexNode: ma,
  ObjectNode: pa,
  OperatorNode: ei,
  ParenthesisNode: Hi,
  SymbolNode: xi,
  add: ut,
  config: qe,
  divide: ur,
  equal: wn,
  isZero: On,
  mathWithTransform: fs,
  matrix: ze,
  multiply: it,
  parse: Et,
  pow: _t,
  resolve: $v,
  simplifyConstant: mm,
  simplifyCore: dm,
  subtract: Xt,
  typed: se
}), xE = up({
  OperatorNode: ei,
  parse: Et,
  simplify: xo,
  typed: se
}), bE = np({
  parse: Et,
  typed: se
}), wE = gf({
  Parser: Uv,
  typed: se
}), NE = cp({
  bignumber: ln,
  fraction: fa,
  AccessorNode: da,
  ArrayNode: ha,
  ConstantNode: yi,
  FunctionNode: bi,
  IndexNode: ma,
  ObjectNode: pa,
  OperatorNode: ei,
  ParenthesisNode: Hi,
  SymbolNode: xi,
  add: ut,
  config: qe,
  divide: ur,
  equal: wn,
  isZero: On,
  mathWithTransform: fs,
  matrix: ze,
  multiply: it,
  parse: Et,
  pow: _t,
  simplify: xo,
  simplifyConstant: mm,
  simplifyCore: dm,
  subtract: Xt,
  typed: se
}), DE = lp({
  ConstantNode: yi,
  FunctionNode: bi,
  OperatorNode: ei,
  ParenthesisNode: Hi,
  SymbolNode: xi,
  config: qe,
  equal: wn,
  isZero: On,
  numeric: gn,
  parse: Et,
  simplify: xo,
  typed: se
}), AE = Ef({
  Help: zv,
  mathWithTransform: fs,
  typed: se
});
hr(cs, {
  e: ud,
  false: tN,
  fineStructure: rN,
  i: Vd,
  Infinity: nN,
  LN10: iN,
  LOG10E: aN,
  NaN: sN,
  null: oN,
  phi: uN,
  SQRT1_2: cN,
  sackurTetrode: fN,
  tau: jd,
  true: pN,
  E: ud,
  version: hN,
  efimovFactor: mN,
  LN2: dN,
  pi: Oi,
  replacer: vN,
  reviver: vE,
  SQRT2: gN,
  typed: se,
  PI: Oi,
  weakMixingAngle: yN,
  abs: $t,
  acos: Zd,
  acot: xN,
  acsc: bN,
  addScalar: vr,
  arg: Rs,
  asech: wN,
  asinh: NN,
  atan: Jd,
  atanh: DN,
  bigint: AN,
  bitNot: EN,
  boolean: SN,
  clone: CN,
  combinations: fo,
  complex: Wt,
  conj: Yn,
  cos: Kh,
  cot: TN,
  csc: Yd,
  cube: _N,
  equalScalar: wt,
  erf: MN,
  exp: Xd,
  expm1: ON,
  filter: FN,
  forEach: qN,
  format: ns,
  getMatrixDataType: em,
  hex: IN,
  im: Ga,
  isInteger: en,
  isNegative: di,
  isPositive: ki,
  isZero: On,
  LOG2E: BN,
  lgamma: RN,
  log10: LN,
  log2: vi,
  map: $i,
  multiplyScalar: ar,
  not: Ls,
  number: Xn,
  oct: PN,
  pickRandom: kN,
  print: $N,
  random: zN,
  re: Ha,
  sec: UN,
  sign: Kd,
  sin: po,
  splitUnit: GN,
  square: HN,
  string: QN,
  subtractScalar: bn,
  tan: VN,
  typeOf: ev,
  acosh: WN,
  acsch: jN,
  apply: tm,
  asec: ZN,
  bignumber: ln,
  chain: gE,
  combinationsWithRep: JN,
  cosh: YN,
  csch: XN,
  isNaN: is,
  isPrime: KN,
  randomInt: eD,
  sech: tD,
  sinh: rD,
  sparse: nD,
  sqrt: dr,
  tanh: iD,
  unaryMinus: Gn,
  acoth: aD,
  bin: sD,
  coth: oD,
  fraction: fa,
  isNumeric: zi,
  matrix: ze,
  matrixFromFunction: uD,
  mode: lD,
  numeric: gn,
  prod: tv,
  reshape: rv,
  size: Tr,
  squeeze: cD,
  transpose: as,
  xgcd: nv,
  zeros: yr,
  asin: fD,
  cbrt: iv,
  concat: Tt,
  count: pD,
  ctranspose: ss,
  diag: av,
  divideScalar: rr,
  dotDivide: os,
  equal: wn,
  flatten: us,
  hasNumericValue: hD,
  identity: gi,
  kron: mD,
  largerEq: ho,
  leftShift: dD,
  lsolve: sv,
  matrixFromColumns: rm,
  nthRoot: vD,
  ones: gD,
  qr: nm,
  resize: yD,
  rightArithShift: xD,
  round: kt,
  smaller: Qr,
  subtract: Xt,
  to: bD,
  unaryPlus: im,
  usolve: am,
  xor: wD,
  add: ut,
  atan2: ov,
  bitAnd: ND,
  bitOr: DD,
  bitXor: AD,
  catalan: ED,
  compare: Ui,
  compareText: uv,
  cumsum: SD,
  deepEqual: sm,
  diff: CD,
  distance: TD,
  dot: mo,
  equalText: _D,
  floor: lv,
  gcd: MD,
  hypot: OD,
  larger: Vr,
  log: vo,
  lsolveAll: FD,
  matrixFromRows: qD,
  min: fv,
  mod: pv,
  multiply: it,
  nthRoots: ID,
  or: BD,
  partitionSelect: go,
  rightLogShift: RD,
  slu: hv,
  subset: hn,
  sum: om,
  trace: mv,
  usolveAll: dv,
  zpk2tf: LD,
  ceil: um,
  compareNatural: Hn,
  composition: PD,
  cross: kD,
  det: lm,
  dotMultiply: $D,
  fix: gv,
  index: yv,
  intersect: zD,
  invmod: UD,
  lcm: GD,
  log1p: HD,
  max: yo,
  setCartesian: QD,
  setDistinct: VD,
  setIsSubset: WD,
  setPowerset: jD,
  smallerEq: aa,
  sort: ZD,
  unequal: JD,
  and: YD,
  range: sa,
  row: XD,
  setDifference: xv,
  setMultiplicity: KD,
  setSymDifference: bv,
  column: Nv,
  inv: Gi,
  lup: Dv,
  pinv: eA,
  pow: _t,
  setIntersect: Av,
  setUnion: tA,
  sqrtm: rA,
  vacuumImpedance: nA,
  wienDisplacement: iA,
  atomicMass: aA,
  bohrMagneton: sA,
  boltzmann: oA,
  conductanceQuantum: uA,
  coulomb: lA,
  deuteronMass: cA,
  dotPow: fA,
  electricConstant: pA,
  elementaryCharge: hA,
  expm: mA,
  faraday: dA,
  fft: Ev,
  gamma: cm,
  gravitationConstant: vA,
  hartreeEnergy: gA,
  ifft: yA,
  klitzing: xA,
  loschmidt: bA,
  magneticConstant: wA,
  molarMass: NA,
  molarPlanckConstant: DA,
  neutronMass: AA,
  nuclearMagneton: EA,
  planckCharge: SA,
  planckLength: CA,
  planckTemperature: TA,
  protonMass: _A,
  quantumOfCirculation: MA,
  reducedPlanckConstant: OA,
  rydberg: FA,
  secondRadiation: qA,
  speedOfLight: IA,
  stefanBoltzmann: BA,
  thomsonCrossSection: RA,
  avogadro: LA,
  bohrRadius: PA,
  createUnit: kA,
  divide: ur,
  electronMass: $A,
  factorial: ls,
  firstRadiation: zA,
  gravity: UA,
  inverseConductanceQuantum: GA,
  lusolve: Sv,
  magneticFluxQuantum: HA,
  molarMassC12: QA,
  multinomial: VA,
  parse: Et,
  permutations: WA,
  planckMass: jA,
  polynomialRoot: ZA,
  resolve: $v,
  setSize: JA,
  simplifyConstant: mm,
  solveODE: YA,
  stirlingS2: Cv,
  unit: XA,
  bellNumbers: KA,
  compile: yE,
  eigs: Tv,
  fermiCoupling: eE,
  gasConstant: tE,
  kldivergence: rE,
  mean: _v,
  molarVolume: nE,
  planckConstant: iE,
  quantileSeq: aE,
  simplifyCore: dm,
  variance: fm,
  classicalElectronRadius: sE,
  evaluate: Br,
  median: Mv,
  simplify: xo,
  symbolicEqual: xE,
  corr: oE,
  freqz: uE,
  leafCount: bE,
  mad: lE,
  parser: wE,
  rationalize: NE,
  std: cE,
  zeta: fE,
  derivative: DE,
  norm: pm,
  rotationMatrix: Ov,
  help: AE,
  planckTime: pE,
  schur: Fv,
  rotate: hE,
  sylvester: qv,
  lyap: mE,
  config: qe
});
hr(fs, cs, {
  filter: Oh({
    typed: se
  }),
  forEach: Fh({
    typed: se
  }),
  map: Ih({
    typed: se
  }),
  apply: _h({
    isInteger: en,
    typed: se
  }),
  or: Jh({
    DenseMatrix: yt,
    concat: Tt,
    equalScalar: wt,
    matrix: ze,
    typed: se
  }),
  and: Zh({
    add: ut,
    concat: Tt,
    equalScalar: wt,
    matrix: ze,
    not: Ls,
    typed: se,
    zeros: yr
  }),
  concat: zh({
    isInteger: en,
    matrix: ze,
    typed: se
  }),
  max: Bh({
    config: qe,
    larger: Vr,
    numeric: gn,
    typed: se
  }),
  print: jh({
    add: ut,
    matrix: ze,
    typed: se,
    zeros: yr
  }),
  bitAnd: Yh({
    add: ut,
    concat: Tt,
    equalScalar: wt,
    matrix: ze,
    not: Ls,
    typed: se,
    zeros: yr
  }),
  diff: Uh({
    bignumber: ln,
    matrix: ze,
    number: Xn,
    subtract: Xt,
    typed: se
  }),
  min: Lh({
    config: qe,
    numeric: gn,
    smaller: Qr,
    typed: se
  }),
  subset: $h({
    add: ut,
    matrix: ze,
    typed: se,
    zeros: yr
  }),
  bitOr: Xh({
    DenseMatrix: yt,
    concat: Tt,
    equalScalar: wt,
    matrix: ze,
    typed: se
  }),
  cumsum: Vh({
    add: ut,
    typed: se,
    unaryPlus: im
  }),
  index: qh({
    Index: Rr,
    getMatrixDataType: em
  }),
  sum: Hh({
    add: ut,
    config: qe,
    numeric: gn,
    typed: se
  }),
  range: Ph({
    bignumber: ln,
    matrix: ze,
    add: ut,
    config: qe,
    isPositive: ki,
    larger: Vr,
    largerEq: ho,
    smaller: Qr,
    smallerEq: aa,
    typed: se
  }),
  row: kh({
    Index: Rr,
    matrix: ze,
    range: sa,
    typed: se
  }),
  column: Mh({
    Index: Rr,
    matrix: ze,
    range: sa,
    typed: se
  }),
  mean: Rh({
    add: ut,
    divide: ur,
    typed: se
  }),
  quantileSeq: Qh({
    add: ut,
    bignumber: ln,
    compare: Ui,
    divide: ur,
    isInteger: en,
    larger: Vr,
    multiply: it,
    partitionSelect: go,
    smaller: Qr,
    smallerEq: aa,
    subtract: Xt,
    typed: se
  }),
  variance: Wh({
    add: ut,
    apply: tm,
    divide: ur,
    isNaN: is,
    multiply: it,
    subtract: Xt,
    typed: se
  }),
  std: Gh({
    map: $i,
    sqrt: dr,
    typed: se,
    variance: fm
  })
});
hr(dE, {
  BigNumber: He,
  Complex: Ft,
  Fraction: Pi,
  Matrix: rs,
  Node: kr,
  ObjectNode: pa,
  OperatorNode: ei,
  ParenthesisNode: Hi,
  Range: lN,
  RelationalNode: Iv,
  ResultSet: Wd,
  ArrayNode: ha,
  BlockNode: Bv,
  ConditionalNode: Rv,
  ConstantNode: yi,
  DenseMatrix: yt,
  RangeNode: Lv,
  Chain: hm,
  FunctionAssignmentNode: Pv,
  SparseMatrix: Kn,
  IndexNode: ma,
  ImmutableDenseMatrix: cv,
  Index: Rr,
  AccessorNode: da,
  AssignmentNode: kv,
  FibonacciHeap: vv,
  Spa: wv,
  Unit: st,
  SymbolNode: xi,
  FunctionNode: bi,
  Help: zv,
  Parser: Uv
});
hm.createProxy(cs);
var Qe = {
  createBigNumberClass: qu
}, jt = {
  createComplexClass: Iu
}, vm = {
  createMatrixClass: Lu
}, bt = {
  MatrixDependencies: vm,
  createDenseMatrixClass: ku
}, va = {
  createFractionClass: Bu
}, oe = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  DenseMatrixDependencies: bt,
  FractionDependencies: va,
  createTyped: Tu
}, an = {
  typedDependencies: oe,
  createAbs: p0
}, Zr = {
  createNode: Jc
}, At = {
  typedDependencies: oe,
  createEqualScalar: Ju
}, wi = {
  MatrixDependencies: vm,
  equalScalarDependencies: At,
  typedDependencies: oe,
  createSparseMatrixClass: Yu
}, wr = {
  typedDependencies: oe,
  createAddScalar: h0
}, mn = {
  typedDependencies: oe,
  createIsInteger: Uu
}, Ue = {
  DenseMatrixDependencies: bt,
  MatrixDependencies: vm,
  SparseMatrixDependencies: wi,
  typedDependencies: oe,
  createMatrix: a0
}, qt = {
  isIntegerDependencies: mn,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createConcat: js
}, St = {
  DenseMatrixDependencies: bt,
  SparseMatrixDependencies: wi,
  addScalarDependencies: wr,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createAdd: Hc
}, $r = {
  BigNumberDependencies: Qe,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createZeros: fl
}, Nn = {
  addDependencies: St,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createSubset: Ks
}, ps = {
  NodeDependencies: Zr,
  subsetDependencies: Nn,
  createAccessorNode: Yc
}, t6 = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAcos: lc
}, r6 = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAcosh: cc
}, n6 = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createAcot: fc
}, i6 = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAcoth: pc
}, a6 = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAcsc: hc
}, s6 = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createAcsch: mc
}, gm = {
  typedDependencies: oe,
  createNot: G0
}, o6 = {
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  notDependencies: gm,
  typedDependencies: oe,
  zerosDependencies: $r,
  createAnd: ro
}, u6 = {
  addDependencies: St,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  notDependencies: gm,
  typedDependencies: oe,
  zerosDependencies: $r,
  createAndTransform: Zh
}, Gv = {
  isIntegerDependencies: mn,
  typedDependencies: oe,
  createApply: Ka
}, l6 = {
  isIntegerDependencies: mn,
  typedDependencies: oe,
  createApplyTransform: _h
}, c6 = {
  typedDependencies: oe,
  createArg: k0
}, hs = {
  NodeDependencies: Zr,
  createArrayNode: Xc
}, f6 = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAsec: dc
}, p6 = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAsech: vc
}, h6 = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAsin: gc
}, m6 = {
  typedDependencies: oe,
  createAsinh: yc
}, EE = {
  matrixDependencies: Ue,
  NodeDependencies: Zr,
  subsetDependencies: Nn,
  createAssignmentNode: Kc
}, SE = {
  typedDependencies: oe,
  createAtan: xc
}, d6 = {
  BigNumberDependencies: Qe,
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createAtan2: bc
}, v6 = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createAtanh: wc
}, Dn = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createBignumber: r0
}, ms = {
  FractionDependencies: va,
  typedDependencies: oe,
  createFraction: i0
}, Ni = {
  typedDependencies: oe,
  createNumber: Xu
}, Fn = {
  bignumberDependencies: Dn,
  fractionDependencies: ms,
  numberDependencies: Ni,
  createNumeric: El
}, nr = {
  numericDependencies: Fn,
  typedDependencies: oe,
  createDivideScalar: Sl
}, qn = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createEqual: Hl
}, ds = {
  BigNumberDependencies: Qe,
  DenseMatrixDependencies: bt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createRound: Tl
}, Hv = {
  DenseMatrixDependencies: bt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  roundDependencies: ds,
  typedDependencies: oe,
  zerosDependencies: $r,
  createCeil: v0
}, CE = {
  DenseMatrixDependencies: bt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  roundDependencies: ds,
  typedDependencies: oe,
  zerosDependencies: $r,
  createFloor: Gs
}, TE = {
  ComplexDependencies: jt,
  DenseMatrixDependencies: bt,
  ceilDependencies: Hv,
  equalScalarDependencies: At,
  floorDependencies: CE,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createFix: b0
}, bo = {
  typedDependencies: oe,
  createFormat: xl
}, ga = {
  typedDependencies: oe,
  createIsNumeric: Hu
}, lr = {
  typedDependencies: oe,
  createMultiplyScalar: C0
}, Qi = {
  BigNumberDependencies: Qe,
  DenseMatrixDependencies: bt,
  SparseMatrixDependencies: wi,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createIdentity: X0
}, Qn = {
  equalScalarDependencies: At,
  typedDependencies: oe,
  createIsZero: Wu
}, ya = {
  typedDependencies: oe,
  createConj: $0
}, zr = {
  matrixDependencies: Ue,
  typedDependencies: oe,
  createSize: ol
}, ym = {
  addScalarDependencies: wr,
  conjDependencies: ya,
  multiplyScalarDependencies: lr,
  sizeDependencies: zr,
  typedDependencies: oe,
  createDot: Wc
}, Gt = {
  addScalarDependencies: wr,
  dotDependencies: ym,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  typedDependencies: oe,
  createMultiply: T0
}, In = {
  typedDependencies: oe,
  createSubtractScalar: m0
}, ti = {
  typedDependencies: oe,
  createUnaryMinus: c0
}, _E = {
  divideScalarDependencies: nr,
  isZeroDependencies: Qn,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createDet: Cf
}, xa = {
  absDependencies: an,
  addScalarDependencies: wr,
  detDependencies: _E,
  divideScalarDependencies: nr,
  identityDependencies: Qi,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createInv: Tf
}, Bn = {
  ComplexDependencies: jt,
  fractionDependencies: ms,
  identityDependencies: Qi,
  invDependencies: xa,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  numberDependencies: Ni,
  typedDependencies: oe,
  createPow: Cl
}, ot = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  FractionDependencies: va,
  absDependencies: an,
  addScalarDependencies: wr,
  divideScalarDependencies: nr,
  equalDependencies: qn,
  fixDependencies: TE,
  formatDependencies: bo,
  isNumericDependencies: ga,
  multiplyScalarDependencies: lr,
  numberDependencies: Ni,
  powDependencies: Bn,
  roundDependencies: ds,
  subtractScalarDependencies: In,
  createUnitClass: ac
}, g6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createAtomicMass: oh
}, y6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createAvogadro: uh
}, Vi = {
  typedDependencies: oe,
  createIsNegative: Gu
}, xm = {
  typedDependencies: oe,
  createCombinations: Uf
}, Qv = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  multiplyScalarDependencies: lr,
  powDependencies: Bn,
  typedDependencies: oe,
  createGamma: Hf
}, wo = {
  gammaDependencies: Qv,
  typedDependencies: oe,
  createFactorial: Vf
}, sn = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createLarger: jl
}, ME = {
  bignumberDependencies: Dn,
  addScalarDependencies: wr,
  combinationsDependencies: xm,
  divideScalarDependencies: nr,
  factorialDependencies: wo,
  isIntegerDependencies: mn,
  isNegativeDependencies: Vi,
  largerDependencies: sn,
  multiplyScalarDependencies: lr,
  numberDependencies: Ni,
  powDependencies: Bn,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  createStirlingS2: Kf
}, x6 = {
  addScalarDependencies: wr,
  isIntegerDependencies: mn,
  isNegativeDependencies: Vi,
  stirlingS2Dependencies: ME,
  typedDependencies: oe,
  createBellNumbers: ep
}, b6 = {
  typedDependencies: oe,
  createBigint: Ku
}, w6 = {
  formatDependencies: bo,
  typedDependencies: oe,
  createBin: bl
}, N6 = {
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createBitAnd: Qs
}, D6 = {
  addDependencies: St,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  notDependencies: gm,
  typedDependencies: oe,
  zerosDependencies: $r,
  createBitAndTransform: Yh
}, A6 = {
  typedDependencies: oe,
  createBitNot: L0
}, E6 = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createBitOr: Vs
}, S6 = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createBitOrTransform: Xh
}, C6 = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createBitXor: P0
}, OE = {
  createResultSet: _u
}, FE = {
  NodeDependencies: Zr,
  ResultSetDependencies: OE,
  createBlockNode: ef
}, T6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createBohrMagneton: zp
}, _6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createBohrRadius: Wp
}, M6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createBoltzmann: lh
}, O6 = {
  typedDependencies: oe,
  createBoolean: t0
}, F6 = {
  addScalarDependencies: wr,
  combinationsDependencies: xm,
  divideScalarDependencies: nr,
  isIntegerDependencies: mn,
  isNegativeDependencies: Vi,
  multiplyScalarDependencies: lr,
  typedDependencies: oe,
  createCatalan: tp
}, qE = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  FractionDependencies: va,
  isNegativeDependencies: Vi,
  matrixDependencies: Ue,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createCbrt: d0
}, IE = {
  typedDependencies: oe,
  createChainClass: Af
}, q6 = {
  ChainDependencies: IE,
  typedDependencies: oe,
  createChain: Sf
}, I6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createClassicalElectronRadius: jp
}, B6 = {
  typedDependencies: oe,
  createClone: $u
}, on = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createSmaller: Vl
}, BE = {
  DenseMatrixDependencies: bt,
  smallerDependencies: on,
  createImmutableDenseMatrixClass: ec
}, Vv = {
  typedDependencies: oe,
  createGetMatrixDataType: Y0
}, Jr = {
  ImmutableDenseMatrixDependencies: BE,
  getMatrixDataTypeDependencies: Vv,
  createIndexClass: tc
}, ba = {
  typedDependencies: oe,
  createIsPositive: Vu
}, bm = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createLargerEq: Zl
}, vs = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createSmallerEq: Wl
}, gs = {
  bignumberDependencies: Dn,
  matrixDependencies: Ue,
  addDependencies: St,
  isPositiveDependencies: ba,
  largerDependencies: sn,
  largerEqDependencies: bm,
  smallerDependencies: on,
  smallerEqDependencies: vs,
  typedDependencies: oe,
  createRange: Ys
}, RE = {
  IndexDependencies: Jr,
  matrixDependencies: Ue,
  rangeDependencies: gs,
  typedDependencies: oe,
  createColumn: Zs
}, R6 = {
  IndexDependencies: Jr,
  matrixDependencies: Ue,
  rangeDependencies: gs,
  typedDependencies: oe,
  createColumnTransform: Mh
}, L6 = {
  typedDependencies: oe,
  createCombinationsWithRep: Gf
}, wa = {
  BigNumberDependencies: Qe,
  DenseMatrixDependencies: bt,
  FractionDependencies: va,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createCompare: zl
}, ri = {
  compareDependencies: wa,
  typedDependencies: oe,
  createCompareNatural: Ul
}, LE = {
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createCompareText: Gl
}, PE = {
  NodeDependencies: Zr,
  createConditionalNode: tf
}, Wi = {
  NodeDependencies: Zr,
  createConstantNode: rf
}, kE = {
  NodeDependencies: Zr,
  typedDependencies: oe,
  createFunctionAssignmentNode: nf
}, ji = {
  UnitDependencies: ot,
  NodeDependencies: Zr,
  createSymbolNode: ff
}, Zi = {
  NodeDependencies: Zr,
  SymbolNodeDependencies: ji,
  createFunctionNode: pf
}, ys = {
  NodeDependencies: Zr,
  sizeDependencies: zr,
  createIndexNode: af
}, xs = {
  NodeDependencies: Zr,
  createObjectNode: sf
}, Di = {
  NodeDependencies: Zr,
  createOperatorNode: of
}, Na = {
  NodeDependencies: Zr,
  createParenthesisNode: uf
}, $E = {
  NodeDependencies: Zr,
  createRangeNode: lf
}, zE = {
  NodeDependencies: Zr,
  createRelationalNode: cf
}, ni = {
  AccessorNodeDependencies: ps,
  ArrayNodeDependencies: hs,
  AssignmentNodeDependencies: EE,
  BlockNodeDependencies: FE,
  ConditionalNodeDependencies: PE,
  ConstantNodeDependencies: Wi,
  FunctionAssignmentNodeDependencies: kE,
  FunctionNodeDependencies: Zi,
  IndexNodeDependencies: ys,
  ObjectNodeDependencies: xs,
  OperatorNodeDependencies: Di,
  ParenthesisNodeDependencies: Na,
  RangeNodeDependencies: $E,
  RelationalNodeDependencies: zE,
  SymbolNodeDependencies: ji,
  numericDependencies: Fn,
  typedDependencies: oe,
  createParse: hf
}, P6 = {
  parseDependencies: ni,
  typedDependencies: oe,
  createCompile: mf
}, wm = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createComplex: n0
}, k6 = {
  addScalarDependencies: wr,
  combinationsDependencies: xm,
  isIntegerDependencies: mn,
  isNegativeDependencies: Vi,
  isPositiveDependencies: ba,
  largerDependencies: sn,
  typedDependencies: oe,
  createComposition: rp
}, $6 = {
  isIntegerDependencies: mn,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createConcatTransform: zh
}, z6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createConductanceQuantum: Up
}, _r = {
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  invDependencies: xa,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  typedDependencies: oe,
  createDivide: Rf
}, UE = {
  addDependencies: St,
  divideDependencies: _r,
  typedDependencies: oe,
  createMean: oo
}, Vn = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createSqrt: O0
}, cr = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createSubtract: q0
}, Wv = {
  addDependencies: St,
  numericDependencies: Fn,
  typedDependencies: oe,
  createSum: ao
}, U6 = {
  addDependencies: St,
  divideDependencies: _r,
  matrixDependencies: Ue,
  meanDependencies: UE,
  multiplyDependencies: Gt,
  powDependencies: Bn,
  sqrtDependencies: Vn,
  subtractDependencies: cr,
  sumDependencies: Wv,
  typedDependencies: oe,
  createCorr: zf
}, jv = {
  typedDependencies: oe,
  createCos: Nc
}, G6 = {
  typedDependencies: oe,
  createCosh: Dc
}, H6 = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createCot: Ac
}, Q6 = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createCoth: Ec
}, V6 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createCoulomb: kp
}, GE = {
  multiplyScalarDependencies: lr,
  numericDependencies: Fn,
  typedDependencies: oe,
  createProd: yl
}, W6 = {
  prodDependencies: GE,
  sizeDependencies: zr,
  typedDependencies: oe,
  createCount: Q0
}, j6 = {
  UnitDependencies: ot,
  typedDependencies: oe,
  createCreateUnit: uc
}, Z6 = {
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  subtractDependencies: cr,
  typedDependencies: oe,
  createCross: V0
}, J6 = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createCsc: Sc
}, Y6 = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createCsch: Cc
}, No = {
  matrixDependencies: Ue,
  typedDependencies: oe,
  createTranspose: ll
}, Zv = {
  conjDependencies: ya,
  transposeDependencies: No,
  typedDependencies: oe,
  createCtranspose: cl
}, X6 = {
  typedDependencies: oe,
  createCube: g0
}, Jv = {
  numericDependencies: Fn,
  typedDependencies: oe,
  createUnaryPlus: f0
}, K6 = {
  addDependencies: St,
  typedDependencies: oe,
  unaryPlusDependencies: Jv,
  createCumSum: so
}, e9 = {
  addDependencies: St,
  typedDependencies: oe,
  unaryPlusDependencies: Jv,
  createCumSumTransform: Vh
}, Yv = {
  equalDependencies: qn,
  typedDependencies: oe,
  createDeepEqual: Jl
}, HE = {
  ConstantNodeDependencies: Wi,
  FunctionNodeDependencies: Zi,
  OperatorNodeDependencies: Di,
  ParenthesisNodeDependencies: Na,
  parseDependencies: ni,
  typedDependencies: oe,
  createResolve: op
}, Xv = {
  bignumberDependencies: Dn,
  fractionDependencies: ms,
  AccessorNodeDependencies: ps,
  ArrayNodeDependencies: hs,
  ConstantNodeDependencies: Wi,
  FunctionNodeDependencies: Zi,
  IndexNodeDependencies: ys,
  ObjectNodeDependencies: xs,
  OperatorNodeDependencies: Di,
  SymbolNodeDependencies: ji,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createSimplifyConstant: ap
}, Kv = {
  AccessorNodeDependencies: ps,
  ArrayNodeDependencies: hs,
  ConstantNodeDependencies: Wi,
  FunctionNodeDependencies: Zi,
  IndexNodeDependencies: ys,
  ObjectNodeDependencies: xs,
  OperatorNodeDependencies: Di,
  ParenthesisNodeDependencies: Na,
  SymbolNodeDependencies: ji,
  addDependencies: St,
  divideDependencies: _r,
  equalDependencies: qn,
  isZeroDependencies: Qn,
  multiplyDependencies: Gt,
  parseDependencies: ni,
  powDependencies: Bn,
  subtractDependencies: cr,
  typedDependencies: oe,
  createSimplifyCore: sp
}, Nm = {
  bignumberDependencies: Dn,
  fractionDependencies: ms,
  AccessorNodeDependencies: ps,
  ArrayNodeDependencies: hs,
  ConstantNodeDependencies: Wi,
  FunctionNodeDependencies: Zi,
  IndexNodeDependencies: ys,
  ObjectNodeDependencies: xs,
  OperatorNodeDependencies: Di,
  ParenthesisNodeDependencies: Na,
  SymbolNodeDependencies: ji,
  addDependencies: St,
  divideDependencies: _r,
  equalDependencies: qn,
  isZeroDependencies: Qn,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  parseDependencies: ni,
  powDependencies: Bn,
  resolveDependencies: HE,
  simplifyConstantDependencies: Xv,
  simplifyCoreDependencies: Kv,
  subtractDependencies: cr,
  typedDependencies: oe,
  createSimplify: ip
}, t9 = {
  ConstantNodeDependencies: Wi,
  FunctionNodeDependencies: Zi,
  OperatorNodeDependencies: Di,
  ParenthesisNodeDependencies: Na,
  SymbolNodeDependencies: ji,
  equalDependencies: qn,
  isZeroDependencies: Qn,
  numericDependencies: Fn,
  parseDependencies: ni,
  simplifyDependencies: Nm,
  typedDependencies: oe,
  createDerivative: lp
}, r9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createDeuteronMass: eh
}, QE = {
  DenseMatrixDependencies: bt,
  SparseMatrixDependencies: wi,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createDiag: W0
}, n9 = {
  matrixDependencies: Ue,
  numberDependencies: Ni,
  subtractDependencies: cr,
  typedDependencies: oe,
  createDiff: Js
}, i9 = {
  bignumberDependencies: Dn,
  matrixDependencies: Ue,
  numberDependencies: Ni,
  subtractDependencies: cr,
  typedDependencies: oe,
  createDiffTransform: Uh
}, a9 = {
  absDependencies: an,
  addScalarDependencies: wr,
  deepEqualDependencies: Yv,
  divideScalarDependencies: nr,
  multiplyScalarDependencies: lr,
  sqrtDependencies: Vn,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  createDistance: Lf
}, Do = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createDotDivide: ql
}, s9 = {
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  typedDependencies: oe,
  createDotMultiply: R0
}, o9 = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  powDependencies: Bn,
  typedDependencies: oe,
  createDotPow: Fl
}, VE = {
  BigNumberDependencies: Qe,
  createE: Np
}, u9 = {
  BigNumberDependencies: Qe,
  createEfimovFactor: sh
}, Ao = {
  matrixDependencies: Ue,
  typedDependencies: oe,
  createFlatten: Z0
}, eg = {
  typedDependencies: oe,
  createIm: z0
}, tg = {
  flattenDependencies: Ao,
  matrixDependencies: Ue,
  sizeDependencies: zr,
  typedDependencies: oe,
  createMatrixFromColumns: u0
}, WE = {
  BigNumberDependencies: Qe,
  FractionDependencies: va,
  complexDependencies: wm,
  typedDependencies: oe,
  createSign: M0
}, rg = {
  addScalarDependencies: wr,
  complexDependencies: wm,
  conjDependencies: ya,
  divideScalarDependencies: nr,
  equalDependencies: qn,
  identityDependencies: Qi,
  isZeroDependencies: Qn,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  signDependencies: WE,
  sqrtDependencies: Vn,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  zerosDependencies: $r,
  createQr: xf
}, ng = {
  typedDependencies: oe,
  createRe: U0
}, jE = {
  isIntegerDependencies: mn,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createReshape: nl
}, Dm = {
  typedDependencies: oe,
  createSin: Mc
}, ig = {
  DenseMatrixDependencies: bt,
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  createUsolve: Bl
}, ZE = {
  DenseMatrixDependencies: bt,
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  createUsolveAll: Ll
}, JE = {
  absDependencies: an,
  addDependencies: St,
  addScalarDependencies: wr,
  atanDependencies: SE,
  bignumberDependencies: Dn,
  columnDependencies: RE,
  complexDependencies: wm,
  cosDependencies: jv,
  diagDependencies: QE,
  divideScalarDependencies: nr,
  dotDependencies: ym,
  equalDependencies: qn,
  flattenDependencies: Ao,
  imDependencies: eg,
  invDependencies: xa,
  largerDependencies: sn,
  matrixDependencies: Ue,
  matrixFromColumnsDependencies: tg,
  multiplyDependencies: Gt,
  multiplyScalarDependencies: lr,
  numberDependencies: Ni,
  qrDependencies: rg,
  reDependencies: ng,
  reshapeDependencies: jE,
  sinDependencies: Dm,
  sizeDependencies: zr,
  smallerDependencies: on,
  sqrtDependencies: Vn,
  subtractDependencies: cr,
  typedDependencies: oe,
  usolveDependencies: ig,
  usolveAllDependencies: ZE,
  createEigs: Mf
}, l9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createElectricConstant: Lp
}, c9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createElectronMass: Zp
}, f9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createElementaryCharge: $p
}, p9 = {
  compareTextDependencies: LE,
  isZeroDependencies: Qn,
  typedDependencies: oe,
  createEqualText: Ql
}, h9 = {
  typedDependencies: oe,
  createErf: dl
}, ag = {
  parseDependencies: ni,
  typedDependencies: oe,
  createEvaluate: df
}, YE = {
  typedDependencies: oe,
  createExp: y0
}, m9 = {
  absDependencies: an,
  addDependencies: St,
  identityDependencies: Qi,
  invDependencies: xa,
  multiplyDependencies: Gt,
  typedDependencies: oe,
  createExpm: Of
}, d9 = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createExpm1: x0
}, v9 = {
  createFalse: vp
}, g9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createFaraday: ch
}, y9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createFermiCoupling: Jp
}, XE = {
  ComplexDependencies: jt,
  createI: Mp
}, KE = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createLog2: S0
}, eS = {
  BigNumberDependencies: Qe,
  createTau: wp
}, tS = {
  addScalarDependencies: wr,
  ceilDependencies: Hv,
  conjDependencies: ya,
  divideScalarDependencies: nr,
  dotDivideDependencies: Do,
  expDependencies: YE,
  iDependencies: XE,
  log2Dependencies: KE,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  powDependencies: Bn,
  tauDependencies: eS,
  typedDependencies: oe,
  createFft: pl
}, rS = {
  largerDependencies: sn,
  smallerDependencies: on,
  createFibonacciHeapClass: rc
}, x9 = {
  typedDependencies: oe,
  createFilter: j0
}, b9 = {
  typedDependencies: oe,
  createFilterTransform: Oh
}, w9 = {
  BigNumberDependencies: Qe,
  createFineStructure: Yp
}, N9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createFirstRadiation: fh
}, D9 = {
  typedDependencies: oe,
  createForEach: J0
}, A9 = {
  typedDependencies: oe,
  createForEachTransform: Fh
}, E9 = {
  ComplexDependencies: jt,
  addDependencies: St,
  divideDependencies: _r,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  typedDependencies: oe,
  createFreqz: pp
}, S9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createGasConstant: hh
}, C9 = {
  BigNumberDependencies: Qe,
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  roundDependencies: ds,
  typedDependencies: oe,
  zerosDependencies: $r,
  createGcd: N0
}, T9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createGravitationConstant: qp
}, _9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createGravity: Nh
}, M9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createHartreeEnergy: Xp
}, O9 = {
  isNumericDependencies: ga,
  typedDependencies: oe,
  createHasNumericValue: Qu
}, nS = {
  evaluateDependencies: ag,
  createHelpClass: Df
}, F9 = {
  HelpDependencies: nS,
  typedDependencies: oe,
  createHelp: Ef
}, q9 = {
  formatDependencies: bo,
  typedDependencies: oe,
  createHex: Nl
}, I9 = {
  absDependencies: an,
  addScalarDependencies: wr,
  divideScalarDependencies: nr,
  isPositiveDependencies: ba,
  multiplyScalarDependencies: lr,
  smallerDependencies: on,
  sqrtDependencies: Vn,
  typedDependencies: oe,
  createHypot: Qc
}, B9 = {
  conjDependencies: ya,
  dotDivideDependencies: Do,
  fftDependencies: tS,
  typedDependencies: oe,
  createIfft: hl
}, iS = {
  IndexDependencies: Jr,
  typedDependencies: oe,
  createIndex: Zc
}, R9 = {
  IndexDependencies: Jr,
  getMatrixDataTypeDependencies: Vv,
  createIndexTransform: qh
}, L9 = {
  BigNumberDependencies: Qe,
  createInfinity: yp
}, P9 = {
  absDependencies: an,
  addDependencies: St,
  addScalarDependencies: wr,
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  flattenDependencies: Ao,
  isNumericDependencies: ga,
  isZeroDependencies: Qn,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  multiplyScalarDependencies: lr,
  smallerDependencies: on,
  subtractDependencies: cr,
  typedDependencies: oe,
  createIntersect: Pf
}, k9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createInverseConductanceQuantum: Gp
}, aS = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  roundDependencies: ds,
  typedDependencies: oe,
  zerosDependencies: $r,
  createMod: Hs
}, sS = {
  BigNumberDependencies: Qe,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createXgcd: I0
}, $9 = {
  BigNumberDependencies: Qe,
  addDependencies: St,
  equalDependencies: qn,
  isIntegerDependencies: mn,
  modDependencies: aS,
  smallerDependencies: on,
  typedDependencies: oe,
  xgcdDependencies: sS,
  createInvmod: B0
}, Eo = {
  typedDependencies: oe,
  createIsNaN: ju
}, z9 = {
  typedDependencies: oe,
  createIsPrime: Al
}, sg = {
  ComplexDependencies: jt,
  divideScalarDependencies: nr,
  typedDependencies: oe,
  createLog: _l
}, Da = {
  typedDependencies: oe,
  createMap: tl
}, U9 = {
  divideDependencies: _r,
  dotDivideDependencies: Do,
  isNumericDependencies: ga,
  logDependencies: sg,
  mapDependencies: Da,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  sumDependencies: Wv,
  typedDependencies: oe,
  createKldivergence: Wf
}, G9 = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createKlitzing: Vp
}, H9 = {
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  typedDependencies: oe,
  createKron: K0
}, Q9 = {
  BigNumberDependencies: Qe,
  createLN10: Ep
}, V9 = {
  BigNumberDependencies: Qe,
  createLN2: Ap
}, W9 = {
  BigNumberDependencies: Qe,
  createLOG10E: Cp
}, j9 = {
  BigNumberDependencies: Qe,
  createLOG2E: Sp
}, Z9 = {
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createLcm: A0
}, J9 = {
  parseDependencies: ni,
  typedDependencies: oe,
  createLeafCount: np
}, Y9 = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createLeftShift: Pl
}, X9 = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createLgamma: Qf
}, K9 = {
  ComplexDependencies: jt,
  typedDependencies: oe,
  createLog10: E0
}, eL = {
  ComplexDependencies: jt,
  divideScalarDependencies: nr,
  logDependencies: sg,
  typedDependencies: oe,
  createLog1p: Ml
}, tL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createLoschmidt: ph
}, oS = {
  DenseMatrixDependencies: bt,
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  createLsolve: Il
}, rL = {
  DenseMatrixDependencies: bt,
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  createLsolveAll: Rl
}, uS = {
  FibonacciHeapDependencies: rS,
  addScalarDependencies: wr,
  equalScalarDependencies: At,
  createSpaClass: nc
}, lS = {
  DenseMatrixDependencies: bt,
  SpaDependencies: uS,
  SparseMatrixDependencies: wi,
  absDependencies: an,
  addScalarDependencies: wr,
  divideScalarDependencies: nr,
  equalScalarDependencies: At,
  largerDependencies: sn,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  subtractScalarDependencies: In,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createLup: yf
}, cS = {
  SparseMatrixDependencies: wi,
  absDependencies: an,
  addDependencies: St,
  divideScalarDependencies: nr,
  largerDependencies: sn,
  largerEqDependencies: bm,
  multiplyDependencies: Gt,
  subtractDependencies: cr,
  transposeDependencies: No,
  typedDependencies: oe,
  createSlu: bf
}, fS = {
  DenseMatrixDependencies: bt,
  lsolveDependencies: oS,
  lupDependencies: lS,
  matrixDependencies: Ue,
  sluDependencies: cS,
  typedDependencies: oe,
  usolveDependencies: ig,
  createLusolve: wf
}, og = {
  absDependencies: an,
  addDependencies: St,
  conjDependencies: ya,
  ctransposeDependencies: Zv,
  eigsDependencies: JE,
  equalScalarDependencies: At,
  largerDependencies: sn,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  powDependencies: Bn,
  smallerDependencies: on,
  sqrtDependencies: Vn,
  typedDependencies: oe,
  createNorm: Vc
}, pS = {
  identityDependencies: Qi,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  normDependencies: og,
  qrDependencies: rg,
  subtractDependencies: cr,
  typedDependencies: oe,
  createSchur: If
}, hS = {
  absDependencies: an,
  addDependencies: St,
  concatDependencies: qt,
  identityDependencies: Qi,
  indexDependencies: iS,
  lusolveDependencies: fS,
  matrixDependencies: Ue,
  matrixFromColumnsDependencies: tg,
  multiplyDependencies: Gt,
  rangeDependencies: gs,
  schurDependencies: pS,
  subsetDependencies: Nn,
  subtractDependencies: cr,
  transposeDependencies: No,
  typedDependencies: oe,
  createSylvester: qf
}, nL = {
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  sylvesterDependencies: hS,
  transposeDependencies: No,
  typedDependencies: oe,
  createLyap: Bf
}, Am = {
  compareDependencies: wa,
  isNaNDependencies: Eo,
  isNumericDependencies: ga,
  typedDependencies: oe,
  createPartitionSelect: Xl
}, mS = {
  addDependencies: St,
  compareDependencies: wa,
  divideDependencies: _r,
  partitionSelectDependencies: Am,
  typedDependencies: oe,
  createMedian: kf
}, iL = {
  absDependencies: an,
  mapDependencies: Da,
  medianDependencies: mS,
  subtractDependencies: cr,
  typedDependencies: oe,
  createMad: $f
}, aL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createMagneticConstant: Rp
}, sL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createMagneticFluxQuantum: Hp
}, oL = {
  typedDependencies: oe,
  createMapTransform: Ih
}, uL = {
  isZeroDependencies: Qn,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createMatrixFromFunction: s0
}, lL = {
  flattenDependencies: Ao,
  matrixDependencies: Ue,
  sizeDependencies: zr,
  typedDependencies: oe,
  createMatrixFromRows: o0
}, ug = {
  largerDependencies: sn,
  numericDependencies: Fn,
  typedDependencies: oe,
  createMax: no
}, cL = {
  largerDependencies: sn,
  numericDependencies: Fn,
  typedDependencies: oe,
  createMaxTransform: Bh
}, fL = {
  addDependencies: St,
  divideDependencies: _r,
  typedDependencies: oe,
  createMeanTransform: Rh
}, pL = {
  numericDependencies: Fn,
  smallerDependencies: on,
  typedDependencies: oe,
  createMin: io
}, hL = {
  numericDependencies: Fn,
  smallerDependencies: on,
  typedDependencies: oe,
  createMinTransform: Lh
}, mL = {
  isNaNDependencies: Eo,
  isNumericDependencies: ga,
  typedDependencies: oe,
  createMode: gl
}, dL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createMolarMass: bh
}, vL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createMolarMassC12: wh
}, gL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createMolarPlanckConstant: mh
}, yL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createMolarVolume: dh
}, xL = {
  addDependencies: St,
  divideDependencies: _r,
  factorialDependencies: wo,
  isIntegerDependencies: mn,
  isPositiveDependencies: ba,
  multiplyDependencies: Gt,
  typedDependencies: oe,
  createMultinomial: jf
}, bL = {
  BigNumberDependencies: Qe,
  createNaN: xp
}, wL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createNeutronMass: th
}, NL = {
  BigNumberDependencies: Qe,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createNthRoot: _0
}, DL = {
  ComplexDependencies: jt,
  divideScalarDependencies: nr,
  typedDependencies: oe,
  createNthRoots: Ol
}, AL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createNuclearMagneton: Qp
}, EL = {
  createNull: gp
}, SL = {
  formatDependencies: bo,
  typedDependencies: oe,
  createOct: wl
}, CL = {
  BigNumberDependencies: Qe,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createOnes: rl
}, TL = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createOr: Ws
}, _L = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createOrTransform: Jh
}, dS = {
  evaluateDependencies: ag,
  createParserClass: vf
}, ML = {
  ParserDependencies: dS,
  typedDependencies: oe,
  createParser: gf
}, OL = {
  factorialDependencies: wo,
  typedDependencies: oe,
  createPermutations: Zf
}, FL = {
  BigNumberDependencies: Qe,
  createPhi: Dp
}, lg = {
  BigNumberDependencies: Qe,
  createPi: bp
}, qL = {
  typedDependencies: oe,
  createPickRandom: Jf
}, IL = {
  ComplexDependencies: jt,
  addDependencies: St,
  ctransposeDependencies: Zv,
  deepEqualDependencies: Yv,
  divideScalarDependencies: nr,
  dotDependencies: ym,
  dotDivideDependencies: Do,
  equalDependencies: qn,
  invDependencies: xa,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  typedDependencies: oe,
  createPinv: _f
}, BL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createPlanckCharge: Sh
}, RL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createPlanckConstant: Ip
}, LL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createPlanckLength: Dh
}, PL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createPlanckMass: Ah
}, kL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createPlanckTemperature: Ch
}, $L = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createPlanckTime: Eh
}, vS = {
  typedDependencies: oe,
  createTypeOf: Zu
}, zL = {
  addDependencies: St,
  cbrtDependencies: qE,
  divideDependencies: _r,
  equalScalarDependencies: At,
  imDependencies: eg,
  isZeroDependencies: Qn,
  multiplyDependencies: Gt,
  reDependencies: ng,
  sqrtDependencies: Vn,
  subtractDependencies: cr,
  typeOfDependencies: vS,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createPolynomialRoot: Nf
}, UL = {
  typedDependencies: oe,
  createPrint: eo
}, GL = {
  addDependencies: St,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createPrintTransform: jh
}, HL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createProtonMass: Kp
}, QL = {
  bignumberDependencies: Dn,
  addDependencies: St,
  compareDependencies: wa,
  divideDependencies: _r,
  isIntegerDependencies: mn,
  largerDependencies: sn,
  multiplyDependencies: Gt,
  partitionSelectDependencies: Am,
  smallerDependencies: on,
  smallerEqDependencies: vs,
  subtractDependencies: cr,
  typedDependencies: oe,
  createQuantileSeq: lo
}, VL = {
  addDependencies: St,
  bignumberDependencies: Dn,
  compareDependencies: wa,
  divideDependencies: _r,
  isIntegerDependencies: mn,
  largerDependencies: sn,
  multiplyDependencies: Gt,
  partitionSelectDependencies: Am,
  smallerDependencies: on,
  smallerEqDependencies: vs,
  subtractDependencies: cr,
  typedDependencies: oe,
  createQuantileSeqTransform: Qh
}, WL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createQuantumOfCirculation: rh
}, jL = {
  typedDependencies: oe,
  createRandom: Yf
}, ZL = {
  typedDependencies: oe,
  createRandomInt: Xf
}, JL = {
  createRangeClass: Ru
}, YL = {
  bignumberDependencies: Dn,
  matrixDependencies: Ue,
  addDependencies: St,
  isPositiveDependencies: ba,
  largerDependencies: sn,
  largerEqDependencies: bm,
  smallerDependencies: on,
  smallerEqDependencies: vs,
  typedDependencies: oe,
  createRangeTransform: Ph
}, XL = {
  bignumberDependencies: Dn,
  fractionDependencies: ms,
  AccessorNodeDependencies: ps,
  ArrayNodeDependencies: hs,
  ConstantNodeDependencies: Wi,
  FunctionNodeDependencies: Zi,
  IndexNodeDependencies: ys,
  ObjectNodeDependencies: xs,
  OperatorNodeDependencies: Di,
  ParenthesisNodeDependencies: Na,
  SymbolNodeDependencies: ji,
  addDependencies: St,
  divideDependencies: _r,
  equalDependencies: qn,
  isZeroDependencies: Qn,
  matrixDependencies: Ue,
  multiplyDependencies: Gt,
  parseDependencies: ni,
  powDependencies: Bn,
  simplifyDependencies: Nm,
  simplifyConstantDependencies: Xv,
  simplifyCoreDependencies: Kv,
  subtractDependencies: cr,
  typedDependencies: oe,
  createRationalize: cp
}, KL = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createReducedPlanckConstant: Bp
}, eP = {
  createReplacer: mp
}, tP = {
  matrixDependencies: Ue,
  createResize: il
}, rP = {
  createReviver: hp
}, nP = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createRightArithShift: kl
}, iP = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createRightLogShift: $l
}, gS = {
  BigNumberDependencies: Qe,
  DenseMatrixDependencies: bt,
  SparseMatrixDependencies: wi,
  addScalarDependencies: wr,
  cosDependencies: jv,
  matrixDependencies: Ue,
  multiplyScalarDependencies: lr,
  normDependencies: og,
  sinDependencies: Dm,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createRotationMatrix: sl
}, aP = {
  multiplyDependencies: Gt,
  rotationMatrixDependencies: gS,
  typedDependencies: oe,
  createRotate: al
}, sP = {
  IndexDependencies: Jr,
  matrixDependencies: Ue,
  rangeDependencies: gs,
  typedDependencies: oe,
  createRow: Xs
}, oP = {
  IndexDependencies: Jr,
  matrixDependencies: Ue,
  rangeDependencies: gs,
  typedDependencies: oe,
  createRowTransform: kh
}, uP = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createRydberg: nh
}, lP = {
  // eslint-disable-line camelcase
  BigNumberDependencies: Qe,
  createSQRT1_2: Tp
}, cP = {
  BigNumberDependencies: Qe,
  createSQRT2: _p
}, fP = {
  BigNumberDependencies: Qe,
  createSackurTetrode: vh
}, pP = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createSec: Tc
}, hP = {
  BigNumberDependencies: Qe,
  typedDependencies: oe,
  createSech: _c
}, mP = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createSecondRadiation: gh
}, dP = {
  DenseMatrixDependencies: bt,
  IndexDependencies: Jr,
  compareNaturalDependencies: ri,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetCartesian: Ic
}, yS = {
  DenseMatrixDependencies: bt,
  IndexDependencies: Jr,
  compareNaturalDependencies: ri,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetDifference: Bc
}, vP = {
  DenseMatrixDependencies: bt,
  IndexDependencies: Jr,
  compareNaturalDependencies: ri,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetDistinct: Rc
}, xS = {
  DenseMatrixDependencies: bt,
  IndexDependencies: Jr,
  compareNaturalDependencies: ri,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetIntersect: Lc
}, gP = {
  IndexDependencies: Jr,
  compareNaturalDependencies: ri,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetIsSubset: Pc
}, yP = {
  IndexDependencies: Jr,
  compareNaturalDependencies: ri,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetMultiplicity: kc
}, xP = {
  IndexDependencies: Jr,
  compareNaturalDependencies: ri,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetPowerset: $c
}, bP = {
  compareNaturalDependencies: ri,
  typedDependencies: oe,
  createSetSize: zc
}, bS = {
  IndexDependencies: Jr,
  concatDependencies: qt,
  setDifferenceDependencies: yS,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetSymDifference: Uc
}, wP = {
  IndexDependencies: Jr,
  concatDependencies: qt,
  setIntersectDependencies: xS,
  setSymDifferenceDependencies: bS,
  sizeDependencies: zr,
  subsetDependencies: Nn,
  typedDependencies: oe,
  createSetUnion: Gc
}, NP = {
  typedDependencies: oe,
  createSinh: Oc
}, DP = {
  absDependencies: an,
  addDependencies: St,
  bignumberDependencies: Dn,
  divideDependencies: _r,
  isNegativeDependencies: Vi,
  isPositiveDependencies: ba,
  largerDependencies: sn,
  mapDependencies: Da,
  matrixDependencies: Ue,
  maxDependencies: ug,
  multiplyDependencies: Gt,
  smallerDependencies: on,
  subtractDependencies: cr,
  typedDependencies: oe,
  unaryMinusDependencies: ti,
  createSolveODE: ml
}, AP = {
  compareDependencies: wa,
  compareNaturalDependencies: ri,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createSort: Kl
}, EP = {
  SparseMatrixDependencies: wi,
  typedDependencies: oe,
  createSparse: oc
}, SP = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createSpeedOfLight: Fp
}, CP = {
  typedDependencies: oe,
  createSplitUnit: l0
}, TP = {
  absDependencies: an,
  addDependencies: St,
  identityDependencies: Qi,
  invDependencies: xa,
  mapDependencies: Da,
  maxDependencies: ug,
  multiplyDependencies: Gt,
  sizeDependencies: zr,
  sqrtDependencies: Vn,
  subtractDependencies: cr,
  typedDependencies: oe,
  createSqrtm: Ff
}, _P = {
  typedDependencies: oe,
  createSquare: F0
}, MP = {
  matrixDependencies: Ue,
  typedDependencies: oe,
  createSqueeze: ul
}, cg = {
  addDependencies: St,
  applyDependencies: Gv,
  divideDependencies: _r,
  isNaNDependencies: Eo,
  multiplyDependencies: Gt,
  subtractDependencies: cr,
  typedDependencies: oe,
  createVariance: uo
}, OP = {
  mapDependencies: Da,
  sqrtDependencies: Vn,
  typedDependencies: oe,
  varianceDependencies: cg,
  createStd: co
}, FP = {
  mapDependencies: Da,
  sqrtDependencies: Vn,
  typedDependencies: oe,
  varianceDependencies: cg,
  createStdTransform: Gh
}, qP = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createStefanBoltzmann: yh
}, IP = {
  typedDependencies: oe,
  createString: e0
}, BP = {
  addDependencies: St,
  matrixDependencies: Ue,
  typedDependencies: oe,
  zerosDependencies: $r,
  createSubsetTransform: $h
}, RP = {
  addDependencies: St,
  numericDependencies: Fn,
  typedDependencies: oe,
  createSumTransform: Hh
}, LP = {
  OperatorNodeDependencies: Di,
  parseDependencies: ni,
  simplifyDependencies: Nm,
  typedDependencies: oe,
  createSymbolicEqual: up
}, PP = {
  typedDependencies: oe,
  createTan: Fc
}, kP = {
  typedDependencies: oe,
  createTanh: qc
}, $P = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createThomsonCrossSection: ih
}, zP = {
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createTo: Dl
}, UP = {
  addDependencies: St,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createTrace: jc
}, GP = {
  createTrue: dp
}, HP = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  equalScalarDependencies: At,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createUnequal: Yl
}, QP = {
  UnitDependencies: ot,
  typedDependencies: oe,
  createUnitFunction: sc
}, VP = {
  eDependencies: VE,
  createUppercaseE: Hd
}, WP = {
  piDependencies: lg,
  createUppercasePi: Gd
}, jP = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createVacuumImpedance: Pp
}, ZP = {
  addDependencies: St,
  applyDependencies: Gv,
  divideDependencies: _r,
  isNaNDependencies: Eo,
  multiplyDependencies: Gt,
  subtractDependencies: cr,
  typedDependencies: oe,
  createVarianceTransform: Wh
}, JP = {
  createVersion: Op
}, YP = {
  BigNumberDependencies: Qe,
  createWeakMixingAngle: ah
}, XP = {
  BigNumberDependencies: Qe,
  UnitDependencies: ot,
  createWienDisplacement: xh
}, KP = {
  DenseMatrixDependencies: bt,
  concatDependencies: qt,
  matrixDependencies: Ue,
  typedDependencies: oe,
  createXor: H0
}, ek = {
  BigNumberDependencies: Qe,
  ComplexDependencies: jt,
  addDependencies: St,
  divideDependencies: _r,
  equalDependencies: qn,
  factorialDependencies: wo,
  gammaDependencies: Qv,
  isNegativeDependencies: Vi,
  multiplyDependencies: Gt,
  piDependencies: lg,
  powDependencies: Bn,
  sinDependencies: Dm,
  smallerEqDependencies: vs,
  subtractDependencies: cr,
  typedDependencies: oe,
  createZeta: vl
}, tk = {
  ComplexDependencies: jt,
  addDependencies: St,
  multiplyDependencies: Gt,
  numberDependencies: Ni,
  typedDependencies: oe,
  createZpk2tf: fp
}, rk = e6, fg = { exports: {} };
function pg() {
}
pg.prototype = {
  on: function(t, e, r) {
    var n = this.e || (this.e = {});
    return (n[t] || (n[t] = [])).push({
      fn: e,
      ctx: r
    }), this;
  },
  once: function(t, e, r) {
    var n = this;
    function a() {
      n.off(t, a), e.apply(r, arguments);
    }
    return a._ = e, this.on(t, a, r);
  },
  emit: function(t) {
    var e = [].slice.call(arguments, 1), r = ((this.e || (this.e = {}))[t] || []).slice(), n = 0, a = r.length;
    for (n; n < a; n++)
      r[n].fn.apply(r[n].ctx, e);
    return this;
  },
  off: function(t, e) {
    var r = this.e || (this.e = {}), n = r[t], a = [];
    if (n && e)
      for (var s = 0, o = n.length; s < o; s++)
        n[s].fn !== e && n[s].fn._ !== e && a.push(n[s]);
    return a.length ? r[t] = a : delete r[t], this;
  }
};
fg.exports = pg;
fg.exports.TinyEmitter = pg;
var nk = fg.exports;
const ik = /* @__PURE__ */ zs(nk);
function ak(t) {
  var e = new ik();
  return t.on = e.on.bind(e), t.off = e.off.bind(e), t.once = e.once.bind(e), t.emit = e.emit.bind(e), t;
}
function sk(t, e, r, n) {
  function a(N, b) {
    var C = arguments.length;
    if (C !== 1 && C !== 2)
      throw new Zn("import", C, 1, 2);
    b || (b = {});
    function x(M, _, O) {
      if (Array.isArray(_))
        _.forEach((q) => x(M, q));
      else if (typeof _ == "object")
        for (var T in _)
          We(_, T) && x(M, _[T], T);
      else if (Ms(_) || O !== void 0) {
        var I = Ms(_) ? g(_) ? _.fn + ".transform" : _.fn : O;
        if (We(M, I) && M[I] !== _ && !b.silent)
          throw new Error('Cannot import "' + I + '" twice');
        M[I] = _;
      } else if (!b.silent)
        throw new TypeError("Factory, Object, or Array expected");
    }
    var E = {};
    x(E, N);
    for (var D in E)
      if (We(E, D)) {
        var A = E[D];
        if (Ms(A))
          f(A, b);
        else if (l(A))
          s(D, A, b);
        else if (!b.silent)
          throw new TypeError("Factory, Object, or Array expected");
      }
  }
  function s(N, b, C) {
    if (C.wrap && typeof b == "function" && (b = u(b)), c(b) && (b = t(N, {
      [b.signature]: b
    })), t.isTypedFunction(r[N]) && t.isTypedFunction(b)) {
      C.override ? b = t(N, b.signatures) : b = t(r[N], b), r[N] = b, delete n[N], o(N, b), r.emit("import", N, function() {
        return b;
      });
      return;
    }
    if (r[N] === void 0 || C.override) {
      r[N] = b, delete n[N], o(N, b), r.emit("import", N, function() {
        return b;
      });
      return;
    }
    if (!C.silent)
      throw new Error('Cannot import "' + N + '": already exists');
  }
  function o(N, b) {
    b && typeof b.transform == "function" ? (r.expression.transform[N] = b.transform, h(N) && (r.expression.mathWithTransform[N] = b.transform)) : (delete r.expression.transform[N], h(N) && (r.expression.mathWithTransform[N] = b));
  }
  function p(N) {
    delete r.expression.transform[N], h(N) ? r.expression.mathWithTransform[N] = r[N] : delete r.expression.mathWithTransform[N];
  }
  function u(N) {
    var b = function() {
      for (var x = [], E = 0, D = arguments.length; E < D; E++) {
        var A = arguments[E];
        x[E] = A && A.valueOf();
      }
      return N.apply(r, x);
    };
    return N.transform && (b.transform = N.transform), b;
  }
  function f(N, b) {
    var C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : N.fn;
    if (C.includes("."))
      throw new Error("Factory name should not contain a nested path. Name: " + JSON.stringify(C));
    var x = g(N) ? r.expression.transform : r, E = C in r.expression.transform, D = We(x, C) ? x[C] : void 0, A = function() {
      var _ = {};
      N.dependencies.map(N2).forEach((T) => {
        if (T.includes("."))
          throw new Error("Factory dependency should not contain a nested path. Name: " + JSON.stringify(T));
        T === "math" ? _.math = r : T === "mathWithTransform" ? _.mathWithTransform = r.expression.mathWithTransform : T === "classes" ? _.classes = r : _[T] = r[T];
      });
      var O = /* @__PURE__ */ N(_);
      if (O && typeof O.transform == "function")
        throw new Error('Transforms cannot be attached to factory functions. Please create a separate function for it with export const path = "expression.transform"');
      if (D === void 0 || b.override)
        return O;
      if (t.isTypedFunction(D) && t.isTypedFunction(O))
        return t(D, O);
      if (b.silent)
        return D;
      throw new Error('Cannot import "' + C + '": already exists');
    };
    !N.meta || N.meta.lazy !== !1 ? (Jo(x, C, A), D && E ? p(C) : (g(N) || d(N)) && Jo(r.expression.mathWithTransform, C, () => x[C])) : (x[C] = A(), D && E ? p(C) : (g(N) || d(N)) && Jo(r.expression.mathWithTransform, C, () => x[C])), n[C] = N, r.emit("import", C, A);
  }
  function l(N) {
    return typeof N == "function" || typeof N == "number" || typeof N == "string" || typeof N == "boolean" || N === null || Xr(N) || Mn(N) || ct(N) || Fi(N) || tt(N) || Array.isArray(N);
  }
  function c(N) {
    return typeof N == "function" && typeof N.signature == "string";
  }
  function h(N) {
    return !We(v, N);
  }
  function d(N) {
    return !N.fn.includes(".") && // FIXME: make checking on path redundant, check on meta data instead
    !We(v, N.fn) && (!N.meta || !N.meta.isClass);
  }
  function g(N) {
    return N !== void 0 && N.meta !== void 0 && N.meta.isTransformFunction === !0 || !1;
  }
  var v = {
    expression: !0,
    type: !0,
    docs: !0,
    error: !0,
    json: !0,
    chain: !0
    // chain method not supported. Note that there is a unit chain too.
  };
  return a;
}
function wS(t, e) {
  var r = hr({}, Du, e);
  if (typeof Object.create != "function")
    throw new Error("ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility.");
  var n = ak({
    // only here for backward compatibility for legacy factory functions
    isNumber: ht,
    isComplex: Mn,
    isBigNumber: ct,
    isBigInt: ld,
    isFraction: Fi,
    isUnit: Xr,
    isString: Er,
    isArray: Rt,
    isMatrix: tt,
    isCollection: cn,
    isDenseMatrix: Ra,
    isSparseMatrix: oi,
    isRange: ks,
    isIndex: Va,
    isBoolean: cd,
    isResultSet: fd,
    isHelp: Au,
    isFunction: pd,
    isDate: hd,
    isRegExp: md,
    isObject: Wa,
    isNull: dd,
    isUndefined: vd,
    isAccessorNode: pi,
    isArrayNode: un,
    isAssignmentNode: gd,
    isBlockNode: yd,
    isConditionalNode: xd,
    isConstantNode: Ct,
    isFunctionAssignmentNode: oa,
    isFunctionNode: Wn,
    isIndexNode: qi,
    isNode: Ut,
    isObjectNode: ja,
    isOperatorNode: or,
    isParenthesisNode: kn,
    isRangeNode: bd,
    isRelationalNode: wd,
    isSymbolNode: mr,
    isChain: Eu
  });
  n.config = QS(r, n.emit), n.expression = {
    transform: {},
    mathWithTransform: {
      config: n.config
    }
  };
  var a = [], s = [];
  function o(l) {
    if (Ms(l))
      return l(n);
    var c = l[Object.keys(l)[0]];
    if (Ms(c))
      return c(n);
    if (!GS(l))
      throw console.warn("Factory object with properties `type`, `name`, and `factory` expected", l), new Error("Factory object with properties `type`, `name`, and `factory` expected");
    var h = a.indexOf(l), d;
    return h === -1 ? (l.math === !0 ? d = l.factory(n.type, r, o, n.typed, n) : d = l.factory(n.type, r, o, n.typed), a.push(l), s.push(d)) : d = s[h], d;
  }
  var p = {};
  function u() {
    for (var l = arguments.length, c = new Array(l), h = 0; h < l; h++)
      c[h] = arguments[h];
    return n.typed.apply(n.typed, c);
  }
  u.isTypedFunction = ea.isTypedFunction;
  var f = sk(u, o, n, p);
  return n.import = f, n.on("config", () => {
    Object.values(p).forEach((l) => {
      l && l.meta && l.meta.recreateOnConfigChange && f(l, {
        override: !0
      });
    });
  }), n.create = wS.bind(null, t), n.factory = j, n.import(Object.values(US(t))), n.ArgumentsError = Zn, n.DimensionError = xt, n.IndexError = yn, n;
}
const NS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AccessorNode: da,
  AccessorNodeDependencies: ps,
  ArgumentsError: Zn,
  ArrayNode: ha,
  ArrayNodeDependencies: hs,
  AssignmentNode: kv,
  AssignmentNodeDependencies: EE,
  BigNumber: He,
  BigNumberDependencies: Qe,
  BlockNode: Bv,
  BlockNodeDependencies: FE,
  Chain: hm,
  ChainDependencies: IE,
  Complex: Ft,
  ComplexDependencies: jt,
  ConditionalNode: Rv,
  ConditionalNodeDependencies: PE,
  ConstantNode: yi,
  ConstantNodeDependencies: Wi,
  DenseMatrix: yt,
  DenseMatrixDependencies: bt,
  DimensionError: xt,
  EDependencies: VP,
  FibonacciHeap: vv,
  FibonacciHeapDependencies: rS,
  Fraction: Pi,
  FractionDependencies: va,
  FunctionAssignmentNode: Pv,
  FunctionAssignmentNodeDependencies: kE,
  FunctionNode: bi,
  FunctionNodeDependencies: Zi,
  Help: zv,
  HelpDependencies: nS,
  ImmutableDenseMatrix: cv,
  ImmutableDenseMatrixDependencies: BE,
  Index: Rr,
  IndexDependencies: Jr,
  IndexError: yn,
  IndexNode: ma,
  IndexNodeDependencies: ys,
  InfinityDependencies: L9,
  LN10: iN,
  LN10Dependencies: Q9,
  LN2: dN,
  LN2Dependencies: V9,
  LOG10E: aN,
  LOG10EDependencies: W9,
  LOG2E: BN,
  LOG2EDependencies: j9,
  Matrix: rs,
  MatrixDependencies: vm,
  NaNDependencies: bL,
  Node: kr,
  NodeDependencies: Zr,
  ObjectNode: pa,
  ObjectNodeDependencies: xs,
  OperatorNode: ei,
  OperatorNodeDependencies: Di,
  PIDependencies: WP,
  ParenthesisNode: Hi,
  ParenthesisNodeDependencies: Na,
  Parser: Uv,
  ParserDependencies: dS,
  Range: lN,
  RangeDependencies: JL,
  RangeNode: Lv,
  RangeNodeDependencies: $E,
  RelationalNode: Iv,
  RelationalNodeDependencies: zE,
  ResultSet: Wd,
  ResultSetDependencies: OE,
  SQRT1_2: cN,
  SQRT1_2Dependencies: lP,
  SQRT2: gN,
  SQRT2Dependencies: cP,
  Spa: wv,
  SpaDependencies: uS,
  SparseMatrix: Kn,
  SparseMatrixDependencies: wi,
  SymbolNode: xi,
  SymbolNodeDependencies: ji,
  Unit: st,
  UnitDependencies: ot,
  _Infinity: nN,
  _NaN: sN,
  _false: tN,
  _null: oN,
  _true: pN,
  abs: $t,
  absDependencies: an,
  acos: Zd,
  acosDependencies: t6,
  acosh: WN,
  acoshDependencies: r6,
  acot: xN,
  acotDependencies: n6,
  acoth: aD,
  acothDependencies: i6,
  acsc: bN,
  acscDependencies: a6,
  acsch: jN,
  acschDependencies: s6,
  add: ut,
  addDependencies: St,
  addScalar: vr,
  addScalarDependencies: wr,
  all: rk,
  and: YD,
  andDependencies: o6,
  andTransformDependencies: u6,
  apply: tm,
  applyDependencies: Gv,
  applyTransformDependencies: l6,
  arg: Rs,
  argDependencies: c6,
  asec: ZN,
  asecDependencies: f6,
  asech: wN,
  asechDependencies: p6,
  asin: fD,
  asinDependencies: h6,
  asinh: NN,
  asinhDependencies: m6,
  atan: Jd,
  atan2: ov,
  atan2Dependencies: d6,
  atanDependencies: SE,
  atanh: DN,
  atanhDependencies: v6,
  atomicMass: aA,
  atomicMassDependencies: g6,
  avogadro: LA,
  avogadroDependencies: y6,
  bellNumbers: KA,
  bellNumbersDependencies: x6,
  bigint: AN,
  bigintDependencies: b6,
  bignumber: ln,
  bignumberDependencies: Dn,
  bin: sD,
  binDependencies: w6,
  bitAnd: ND,
  bitAndDependencies: N6,
  bitAndTransformDependencies: D6,
  bitNot: EN,
  bitNotDependencies: A6,
  bitOr: DD,
  bitOrDependencies: E6,
  bitOrTransformDependencies: S6,
  bitXor: AD,
  bitXorDependencies: C6,
  bohrMagneton: sA,
  bohrMagnetonDependencies: T6,
  bohrRadius: PA,
  bohrRadiusDependencies: _6,
  boltzmann: oA,
  boltzmannDependencies: M6,
  boolean: SN,
  booleanDependencies: O6,
  catalan: ED,
  catalanDependencies: F6,
  cbrt: iv,
  cbrtDependencies: qE,
  ceil: um,
  ceilDependencies: Hv,
  chain: gE,
  chainDependencies: q6,
  classicalElectronRadius: sE,
  classicalElectronRadiusDependencies: I6,
  clone: CN,
  cloneDependencies: B6,
  column: Nv,
  columnDependencies: RE,
  columnTransformDependencies: R6,
  combinations: fo,
  combinationsDependencies: xm,
  combinationsWithRep: JN,
  combinationsWithRepDependencies: L6,
  compare: Ui,
  compareDependencies: wa,
  compareNatural: Hn,
  compareNaturalDependencies: ri,
  compareText: uv,
  compareTextDependencies: LE,
  compile: yE,
  compileDependencies: P6,
  complex: Wt,
  complexDependencies: wm,
  composition: PD,
  compositionDependencies: k6,
  concat: Tt,
  concatDependencies: qt,
  concatTransformDependencies: $6,
  conductanceQuantum: uA,
  conductanceQuantumDependencies: z6,
  config: qe,
  conj: Yn,
  conjDependencies: ya,
  corr: oE,
  corrDependencies: U6,
  cos: Kh,
  cosDependencies: jv,
  cosh: YN,
  coshDependencies: G6,
  cot: TN,
  cotDependencies: H6,
  coth: oD,
  cothDependencies: Q6,
  coulomb: lA,
  coulombDependencies: V6,
  count: pD,
  countDependencies: W6,
  create: wS,
  createAbs: p0,
  createAccessorNode: Yc,
  createAcos: lc,
  createAcosh: cc,
  createAcot: fc,
  createAcoth: pc,
  createAcsc: hc,
  createAcsch: mc,
  createAdd: Hc,
  createAddScalar: h0,
  createAnd: ro,
  createAndTransform: Zh,
  createApply: Ka,
  createApplyTransform: _h,
  createArg: k0,
  createArrayNode: Xc,
  createAsec: dc,
  createAsech: vc,
  createAsin: gc,
  createAsinh: yc,
  createAssignmentNode: Kc,
  createAtan: xc,
  createAtan2: bc,
  createAtanh: wc,
  createAtomicMass: oh,
  createAvogadro: uh,
  createBellNumbers: ep,
  createBigNumberClass: qu,
  createBigint: Ku,
  createBignumber: r0,
  createBin: bl,
  createBitAnd: Qs,
  createBitAndTransform: Yh,
  createBitNot: L0,
  createBitOr: Vs,
  createBitOrTransform: Xh,
  createBitXor: P0,
  createBlockNode: ef,
  createBohrMagneton: zp,
  createBohrRadius: Wp,
  createBoltzmann: lh,
  createBoolean: t0,
  createCatalan: tp,
  createCbrt: d0,
  createCeil: v0,
  createChain: Sf,
  createChainClass: Af,
  createClassicalElectronRadius: jp,
  createClone: $u,
  createColumn: Zs,
  createColumnTransform: Mh,
  createCombinations: Uf,
  createCombinationsWithRep: Gf,
  createCompare: zl,
  createCompareNatural: Ul,
  createCompareText: Gl,
  createCompile: mf,
  createComplex: n0,
  createComplexClass: Iu,
  createComposition: rp,
  createConcat: js,
  createConcatTransform: zh,
  createConditionalNode: tf,
  createConductanceQuantum: Up,
  createConj: $0,
  createConstantNode: rf,
  createCorr: zf,
  createCos: Nc,
  createCosh: Dc,
  createCot: Ac,
  createCoth: Ec,
  createCoulomb: kp,
  createCount: Q0,
  createCreateUnit: uc,
  createCross: V0,
  createCsc: Sc,
  createCsch: Cc,
  createCtranspose: cl,
  createCube: g0,
  createCumSum: so,
  createCumSumTransform: Vh,
  createDeepEqual: Jl,
  createDenseMatrixClass: ku,
  createDerivative: lp,
  createDet: Cf,
  createDeuteronMass: eh,
  createDiag: W0,
  createDiff: Js,
  createDiffTransform: Uh,
  createDistance: Lf,
  createDivide: Rf,
  createDivideScalar: Sl,
  createDot: Wc,
  createDotDivide: ql,
  createDotMultiply: R0,
  createDotPow: Fl,
  createE: Np,
  createEfimovFactor: sh,
  createEigs: Mf,
  createElectricConstant: Lp,
  createElectronMass: Zp,
  createElementaryCharge: $p,
  createEqual: Hl,
  createEqualScalar: Ju,
  createEqualText: Ql,
  createErf: dl,
  createEvaluate: df,
  createExp: y0,
  createExpm: Of,
  createExpm1: x0,
  createFactorial: Vf,
  createFalse: vp,
  createFaraday: ch,
  createFermiCoupling: Jp,
  createFft: pl,
  createFibonacciHeapClass: rc,
  createFilter: j0,
  createFilterTransform: Oh,
  createFineStructure: Yp,
  createFirstRadiation: fh,
  createFix: b0,
  createFlatten: Z0,
  createFloor: Gs,
  createForEach: J0,
  createForEachTransform: Fh,
  createFormat: xl,
  createFraction: i0,
  createFractionClass: Bu,
  createFreqz: pp,
  createFunctionAssignmentNode: nf,
  createFunctionNode: pf,
  createGamma: Hf,
  createGasConstant: hh,
  createGcd: N0,
  createGetMatrixDataType: Y0,
  createGravitationConstant: qp,
  createGravity: Nh,
  createHartreeEnergy: Xp,
  createHasNumericValue: Qu,
  createHelp: Ef,
  createHelpClass: Df,
  createHex: Nl,
  createHypot: Qc,
  createI: Mp,
  createIdentity: X0,
  createIfft: hl,
  createIm: z0,
  createImmutableDenseMatrixClass: ec,
  createIndex: Zc,
  createIndexClass: tc,
  createIndexNode: af,
  createIndexTransform: qh,
  createInfinity: yp,
  createIntersect: Pf,
  createInv: Tf,
  createInverseConductanceQuantum: Gp,
  createInvmod: B0,
  createIsInteger: Uu,
  createIsNaN: ju,
  createIsNegative: Gu,
  createIsNumeric: Hu,
  createIsPositive: Vu,
  createIsPrime: Al,
  createIsZero: Wu,
  createKldivergence: Wf,
  createKlitzing: Vp,
  createKron: K0,
  createLN10: Ep,
  createLN2: Ap,
  createLOG10E: Cp,
  createLOG2E: Sp,
  createLarger: jl,
  createLargerEq: Zl,
  createLcm: A0,
  createLeafCount: np,
  createLeftShift: Pl,
  createLgamma: Qf,
  createLog: _l,
  createLog10: E0,
  createLog1p: Ml,
  createLog2: S0,
  createLoschmidt: ph,
  createLsolve: Il,
  createLsolveAll: Rl,
  createLup: yf,
  createLusolve: wf,
  createLyap: Bf,
  createMad: $f,
  createMagneticConstant: Rp,
  createMagneticFluxQuantum: Hp,
  createMap: tl,
  createMapTransform: Ih,
  createMatrix: a0,
  createMatrixClass: Lu,
  createMatrixFromColumns: u0,
  createMatrixFromFunction: s0,
  createMatrixFromRows: o0,
  createMax: no,
  createMaxTransform: Bh,
  createMean: oo,
  createMeanTransform: Rh,
  createMedian: kf,
  createMin: io,
  createMinTransform: Lh,
  createMod: Hs,
  createMode: gl,
  createMolarMass: bh,
  createMolarMassC12: wh,
  createMolarPlanckConstant: mh,
  createMolarVolume: dh,
  createMultinomial: jf,
  createMultiply: T0,
  createMultiplyScalar: C0,
  createNaN: xp,
  createNeutronMass: th,
  createNode: Jc,
  createNorm: Vc,
  createNot: G0,
  createNthRoot: _0,
  createNthRoots: Ol,
  createNuclearMagneton: Qp,
  createNull: gp,
  createNumber: Xu,
  createNumeric: El,
  createObjectNode: sf,
  createOct: wl,
  createOnes: rl,
  createOperatorNode: of,
  createOr: Ws,
  createOrTransform: Jh,
  createParenthesisNode: uf,
  createParse: hf,
  createParser: gf,
  createParserClass: vf,
  createPartitionSelect: Xl,
  createPermutations: Zf,
  createPhi: Dp,
  createPi: bp,
  createPickRandom: Jf,
  createPinv: _f,
  createPlanckCharge: Sh,
  createPlanckConstant: Ip,
  createPlanckLength: Dh,
  createPlanckMass: Ah,
  createPlanckTemperature: Ch,
  createPlanckTime: Eh,
  createPolynomialRoot: Nf,
  createPow: Cl,
  createPrint: eo,
  createPrintTransform: jh,
  createProd: yl,
  createProtonMass: Kp,
  createQr: xf,
  createQuantileSeq: lo,
  createQuantileSeqTransform: Qh,
  createQuantumOfCirculation: rh,
  createRandom: Yf,
  createRandomInt: Xf,
  createRange: Ys,
  createRangeClass: Ru,
  createRangeNode: lf,
  createRangeTransform: Ph,
  createRationalize: cp,
  createRe: U0,
  createReducedPlanckConstant: Bp,
  createRelationalNode: cf,
  createReplacer: mp,
  createReshape: nl,
  createResize: il,
  createResolve: op,
  createResultSet: _u,
  createReviver: hp,
  createRightArithShift: kl,
  createRightLogShift: $l,
  createRotate: al,
  createRotationMatrix: sl,
  createRound: Tl,
  createRow: Xs,
  createRowTransform: kh,
  createRydberg: nh,
  createSQRT1_2: Tp,
  createSQRT2: _p,
  createSackurTetrode: vh,
  createSchur: If,
  createSec: Tc,
  createSech: _c,
  createSecondRadiation: gh,
  createSetCartesian: Ic,
  createSetDifference: Bc,
  createSetDistinct: Rc,
  createSetIntersect: Lc,
  createSetIsSubset: Pc,
  createSetMultiplicity: kc,
  createSetPowerset: $c,
  createSetSize: zc,
  createSetSymDifference: Uc,
  createSetUnion: Gc,
  createSign: M0,
  createSimplify: ip,
  createSimplifyConstant: ap,
  createSimplifyCore: sp,
  createSin: Mc,
  createSinh: Oc,
  createSize: ol,
  createSlu: bf,
  createSmaller: Vl,
  createSmallerEq: Wl,
  createSolveODE: ml,
  createSort: Kl,
  createSpaClass: nc,
  createSparse: oc,
  createSparseMatrixClass: Yu,
  createSpeedOfLight: Fp,
  createSplitUnit: l0,
  createSqrt: O0,
  createSqrtm: Ff,
  createSquare: F0,
  createSqueeze: ul,
  createStd: co,
  createStdTransform: Gh,
  createStefanBoltzmann: yh,
  createStirlingS2: Kf,
  createString: e0,
  createSubset: Ks,
  createSubsetTransform: $h,
  createSubtract: q0,
  createSubtractScalar: m0,
  createSum: ao,
  createSumTransform: Hh,
  createSylvester: qf,
  createSymbolNode: ff,
  createSymbolicEqual: up,
  createTan: Fc,
  createTanh: qc,
  createTau: wp,
  createThomsonCrossSection: ih,
  createTo: Dl,
  createTrace: jc,
  createTranspose: ll,
  createTrue: dp,
  createTypeOf: Zu,
  createTyped: Tu,
  createUnaryMinus: c0,
  createUnaryPlus: f0,
  createUnequal: Yl,
  createUnit: kA,
  createUnitClass: ac,
  createUnitDependencies: j6,
  createUnitFunction: sc,
  createUppercaseE: Hd,
  createUppercasePi: Gd,
  createUsolve: Bl,
  createUsolveAll: Ll,
  createVacuumImpedance: Pp,
  createVariance: uo,
  createVarianceTransform: Wh,
  createVersion: Op,
  createWeakMixingAngle: ah,
  createWienDisplacement: xh,
  createXgcd: I0,
  createXor: H0,
  createZeros: fl,
  createZeta: vl,
  createZpk2tf: fp,
  cross: kD,
  crossDependencies: Z6,
  csc: Yd,
  cscDependencies: J6,
  csch: XN,
  cschDependencies: Y6,
  ctranspose: ss,
  ctransposeDependencies: Zv,
  cube: _N,
  cubeDependencies: X6,
  cumsum: SD,
  cumsumDependencies: K6,
  cumsumTransformDependencies: e9,
  deepEqual: sm,
  deepEqualDependencies: Yv,
  derivative: DE,
  derivativeDependencies: t9,
  det: lm,
  detDependencies: _E,
  deuteronMass: cA,
  deuteronMassDependencies: r9,
  diag: av,
  diagDependencies: QE,
  diff: CD,
  diffDependencies: n9,
  diffTransformDependencies: i9,
  distance: TD,
  distanceDependencies: a9,
  divide: ur,
  divideDependencies: _r,
  divideScalar: rr,
  divideScalarDependencies: nr,
  docs: Xw,
  dot: mo,
  dotDependencies: ym,
  dotDivide: os,
  dotDivideDependencies: Do,
  dotMultiply: $D,
  dotMultiplyDependencies: s9,
  dotPow: fA,
  dotPowDependencies: o9,
  e: ud,
  eDependencies: VE,
  efimovFactor: mN,
  efimovFactorDependencies: u9,
  eigs: Tv,
  eigsDependencies: JE,
  electricConstant: pA,
  electricConstantDependencies: l9,
  electronMass: $A,
  electronMassDependencies: c9,
  elementaryCharge: hA,
  elementaryChargeDependencies: f9,
  equal: wn,
  equalDependencies: qn,
  equalScalar: wt,
  equalScalarDependencies: At,
  equalText: _D,
  equalTextDependencies: p9,
  erf: MN,
  erfDependencies: h9,
  evaluate: Br,
  evaluateDependencies: ag,
  exp: Xd,
  expDependencies: YE,
  expm: mA,
  expm1: ON,
  expm1Dependencies: d9,
  expmDependencies: m9,
  factorial: ls,
  factorialDependencies: wo,
  factory: j,
  falseDependencies: v9,
  faraday: dA,
  faradayDependencies: g9,
  fermiCoupling: eE,
  fermiCouplingDependencies: y9,
  fft: Ev,
  fftDependencies: tS,
  filter: FN,
  filterDependencies: x9,
  filterTransformDependencies: b9,
  fineStructure: rN,
  fineStructureDependencies: w9,
  firstRadiation: zA,
  firstRadiationDependencies: N9,
  fix: gv,
  fixDependencies: TE,
  flatten: us,
  flattenDependencies: Ao,
  floor: lv,
  floorDependencies: CE,
  forEach: qN,
  forEachDependencies: D9,
  forEachTransformDependencies: A9,
  format: ns,
  formatDependencies: bo,
  fraction: fa,
  fractionDependencies: ms,
  freqz: uE,
  freqzDependencies: E9,
  gamma: cm,
  gammaDependencies: Qv,
  gasConstant: tE,
  gasConstantDependencies: S9,
  gcd: MD,
  gcdDependencies: C9,
  getMatrixDataType: em,
  getMatrixDataTypeDependencies: Vv,
  gravitationConstant: vA,
  gravitationConstantDependencies: T9,
  gravity: UA,
  gravityDependencies: _9,
  hartreeEnergy: gA,
  hartreeEnergyDependencies: M9,
  hasNumericValue: hD,
  hasNumericValueDependencies: O9,
  help: AE,
  helpDependencies: F9,
  hex: IN,
  hexDependencies: q9,
  hypot: OD,
  hypotDependencies: I9,
  i: Vd,
  iDependencies: XE,
  identity: gi,
  identityDependencies: Qi,
  ifft: yA,
  ifftDependencies: B9,
  im: Ga,
  imDependencies: eg,
  index: yv,
  indexDependencies: iS,
  indexTransformDependencies: R9,
  intersect: zD,
  intersectDependencies: P9,
  inv: Gi,
  invDependencies: xa,
  inverseConductanceQuantum: GA,
  inverseConductanceQuantumDependencies: k9,
  invmod: UD,
  invmodDependencies: $9,
  isAccessorNode: pi,
  isArray: Rt,
  isArrayNode: un,
  isAssignmentNode: gd,
  isBigInt: ld,
  isBigNumber: ct,
  isBlockNode: yd,
  isBoolean: cd,
  isChain: Eu,
  isCollection: cn,
  isComplex: Mn,
  isConditionalNode: xd,
  isConstantNode: Ct,
  isDate: hd,
  isDenseMatrix: Ra,
  isFraction: Fi,
  isFunction: pd,
  isFunctionAssignmentNode: oa,
  isFunctionNode: Wn,
  isHelp: Au,
  isIndex: Va,
  isIndexNode: qi,
  isInteger: en,
  isIntegerDependencies: mn,
  isMatrix: tt,
  isNaN: is,
  isNaNDependencies: Eo,
  isNegative: di,
  isNegativeDependencies: Vi,
  isNode: Ut,
  isNull: dd,
  isNumber: ht,
  isNumeric: zi,
  isNumericDependencies: ga,
  isObject: Wa,
  isObjectNode: ja,
  isOperatorNode: or,
  isParenthesisNode: kn,
  isPositive: ki,
  isPositiveDependencies: ba,
  isPrime: KN,
  isPrimeDependencies: z9,
  isRange: ks,
  isRangeNode: bd,
  isRegExp: md,
  isRelationalNode: wd,
  isResultSet: fd,
  isSparseMatrix: oi,
  isString: Er,
  isSymbolNode: mr,
  isUndefined: vd,
  isUnit: Xr,
  isZero: On,
  isZeroDependencies: Qn,
  kldivergence: rE,
  kldivergenceDependencies: U9,
  klitzing: xA,
  klitzingDependencies: G9,
  kron: mD,
  kronDependencies: H9,
  larger: Vr,
  largerDependencies: sn,
  largerEq: ho,
  largerEqDependencies: bm,
  lcm: GD,
  lcmDependencies: Z9,
  leafCount: bE,
  leafCountDependencies: J9,
  leftShift: dD,
  leftShiftDependencies: Y9,
  lgamma: RN,
  lgammaDependencies: X9,
  log: vo,
  log10: LN,
  log10Dependencies: K9,
  log1p: HD,
  log1pDependencies: eL,
  log2: vi,
  log2Dependencies: KE,
  logDependencies: sg,
  loschmidt: bA,
  loschmidtDependencies: tL,
  lsolve: sv,
  lsolveAll: FD,
  lsolveAllDependencies: rL,
  lsolveDependencies: oS,
  lup: Dv,
  lupDependencies: lS,
  lusolve: Sv,
  lusolveDependencies: fS,
  lyap: mE,
  lyapDependencies: nL,
  mad: lE,
  madDependencies: iL,
  magneticConstant: wA,
  magneticConstantDependencies: aL,
  magneticFluxQuantum: HA,
  magneticFluxQuantumDependencies: sL,
  map: $i,
  mapDependencies: Da,
  mapTransformDependencies: oL,
  matrix: ze,
  matrixDependencies: Ue,
  matrixFromColumns: rm,
  matrixFromColumnsDependencies: tg,
  matrixFromFunction: uD,
  matrixFromFunctionDependencies: uL,
  matrixFromRows: qD,
  matrixFromRowsDependencies: lL,
  max: yo,
  maxDependencies: ug,
  maxTransformDependencies: cL,
  mean: _v,
  meanDependencies: UE,
  meanTransformDependencies: fL,
  median: Mv,
  medianDependencies: mS,
  min: fv,
  minDependencies: pL,
  minTransformDependencies: hL,
  mod: pv,
  modDependencies: aS,
  mode: lD,
  modeDependencies: mL,
  molarMass: NA,
  molarMassC12: QA,
  molarMassC12Dependencies: vL,
  molarMassDependencies: dL,
  molarPlanckConstant: DA,
  molarPlanckConstantDependencies: gL,
  molarVolume: nE,
  molarVolumeDependencies: yL,
  multinomial: VA,
  multinomialDependencies: xL,
  multiply: it,
  multiplyDependencies: Gt,
  multiplyScalar: ar,
  multiplyScalarDependencies: lr,
  neutronMass: AA,
  neutronMassDependencies: wL,
  norm: pm,
  normDependencies: og,
  not: Ls,
  notDependencies: gm,
  nthRoot: vD,
  nthRootDependencies: NL,
  nthRoots: ID,
  nthRootsDependencies: DL,
  nuclearMagneton: EA,
  nuclearMagnetonDependencies: AL,
  nullDependencies: EL,
  number: Xn,
  numberDependencies: Ni,
  numeric: gn,
  numericDependencies: Fn,
  oct: PN,
  octDependencies: SL,
  ones: gD,
  onesDependencies: CL,
  or: BD,
  orDependencies: TL,
  orTransformDependencies: _L,
  parse: Et,
  parseDependencies: ni,
  parser: wE,
  parserDependencies: ML,
  partitionSelect: go,
  partitionSelectDependencies: Am,
  permutations: WA,
  permutationsDependencies: OL,
  phi: uN,
  phiDependencies: FL,
  pi: Oi,
  piDependencies: lg,
  pickRandom: kN,
  pickRandomDependencies: qL,
  pinv: eA,
  pinvDependencies: IL,
  planckCharge: SA,
  planckChargeDependencies: BL,
  planckConstant: iE,
  planckConstantDependencies: RL,
  planckLength: CA,
  planckLengthDependencies: LL,
  planckMass: jA,
  planckMassDependencies: PL,
  planckTemperature: TA,
  planckTemperatureDependencies: kL,
  planckTime: pE,
  planckTimeDependencies: $L,
  polynomialRoot: ZA,
  polynomialRootDependencies: zL,
  pow: _t,
  powDependencies: Bn,
  print: $N,
  printDependencies: UL,
  printTransformDependencies: GL,
  prod: tv,
  prodDependencies: GE,
  protonMass: _A,
  protonMassDependencies: HL,
  qr: nm,
  qrDependencies: rg,
  quantileSeq: aE,
  quantileSeqDependencies: QL,
  quantileSeqTransformDependencies: VL,
  quantumOfCirculation: MA,
  quantumOfCirculationDependencies: WL,
  random: zN,
  randomDependencies: jL,
  randomInt: eD,
  randomIntDependencies: ZL,
  range: sa,
  rangeDependencies: gs,
  rangeTransformDependencies: YL,
  rationalize: NE,
  rationalizeDependencies: XL,
  re: Ha,
  reDependencies: ng,
  reducedPlanckConstant: OA,
  reducedPlanckConstantDependencies: KL,
  replacer: vN,
  replacerDependencies: eP,
  reshape: rv,
  reshapeDependencies: jE,
  resize: yD,
  resizeDependencies: tP,
  resolve: $v,
  resolveDependencies: HE,
  reviver: vE,
  reviverDependencies: rP,
  rightArithShift: xD,
  rightArithShiftDependencies: nP,
  rightLogShift: RD,
  rightLogShiftDependencies: iP,
  rotate: hE,
  rotateDependencies: aP,
  rotationMatrix: Ov,
  rotationMatrixDependencies: gS,
  round: kt,
  roundDependencies: ds,
  row: XD,
  rowDependencies: sP,
  rowTransformDependencies: oP,
  rydberg: FA,
  rydbergDependencies: uP,
  sackurTetrode: fN,
  sackurTetrodeDependencies: fP,
  schur: Fv,
  schurDependencies: pS,
  sec: UN,
  secDependencies: pP,
  sech: tD,
  sechDependencies: hP,
  secondRadiation: qA,
  secondRadiationDependencies: mP,
  setCartesian: QD,
  setCartesianDependencies: dP,
  setDifference: xv,
  setDifferenceDependencies: yS,
  setDistinct: VD,
  setDistinctDependencies: vP,
  setIntersect: Av,
  setIntersectDependencies: xS,
  setIsSubset: WD,
  setIsSubsetDependencies: gP,
  setMultiplicity: KD,
  setMultiplicityDependencies: yP,
  setPowerset: jD,
  setPowersetDependencies: xP,
  setSize: JA,
  setSizeDependencies: bP,
  setSymDifference: bv,
  setSymDifferenceDependencies: bS,
  setUnion: tA,
  setUnionDependencies: wP,
  sign: Kd,
  signDependencies: WE,
  simplify: xo,
  simplifyConstant: mm,
  simplifyConstantDependencies: Xv,
  simplifyCore: dm,
  simplifyCoreDependencies: Kv,
  simplifyDependencies: Nm,
  sin: po,
  sinDependencies: Dm,
  sinh: rD,
  sinhDependencies: NP,
  size: Tr,
  sizeDependencies: zr,
  slu: hv,
  sluDependencies: cS,
  smaller: Qr,
  smallerDependencies: on,
  smallerEq: aa,
  smallerEqDependencies: vs,
  solveODE: YA,
  solveODEDependencies: DP,
  sort: ZD,
  sortDependencies: AP,
  sparse: nD,
  sparseDependencies: EP,
  speedOfLight: IA,
  speedOfLightDependencies: SP,
  splitUnit: GN,
  splitUnitDependencies: CP,
  sqrt: dr,
  sqrtDependencies: Vn,
  sqrtm: rA,
  sqrtmDependencies: TP,
  square: HN,
  squareDependencies: _P,
  squeeze: cD,
  squeezeDependencies: MP,
  std: cE,
  stdDependencies: OP,
  stdTransformDependencies: FP,
  stefanBoltzmann: BA,
  stefanBoltzmannDependencies: qP,
  stirlingS2: Cv,
  stirlingS2Dependencies: ME,
  string: QN,
  stringDependencies: IP,
  subset: hn,
  subsetDependencies: Nn,
  subsetTransformDependencies: BP,
  subtract: Xt,
  subtractDependencies: cr,
  subtractScalar: bn,
  subtractScalarDependencies: In,
  sum: om,
  sumDependencies: Wv,
  sumTransformDependencies: RP,
  sylvester: qv,
  sylvesterDependencies: hS,
  symbolicEqual: xE,
  symbolicEqualDependencies: LP,
  tan: VN,
  tanDependencies: PP,
  tanh: iD,
  tanhDependencies: kP,
  tau: jd,
  tauDependencies: eS,
  thomsonCrossSection: RA,
  thomsonCrossSectionDependencies: $P,
  to: bD,
  toDependencies: zP,
  trace: mv,
  traceDependencies: UP,
  transpose: as,
  transposeDependencies: No,
  trueDependencies: GP,
  typeOf: ev,
  typeOfDependencies: vS,
  typed: se,
  typedDependencies: oe,
  unaryMinus: Gn,
  unaryMinusDependencies: ti,
  unaryPlus: im,
  unaryPlusDependencies: Jv,
  unequal: JD,
  unequalDependencies: HP,
  unit: XA,
  unitDependencies: QP,
  usolve: am,
  usolveAll: dv,
  usolveAllDependencies: ZE,
  usolveDependencies: ig,
  vacuumImpedance: nA,
  vacuumImpedanceDependencies: jP,
  variance: fm,
  varianceDependencies: cg,
  varianceTransformDependencies: ZP,
  version: hN,
  versionDependencies: JP,
  weakMixingAngle: yN,
  weakMixingAngleDependencies: YP,
  wienDisplacement: iA,
  wienDisplacementDependencies: XP,
  xgcd: nv,
  xgcdDependencies: sS,
  xor: wD,
  xorDependencies: KP,
  zeros: yr,
  zerosDependencies: $r,
  zeta: fE,
  zetaDependencies: ek,
  zpk2tf: LD,
  zpk2tfDependencies: tk
}, Symbol.toStringTag, { value: "Module" }));
var ok = { 92: () => {
} }, m2 = {};
function ta(t) {
  var e = m2[t];
  if (e !== void 0) return e.exports;
  var r = m2[t] = { exports: {} };
  return ok[t](r, r.exports, ta), r.exports;
}
ta.d = (t, e) => {
  for (var r in e) ta.o(e, r) && !ta.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: e[r] });
}, ta.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var zt = {};
(() => {
  ta.d(zt, { dx: () => he, q2: () => ft, FO: () => Og, xf: () => As, Gy: () => Bg, s4: () => Or, c7: () => Lg, _7: () => Tg, gp: () => Mg, cK: () => lt, zs: () => Tm, AV: () => As, Xp: () => b, VS: () => C, ul: () => ve, hW: () => Zt, x1: () => It, z5: () => Pt, oN: () => Cm, TB: () => _g, u1: () => To, _b: () => Om, $F: () => Co, _T: () => Fm, db: () => Xi, Zx: () => tr, _x: () => Fr, r8: () => P, JI: () => U, TP: () => k, WU: () => t, Nj: () => u, ZP: () => $S });
  class t {
    constructor() {
      this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
    }
    getTokenSource() {
      return this.source[0];
    }
    getInputStream() {
      return this.source[1];
    }
    get text() {
      return this._text;
    }
    set text(m) {
      this._text = m;
    }
  }
  function e(ae, m) {
    if (!Array.isArray(ae) || !Array.isArray(m)) return !1;
    if (ae === m) return !0;
    if (ae.length !== m.length) return !1;
    for (let y = 0; y < ae.length; y++) if (!(ae[y] === m[y] || ae[y].equals && ae[y].equals(m[y]))) return !1;
    return !0;
  }
  t.INVALID_TYPE = 0, t.EPSILON = -2, t.MIN_USER_TOKEN_TYPE = 1, t.EOF = -1, t.DEFAULT_CHANNEL = 0, t.HIDDEN_CHANNEL = 1;
  const r = Math.round(Math.random() * Math.pow(2, 32));
  function n(ae) {
    if (!ae) return 0;
    const m = typeof ae, y = m === "string" ? ae : !(m !== "object" || !ae.toString) && ae.toString();
    if (!y) return 0;
    let S, F;
    const z = 3 & y.length, J = y.length - z;
    let fe = r;
    const _e = 3432918353, Fe = 461845907;
    let $e = 0;
    for (; $e < J; ) F = 255 & y.charCodeAt($e) | (255 & y.charCodeAt(++$e)) << 8 | (255 & y.charCodeAt(++$e)) << 16 | (255 & y.charCodeAt(++$e)) << 24, ++$e, F = (65535 & F) * _e + (((F >>> 16) * _e & 65535) << 16) & 4294967295, F = F << 15 | F >>> 17, F = (65535 & F) * Fe + (((F >>> 16) * Fe & 65535) << 16) & 4294967295, fe ^= F, fe = fe << 13 | fe >>> 19, S = 5 * (65535 & fe) + ((5 * (fe >>> 16) & 65535) << 16) & 4294967295, fe = 27492 + (65535 & S) + ((58964 + (S >>> 16) & 65535) << 16);
    switch (F = 0, z) {
      case 3:
        F ^= (255 & y.charCodeAt($e + 2)) << 16;
      case 2:
        F ^= (255 & y.charCodeAt($e + 1)) << 8;
      case 1:
        F ^= 255 & y.charCodeAt($e), F = (65535 & F) * _e + (((F >>> 16) * _e & 65535) << 16) & 4294967295, F = F << 15 | F >>> 17, F = (65535 & F) * Fe + (((F >>> 16) * Fe & 65535) << 16) & 4294967295, fe ^= F;
    }
    return fe ^= y.length, fe ^= fe >>> 16, fe = 2246822507 * (65535 & fe) + ((2246822507 * (fe >>> 16) & 65535) << 16) & 4294967295, fe ^= fe >>> 13, fe = 3266489909 * (65535 & fe) + ((3266489909 * (fe >>> 16) & 65535) << 16) & 4294967295, fe ^= fe >>> 16, fe >>> 0;
  }
  class a {
    constructor() {
      this.count = 0, this.hash = 0;
    }
    update() {
      for (let m = 0; m < arguments.length; m++) {
        const y = arguments[m];
        if (y != null) if (Array.isArray(y)) this.update.apply(this, y);
        else {
          let S = 0;
          switch (typeof y) {
            case "undefined":
            case "function":
              continue;
            case "number":
            case "boolean":
              S = y;
              break;
            case "string":
              S = n(y);
              break;
            default:
              y.updateHashCode ? y.updateHashCode(this) : console.log("No updateHashCode for " + y.toString());
              continue;
          }
          S *= 3432918353, S = S << 15 | S >>> 17, S *= 461845907, this.count = this.count + 1;
          let F = this.hash ^ S;
          F = F << 13 | F >>> 19, F = 5 * F + 3864292196, this.hash = F;
        }
      }
    }
    finish() {
      let m = this.hash ^ 4 * this.count;
      return m ^= m >>> 16, m *= 2246822507, m ^= m >>> 13, m *= 3266489909, m ^= m >>> 16, m;
    }
    static hashStuff() {
      const m = new a();
      return m.update.apply(m, arguments), m.finish();
    }
  }
  function s(ae) {
    return ae ? typeof ae == "string" ? n(ae) : ae.hashCode() : -1;
  }
  function o(ae, m) {
    return ae ? ae.equals(m) : ae === m;
  }
  function p(ae) {
    return ae === null ? "null" : ae;
  }
  function u(ae) {
    return Array.isArray(ae) ? "[" + ae.map(p).join(", ") + "]" : "null";
  }
  const f = "h-";
  class l {
    constructor(m, y) {
      this.data = {}, this.hashFunction = m || s, this.equalsFunction = y || o;
    }
    add(m) {
      const y = f + this.hashFunction(m);
      if (y in this.data) {
        const S = this.data[y];
        for (let F = 0; F < S.length; F++) if (this.equalsFunction(m, S[F])) return S[F];
        return S.push(m), m;
      }
      return this.data[y] = [m], m;
    }
    has(m) {
      return this.get(m) != null;
    }
    get(m) {
      const y = f + this.hashFunction(m);
      if (y in this.data) {
        const S = this.data[y];
        for (let F = 0; F < S.length; F++) if (this.equalsFunction(m, S[F])) return S[F];
      }
      return null;
    }
    values() {
      return Object.keys(this.data).filter((m) => m.startsWith(f)).flatMap((m) => this.data[m], this);
    }
    toString() {
      return u(this.values());
    }
    get length() {
      return Object.keys(this.data).filter((m) => m.startsWith(f)).map((m) => this.data[m].length, this).reduce((m, y) => m + y, 0);
    }
  }
  class c {
    hashCode() {
      const m = new a();
      return this.updateHashCode(m), m.finish();
    }
    evaluate(m, y) {
    }
    evalPrecedence(m, y) {
      return this;
    }
    static andContext(m, y) {
      if (m === null || m === c.NONE) return y;
      if (y === null || y === c.NONE) return m;
      const S = new h(m, y);
      return S.opnds.length === 1 ? S.opnds[0] : S;
    }
    static orContext(m, y) {
      if (m === null) return y;
      if (y === null) return m;
      if (m === c.NONE || y === c.NONE) return c.NONE;
      const S = new d(m, y);
      return S.opnds.length === 1 ? S.opnds[0] : S;
    }
  }
  class h extends c {
    constructor(m, y) {
      super();
      const S = new l();
      m instanceof h ? m.opnds.map(function(z) {
        S.add(z);
      }) : S.add(m), y instanceof h ? y.opnds.map(function(z) {
        S.add(z);
      }) : S.add(y);
      const F = g(S);
      if (F.length > 0) {
        let z = null;
        F.map(function(J) {
          (z === null || J.precedence < z.precedence) && (z = J);
        }), S.add(z);
      }
      this.opnds = Array.from(S.values());
    }
    equals(m) {
      return this === m || m instanceof h && e(this.opnds, m.opnds);
    }
    updateHashCode(m) {
      m.update(this.opnds, "AND");
    }
    evaluate(m, y) {
      for (let S = 0; S < this.opnds.length; S++) if (!this.opnds[S].evaluate(m, y)) return !1;
      return !0;
    }
    evalPrecedence(m, y) {
      let S = !1;
      const F = [];
      for (let J = 0; J < this.opnds.length; J++) {
        const fe = this.opnds[J], _e = fe.evalPrecedence(m, y);
        if (S |= _e !== fe, _e === null) return null;
        _e !== c.NONE && F.push(_e);
      }
      if (!S) return this;
      if (F.length === 0) return c.NONE;
      let z = null;
      return F.map(function(J) {
        z = z === null ? J : c.andContext(z, J);
      }), z;
    }
    toString() {
      const m = this.opnds.map((y) => y.toString());
      return (m.length > 3 ? m.slice(3) : m).join("&&");
    }
  }
  class d extends c {
    constructor(m, y) {
      super();
      const S = new l();
      m instanceof d ? m.opnds.map(function(z) {
        S.add(z);
      }) : S.add(m), y instanceof d ? y.opnds.map(function(z) {
        S.add(z);
      }) : S.add(y);
      const F = g(S);
      if (F.length > 0) {
        const z = F.sort(function(fe, _e) {
          return fe.compareTo(_e);
        }), J = z[z.length - 1];
        S.add(J);
      }
      this.opnds = Array.from(S.values());
    }
    equals(m) {
      return this === m || m instanceof d && e(this.opnds, m.opnds);
    }
    updateHashCode(m) {
      m.update(this.opnds, "OR");
    }
    evaluate(m, y) {
      for (let S = 0; S < this.opnds.length; S++) if (this.opnds[S].evaluate(m, y)) return !0;
      return !1;
    }
    evalPrecedence(m, y) {
      let S = !1;
      const F = [];
      for (let z = 0; z < this.opnds.length; z++) {
        const J = this.opnds[z], fe = J.evalPrecedence(m, y);
        if (S |= fe !== J, fe === c.NONE) return c.NONE;
        fe !== null && F.push(fe);
      }
      return S ? (F.length === 0, null) : this;
    }
    toString() {
      const m = this.opnds.map((y) => y.toString());
      return (m.length > 3 ? m.slice(3) : m).join("||");
    }
  }
  function g(ae) {
    const m = [];
    return ae.values().map(function(y) {
      y instanceof c.PrecedencePredicate && m.push(y);
    }), m;
  }
  function v(ae, m) {
    if (ae === null) {
      const y = { state: null, alt: null, context: null, semanticContext: null };
      return m && (y.reachesIntoOuterContext = 0), y;
    }
    {
      const y = {};
      return y.state = ae.state || null, y.alt = ae.alt === void 0 ? null : ae.alt, y.context = ae.context || null, y.semanticContext = ae.semanticContext || null, m && (y.reachesIntoOuterContext = ae.reachesIntoOuterContext || 0, y.precedenceFilterSuppressed = ae.precedenceFilterSuppressed || !1), y;
    }
  }
  class N {
    constructor(m, y) {
      this.checkContext(m, y), m = v(m), y = v(y, !0), this.state = m.state !== null ? m.state : y.state, this.alt = m.alt !== null ? m.alt : y.alt, this.context = m.context !== null ? m.context : y.context, this.semanticContext = m.semanticContext !== null ? m.semanticContext : y.semanticContext !== null ? y.semanticContext : c.NONE, this.reachesIntoOuterContext = y.reachesIntoOuterContext, this.precedenceFilterSuppressed = y.precedenceFilterSuppressed;
    }
    checkContext(m, y) {
      m.context !== null && m.context !== void 0 || y !== null && y.context !== null && y.context !== void 0 || (this.context = null);
    }
    hashCode() {
      const m = new a();
      return this.updateHashCode(m), m.finish();
    }
    updateHashCode(m) {
      m.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
    }
    equals(m) {
      return this === m || m instanceof N && this.state.stateNumber === m.state.stateNumber && this.alt === m.alt && (this.context === null ? m.context === null : this.context.equals(m.context)) && this.semanticContext.equals(m.semanticContext) && this.precedenceFilterSuppressed === m.precedenceFilterSuppressed;
    }
    hashCodeForConfigSet() {
      const m = new a();
      return m.update(this.state.stateNumber, this.alt, this.semanticContext), m.finish();
    }
    equalsForConfigSet(m) {
      return this === m || m instanceof N && this.state.stateNumber === m.state.stateNumber && this.alt === m.alt && this.semanticContext.equals(m.semanticContext);
    }
    toString() {
      return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== c.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
    }
  }
  class b {
    constructor(m, y) {
      this.start = m, this.stop = y;
    }
    clone() {
      return new b(this.start, this.stop);
    }
    contains(m) {
      return m >= this.start && m < this.stop;
    }
    toString() {
      return this.start === this.stop - 1 ? this.start.toString() : this.start.toString() + ".." + (this.stop - 1).toString();
    }
    get length() {
      return this.stop - this.start;
    }
  }
  b.INVALID_INTERVAL = new b(-1, -2);
  class C {
    constructor() {
      this.intervals = null, this.readOnly = !1;
    }
    first(m) {
      return this.intervals === null || this.intervals.length === 0 ? t.INVALID_TYPE : this.intervals[0].start;
    }
    addOne(m) {
      this.addInterval(new b(m, m + 1));
    }
    addRange(m, y) {
      this.addInterval(new b(m, y + 1));
    }
    addInterval(m) {
      if (this.intervals === null) this.intervals = [], this.intervals.push(m.clone());
      else {
        for (let y = 0; y < this.intervals.length; y++) {
          const S = this.intervals[y];
          if (m.stop < S.start) return void this.intervals.splice(y, 0, m);
          if (m.stop === S.start) return void (this.intervals[y] = new b(m.start, S.stop));
          if (m.start <= S.stop) return this.intervals[y] = new b(Math.min(S.start, m.start), Math.max(S.stop, m.stop)), void this.reduce(y);
        }
        this.intervals.push(m.clone());
      }
    }
    addSet(m) {
      return m.intervals !== null && m.intervals.forEach((y) => this.addInterval(y), this), this;
    }
    reduce(m) {
      if (m < this.intervals.length - 1) {
        const y = this.intervals[m], S = this.intervals[m + 1];
        y.stop >= S.stop ? (this.intervals.splice(m + 1, 1), this.reduce(m)) : y.stop >= S.start && (this.intervals[m] = new b(y.start, S.stop), this.intervals.splice(m + 1, 1));
      }
    }
    complement(m, y) {
      const S = new C();
      return S.addInterval(new b(m, y + 1)), this.intervals !== null && this.intervals.forEach((F) => S.removeRange(F)), S;
    }
    contains(m) {
      if (this.intervals === null) return !1;
      for (let y = 0; y < this.intervals.length; y++) if (this.intervals[y].contains(m)) return !0;
      return !1;
    }
    removeRange(m) {
      if (m.start === m.stop - 1) this.removeOne(m.start);
      else if (this.intervals !== null) {
        let y = 0;
        for (let S = 0; S < this.intervals.length; S++) {
          const F = this.intervals[y];
          if (m.stop <= F.start) return;
          if (m.start > F.start && m.stop < F.stop) {
            this.intervals[y] = new b(F.start, m.start);
            const z = new b(m.stop, F.stop);
            return void this.intervals.splice(y, 0, z);
          }
          m.start <= F.start && m.stop >= F.stop ? (this.intervals.splice(y, 1), y -= 1) : m.start < F.stop ? this.intervals[y] = new b(F.start, m.start) : m.stop < F.stop && (this.intervals[y] = new b(m.stop, F.stop)), y += 1;
        }
      }
    }
    removeOne(m) {
      if (this.intervals !== null) for (let y = 0; y < this.intervals.length; y++) {
        const S = this.intervals[y];
        if (m < S.start) return;
        if (m === S.start && m === S.stop - 1) return void this.intervals.splice(y, 1);
        if (m === S.start) return void (this.intervals[y] = new b(S.start + 1, S.stop));
        if (m === S.stop - 1) return void (this.intervals[y] = new b(S.start, S.stop - 1));
        if (m < S.stop - 1) {
          const F = new b(S.start, m);
          return S.start = m + 1, void this.intervals.splice(y, 0, F);
        }
      }
    }
    toString(m, y, S) {
      return m = m || null, y = y || null, S = S || !1, this.intervals === null ? "{}" : m !== null || y !== null ? this.toTokenString(m, y) : S ? this.toCharString() : this.toIndexString();
    }
    toCharString() {
      const m = [];
      for (let y = 0; y < this.intervals.length; y++) {
        const S = this.intervals[y];
        S.stop === S.start + 1 ? S.start === t.EOF ? m.push("<EOF>") : m.push("'" + String.fromCharCode(S.start) + "'") : m.push("'" + String.fromCharCode(S.start) + "'..'" + String.fromCharCode(S.stop - 1) + "'");
      }
      return m.length > 1 ? "{" + m.join(", ") + "}" : m[0];
    }
    toIndexString() {
      const m = [];
      for (let y = 0; y < this.intervals.length; y++) {
        const S = this.intervals[y];
        S.stop === S.start + 1 ? S.start === t.EOF ? m.push("<EOF>") : m.push(S.start.toString()) : m.push(S.start.toString() + ".." + (S.stop - 1).toString());
      }
      return m.length > 1 ? "{" + m.join(", ") + "}" : m[0];
    }
    toTokenString(m, y) {
      const S = [];
      for (let F = 0; F < this.intervals.length; F++) {
        const z = this.intervals[F];
        for (let J = z.start; J < z.stop; J++) S.push(this.elementName(m, y, J));
      }
      return S.length > 1 ? "{" + S.join(", ") + "}" : S[0];
    }
    elementName(m, y, S) {
      return S === t.EOF ? "<EOF>" : S === t.EPSILON ? "<EPSILON>" : m[S] || y[S];
    }
    get length() {
      return this.intervals.map((m) => m.length).reduce((m, y) => m + y);
    }
  }
  class x {
    constructor() {
      this.atn = null, this.stateNumber = x.INVALID_STATE_NUMBER, this.stateType = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = !1, this.transitions = [], this.nextTokenWithinRule = null;
    }
    toString() {
      return this.stateNumber;
    }
    equals(m) {
      return m instanceof x && this.stateNumber === m.stateNumber;
    }
    isNonGreedyExitState() {
      return !1;
    }
    addTransition(m, y) {
      y === void 0 && (y = -1), this.transitions.length === 0 ? this.epsilonOnlyTransitions = m.isEpsilon : this.epsilonOnlyTransitions !== m.isEpsilon && (this.epsilonOnlyTransitions = !1), y === -1 ? this.transitions.push(m) : this.transitions.splice(y, 1, m);
    }
  }
  x.INVALID_TYPE = 0, x.BASIC = 1, x.RULE_START = 2, x.BLOCK_START = 3, x.PLUS_BLOCK_START = 4, x.STAR_BLOCK_START = 5, x.TOKEN_START = 6, x.RULE_STOP = 7, x.BLOCK_END = 8, x.STAR_LOOP_BACK = 9, x.STAR_LOOP_ENTRY = 10, x.PLUS_LOOP_BACK = 11, x.LOOP_END = 12, x.serializationNames = ["INVALID", "BASIC", "RULE_START", "BLOCK_START", "PLUS_BLOCK_START", "STAR_BLOCK_START", "TOKEN_START", "RULE_STOP", "BLOCK_END", "STAR_LOOP_BACK", "STAR_LOOP_ENTRY", "PLUS_LOOP_BACK", "LOOP_END"], x.INVALID_STATE_NUMBER = -1;
  class E extends x {
    constructor() {
      return super(), this.stateType = x.RULE_STOP, this;
    }
  }
  class D {
    constructor(m) {
      if (m == null) throw "target cannot be null.";
      this.target = m, this.isEpsilon = !1, this.label = null;
    }
  }
  D.EPSILON = 1, D.RANGE = 2, D.RULE = 3, D.PREDICATE = 4, D.ATOM = 5, D.ACTION = 6, D.SET = 7, D.NOT_SET = 8, D.WILDCARD = 9, D.PRECEDENCE = 10, D.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"], D.serializationTypes = { EpsilonTransition: D.EPSILON, RangeTransition: D.RANGE, RuleTransition: D.RULE, PredicateTransition: D.PREDICATE, AtomTransition: D.ATOM, ActionTransition: D.ACTION, SetTransition: D.SET, NotSetTransition: D.NOT_SET, WildcardTransition: D.WILDCARD, PrecedencePredicateTransition: D.PRECEDENCE };
  class A extends D {
    constructor(m, y, S, F) {
      super(m), this.ruleIndex = y, this.precedence = S, this.followState = F, this.serializationType = D.RULE, this.isEpsilon = !0;
    }
    matches(m, y, S) {
      return !1;
    }
  }
  class M extends D {
    constructor(m, y) {
      super(m), this.serializationType = D.SET, y != null ? this.label = y : (this.label = new C(), this.label.addOne(t.INVALID_TYPE));
    }
    matches(m, y, S) {
      return this.label.contains(m);
    }
    toString() {
      return this.label.toString();
    }
  }
  class _ extends M {
    constructor(m, y) {
      super(m, y), this.serializationType = D.NOT_SET;
    }
    matches(m, y, S) {
      return m >= y && m <= S && !super.matches(m, y, S);
    }
    toString() {
      return "~" + super.toString();
    }
  }
  class O extends D {
    constructor(m) {
      super(m), this.serializationType = D.WILDCARD;
    }
    matches(m, y, S) {
      return m >= y && m <= S;
    }
    toString() {
      return ".";
    }
  }
  class T extends D {
    constructor(m) {
      super(m);
    }
  }
  class I {
  }
  class q extends I {
  }
  class $ extends q {
  }
  class U extends $ {
    get ruleContext() {
      throw new Error("missing interface implementation");
    }
  }
  class k extends $ {
  }
  class L extends k {
  }
  const R = { toStringTree: function(ae, m, y) {
    m = m || null, (y = y || null) !== null && (m = y.ruleNames);
    let S = R.getNodeText(ae, m);
    S = function(J, fe) {
      return J = J.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
    }(S);
    const F = ae.getChildCount();
    if (F === 0) return S;
    let z = "(" + S + " ";
    F > 0 && (S = R.toStringTree(ae.getChild(0), m), z = z.concat(S));
    for (let J = 1; J < F; J++) S = R.toStringTree(ae.getChild(J), m), z = z.concat(" " + S);
    return z = z.concat(")"), z;
  }, getNodeText: function(ae, m, y) {
    if (m = m || null, (y = y || null) !== null && (m = y.ruleNames), m !== null) {
      if (ae instanceof U) {
        const F = ae.ruleContext.getAltNumber();
        return F != 0 ? m[ae.ruleIndex] + ":" + F : m[ae.ruleIndex];
      }
      if (ae instanceof L) return ae.toString();
      if (ae instanceof k && ae.symbol !== null) return ae.symbol.text;
    }
    const S = ae.getPayload();
    return S instanceof t ? S.text : ae.getPayload().toString();
  }, getChildren: function(ae) {
    const m = [];
    for (let y = 0; y < ae.getChildCount(); y++) m.push(ae.getChild(y));
    return m;
  }, getAncestors: function(ae) {
    let m = [];
    for (ae = ae.getParent(); ae !== null; ) m = [ae].concat(m), ae = ae.getParent();
    return m;
  }, findAllTokenNodes: function(ae, m) {
    return R.findAllNodes(ae, m, !0);
  }, findAllRuleNodes: function(ae, m) {
    return R.findAllNodes(ae, m, !1);
  }, findAllNodes: function(ae, m, y) {
    const S = [];
    return R._findAllNodes(ae, m, y, S), S;
  }, _findAllNodes: function(ae, m, y, S) {
    y && ae instanceof k ? ae.symbol.type === m && S.push(ae) : !y && ae instanceof U && ae.ruleIndex === m && S.push(ae);
    for (let F = 0; F < ae.getChildCount(); F++) R._findAllNodes(ae.getChild(F), m, y, S);
  }, descendants: function(ae) {
    let m = [ae];
    for (let y = 0; y < ae.getChildCount(); y++) m = m.concat(R.descendants(ae.getChild(y)));
    return m;
  } }, G = R;
  class P extends U {
    constructor(m, y) {
      super(), this.parentCtx = m || null, this.invokingState = y || -1;
    }
    depth() {
      let m = 0, y = this;
      for (; y !== null; ) y = y.parentCtx, m += 1;
      return m;
    }
    isEmpty() {
      return this.invokingState === -1;
    }
    getSourceInterval() {
      return b.INVALID_INTERVAL;
    }
    get ruleContext() {
      return this;
    }
    getPayload() {
      return this;
    }
    getText() {
      return this.getChildCount() === 0 ? "" : this.children.map(function(m) {
        return m.getText();
      }).join("");
    }
    getAltNumber() {
      return 0;
    }
    setAltNumber(m) {
    }
    getChild(m) {
      return null;
    }
    getChildCount() {
      return 0;
    }
    accept(m) {
      return m.visitChildren(this);
    }
    toStringTree(m, y) {
      return G.toStringTree(this, m, y);
    }
    toString(m, y) {
      m = m || null, y = y || null;
      let S = this, F = "[";
      for (; S !== null && S !== y; ) {
        if (m === null) S.isEmpty() || (F += S.invokingState);
        else {
          const z = S.ruleIndex;
          F += z >= 0 && z < m.length ? m[z] : "" + z;
        }
        S.parentCtx === null || m === null && S.parentCtx.isEmpty() || (F += " "), S = S.parentCtx;
      }
      return F += "]", F;
    }
  }
  class W {
    constructor(m) {
      this.cachedHashCode = m;
    }
    isEmpty() {
      return this === W.EMPTY;
    }
    hasEmptyPath() {
      return this.getReturnState(this.length - 1) === W.EMPTY_RETURN_STATE;
    }
    hashCode() {
      return this.cachedHashCode;
    }
    updateHashCode(m) {
      m.update(this.cachedHashCode);
    }
  }
  W.EMPTY = null, W.EMPTY_RETURN_STATE = 2147483647, W.globalNodeCount = 1, W.id = W.globalNodeCount, W.trace_atn_sim = !1;
  class le extends W {
    constructor(m, y) {
      const S = new a();
      return S.update(m, y), super(S.finish()), this.parents = m, this.returnStates = y, this;
    }
    isEmpty() {
      return this.returnStates[0] === W.EMPTY_RETURN_STATE;
    }
    getParent(m) {
      return this.parents[m];
    }
    getReturnState(m) {
      return this.returnStates[m];
    }
    equals(m) {
      return this === m || m instanceof le && this.hashCode() === m.hashCode() && e(this.returnStates, m.returnStates) && e(this.parents, m.parents);
    }
    toString() {
      if (this.isEmpty()) return "[]";
      {
        let m = "[";
        for (let y = 0; y < this.returnStates.length; y++) y > 0 && (m += ", "), this.returnStates[y] !== W.EMPTY_RETURN_STATE ? (m += this.returnStates[y], this.parents[y] !== null ? m = m + " " + this.parents[y] : m += "null") : m += "$";
        return m + "]";
      }
    }
    get length() {
      return this.returnStates.length;
    }
  }
  class Z extends W {
    constructor(m, y) {
      let S = 0;
      const F = new a();
      m !== null ? F.update(m, y) : F.update(1), S = F.finish(), super(S), this.parentCtx = m, this.returnState = y;
    }
    getParent(m) {
      return this.parentCtx;
    }
    getReturnState(m) {
      return this.returnState;
    }
    equals(m) {
      return this === m || m instanceof Z && this.hashCode() === m.hashCode() && this.returnState === m.returnState && (this.parentCtx == null ? m.parentCtx == null : this.parentCtx.equals(m.parentCtx));
    }
    toString() {
      const m = this.parentCtx === null ? "" : this.parentCtx.toString();
      return m.length === 0 ? this.returnState === W.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : this.returnState + " " + m;
    }
    get length() {
      return 1;
    }
    static create(m, y) {
      return y === W.EMPTY_RETURN_STATE && m === null ? W.EMPTY : new Z(m, y);
    }
  }
  class H extends Z {
    constructor() {
      super(null, W.EMPTY_RETURN_STATE);
    }
    isEmpty() {
      return !0;
    }
    getParent(m) {
      return null;
    }
    getReturnState(m) {
      return this.returnState;
    }
    equals(m) {
      return this === m;
    }
    toString() {
      return "$";
    }
  }
  W.EMPTY = new H();
  const te = "h-";
  class be {
    constructor(m, y) {
      this.data = {}, this.hashFunction = m || s, this.equalsFunction = y || o;
    }
    set(m, y) {
      const S = te + this.hashFunction(m);
      if (S in this.data) {
        const F = this.data[S];
        for (let z = 0; z < F.length; z++) {
          const J = F[z];
          if (this.equalsFunction(m, J.key)) {
            const fe = J.value;
            return J.value = y, fe;
          }
        }
        return F.push({ key: m, value: y }), y;
      }
      return this.data[S] = [{ key: m, value: y }], y;
    }
    containsKey(m) {
      const y = te + this.hashFunction(m);
      if (y in this.data) {
        const S = this.data[y];
        for (let F = 0; F < S.length; F++) {
          const z = S[F];
          if (this.equalsFunction(m, z.key)) return !0;
        }
      }
      return !1;
    }
    get(m) {
      const y = te + this.hashFunction(m);
      if (y in this.data) {
        const S = this.data[y];
        for (let F = 0; F < S.length; F++) {
          const z = S[F];
          if (this.equalsFunction(m, z.key)) return z.value;
        }
      }
      return null;
    }
    entries() {
      return Object.keys(this.data).filter((m) => m.startsWith(te)).flatMap((m) => this.data[m], this);
    }
    getKeys() {
      return this.entries().map((m) => m.key);
    }
    getValues() {
      return this.entries().map((m) => m.value);
    }
    toString() {
      return "[" + this.entries().map((m) => "{" + m.key + ":" + m.value + "}").join(", ") + "]";
    }
    get length() {
      return Object.keys(this.data).filter((m) => m.startsWith(te)).map((m) => this.data[m].length, this).reduce((m, y) => m + y, 0);
    }
  }
  function K(ae, m) {
    if (m == null && (m = P.EMPTY), m.parentCtx === null || m === P.EMPTY) return W.EMPTY;
    const y = K(ae, m.parentCtx), S = ae.states[m.invokingState].transitions[0];
    return Z.create(y, S.followState.stateNumber);
  }
  function ce(ae, m, y) {
    if (ae.isEmpty()) return ae;
    let S = y.get(ae) || null;
    if (S !== null) return S;
    if (S = m.get(ae), S !== null) return y.set(ae, S), S;
    let F = !1, z = [];
    for (let fe = 0; fe < z.length; fe++) {
      const _e = ce(ae.getParent(fe), m, y);
      if (F || _e !== ae.getParent(fe)) {
        if (!F) {
          z = [];
          for (let Fe = 0; Fe < ae.length; Fe++) z[Fe] = ae.getParent(Fe);
          F = !0;
        }
        z[fe] = _e;
      }
    }
    if (!F) return m.add(ae), y.set(ae, ae), ae;
    let J = null;
    return J = z.length === 0 ? W.EMPTY : z.length === 1 ? Z.create(z[0], ae.getReturnState(0)) : new le(z, ae.returnStates), m.add(J), y.set(J, J), y.set(ae, J), J;
  }
  function de(ae, m, y, S) {
    if (ae === m) return ae;
    if (ae instanceof Z && m instanceof Z) return function(F, z, J, fe) {
      if (fe !== null) {
        let Fe = fe.get(F, z);
        if (Fe !== null || (Fe = fe.get(z, F), Fe !== null)) return Fe;
      }
      const _e = function(Fe, $e, je) {
        if (je) {
          if (Fe === W.EMPTY || $e === W.EMPTY) return W.EMPTY;
        } else {
          if (Fe === W.EMPTY && $e === W.EMPTY) return W.EMPTY;
          if (Fe === W.EMPTY) {
            const Je = [$e.returnState, W.EMPTY_RETURN_STATE], Ot = [$e.parentCtx, null];
            return new le(Ot, Je);
          }
          if ($e === W.EMPTY) {
            const Je = [Fe.returnState, W.EMPTY_RETURN_STATE], Ot = [Fe.parentCtx, null];
            return new le(Ot, Je);
          }
        }
        return null;
      }(F, z, J);
      if (_e !== null) return fe !== null && fe.set(F, z, _e), _e;
      if (F.returnState === z.returnState) {
        const Fe = de(F.parentCtx, z.parentCtx, J, fe);
        if (Fe === F.parentCtx) return F;
        if (Fe === z.parentCtx) return z;
        const $e = Z.create(Fe, F.returnState);
        return fe !== null && fe.set(F, z, $e), $e;
      }
      {
        let Fe = null;
        if ((F === z || F.parentCtx !== null && F.parentCtx === z.parentCtx) && (Fe = F.parentCtx), Fe !== null) {
          const Ot = [F.returnState, z.returnState];
          F.returnState > z.returnState && (Ot[0] = z.returnState, Ot[1] = F.returnState);
          const pt = new le([Fe, Fe], Ot);
          return fe !== null && fe.set(F, z, pt), pt;
        }
        const $e = [F.returnState, z.returnState];
        let je = [F.parentCtx, z.parentCtx];
        F.returnState > z.returnState && ($e[0] = z.returnState, $e[1] = F.returnState, je = [z.parentCtx, F.parentCtx]);
        const Je = new le(je, $e);
        return fe !== null && fe.set(F, z, Je), Je;
      }
    }(ae, m, y, S);
    if (y) {
      if (ae instanceof H) return ae;
      if (m instanceof H) return m;
    }
    return ae instanceof Z && (ae = new le([ae.getParent()], [ae.returnState])), m instanceof Z && (m = new le([m.getParent()], [m.returnState])), function(F, z, J, fe) {
      if (fe !== null) {
        let pt = fe.get(F, z);
        if (pt !== null || (pt = fe.get(z, F), pt !== null)) return W.trace_atn_sim && console.log("mergeArrays a=" + F + ",b=" + z + " -> previous"), pt;
      }
      let _e = 0, Fe = 0, $e = 0, je = new Array(F.returnStates.length + z.returnStates.length).fill(0), Je = new Array(F.returnStates.length + z.returnStates.length).fill(null);
      for (; _e < F.returnStates.length && Fe < z.returnStates.length; ) {
        const pt = F.parents[_e], dn = z.parents[Fe];
        if (F.returnStates[_e] === z.returnStates[Fe]) {
          const Cn = F.returnStates[_e];
          Cn === W.EMPTY_RETURN_STATE && pt === null && dn === null || pt !== null && dn !== null && pt === dn ? (Je[$e] = pt, je[$e] = Cn) : (Je[$e] = de(pt, dn, J, fe), je[$e] = Cn), _e += 1, Fe += 1;
        } else F.returnStates[_e] < z.returnStates[Fe] ? (Je[$e] = pt, je[$e] = F.returnStates[_e], _e += 1) : (Je[$e] = dn, je[$e] = z.returnStates[Fe], Fe += 1);
        $e += 1;
      }
      if (_e < F.returnStates.length) for (let pt = _e; pt < F.returnStates.length; pt++) Je[$e] = F.parents[pt], je[$e] = F.returnStates[pt], $e += 1;
      else for (let pt = Fe; pt < z.returnStates.length; pt++) Je[$e] = z.parents[pt], je[$e] = z.returnStates[pt], $e += 1;
      if ($e < Je.length) {
        if ($e === 1) {
          const pt = Z.create(Je[0], je[0]);
          return fe !== null && fe.set(F, z, pt), pt;
        }
        Je = Je.slice(0, $e), je = je.slice(0, $e);
      }
      const Ot = new le(Je, je);
      return Ot.equals(F) ? (fe !== null && fe.set(F, z, F), W.trace_atn_sim && console.log("mergeArrays a=" + F + ",b=" + z + " -> a"), F) : Ot.equals(z) ? (fe !== null && fe.set(F, z, z), W.trace_atn_sim && console.log("mergeArrays a=" + F + ",b=" + z + " -> b"), z) : (function(pt) {
        const dn = new be();
        for (let Cn = 0; Cn < pt.length; Cn++) {
          const qm = pt[Cn];
          dn.containsKey(qm) || dn.set(qm, qm);
        }
        for (let Cn = 0; Cn < pt.length; Cn++) pt[Cn] = dn.get(pt[Cn]);
      }(Je), fe !== null && fe.set(F, z, Ot), W.trace_atn_sim && console.log("mergeArrays a=" + F + ",b=" + z + " -> " + Ot), Ot);
    }(ae, m, y, S);
  }
  class ue {
    constructor() {
      this.data = [];
    }
    add(m) {
      this.data[m] = !0;
    }
    or(m) {
      Object.keys(m.data).map((y) => this.add(y), this);
    }
    remove(m) {
      delete this.data[m];
    }
    has(m) {
      return this.data[m] === !0;
    }
    values() {
      return Object.keys(this.data);
    }
    minValue() {
      return Math.min.apply(null, this.values());
    }
    hashCode() {
      return a.hashStuff(this.values());
    }
    equals(m) {
      return m instanceof ue && e(this.data, m.data);
    }
    toString() {
      return "{" + this.values().join(", ") + "}";
    }
    get length() {
      return this.values().length;
    }
  }
  class ve {
    constructor(m) {
      this.atn = m;
    }
    getDecisionLookahead(m) {
      if (m === null) return null;
      const y = m.transitions.length, S = [];
      for (let F = 0; F < y; F++) {
        S[F] = new C();
        const z = new l();
        this._LOOK(m.transition(F).target, null, W.EMPTY, S[F], z, new ue(), !1, !1), (S[F].length === 0 || S[F].contains(ve.HIT_PRED)) && (S[F] = null);
      }
      return S;
    }
    LOOK(m, y, S) {
      const F = new C(), z = (S = S || null) !== null ? K(m.atn, S) : null;
      return this._LOOK(m, y, z, F, new l(), new ue(), !0, !0), F;
    }
    _LOOK(m, y, S, F, z, J, fe, _e) {
      const Fe = new N({ state: m, alt: 0, context: S }, null);
      if (!z.has(Fe)) {
        if (z.add(Fe), m === y) {
          if (S === null) return void F.addOne(t.EPSILON);
          if (S.isEmpty() && _e) return void F.addOne(t.EOF);
        }
        if (m instanceof E) {
          if (S === null) return void F.addOne(t.EPSILON);
          if (S.isEmpty() && _e) return void F.addOne(t.EOF);
          if (S !== W.EMPTY) {
            const $e = J.has(m.ruleIndex);
            try {
              J.remove(m.ruleIndex);
              for (let je = 0; je < S.length; je++) {
                const Je = this.atn.states[S.getReturnState(je)];
                this._LOOK(Je, y, S.getParent(je), F, z, J, fe, _e);
              }
            } finally {
              $e && J.add(m.ruleIndex);
            }
            return;
          }
        }
        for (let $e = 0; $e < m.transitions.length; $e++) {
          const je = m.transitions[$e];
          if (je.constructor === A) {
            if (J.has(je.target.ruleIndex)) continue;
            const Je = Z.create(S, je.followState.stateNumber);
            try {
              J.add(je.target.ruleIndex), this._LOOK(je.target, y, Je, F, z, J, fe, _e);
            } finally {
              J.remove(je.target.ruleIndex);
            }
          } else if (je instanceof T) fe ? this._LOOK(je.target, y, S, F, z, J, fe, _e) : F.addOne(ve.HIT_PRED);
          else if (je.isEpsilon) this._LOOK(je.target, y, S, F, z, J, fe, _e);
          else if (je.constructor === O) F.addRange(t.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          else {
            let Je = je.label;
            Je !== null && (je instanceof _ && (Je = Je.complement(t.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), F.addSet(Je));
          }
        }
      }
    }
  }
  ve.HIT_PRED = t.INVALID_TYPE;
  class he {
    constructor(m, y) {
      this.grammarType = m, this.maxTokenType = y, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = null, this.modeNameToStartState = {}, this.ruleToTokenType = null, this.lexerActions = null, this.modeToStartState = [];
    }
    nextTokensInContext(m, y) {
      return new ve(this).LOOK(m, null, y);
    }
    nextTokensNoContext(m) {
      return m.nextTokenWithinRule !== null || (m.nextTokenWithinRule = this.nextTokensInContext(m, null), m.nextTokenWithinRule.readOnly = !0), m.nextTokenWithinRule;
    }
    nextTokens(m, y) {
      return y === void 0 ? this.nextTokensNoContext(m) : this.nextTokensInContext(m, y);
    }
    addState(m) {
      m !== null && (m.atn = this, m.stateNumber = this.states.length), this.states.push(m);
    }
    removeState(m) {
      this.states[m.stateNumber] = null;
    }
    defineDecisionState(m) {
      return this.decisionToState.push(m), m.decision = this.decisionToState.length - 1, m.decision;
    }
    getDecisionState(m) {
      return this.decisionToState.length === 0 ? null : this.decisionToState[m];
    }
    getExpectedTokens(m, y) {
      if (m < 0 || m >= this.states.length) throw "Invalid state number.";
      const S = this.states[m];
      let F = this.nextTokens(S);
      if (!F.contains(t.EPSILON)) return F;
      const z = new C();
      for (z.addSet(F), z.removeOne(t.EPSILON); y !== null && y.invokingState >= 0 && F.contains(t.EPSILON); ) {
        const J = this.states[y.invokingState].transitions[0];
        F = this.nextTokens(J.followState), z.addSet(F), z.removeOne(t.EPSILON), y = y.parentCtx;
      }
      return F.contains(t.EPSILON) && z.addOne(t.EOF), z;
    }
  }
  he.INVALID_ALT_NUMBER = 0;
  class Ne extends x {
    constructor() {
      super(), this.stateType = x.BASIC;
    }
  }
  class we extends x {
    constructor() {
      return super(), this.decision = -1, this.nonGreedy = !1, this;
    }
  }
  class Se extends we {
    constructor() {
      return super(), this.endState = null, this;
    }
  }
  class V extends x {
    constructor() {
      return super(), this.stateType = x.BLOCK_END, this.startState = null, this;
    }
  }
  class re extends x {
    constructor() {
      return super(), this.stateType = x.LOOP_END, this.loopBackState = null, this;
    }
  }
  class pe extends x {
    constructor() {
      return super(), this.stateType = x.RULE_START, this.stopState = null, this.isPrecedenceRule = !1, this;
    }
  }
  class X extends we {
    constructor() {
      return super(), this.stateType = x.TOKEN_START, this;
    }
  }
  class ie extends we {
    constructor() {
      return super(), this.stateType = x.PLUS_LOOP_BACK, this;
    }
  }
  class me extends x {
    constructor() {
      return super(), this.stateType = x.STAR_LOOP_BACK, this;
    }
  }
  class Ae extends we {
    constructor() {
      return super(), this.stateType = x.STAR_LOOP_ENTRY, this.loopBackState = null, this.isPrecedenceDecision = null, this;
    }
  }
  class Me extends Se {
    constructor() {
      return super(), this.stateType = x.PLUS_BLOCK_START, this.loopBackState = null, this;
    }
  }
  class Q extends Se {
    constructor() {
      return super(), this.stateType = x.STAR_BLOCK_START, this;
    }
  }
  class ee extends Se {
    constructor() {
      return super(), this.stateType = x.BLOCK_START, this;
    }
  }
  class ye extends D {
    constructor(m, y) {
      super(m), this.label_ = y, this.label = this.makeLabel(), this.serializationType = D.ATOM;
    }
    makeLabel() {
      const m = new C();
      return m.addOne(this.label_), m;
    }
    matches(m, y, S) {
      return this.label_ === m;
    }
    toString() {
      return this.label_;
    }
  }
  class Ee extends D {
    constructor(m, y, S) {
      super(m), this.serializationType = D.RANGE, this.start = y, this.stop = S, this.label = this.makeLabel();
    }
    makeLabel() {
      const m = new C();
      return m.addRange(this.start, this.stop), m;
    }
    matches(m, y, S) {
      return m >= this.start && m <= this.stop;
    }
    toString() {
      return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
    }
  }
  class Ce extends D {
    constructor(m, y, S, F) {
      super(m), this.serializationType = D.ACTION, this.ruleIndex = y, this.actionIndex = S === void 0 ? -1 : S, this.isCtxDependent = F !== void 0 && F, this.isEpsilon = !0;
    }
    matches(m, y, S) {
      return !1;
    }
    toString() {
      return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
  }
  class De extends D {
    constructor(m, y) {
      super(m), this.serializationType = D.EPSILON, this.isEpsilon = !0, this.outermostPrecedenceReturn = y;
    }
    matches(m, y, S) {
      return !1;
    }
    toString() {
      return "epsilon";
    }
  }
  class Oe extends c {
    constructor(m, y, S) {
      super(), this.ruleIndex = m === void 0 ? -1 : m, this.predIndex = y === void 0 ? -1 : y, this.isCtxDependent = S !== void 0 && S;
    }
    evaluate(m, y) {
      const S = this.isCtxDependent ? y : null;
      return m.sempred(S, this.ruleIndex, this.predIndex);
    }
    updateHashCode(m) {
      m.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    equals(m) {
      return this === m || m instanceof Oe && this.ruleIndex === m.ruleIndex && this.predIndex === m.predIndex && this.isCtxDependent === m.isCtxDependent;
    }
    toString() {
      return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
    }
  }
  c.NONE = new Oe();
  class Be extends T {
    constructor(m, y, S, F) {
      super(m), this.serializationType = D.PREDICATE, this.ruleIndex = y, this.predIndex = S, this.isCtxDependent = F, this.isEpsilon = !0;
    }
    matches(m, y, S) {
      return !1;
    }
    getPredicate() {
      return new Oe(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    toString() {
      return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
  }
  class Le extends c {
    constructor(m) {
      super(), this.precedence = m === void 0 ? 0 : m;
    }
    evaluate(m, y) {
      return m.precpred(y, this.precedence);
    }
    evalPrecedence(m, y) {
      return m.precpred(y, this.precedence) ? c.NONE : null;
    }
    compareTo(m) {
      return this.precedence - m.precedence;
    }
    updateHashCode(m) {
      m.update(this.precedence);
    }
    equals(m) {
      return this === m || m instanceof Le && this.precedence === m.precedence;
    }
    toString() {
      return "{" + this.precedence + ">=prec}?";
    }
  }
  c.PrecedencePredicate = Le;
  class Re extends T {
    constructor(m, y) {
      super(m), this.serializationType = D.PRECEDENCE, this.precedence = y, this.isEpsilon = !0;
    }
    matches(m, y, S) {
      return !1;
    }
    getPredicate() {
      return new Le(this.precedence);
    }
    toString() {
      return this.precedence + " >= _p";
    }
  }
  class rt {
    constructor(m) {
      m === void 0 && (m = null), this.readOnly = !1, this.verifyATN = m === null || m.verifyATN, this.generateRuleBypassTransitions = m !== null && m.generateRuleBypassTransitions;
    }
  }
  rt.defaultOptions = new rt(), rt.defaultOptions.readOnly = !0;
  class Ke {
    constructor(m) {
      this.actionType = m, this.isPositionDependent = !1;
    }
    hashCode() {
      const m = new a();
      return this.updateHashCode(m), m.finish();
    }
    updateHashCode(m) {
      m.update(this.actionType);
    }
    equals(m) {
      return this === m;
    }
  }
  class Ze extends Ke {
    constructor() {
      super(6);
    }
    execute(m) {
      m.skip();
    }
    toString() {
      return "skip";
    }
  }
  Ze.INSTANCE = new Ze();
  class Ie extends Ke {
    constructor(m) {
      super(0), this.channel = m;
    }
    execute(m) {
      m._channel = this.channel;
    }
    updateHashCode(m) {
      m.update(this.actionType, this.channel);
    }
    equals(m) {
      return this === m || m instanceof Ie && this.channel === m.channel;
    }
    toString() {
      return "channel(" + this.channel + ")";
    }
  }
  class B extends Ke {
    constructor(m, y) {
      super(1), this.ruleIndex = m, this.actionIndex = y, this.isPositionDependent = !0;
    }
    execute(m) {
      m.action(null, this.ruleIndex, this.actionIndex);
    }
    updateHashCode(m) {
      m.update(this.actionType, this.ruleIndex, this.actionIndex);
    }
    equals(m) {
      return this === m || m instanceof B && this.ruleIndex === m.ruleIndex && this.actionIndex === m.actionIndex;
    }
  }
  class ne extends Ke {
    constructor() {
      super(3);
    }
    execute(m) {
      m.more();
    }
    toString() {
      return "more";
    }
  }
  ne.INSTANCE = new ne();
  class xe extends Ke {
    constructor(m) {
      super(7), this.type = m;
    }
    execute(m) {
      m.type = this.type;
    }
    updateHashCode(m) {
      m.update(this.actionType, this.type);
    }
    equals(m) {
      return this === m || m instanceof xe && this.type === m.type;
    }
    toString() {
      return "type(" + this.type + ")";
    }
  }
  class Te extends Ke {
    constructor(m) {
      super(5), this.mode = m;
    }
    execute(m) {
      m.pushMode(this.mode);
    }
    updateHashCode(m) {
      m.update(this.actionType, this.mode);
    }
    equals(m) {
      return this === m || m instanceof Te && this.mode === m.mode;
    }
    toString() {
      return "pushMode(" + this.mode + ")";
    }
  }
  class Pe extends Ke {
    constructor() {
      super(4);
    }
    execute(m) {
      m.popMode();
    }
    toString() {
      return "popMode";
    }
  }
  Pe.INSTANCE = new Pe();
  class Ge extends Ke {
    constructor(m) {
      super(2), this.mode = m;
    }
    execute(m) {
      m.mode(this.mode);
    }
    updateHashCode(m) {
      m.update(this.actionType, this.mode);
    }
    equals(m) {
      return this === m || m instanceof Ge && this.mode === m.mode;
    }
    toString() {
      return "mode(" + this.mode + ")";
    }
  }
  function Ve(ae, m) {
    const y = [];
    return y[ae - 1] = m, y.map(function(S) {
      return m;
    });
  }
  class ft {
    constructor(m) {
      m == null && (m = rt.defaultOptions), this.deserializationOptions = m, this.stateFactories = null, this.actionFactories = null;
    }
    deserialize(m) {
      const y = this.reset(m);
      this.checkVersion(y), y && this.skipUUID();
      const S = this.readATN();
      this.readStates(S, y), this.readRules(S, y), this.readModes(S);
      const F = [];
      return this.readSets(S, F, this.readInt.bind(this)), y && this.readSets(S, F, this.readInt32.bind(this)), this.readEdges(S, F), this.readDecisions(S), this.readLexerActions(S, y), this.markPrecedenceDecisions(S), this.verifyATN(S), this.deserializationOptions.generateRuleBypassTransitions && S.grammarType === 1 && (this.generateRuleBypassTransitions(S), this.verifyATN(S)), S;
    }
    reset(m) {
      if ((m.charCodeAt ? m.charCodeAt(0) : m[0]) === 3) {
        const y = function(F) {
          const z = F.charCodeAt(0);
          return z > 1 ? z - 2 : z + 65534;
        }, S = m.split("").map(y);
        return S[0] = m.charCodeAt(0), this.data = S, this.pos = 0, !0;
      }
      return this.data = m, this.pos = 0, !1;
    }
    skipUUID() {
      let m = 0;
      for (; m++ < 8; ) this.readInt();
    }
    checkVersion(m) {
      const y = this.readInt();
      if (!m && y !== 4) throw "Could not deserialize ATN with version " + y + " (expected 4).";
    }
    readATN() {
      const m = this.readInt(), y = this.readInt();
      return new he(m, y);
    }
    readStates(m, y) {
      let S, F, z;
      const J = [], fe = [], _e = this.readInt();
      for (let je = 0; je < _e; je++) {
        const Je = this.readInt();
        if (Je === x.INVALID_TYPE) {
          m.addState(null);
          continue;
        }
        let Ot = this.readInt();
        y && Ot === 65535 && (Ot = -1);
        const pt = this.stateFactory(Je, Ot);
        if (Je === x.LOOP_END) {
          const dn = this.readInt();
          J.push([pt, dn]);
        } else if (pt instanceof Se) {
          const dn = this.readInt();
          fe.push([pt, dn]);
        }
        m.addState(pt);
      }
      for (S = 0; S < J.length; S++) F = J[S], F[0].loopBackState = m.states[F[1]];
      for (S = 0; S < fe.length; S++) F = fe[S], F[0].endState = m.states[F[1]];
      let Fe = this.readInt();
      for (S = 0; S < Fe; S++) z = this.readInt(), m.states[z].nonGreedy = !0;
      let $e = this.readInt();
      for (S = 0; S < $e; S++) z = this.readInt(), m.states[z].isPrecedenceRule = !0;
    }
    readRules(m, y) {
      let S;
      const F = this.readInt();
      for (m.grammarType === 0 && (m.ruleToTokenType = Ve(F, 0)), m.ruleToStartState = Ve(F, 0), S = 0; S < F; S++) {
        const z = this.readInt();
        if (m.ruleToStartState[S] = m.states[z], m.grammarType === 0) {
          let J = this.readInt();
          y && J === 65535 && (J = t.EOF), m.ruleToTokenType[S] = J;
        }
      }
      for (m.ruleToStopState = Ve(F, 0), S = 0; S < m.states.length; S++) {
        const z = m.states[S];
        z instanceof E && (m.ruleToStopState[z.ruleIndex] = z, m.ruleToStartState[z.ruleIndex].stopState = z);
      }
    }
    readModes(m) {
      const y = this.readInt();
      for (let S = 0; S < y; S++) {
        let F = this.readInt();
        m.modeToStartState.push(m.states[F]);
      }
    }
    readSets(m, y, S) {
      const F = this.readInt();
      for (let z = 0; z < F; z++) {
        const J = new C();
        y.push(J);
        const fe = this.readInt();
        this.readInt() !== 0 && J.addOne(-1);
        for (let _e = 0; _e < fe; _e++) {
          const Fe = S(), $e = S();
          J.addRange(Fe, $e);
        }
      }
    }
    readEdges(m, y) {
      let S, F, z, J, fe;
      const _e = this.readInt();
      for (S = 0; S < _e; S++) {
        const Fe = this.readInt(), $e = this.readInt(), je = this.readInt(), Je = this.readInt(), Ot = this.readInt(), pt = this.readInt();
        J = this.edgeFactory(m, je, Fe, $e, Je, Ot, pt, y), m.states[Fe].addTransition(J);
      }
      for (S = 0; S < m.states.length; S++) for (z = m.states[S], F = 0; F < z.transitions.length; F++) {
        const Fe = z.transitions[F];
        if (!(Fe instanceof A)) continue;
        let $e = -1;
        m.ruleToStartState[Fe.target.ruleIndex].isPrecedenceRule && Fe.precedence === 0 && ($e = Fe.target.ruleIndex), J = new De(Fe.followState, $e), m.ruleToStopState[Fe.target.ruleIndex].addTransition(J);
      }
      for (S = 0; S < m.states.length; S++) {
        if (z = m.states[S], z instanceof Se) {
          if (z.endState === null || z.endState.startState !== null) throw "IllegalState";
          z.endState.startState = z;
        }
        if (z instanceof ie) for (F = 0; F < z.transitions.length; F++) fe = z.transitions[F].target, fe instanceof Me && (fe.loopBackState = z);
        else if (z instanceof me) for (F = 0; F < z.transitions.length; F++) fe = z.transitions[F].target, fe instanceof Ae && (fe.loopBackState = z);
      }
    }
    readDecisions(m) {
      const y = this.readInt();
      for (let S = 0; S < y; S++) {
        const F = this.readInt(), z = m.states[F];
        m.decisionToState.push(z), z.decision = S;
      }
    }
    readLexerActions(m, y) {
      if (m.grammarType === 0) {
        const S = this.readInt();
        m.lexerActions = Ve(S, null);
        for (let F = 0; F < S; F++) {
          const z = this.readInt();
          let J = this.readInt();
          y && J === 65535 && (J = -1);
          let fe = this.readInt();
          y && fe === 65535 && (fe = -1), m.lexerActions[F] = this.lexerActionFactory(z, J, fe);
        }
      }
    }
    generateRuleBypassTransitions(m) {
      let y;
      const S = m.ruleToStartState.length;
      for (y = 0; y < S; y++) m.ruleToTokenType[y] = m.maxTokenType + y + 1;
      for (y = 0; y < S; y++) this.generateRuleBypassTransition(m, y);
    }
    generateRuleBypassTransition(m, y) {
      let S, F;
      const z = new ee();
      z.ruleIndex = y, m.addState(z);
      const J = new V();
      J.ruleIndex = y, m.addState(J), z.endState = J, m.defineDecisionState(z), J.startState = z;
      let fe = null, _e = null;
      if (m.ruleToStartState[y].isPrecedenceRule) {
        for (_e = null, S = 0; S < m.states.length; S++) if (F = m.states[S], this.stateIsEndStateFor(F, y)) {
          _e = F, fe = F.loopBackState.transitions[0];
          break;
        }
        if (fe === null) throw "Couldn't identify final state of the precedence rule prefix section.";
      } else _e = m.ruleToStopState[y];
      for (S = 0; S < m.states.length; S++) {
        F = m.states[S];
        for (let Je = 0; Je < F.transitions.length; Je++) {
          const Ot = F.transitions[Je];
          Ot !== fe && Ot.target === _e && (Ot.target = J);
        }
      }
      const Fe = m.ruleToStartState[y], $e = Fe.transitions.length;
      for (; $e > 0; ) z.addTransition(Fe.transitions[$e - 1]), Fe.transitions = Fe.transitions.slice(-1);
      m.ruleToStartState[y].addTransition(new De(z)), J.addTransition(new De(_e));
      const je = new Ne();
      m.addState(je), je.addTransition(new ye(J, m.ruleToTokenType[y])), z.addTransition(new De(je));
    }
    stateIsEndStateFor(m, y) {
      if (m.ruleIndex !== y || !(m instanceof Ae)) return null;
      const S = m.transitions[m.transitions.length - 1].target;
      return S instanceof re && S.epsilonOnlyTransitions && S.transitions[0].target instanceof E ? m : null;
    }
    markPrecedenceDecisions(m) {
      for (let y = 0; y < m.states.length; y++) {
        const S = m.states[y];
        if (S instanceof Ae && m.ruleToStartState[S.ruleIndex].isPrecedenceRule) {
          const F = S.transitions[S.transitions.length - 1].target;
          F instanceof re && F.epsilonOnlyTransitions && F.transitions[0].target instanceof E && (S.isPrecedenceDecision = !0);
        }
      }
    }
    verifyATN(m) {
      if (this.deserializationOptions.verifyATN) for (let y = 0; y < m.states.length; y++) {
        const S = m.states[y];
        if (S !== null) if (this.checkCondition(S.epsilonOnlyTransitions || S.transitions.length <= 1), S instanceof Me) this.checkCondition(S.loopBackState !== null);
        else if (S instanceof Ae) if (this.checkCondition(S.loopBackState !== null), this.checkCondition(S.transitions.length === 2), S.transitions[0].target instanceof Q) this.checkCondition(S.transitions[1].target instanceof re), this.checkCondition(!S.nonGreedy);
        else {
          if (!(S.transitions[0].target instanceof re)) throw "IllegalState";
          this.checkCondition(S.transitions[1].target instanceof Q), this.checkCondition(S.nonGreedy);
        }
        else S instanceof me ? (this.checkCondition(S.transitions.length === 1), this.checkCondition(S.transitions[0].target instanceof Ae)) : S instanceof re ? this.checkCondition(S.loopBackState !== null) : S instanceof pe ? this.checkCondition(S.stopState !== null) : S instanceof Se ? this.checkCondition(S.endState !== null) : S instanceof V ? this.checkCondition(S.startState !== null) : S instanceof we ? this.checkCondition(S.transitions.length <= 1 || S.decision >= 0) : this.checkCondition(S.transitions.length <= 1 || S instanceof E);
      }
    }
    checkCondition(m, y) {
      if (!m) throw y == null && (y = "IllegalState"), y;
    }
    readInt() {
      return this.data[this.pos++];
    }
    readInt32() {
      return this.readInt() | this.readInt() << 16;
    }
    edgeFactory(m, y, S, F, z, J, fe, _e) {
      const Fe = m.states[F];
      switch (y) {
        case D.EPSILON:
          return new De(Fe);
        case D.RANGE:
          return new Ee(Fe, fe !== 0 ? t.EOF : z, J);
        case D.RULE:
          return new A(m.states[z], J, fe, Fe);
        case D.PREDICATE:
          return new Be(Fe, z, J, fe !== 0);
        case D.PRECEDENCE:
          return new Re(Fe, z);
        case D.ATOM:
          return new ye(Fe, fe !== 0 ? t.EOF : z);
        case D.ACTION:
          return new Ce(Fe, z, J, fe !== 0);
        case D.SET:
          return new M(Fe, _e[z]);
        case D.NOT_SET:
          return new _(Fe, _e[z]);
        case D.WILDCARD:
          return new O(Fe);
        default:
          throw "The specified transition type: " + y + " is not valid.";
      }
    }
    stateFactory(m, y) {
      if (this.stateFactories === null) {
        const S = [];
        S[x.INVALID_TYPE] = null, S[x.BASIC] = () => new Ne(), S[x.RULE_START] = () => new pe(), S[x.BLOCK_START] = () => new ee(), S[x.PLUS_BLOCK_START] = () => new Me(), S[x.STAR_BLOCK_START] = () => new Q(), S[x.TOKEN_START] = () => new X(), S[x.RULE_STOP] = () => new E(), S[x.BLOCK_END] = () => new V(), S[x.STAR_LOOP_BACK] = () => new me(), S[x.STAR_LOOP_ENTRY] = () => new Ae(), S[x.PLUS_LOOP_BACK] = () => new ie(), S[x.LOOP_END] = () => new re(), this.stateFactories = S;
      }
      if (m > this.stateFactories.length || this.stateFactories[m] === null) throw "The specified state type " + m + " is not valid.";
      {
        const S = this.stateFactories[m]();
        if (S !== null) return S.ruleIndex = y, S;
      }
    }
    lexerActionFactory(m, y, S) {
      if (this.actionFactories === null) {
        const F = [];
        F[0] = (z, J) => new Ie(z), F[1] = (z, J) => new B(z, J), F[2] = (z, J) => new Ge(z), F[3] = (z, J) => ne.INSTANCE, F[4] = (z, J) => Pe.INSTANCE, F[5] = (z, J) => new Te(z), F[6] = (z, J) => Ze.INSTANCE, F[7] = (z, J) => new xe(z), this.actionFactories = F;
      }
      if (m > this.actionFactories.length || this.actionFactories[m] === null) throw "The specified lexer action type " + m + " is not valid.";
      return this.actionFactories[m](y, S);
    }
  }
  class lt {
    syntaxError(m, y, S, F, z, J) {
    }
    reportAmbiguity(m, y, S, F, z, J, fe) {
    }
    reportAttemptingFullContext(m, y, S, F, z, J) {
    }
    reportContextSensitivity(m, y, S, F, z, J) {
    }
  }
  class Nr extends lt {
    constructor() {
      super();
    }
    syntaxError(m, y, S, F, z, J) {
      console.error("line " + S + ":" + F + " " + z);
    }
  }
  Nr.INSTANCE = new Nr();
  class Ur extends lt {
    constructor(m) {
      if (super(), m === null) throw "delegates";
      return this.delegates = m, this;
    }
    syntaxError(m, y, S, F, z, J) {
      this.delegates.map((fe) => fe.syntaxError(m, y, S, F, z, J));
    }
    reportAmbiguity(m, y, S, F, z, J, fe) {
      this.delegates.map((_e) => _e.reportAmbiguity(m, y, S, F, z, J, fe));
    }
    reportAttemptingFullContext(m, y, S, F, z, J) {
      this.delegates.map((fe) => fe.reportAttemptingFullContext(m, y, S, F, z, J));
    }
    reportContextSensitivity(m, y, S, F, z, J) {
      this.delegates.map((fe) => fe.reportContextSensitivity(m, y, S, F, z, J));
    }
  }
  class An {
    constructor() {
      this._listeners = [Nr.INSTANCE], this._interp = null, this._stateNumber = -1;
    }
    checkVersion(m) {
      const y = "4.13.1";
      y !== m && console.log("ANTLR runtime and generated code versions disagree: " + y + "!=" + m);
    }
    addErrorListener(m) {
      this._listeners.push(m);
    }
    removeErrorListeners() {
      this._listeners = [];
    }
    getLiteralNames() {
      return Object.getPrototypeOf(this).constructor.literalNames || [];
    }
    getSymbolicNames() {
      return Object.getPrototypeOf(this).constructor.symbolicNames || [];
    }
    getTokenNames() {
      if (!this.tokenNames) {
        const m = this.getLiteralNames(), y = this.getSymbolicNames(), S = m.length > y.length ? m.length : y.length;
        this.tokenNames = [];
        for (let F = 0; F < S; F++) this.tokenNames[F] = m[F] || y[F] || "<INVALID";
      }
      return this.tokenNames;
    }
    getTokenTypeMap() {
      const m = this.getTokenNames();
      if (m === null) throw "The current recognizer does not provide a list of token names.";
      let y = this.tokenTypeMapCache[m];
      return y === void 0 && (y = m.reduce(function(S, F, z) {
        S[F] = z;
      }), y.EOF = t.EOF, this.tokenTypeMapCache[m] = y), y;
    }
    getRuleIndexMap() {
      const m = this.ruleNames;
      if (m === null) throw "The current recognizer does not provide a list of rule names.";
      let y = this.ruleIndexMapCache[m];
      return y === void 0 && (y = m.reduce(function(S, F, z) {
        S[F] = z;
      }), this.ruleIndexMapCache[m] = y), y;
    }
    getTokenType(m) {
      const y = this.getTokenTypeMap()[m];
      return y !== void 0 ? y : t.INVALID_TYPE;
    }
    getErrorHeader(m) {
      return "line " + m.getOffendingToken().line + ":" + m.getOffendingToken().column;
    }
    getTokenErrorDisplay(m) {
      if (m === null) return "<no token>";
      let y = m.text;
      return y === null && (y = m.type === t.EOF ? "<EOF>" : "<" + m.type + ">"), y = y.replace(`
`, "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + y + "'";
    }
    getErrorListenerDispatch() {
      return new Ur(this._listeners);
    }
    sempred(m, y, S) {
      return !0;
    }
    precpred(m, y) {
      return !0;
    }
    get atn() {
      return this._interp.atn;
    }
    get state() {
      return this._stateNumber;
    }
    set state(m) {
      this._stateNumber = m;
    }
  }
  An.tokenTypeMapCache = {}, An.ruleIndexMapCache = {};
  class Or extends t {
    constructor(m, y, S, F, z) {
      super(), this.source = m !== void 0 ? m : Or.EMPTY_SOURCE, this.type = y !== void 0 ? y : null, this.channel = S !== void 0 ? S : t.DEFAULT_CHANNEL, this.start = F !== void 0 ? F : -1, this.stop = z !== void 0 ? z : -1, this.tokenIndex = -1, this.source[0] !== null ? (this.line = m[0].line, this.column = m[0].column) : this.column = -1;
    }
    clone() {
      const m = new Or(this.source, this.type, this.channel, this.start, this.stop);
      return m.tokenIndex = this.tokenIndex, m.line = this.line, m.column = this.column, m.text = this.text, m;
    }
    cloneWithType(m) {
      const y = new Or(this.source, m, this.channel, this.start, this.stop);
      return y.tokenIndex = this.tokenIndex, y.line = this.line, y.column = this.column, m === t.EOF && (y.text = ""), y;
    }
    toString() {
      let m = this.text;
      return m = m !== null ? m.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t") : "<no text>", "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + m + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
    }
    get text() {
      if (this._text !== null) return this._text;
      const m = this.getInputStream();
      if (m === null) return null;
      const y = m.size;
      return this.start < y && this.stop < y ? m.getText(this.start, this.stop) : "<EOF>";
    }
    set text(m) {
      this._text = m;
    }
  }
  Or.EMPTY_SOURCE = [null, null];
  class Aa {
  }
  class fr extends Aa {
    constructor(m) {
      super(), this.copyText = m !== void 0 && m;
    }
    create(m, y, S, F, z, J, fe, _e) {
      const Fe = new Or(m, y, F, z, J);
      return Fe.line = fe, Fe.column = _e, S !== null ? Fe.text = S : this.copyText && m[1] !== null && (Fe.text = m[1].getText(z, J)), Fe;
    }
    createThin(m, y) {
      const S = new Or(null, m);
      return S.text = y, S;
    }
  }
  fr.DEFAULT = new fr();
  class Fr extends Error {
    constructor(m) {
      super(m.message), Error.captureStackTrace && Error.captureStackTrace(this, Fr), this.message = m.message, this.recognizer = m.recognizer, this.input = m.input, this.ctx = m.ctx, this.offendingToken = null, this.offendingState = -1, this.recognizer !== null && (this.offendingState = this.recognizer.state);
    }
    getExpectedTokens() {
      return this.recognizer !== null ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
    }
    toString() {
      return this.message;
    }
  }
  class Dr extends Fr {
    constructor(m, y, S, F) {
      super({ message: "", recognizer: m, input: y, ctx: null }), this.startIndex = S, this.deadEndConfigs = F;
    }
    toString() {
      let m = "";
      return this.startIndex >= 0 && this.startIndex < this.input.size && (m = this.input.getText(new b(this.startIndex, this.startIndex))), "LexerNoViableAltException" + m;
    }
  }
  class Zt extends An {
    constructor(m) {
      super(), this._input = m, this._factory = fr.DEFAULT, this._tokenFactorySourcePair = [this, m], this._interp = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = !1, this._channel = t.DEFAULT_CHANNEL, this._type = t.INVALID_TYPE, this._modeStack = [], this._mode = Zt.DEFAULT_MODE, this._text = null;
    }
    reset() {
      this._input !== null && this._input.seek(0), this._token = null, this._type = t.INVALID_TYPE, this._channel = t.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = !1, this._mode = Zt.DEFAULT_MODE, this._modeStack = [], this._interp.reset();
    }
    nextToken() {
      if (this._input === null) throw "nextToken requires a non-null input stream.";
      const m = this._input.mark();
      try {
        for (; ; ) {
          if (this._hitEOF) return this.emitEOF(), this._token;
          this._token = null, this._channel = t.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this._interp.column, this._tokenStartLine = this._interp.line, this._text = null;
          let y = !1;
          for (; ; ) {
            this._type = t.INVALID_TYPE;
            let S = Zt.SKIP;
            try {
              S = this._interp.match(this._input, this._mode);
            } catch (F) {
              if (!(F instanceof Fr)) throw console.log(F.stack), F;
              this.notifyListeners(F), this.recover(F);
            }
            if (this._input.LA(1) === t.EOF && (this._hitEOF = !0), this._type === t.INVALID_TYPE && (this._type = S), this._type === Zt.SKIP) {
              y = !0;
              break;
            }
            if (this._type !== Zt.MORE) break;
          }
          if (!y) return this._token === null && this.emit(), this._token;
        }
      } finally {
        this._input.release(m);
      }
    }
    skip() {
      this._type = Zt.SKIP;
    }
    more() {
      this._type = Zt.MORE;
    }
    mode(m) {
      this._mode = m;
    }
    pushMode(m) {
      this._interp.debug && console.log("pushMode " + m), this._modeStack.push(this._mode), this.mode(m);
    }
    popMode() {
      if (this._modeStack.length === 0) throw "Empty Stack";
      return this._interp.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.mode(this._modeStack.pop()), this._mode;
    }
    emitToken(m) {
      this._token = m;
    }
    emit() {
      const m = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
      return this.emitToken(m), m;
    }
    emitEOF() {
      const m = this.column, y = this.line, S = this._factory.create(this._tokenFactorySourcePair, t.EOF, null, t.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, y, m);
      return this.emitToken(S), S;
    }
    getCharIndex() {
      return this._input.index;
    }
    getAllTokens() {
      const m = [];
      let y = this.nextToken();
      for (; y.type !== t.EOF; ) m.push(y), y = this.nextToken();
      return m;
    }
    notifyListeners(m) {
      const y = this._tokenStartCharIndex, S = this._input.index, F = this._input.getText(y, S), z = "token recognition error at: '" + this.getErrorDisplay(F) + "'";
      this.getErrorListenerDispatch().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, z, m);
    }
    getErrorDisplay(m) {
      const y = [];
      for (let S = 0; S < m.length; S++) y.push(m[S]);
      return y.join("");
    }
    getErrorDisplayForChar(m) {
      return m.charCodeAt(0) === t.EOF ? "<EOF>" : m === `
` ? "\\n" : m === "	" ? "\\t" : m === "\r" ? "\\r" : m;
    }
    getCharErrorDisplay(m) {
      return "'" + this.getErrorDisplayForChar(m) + "'";
    }
    recover(m) {
      this._input.LA(1) !== t.EOF && (m instanceof Dr ? this._interp.consume(this._input) : this._input.consume());
    }
    get inputStream() {
      return this._input;
    }
    set inputStream(m) {
      this._input = null, this._tokenFactorySourcePair = [this, this._input], this.reset(), this._input = m, this._tokenFactorySourcePair = [this, this._input];
    }
    get sourceName() {
      return this._input.sourceName;
    }
    get type() {
      return this._type;
    }
    set type(m) {
      this._type = m;
    }
    get line() {
      return this._interp.line;
    }
    set line(m) {
      this._interp.line = m;
    }
    get column() {
      return this._interp.column;
    }
    set column(m) {
      this._interp.column = m;
    }
    get text() {
      return this._text !== null ? this._text : this._interp.getText(this._input);
    }
    set text(m) {
      this._text = m;
    }
  }
  function pr(ae) {
    return ae.hashCodeForConfigSet();
  }
  function Ji(ae, m) {
    return ae === m || ae !== null && m !== null && ae.equalsForConfigSet(m);
  }
  Zt.DEFAULT_MODE = 0, Zt.MORE = -2, Zt.SKIP = -3, Zt.DEFAULT_TOKEN_CHANNEL = t.DEFAULT_CHANNEL, Zt.HIDDEN = t.HIDDEN_CHANNEL, Zt.MIN_CHAR_VALUE = 0, Zt.MAX_CHAR_VALUE = 1114111;
  class Kt {
    constructor(m) {
      this.configLookup = new l(pr, Ji), this.fullCtx = m === void 0 || m, this.readOnly = !1, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = !1, this.dipsIntoOuterContext = !1, this.cachedHashCode = -1;
    }
    add(m, y) {
      if (y === void 0 && (y = null), this.readOnly) throw "This set is readonly";
      m.semanticContext !== c.NONE && (this.hasSemanticContext = !0), m.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = !0);
      const S = this.configLookup.add(m);
      if (S === m) return this.cachedHashCode = -1, this.configs.push(m), !0;
      const F = !this.fullCtx, z = de(S.context, m.context, F, y);
      return S.reachesIntoOuterContext = Math.max(S.reachesIntoOuterContext, m.reachesIntoOuterContext), m.precedenceFilterSuppressed && (S.precedenceFilterSuppressed = !0), S.context = z, !0;
    }
    getStates() {
      const m = new l();
      for (let y = 0; y < this.configs.length; y++) m.add(this.configs[y].state);
      return m;
    }
    getPredicates() {
      const m = [];
      for (let y = 0; y < this.configs.length; y++) {
        const S = this.configs[y].semanticContext;
        S !== c.NONE && m.push(S.semanticContext);
      }
      return m;
    }
    optimizeConfigs(m) {
      if (this.readOnly) throw "This set is readonly";
      if (this.configLookup.length !== 0) for (let y = 0; y < this.configs.length; y++) {
        const S = this.configs[y];
        S.context = m.getCachedContext(S.context);
      }
    }
    addAll(m) {
      for (let y = 0; y < m.length; y++) this.add(m[y]);
      return !1;
    }
    equals(m) {
      return this === m || m instanceof Kt && e(this.configs, m.configs) && this.fullCtx === m.fullCtx && this.uniqueAlt === m.uniqueAlt && this.conflictingAlts === m.conflictingAlts && this.hasSemanticContext === m.hasSemanticContext && this.dipsIntoOuterContext === m.dipsIntoOuterContext;
    }
    hashCode() {
      const m = new a();
      return m.update(this.configs), m.finish();
    }
    updateHashCode(m) {
      this.readOnly ? (this.cachedHashCode === -1 && (this.cachedHashCode = this.hashCode()), m.update(this.cachedHashCode)) : m.update(this.hashCode());
    }
    isEmpty() {
      return this.configs.length === 0;
    }
    contains(m) {
      if (this.configLookup === null) throw "This method is not implemented for readonly sets.";
      return this.configLookup.contains(m);
    }
    containsFast(m) {
      if (this.configLookup === null) throw "This method is not implemented for readonly sets.";
      return this.configLookup.containsFast(m);
    }
    clear() {
      if (this.readOnly) throw "This set is readonly";
      this.configs = [], this.cachedHashCode = -1, this.configLookup = new l();
    }
    setReadonly(m) {
      this.readOnly = m, m && (this.configLookup = null);
    }
    toString() {
      return u(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== he.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
    }
    get items() {
      return this.configs;
    }
    get length() {
      return this.configs.length;
    }
  }
  class sr {
    constructor(m, y) {
      return m === null && (m = -1), y === null && (y = new Kt()), this.stateNumber = m, this.configs = y, this.edges = null, this.isAcceptState = !1, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = !1, this.predicates = null, this;
    }
    getAltSet() {
      const m = new l();
      if (this.configs !== null) for (let y = 0; y < this.configs.length; y++) {
        const S = this.configs[y];
        m.add(S.alt);
      }
      return m.length === 0 ? null : m;
    }
    equals(m) {
      return this === m || m instanceof sr && this.configs.equals(m.configs);
    }
    toString() {
      let m = this.stateNumber + ":" + this.configs;
      return this.isAcceptState && (m += "=>", this.predicates !== null ? m += this.predicates : m += this.prediction), m;
    }
    hashCode() {
      const m = new a();
      return m.update(this.configs), m.finish();
    }
  }
  class Ar {
    constructor(m, y) {
      return this.atn = m, this.sharedContextCache = y, this;
    }
    getCachedContext(m) {
      if (this.sharedContextCache === null) return m;
      const y = new be();
      return ce(m, this.sharedContextCache, y);
    }
  }
  Ar.ERROR = new sr(2147483647, new Kt());
  class En extends Kt {
    constructor() {
      super(), this.configLookup = new l();
    }
  }
  class er extends N {
    constructor(m, y) {
      super(m, y);
      const S = m.lexerActionExecutor || null;
      return this.lexerActionExecutor = S || (y !== null ? y.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = y !== null && this.checkNonGreedyDecision(y, this.state), this.hashCodeForConfigSet = er.prototype.hashCode, this.equalsForConfigSet = er.prototype.equals, this;
    }
    updateHashCode(m) {
      m.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
    }
    equals(m) {
      return this === m || m instanceof er && this.passedThroughNonGreedyDecision === m.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(m.lexerActionExecutor) : !m.lexerActionExecutor) && super.equals(m);
    }
    checkNonGreedyDecision(m, y) {
      return m.passedThroughNonGreedyDecision || y instanceof we && y.nonGreedy;
    }
  }
  class ii extends Ke {
    constructor(m, y) {
      super(y.actionType), this.offset = m, this.action = y, this.isPositionDependent = !0;
    }
    execute(m) {
      this.action.execute(m);
    }
    updateHashCode(m) {
      m.update(this.actionType, this.offset, this.action);
    }
    equals(m) {
      return this === m || m instanceof ii && this.offset === m.offset && this.action === m.action;
    }
  }
  class Yr {
    constructor(m) {
      return this.lexerActions = m === null ? [] : m, this.cachedHashCode = a.hashStuff(m), this;
    }
    fixOffsetBeforeMatch(m) {
      let y = null;
      for (let S = 0; S < this.lexerActions.length; S++) !this.lexerActions[S].isPositionDependent || this.lexerActions[S] instanceof ii || (y === null && (y = this.lexerActions.concat([])), y[S] = new ii(m, this.lexerActions[S]));
      return y === null ? this : new Yr(y);
    }
    execute(m, y, S) {
      let F = !1;
      const z = y.index;
      try {
        for (let J = 0; J < this.lexerActions.length; J++) {
          let fe = this.lexerActions[J];
          if (fe instanceof ii) {
            const _e = fe.offset;
            y.seek(S + _e), fe = fe.action, F = S + _e !== z;
          } else fe.isPositionDependent && (y.seek(z), F = !1);
          fe.execute(m);
        }
      } finally {
        F && y.seek(z);
      }
    }
    hashCode() {
      return this.cachedHashCode;
    }
    updateHashCode(m) {
      m.update(this.cachedHashCode);
    }
    equals(m) {
      if (this === m) return !0;
      if (m instanceof Yr) {
        if (this.cachedHashCode != m.cachedHashCode || this.lexerActions.length != m.lexerActions.length) return !1;
        {
          const y = this.lexerActions.length;
          for (let S = 0; S < y; ++S) if (!this.lexerActions[S].equals(m.lexerActions[S])) return !1;
          return !0;
        }
      }
      return !1;
    }
    static append(m, y) {
      if (m === null) return new Yr([y]);
      const S = m.lexerActions.concat([y]);
      return new Yr(S);
    }
  }
  function Yi(ae) {
    ae.index = -1, ae.line = 0, ae.column = -1, ae.dfaState = null;
  }
  class bs {
    constructor() {
      Yi(this);
    }
    reset() {
      Yi(this);
    }
  }
  class It extends Ar {
    constructor(m, y, S, F) {
      super(y, F), this.decisionToDFA = S, this.recog = m, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Zt.DEFAULT_MODE, this.prevAccept = new bs();
    }
    copyState(m) {
      this.column = m.column, this.line = m.line, this.mode = m.mode, this.startIndex = m.startIndex;
    }
    match(m, y) {
      this.mode = y;
      const S = m.mark();
      try {
        this.startIndex = m.index, this.prevAccept.reset();
        const F = this.decisionToDFA[y];
        return F.s0 === null ? this.matchATN(m) : this.execATN(m, F.s0);
      } finally {
        m.release(S);
      }
    }
    reset() {
      this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Zt.DEFAULT_MODE;
    }
    matchATN(m) {
      const y = this.atn.modeToStartState[this.mode];
      It.debug && console.log("matchATN mode " + this.mode + " start: " + y);
      const S = this.mode, F = this.computeStartState(m, y), z = F.hasSemanticContext;
      F.hasSemanticContext = !1;
      const J = this.addDFAState(F);
      z || (this.decisionToDFA[this.mode].s0 = J);
      const fe = this.execATN(m, J);
      return It.debug && console.log("DFA after matchATN: " + this.decisionToDFA[S].toLexerString()), fe;
    }
    execATN(m, y) {
      It.debug && console.log("start state closure=" + y.configs), y.isAcceptState && this.captureSimState(this.prevAccept, m, y);
      let S = m.LA(1), F = y;
      for (; ; ) {
        It.debug && console.log("execATN loop starting closure: " + F.configs);
        let z = this.getExistingTargetState(F, S);
        if (z === null && (z = this.computeTargetState(m, F, S)), z === Ar.ERROR || (S !== t.EOF && this.consume(m), z.isAcceptState && (this.captureSimState(this.prevAccept, m, z), S === t.EOF))) break;
        S = m.LA(1), F = z;
      }
      return this.failOrAccept(this.prevAccept, m, F.configs, S);
    }
    getExistingTargetState(m, y) {
      if (m.edges === null || y < It.MIN_DFA_EDGE || y > It.MAX_DFA_EDGE) return null;
      let S = m.edges[y - It.MIN_DFA_EDGE];
      return S === void 0 && (S = null), It.debug && S !== null && console.log("reuse state " + m.stateNumber + " edge to " + S.stateNumber), S;
    }
    computeTargetState(m, y, S) {
      const F = new En();
      return this.getReachableConfigSet(m, y.configs, F, S), F.items.length === 0 ? (F.hasSemanticContext || this.addDFAEdge(y, S, Ar.ERROR), Ar.ERROR) : this.addDFAEdge(y, S, null, F);
    }
    failOrAccept(m, y, S, F) {
      if (this.prevAccept.dfaState !== null) {
        const z = m.dfaState.lexerActionExecutor;
        return this.accept(y, z, this.startIndex, m.index, m.line, m.column), m.dfaState.prediction;
      }
      if (F === t.EOF && y.index === this.startIndex) return t.EOF;
      throw new Dr(this.recog, y, this.startIndex, S);
    }
    getReachableConfigSet(m, y, S, F) {
      let z = he.INVALID_ALT_NUMBER;
      for (let J = 0; J < y.items.length; J++) {
        const fe = y.items[J], _e = fe.alt === z;
        if (!_e || !fe.passedThroughNonGreedyDecision) {
          It.debug && console.log(`testing %s at %s
`, this.getTokenName(F), fe.toString(this.recog, !0));
          for (let Fe = 0; Fe < fe.state.transitions.length; Fe++) {
            const $e = fe.state.transitions[Fe], je = this.getReachableTarget($e, F);
            if (je !== null) {
              let Je = fe.lexerActionExecutor;
              Je !== null && (Je = Je.fixOffsetBeforeMatch(m.index - this.startIndex));
              const Ot = F === t.EOF, pt = new er({ state: je, lexerActionExecutor: Je }, fe);
              this.closure(m, pt, S, _e, !0, Ot) && (z = fe.alt);
            }
          }
        }
      }
    }
    accept(m, y, S, F, z, J) {
      It.debug && console.log(`ACTION %s
`, y), m.seek(F), this.line = z, this.column = J, y !== null && this.recog !== null && y.execute(this.recog, m, S);
    }
    getReachableTarget(m, y) {
      return m.matches(y, 0, Zt.MAX_CHAR_VALUE) ? m.target : null;
    }
    computeStartState(m, y) {
      const S = W.EMPTY, F = new En();
      for (let z = 0; z < y.transitions.length; z++) {
        const J = y.transitions[z].target, fe = new er({ state: J, alt: z + 1, context: S }, null);
        this.closure(m, fe, F, !1, !1, !1);
      }
      return F;
    }
    closure(m, y, S, F, z, J) {
      let fe = null;
      if (It.debug && console.log("closure(" + y.toString(this.recog, !0) + ")"), y.state instanceof E) {
        if (It.debug && (this.recog !== null ? console.log(`closure at %s rule stop %s
`, this.recog.ruleNames[y.state.ruleIndex], y) : console.log(`closure at rule stop %s
`, y)), y.context === null || y.context.hasEmptyPath()) {
          if (y.context === null || y.context.isEmpty()) return S.add(y), !0;
          S.add(new er({ state: y.state, context: W.EMPTY }, y)), F = !0;
        }
        if (y.context !== null && !y.context.isEmpty()) {
          for (let _e = 0; _e < y.context.length; _e++) if (y.context.getReturnState(_e) !== W.EMPTY_RETURN_STATE) {
            const Fe = y.context.getParent(_e), $e = this.atn.states[y.context.getReturnState(_e)];
            fe = new er({ state: $e, context: Fe }, y), F = this.closure(m, fe, S, F, z, J);
          }
        }
        return F;
      }
      y.state.epsilonOnlyTransitions || F && y.passedThroughNonGreedyDecision || S.add(y);
      for (let _e = 0; _e < y.state.transitions.length; _e++) {
        const Fe = y.state.transitions[_e];
        fe = this.getEpsilonTarget(m, y, Fe, S, z, J), fe !== null && (F = this.closure(m, fe, S, F, z, J));
      }
      return F;
    }
    getEpsilonTarget(m, y, S, F, z, J) {
      let fe = null;
      if (S.serializationType === D.RULE) {
        const _e = Z.create(y.context, S.followState.stateNumber);
        fe = new er({ state: S.target, context: _e }, y);
      } else {
        if (S.serializationType === D.PRECEDENCE) throw "Precedence predicates are not supported in lexers.";
        if (S.serializationType === D.PREDICATE) It.debug && console.log("EVAL rule " + S.ruleIndex + ":" + S.predIndex), F.hasSemanticContext = !0, this.evaluatePredicate(m, S.ruleIndex, S.predIndex, z) && (fe = new er({ state: S.target }, y));
        else if (S.serializationType === D.ACTION) if (y.context === null || y.context.hasEmptyPath()) {
          const _e = Yr.append(y.lexerActionExecutor, this.atn.lexerActions[S.actionIndex]);
          fe = new er({ state: S.target, lexerActionExecutor: _e }, y);
        } else fe = new er({ state: S.target }, y);
        else S.serializationType === D.EPSILON ? fe = new er({ state: S.target }, y) : S.serializationType !== D.ATOM && S.serializationType !== D.RANGE && S.serializationType !== D.SET || J && S.matches(t.EOF, 0, Zt.MAX_CHAR_VALUE) && (fe = new er({ state: S.target }, y));
      }
      return fe;
    }
    evaluatePredicate(m, y, S, F) {
      if (this.recog === null) return !0;
      if (!F) return this.recog.sempred(null, y, S);
      const z = this.column, J = this.line, fe = m.index, _e = m.mark();
      try {
        return this.consume(m), this.recog.sempred(null, y, S);
      } finally {
        this.column = z, this.line = J, m.seek(fe), m.release(_e);
      }
    }
    captureSimState(m, y, S) {
      m.index = y.index, m.line = this.line, m.column = this.column, m.dfaState = S;
    }
    addDFAEdge(m, y, S, F) {
      if (S === void 0 && (S = null), F === void 0 && (F = null), S === null && F !== null) {
        const z = F.hasSemanticContext;
        if (F.hasSemanticContext = !1, S = this.addDFAState(F), z) return S;
      }
      return y < It.MIN_DFA_EDGE || y > It.MAX_DFA_EDGE || (It.debug && console.log("EDGE " + m + " -> " + S + " upon " + y), m.edges === null && (m.edges = []), m.edges[y - It.MIN_DFA_EDGE] = S), S;
    }
    addDFAState(m) {
      const y = new sr(null, m);
      let S = null;
      for (let fe = 0; fe < m.items.length; fe++) {
        const _e = m.items[fe];
        if (_e.state instanceof E) {
          S = _e;
          break;
        }
      }
      S !== null && (y.isAcceptState = !0, y.lexerActionExecutor = S.lexerActionExecutor, y.prediction = this.atn.ruleToTokenType[S.state.ruleIndex]);
      const F = this.decisionToDFA[this.mode], z = F.states.get(y);
      if (z !== null) return z;
      const J = y;
      return J.stateNumber = F.states.length, m.setReadonly(!0), J.configs = m, F.states.add(J), J;
    }
    getDFA(m) {
      return this.decisionToDFA[m];
    }
    getText(m) {
      return m.getText(this.startIndex, m.index - 1);
    }
    consume(m) {
      m.LA(1) === 10 ? (this.line += 1, this.column = 0) : this.column += 1, m.consume();
    }
    getTokenName(m) {
      return m === -1 ? "EOF" : "'" + String.fromCharCode(m) + "'";
    }
  }
  It.debug = !1, It.dfa_debug = !1, It.MIN_DFA_EDGE = 0, It.MAX_DFA_EDGE = 127;
  class So {
    constructor(m, y) {
      this.alt = y, this.pred = m;
    }
    toString() {
      return "(" + this.pred + ", " + this.alt + ")";
    }
  }
  class Sm {
    constructor() {
      this.data = {};
    }
    get(m) {
      return this.data["k-" + m] || null;
    }
    set(m, y) {
      this.data["k-" + m] = y;
    }
    values() {
      return Object.keys(this.data).filter((m) => m.startsWith("k-")).map((m) => this.data[m], this);
    }
  }
  const Sn = { SLL: 0, LL: 1, LL_EXACT_AMBIG_DETECTION: 2, hasSLLConflictTerminatingPrediction: function(ae, m) {
    if (Sn.allConfigsInRuleStopStates(m)) return !0;
    if (ae === Sn.SLL && m.hasSemanticContext) {
      const S = new Kt();
      for (let F = 0; F < m.items.length; F++) {
        let z = m.items[F];
        z = new N({ semanticContext: c.NONE }, z), S.add(z);
      }
      m = S;
    }
    const y = Sn.getConflictingAltSubsets(m);
    return Sn.hasConflictingAltSet(y) && !Sn.hasStateAssociatedWithOneAlt(m);
  }, hasConfigInRuleStopState: function(ae) {
    for (let m = 0; m < ae.items.length; m++) if (ae.items[m].state instanceof E) return !0;
    return !1;
  }, allConfigsInRuleStopStates: function(ae) {
    for (let m = 0; m < ae.items.length; m++) if (!(ae.items[m].state instanceof E)) return !1;
    return !0;
  }, resolvesToJustOneViableAlt: function(ae) {
    return Sn.getSingleViableAlt(ae);
  }, allSubsetsConflict: function(ae) {
    return !Sn.hasNonConflictingAltSet(ae);
  }, hasNonConflictingAltSet: function(ae) {
    for (let m = 0; m < ae.length; m++) if (ae[m].length === 1) return !0;
    return !1;
  }, hasConflictingAltSet: function(ae) {
    for (let m = 0; m < ae.length; m++) if (ae[m].length > 1) return !0;
    return !1;
  }, allSubsetsEqual: function(ae) {
    let m = null;
    for (let y = 0; y < ae.length; y++) {
      const S = ae[y];
      if (m === null) m = S;
      else if (S !== m) return !1;
    }
    return !0;
  }, getUniqueAlt: function(ae) {
    const m = Sn.getAlts(ae);
    return m.length === 1 ? m.minValue() : he.INVALID_ALT_NUMBER;
  }, getAlts: function(ae) {
    const m = new ue();
    return ae.map(function(y) {
      m.or(y);
    }), m;
  }, getConflictingAltSubsets: function(ae) {
    const m = new be();
    return m.hashFunction = function(y) {
      a.hashStuff(y.state.stateNumber, y.context);
    }, m.equalsFunction = function(y, S) {
      return y.state.stateNumber === S.state.stateNumber && y.context.equals(S.context);
    }, ae.items.map(function(y) {
      let S = m.get(y);
      S === null && (S = new ue(), m.set(y, S)), S.add(y.alt);
    }), m.getValues();
  }, getStateToAltMap: function(ae) {
    const m = new Sm();
    return ae.items.map(function(y) {
      let S = m.get(y.state);
      S === null && (S = new ue(), m.set(y.state, S)), S.add(y.alt);
    }), m;
  }, hasStateAssociatedWithOneAlt: function(ae) {
    const m = Sn.getStateToAltMap(ae).values();
    for (let y = 0; y < m.length; y++) if (m[y].length === 1) return !0;
    return !1;
  }, getSingleViableAlt: function(ae) {
    let m = null;
    for (let y = 0; y < ae.length; y++) {
      const S = ae[y].minValue();
      if (m === null) m = S;
      else if (m !== S) return he.INVALID_ALT_NUMBER;
    }
    return m;
  } }, tr = Sn;
  class Pt extends Fr {
    constructor(m, y, S, F, z, J) {
      J = J || m._ctx, F = F || m.getCurrentToken(), S = S || m.getCurrentToken(), y = y || m.getInputStream(), super({ message: "", recognizer: m, input: y, ctx: J }), this.deadEndConfigs = z, this.startToken = S, this.offendingToken = F;
    }
  }
  class Gr {
    constructor(m) {
      this.defaultMapCtor = m || be, this.cacheMap = new this.defaultMapCtor();
    }
    get(m, y) {
      const S = this.cacheMap.get(m) || null;
      return S === null ? null : S.get(y) || null;
    }
    set(m, y, S) {
      let F = this.cacheMap.get(m) || null;
      F === null && (F = new this.defaultMapCtor(), this.cacheMap.set(m, F)), F.set(y, S);
    }
  }
  class Co extends Ar {
    constructor(m, y, S, F) {
      super(y, F), this.parser = m, this.decisionToDFA = S, this.predictionMode = tr.LL, this._input = null, this._startIndex = 0, this._outerContext = null, this._dfa = null, this.mergeCache = null, this.debug = !1, this.debug_closure = !1, this.debug_add = !1, this.trace_atn_sim = !1, this.dfa_debug = !1, this.retry_debug = !1;
    }
    reset() {
    }
    adaptivePredict(m, y, S) {
      (this.debug || this.trace_atn_sim) && console.log("adaptivePredict decision " + y + " exec LA(1)==" + this.getLookaheadName(m) + " line " + m.LT(1).line + ":" + m.LT(1).column), this._input = m, this._startIndex = m.index, this._outerContext = S;
      const F = this.decisionToDFA[y];
      this._dfa = F;
      const z = m.mark(), J = m.index;
      try {
        let fe;
        if (fe = F.precedenceDfa ? F.getPrecedenceStartState(this.parser.getPrecedence()) : F.s0, fe === null) {
          S === null && (S = P.EMPTY), this.debug && console.log("predictATN decision " + F.decision + " exec LA(1)==" + this.getLookaheadName(m) + ", outerContext=" + S.toString(this.parser.ruleNames));
          let $e = this.computeStartState(F.atnStartState, P.EMPTY, !1);
          F.precedenceDfa ? (F.s0.configs = $e, $e = this.applyPrecedenceFilter($e), fe = this.addDFAState(F, new sr(null, $e)), F.setPrecedenceStartState(this.parser.getPrecedence(), fe)) : (fe = this.addDFAState(F, new sr(null, $e)), F.s0 = fe);
        }
        const _e = this.execATN(F, fe, m, J, S);
        return this.debug && console.log("DFA after predictATN: " + F.toString(this.parser.literalNames, this.parser.symbolicNames)), _e;
      } finally {
        this._dfa = null, this.mergeCache = null, m.seek(J), m.release(z);
      }
    }
    execATN(m, y, S, F, z) {
      let J;
      (this.debug || this.trace_atn_sim) && console.log("execATN decision " + m.decision + ", DFA state " + y + ", LA(1)==" + this.getLookaheadName(S) + " line " + S.LT(1).line + ":" + S.LT(1).column);
      let fe = y;
      this.debug && console.log("s0 = " + y);
      let _e = S.LA(1);
      for (; ; ) {
        let Fe = this.getExistingTargetState(fe, _e);
        if (Fe === null && (Fe = this.computeTargetState(m, fe, _e)), Fe === Ar.ERROR) {
          const $e = this.noViableAlt(S, z, fe.configs, F);
          if (S.seek(F), J = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(fe.configs, z), J !== he.INVALID_ALT_NUMBER) return J;
          throw $e;
        }
        if (Fe.requiresFullContext && this.predictionMode !== tr.SLL) {
          let $e = null;
          if (Fe.predicates !== null) {
            this.debug && console.log("DFA state has preds in DFA sim LL failover");
            const Ot = S.index;
            if (Ot !== F && S.seek(F), $e = this.evalSemanticContext(Fe.predicates, z, !0), $e.length === 1) return this.debug && console.log("Full LL avoided"), $e.minValue();
            Ot !== F && S.seek(Ot);
          }
          this.dfa_debug && console.log("ctx sensitive state " + z + " in " + Fe);
          const je = !0, Je = this.computeStartState(m.atnStartState, z, je);
          return this.reportAttemptingFullContext(m, $e, Fe.configs, F, S.index), J = this.execATNWithFullContext(m, Fe, Je, S, F, z), J;
        }
        if (Fe.isAcceptState) {
          if (Fe.predicates === null) return Fe.prediction;
          const $e = S.index;
          S.seek(F);
          const je = this.evalSemanticContext(Fe.predicates, z, !0);
          if (je.length === 0) throw this.noViableAlt(S, z, Fe.configs, F);
          return je.length === 1 || this.reportAmbiguity(m, Fe, F, $e, !1, je, Fe.configs), je.minValue();
        }
        fe = Fe, _e !== t.EOF && (S.consume(), _e = S.LA(1));
      }
    }
    getExistingTargetState(m, y) {
      const S = m.edges;
      return S === null ? null : S[y + 1] || null;
    }
    computeTargetState(m, y, S) {
      const F = this.computeReachSet(y.configs, S, !1);
      if (F === null) return this.addDFAEdge(m, y, S, Ar.ERROR), Ar.ERROR;
      let z = new sr(null, F);
      const J = this.getUniqueAlt(F);
      if (this.debug) {
        const fe = tr.getConflictingAltSubsets(F);
        console.log("SLL altSubSets=" + u(fe) + ", configs=" + F + ", predict=" + J + ", allSubsetsConflict=" + tr.allSubsetsConflict(fe) + ", conflictingAlts=" + this.getConflictingAlts(F));
      }
      return J !== he.INVALID_ALT_NUMBER ? (z.isAcceptState = !0, z.configs.uniqueAlt = J, z.prediction = J) : tr.hasSLLConflictTerminatingPrediction(this.predictionMode, F) && (z.configs.conflictingAlts = this.getConflictingAlts(F), z.requiresFullContext = !0, z.isAcceptState = !0, z.prediction = z.configs.conflictingAlts.minValue()), z.isAcceptState && z.configs.hasSemanticContext && (this.predicateDFAState(z, this.atn.getDecisionState(m.decision)), z.predicates !== null && (z.prediction = he.INVALID_ALT_NUMBER)), z = this.addDFAEdge(m, y, S, z), z;
    }
    predicateDFAState(m, y) {
      const S = y.transitions.length, F = this.getConflictingAltsOrUniqueAlt(m.configs), z = this.getPredsForAmbigAlts(F, m.configs, S);
      z !== null ? (m.predicates = this.getPredicatePredictions(F, z), m.prediction = he.INVALID_ALT_NUMBER) : m.prediction = F.minValue();
    }
    execATNWithFullContext(m, y, S, F, z, J) {
      (this.debug || this.trace_atn_sim) && console.log("execATNWithFullContext " + S);
      let fe, _e = !1, Fe = S;
      F.seek(z);
      let $e = F.LA(1), je = -1;
      for (; ; ) {
        if (fe = this.computeReachSet(Fe, $e, !0), fe === null) {
          const Ot = this.noViableAlt(F, J, Fe, z);
          F.seek(z);
          const pt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(Fe, J);
          if (pt !== he.INVALID_ALT_NUMBER) return pt;
          throw Ot;
        }
        const Je = tr.getConflictingAltSubsets(fe);
        if (this.debug && console.log("LL altSubSets=" + Je + ", predict=" + tr.getUniqueAlt(Je) + ", resolvesToJustOneViableAlt=" + tr.resolvesToJustOneViableAlt(Je)), fe.uniqueAlt = this.getUniqueAlt(fe), fe.uniqueAlt !== he.INVALID_ALT_NUMBER) {
          je = fe.uniqueAlt;
          break;
        }
        if (this.predictionMode !== tr.LL_EXACT_AMBIG_DETECTION) {
          if (je = tr.resolvesToJustOneViableAlt(Je), je !== he.INVALID_ALT_NUMBER) break;
        } else if (tr.allSubsetsConflict(Je) && tr.allSubsetsEqual(Je)) {
          _e = !0, je = tr.getSingleViableAlt(Je);
          break;
        }
        Fe = fe, $e !== t.EOF && (F.consume(), $e = F.LA(1));
      }
      return fe.uniqueAlt !== he.INVALID_ALT_NUMBER ? (this.reportContextSensitivity(m, je, fe, z, F.index), je) : (this.reportAmbiguity(m, y, z, F.index, _e, null, fe), je);
    }
    computeReachSet(m, y, S) {
      this.debug && console.log("in computeReachSet, starting closure: " + m), this.mergeCache === null && (this.mergeCache = new Gr());
      const F = new Kt(S);
      let z = null;
      for (let fe = 0; fe < m.items.length; fe++) {
        const _e = m.items[fe];
        if (this.debug && console.log("testing " + this.getTokenName(y) + " at " + _e), _e.state instanceof E) (S || y === t.EOF) && (z === null && (z = []), z.push(_e), this.debug_add && console.log("added " + _e + " to skippedStopStates"));
        else for (let Fe = 0; Fe < _e.state.transitions.length; Fe++) {
          const $e = _e.state.transitions[Fe], je = this.getReachableTarget($e, y);
          if (je !== null) {
            const Je = new N({ state: je }, _e);
            F.add(Je, this.mergeCache), this.debug_add && console.log("added " + Je + " to intermediate");
          }
        }
      }
      let J = null;
      if (z === null && y !== t.EOF && (F.items.length === 1 || this.getUniqueAlt(F) !== he.INVALID_ALT_NUMBER) && (J = F), J === null) {
        J = new Kt(S);
        const fe = new l(), _e = y === t.EOF;
        for (let Fe = 0; Fe < F.items.length; Fe++) this.closure(F.items[Fe], J, fe, !1, S, _e);
      }
      if (y === t.EOF && (J = this.removeAllConfigsNotInRuleStopState(J, J === F)), !(z === null || S && tr.hasConfigInRuleStopState(J))) for (let fe = 0; fe < z.length; fe++) J.add(z[fe], this.mergeCache);
      return this.trace_atn_sim && console.log("computeReachSet " + m + " -> " + J), J.items.length === 0 ? null : J;
    }
    removeAllConfigsNotInRuleStopState(m, y) {
      if (tr.allConfigsInRuleStopStates(m)) return m;
      const S = new Kt(m.fullCtx);
      for (let F = 0; F < m.items.length; F++) {
        const z = m.items[F];
        if (z.state instanceof E) S.add(z, this.mergeCache);
        else if (y && z.state.epsilonOnlyTransitions && this.atn.nextTokens(z.state).contains(t.EPSILON)) {
          const J = this.atn.ruleToStopState[z.state.ruleIndex];
          S.add(new N({ state: J }, z), this.mergeCache);
        }
      }
      return S;
    }
    computeStartState(m, y, S) {
      const F = K(this.atn, y), z = new Kt(S);
      this.trace_atn_sim && console.log("computeStartState from ATN state " + m + " initialContext=" + F.toString(this.parser));
      for (let J = 0; J < m.transitions.length; J++) {
        const fe = m.transitions[J].target, _e = new N({ state: fe, alt: J + 1, context: F }, null), Fe = new l();
        this.closure(_e, z, Fe, !0, S, !1);
      }
      return z;
    }
    applyPrecedenceFilter(m) {
      let y;
      const S = [], F = new Kt(m.fullCtx);
      for (let z = 0; z < m.items.length; z++) {
        if (y = m.items[z], y.alt !== 1) continue;
        const J = y.semanticContext.evalPrecedence(this.parser, this._outerContext);
        J !== null && (S[y.state.stateNumber] = y.context, J !== y.semanticContext ? F.add(new N({ semanticContext: J }, y), this.mergeCache) : F.add(y, this.mergeCache));
      }
      for (let z = 0; z < m.items.length; z++) if (y = m.items[z], y.alt !== 1) {
        if (!y.precedenceFilterSuppressed) {
          const J = S[y.state.stateNumber] || null;
          if (J !== null && J.equals(y.context)) continue;
        }
        F.add(y, this.mergeCache);
      }
      return F;
    }
    getReachableTarget(m, y) {
      return m.matches(y, 0, this.atn.maxTokenType) ? m.target : null;
    }
    getPredsForAmbigAlts(m, y, S) {
      let F = [];
      for (let J = 0; J < y.items.length; J++) {
        const fe = y.items[J];
        m.has(fe.alt) && (F[fe.alt] = c.orContext(F[fe.alt] || null, fe.semanticContext));
      }
      let z = 0;
      for (let J = 1; J < S + 1; J++) {
        const fe = F[J] || null;
        fe === null ? F[J] = c.NONE : fe !== c.NONE && (z += 1);
      }
      return z === 0 && (F = null), this.debug && console.log("getPredsForAmbigAlts result " + u(F)), F;
    }
    getPredicatePredictions(m, y) {
      const S = [];
      let F = !1;
      for (let z = 1; z < y.length; z++) {
        const J = y[z];
        m !== null && m.has(z) && S.push(new So(J, z)), J !== c.NONE && (F = !0);
      }
      return F ? S : null;
    }
    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(m, y) {
      const S = this.splitAccordingToSemanticValidity(m, y), F = S[0], z = S[1];
      let J = this.getAltThatFinishedDecisionEntryRule(F);
      return J !== he.INVALID_ALT_NUMBER || z.items.length > 0 && (J = this.getAltThatFinishedDecisionEntryRule(z), J !== he.INVALID_ALT_NUMBER) ? J : he.INVALID_ALT_NUMBER;
    }
    getAltThatFinishedDecisionEntryRule(m) {
      const y = [];
      for (let S = 0; S < m.items.length; S++) {
        const F = m.items[S];
        (F.reachesIntoOuterContext > 0 || F.state instanceof E && F.context.hasEmptyPath()) && y.indexOf(F.alt) < 0 && y.push(F.alt);
      }
      return y.length === 0 ? he.INVALID_ALT_NUMBER : Math.min.apply(null, y);
    }
    splitAccordingToSemanticValidity(m, y) {
      const S = new Kt(m.fullCtx), F = new Kt(m.fullCtx);
      for (let z = 0; z < m.items.length; z++) {
        const J = m.items[z];
        J.semanticContext !== c.NONE ? J.semanticContext.evaluate(this.parser, y) ? S.add(J) : F.add(J) : S.add(J);
      }
      return [S, F];
    }
    evalSemanticContext(m, y, S) {
      const F = new ue();
      for (let z = 0; z < m.length; z++) {
        const J = m[z];
        if (J.pred === c.NONE) {
          if (F.add(J.alt), !S) break;
          continue;
        }
        const fe = J.pred.evaluate(this.parser, y);
        if ((this.debug || this.dfa_debug) && console.log("eval pred " + J + "=" + fe), fe && ((this.debug || this.dfa_debug) && console.log("PREDICT " + J.alt), F.add(J.alt), !S)) break;
      }
      return F;
    }
    closure(m, y, S, F, z, J) {
      this.closureCheckingStopState(m, y, S, F, z, 0, J);
    }
    closureCheckingStopState(m, y, S, F, z, J, fe) {
      if ((this.trace_atn_sim || this.debug_closure) && console.log("closure(" + m.toString(this.parser, !0) + ")"), m.state instanceof E) {
        if (!m.context.isEmpty()) {
          for (let _e = 0; _e < m.context.length; _e++) {
            if (m.context.getReturnState(_e) === W.EMPTY_RETURN_STATE) {
              if (z) {
                y.add(new N({ state: m.state, context: W.EMPTY }, m), this.mergeCache);
                continue;
              }
              this.debug && console.log("FALLING off rule " + this.getRuleName(m.state.ruleIndex)), this.closure_(m, y, S, F, z, J, fe);
              continue;
            }
            const Fe = this.atn.states[m.context.getReturnState(_e)], $e = m.context.getParent(_e), je = { state: Fe, alt: m.alt, context: $e, semanticContext: m.semanticContext }, Je = new N(je, null);
            Je.reachesIntoOuterContext = m.reachesIntoOuterContext, this.closureCheckingStopState(Je, y, S, F, z, J - 1, fe);
          }
          return;
        }
        if (z) return void y.add(m, this.mergeCache);
        this.debug && console.log("FALLING off rule " + this.getRuleName(m.state.ruleIndex));
      }
      this.closure_(m, y, S, F, z, J, fe);
    }
    closure_(m, y, S, F, z, J, fe) {
      const _e = m.state;
      _e.epsilonOnlyTransitions || y.add(m, this.mergeCache);
      for (let Fe = 0; Fe < _e.transitions.length; Fe++) {
        if (Fe === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(m)) continue;
        const $e = _e.transitions[Fe], je = F && !($e instanceof Ce), Je = this.getEpsilonTarget(m, $e, je, J === 0, z, fe);
        if (Je !== null) {
          let Ot = J;
          if (m.state instanceof E) {
            if (this._dfa !== null && this._dfa.precedenceDfa && $e.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex && (Je.precedenceFilterSuppressed = !0), Je.reachesIntoOuterContext += 1, S.add(Je) !== Je) continue;
            y.dipsIntoOuterContext = !0, Ot -= 1, this.debug && console.log("dips into outer ctx: " + Je);
          } else {
            if (!$e.isEpsilon && S.add(Je) !== Je) continue;
            $e instanceof A && Ot >= 0 && (Ot += 1);
          }
          this.closureCheckingStopState(Je, y, S, je, z, Ot, fe);
        }
      }
    }
    canDropLoopEntryEdgeInLeftRecursiveRule(m) {
      const y = m.state;
      if (y.stateType !== x.STAR_LOOP_ENTRY || y.stateType !== x.STAR_LOOP_ENTRY || !y.isPrecedenceDecision || m.context.isEmpty() || m.context.hasEmptyPath()) return !1;
      const S = m.context.length;
      for (let J = 0; J < S; J++) if (this.atn.states[m.context.getReturnState(J)].ruleIndex !== y.ruleIndex) return !1;
      const F = y.transitions[0].target.endState.stateNumber, z = this.atn.states[F];
      for (let J = 0; J < S; J++) {
        const fe = m.context.getReturnState(J), _e = this.atn.states[fe];
        if (_e.transitions.length !== 1 || !_e.transitions[0].isEpsilon) return !1;
        const Fe = _e.transitions[0].target;
        if (!(_e.stateType === x.BLOCK_END && Fe === y || _e === z || Fe === z || Fe.stateType === x.BLOCK_END && Fe.transitions.length === 1 && Fe.transitions[0].isEpsilon && Fe.transitions[0].target === y)) return !1;
      }
      return !0;
    }
    getRuleName(m) {
      return this.parser !== null && m >= 0 ? this.parser.ruleNames[m] : "<rule " + m + ">";
    }
    getEpsilonTarget(m, y, S, F, z, J) {
      switch (y.serializationType) {
        case D.RULE:
          return this.ruleTransition(m, y);
        case D.PRECEDENCE:
          return this.precedenceTransition(m, y, S, F, z);
        case D.PREDICATE:
          return this.predTransition(m, y, S, F, z);
        case D.ACTION:
          return this.actionTransition(m, y);
        case D.EPSILON:
          return new N({ state: y.target }, m);
        case D.ATOM:
        case D.RANGE:
        case D.SET:
          return J && y.matches(t.EOF, 0, 1) ? new N({ state: y.target }, m) : null;
        default:
          return null;
      }
    }
    actionTransition(m, y) {
      if (this.debug) {
        const S = y.actionIndex === -1 ? 65535 : y.actionIndex;
        console.log("ACTION edge " + y.ruleIndex + ":" + S);
      }
      return new N({ state: y.target }, m);
    }
    precedenceTransition(m, y, S, F, z) {
      this.debug && (console.log("PRED (collectPredicates=" + S + ") " + y.precedence + ">=_p, ctx dependent=true"), this.parser !== null && console.log("context surrounding pred is " + u(this.parser.getRuleInvocationStack())));
      let J = null;
      if (S && F) if (z) {
        const fe = this._input.index;
        this._input.seek(this._startIndex);
        const _e = y.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(fe), _e && (J = new N({ state: y.target }, m));
      } else {
        const fe = c.andContext(m.semanticContext, y.getPredicate());
        J = new N({ state: y.target, semanticContext: fe }, m);
      }
      else J = new N({ state: y.target }, m);
      return this.debug && console.log("config from pred transition=" + J), J;
    }
    predTransition(m, y, S, F, z) {
      this.debug && (console.log("PRED (collectPredicates=" + S + ") " + y.ruleIndex + ":" + y.predIndex + ", ctx dependent=" + y.isCtxDependent), this.parser !== null && console.log("context surrounding pred is " + u(this.parser.getRuleInvocationStack())));
      let J = null;
      if (S && (y.isCtxDependent && F || !y.isCtxDependent)) if (z) {
        const fe = this._input.index;
        this._input.seek(this._startIndex);
        const _e = y.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(fe), _e && (J = new N({ state: y.target }, m));
      } else {
        const fe = c.andContext(m.semanticContext, y.getPredicate());
        J = new N({ state: y.target, semanticContext: fe }, m);
      }
      else J = new N({ state: y.target }, m);
      return this.debug && console.log("config from pred transition=" + J), J;
    }
    ruleTransition(m, y) {
      this.debug && console.log("CALL rule " + this.getRuleName(y.target.ruleIndex) + ", ctx=" + m.context);
      const S = y.followState, F = Z.create(m.context, S.stateNumber);
      return new N({ state: y.target, context: F }, m);
    }
    getConflictingAlts(m) {
      const y = tr.getConflictingAltSubsets(m);
      return tr.getAlts(y);
    }
    getConflictingAltsOrUniqueAlt(m) {
      let y = null;
      return m.uniqueAlt !== he.INVALID_ALT_NUMBER ? (y = new ue(), y.add(m.uniqueAlt)) : y = m.conflictingAlts, y;
    }
    getTokenName(m) {
      if (m === t.EOF) return "EOF";
      if (this.parser !== null && this.parser.literalNames !== null) {
        if (!(m >= this.parser.literalNames.length && m >= this.parser.symbolicNames.length)) return (this.parser.literalNames[m] || this.parser.symbolicNames[m]) + "<" + m + ">";
        console.log(m + " ttype out of range: " + this.parser.literalNames), console.log("" + this.parser.getInputStream().getTokens());
      }
      return "" + m;
    }
    getLookaheadName(m) {
      return this.getTokenName(m.LA(1));
    }
    dumpDeadEndConfigs(m) {
      console.log("dead end configs: ");
      const y = m.getDeadEndConfigs();
      for (let S = 0; S < y.length; S++) {
        const F = y[S];
        let z = "no edges";
        if (F.state.transitions.length > 0) {
          const J = F.state.transitions[0];
          J instanceof ye ? z = "Atom " + this.getTokenName(J.label) : J instanceof M && (z = (J instanceof _ ? "~" : "") + "Set " + J.set);
        }
        console.error(F.toString(this.parser, !0) + ":" + z);
      }
    }
    noViableAlt(m, y, S, F) {
      return new Pt(this.parser, m, m.get(F), m.LT(1), S, y);
    }
    getUniqueAlt(m) {
      let y = he.INVALID_ALT_NUMBER;
      for (let S = 0; S < m.items.length; S++) {
        const F = m.items[S];
        if (y === he.INVALID_ALT_NUMBER) y = F.alt;
        else if (F.alt !== y) return he.INVALID_ALT_NUMBER;
      }
      return y;
    }
    addDFAEdge(m, y, S, F) {
      if (this.debug && console.log("EDGE " + y + " -> " + F + " upon " + this.getTokenName(S)), F === null) return null;
      if (F = this.addDFAState(m, F), y === null || S < -1 || S > this.atn.maxTokenType) return F;
      if (y.edges === null && (y.edges = []), y.edges[S + 1] = F, this.debug) {
        const z = this.parser === null ? null : this.parser.literalNames, J = this.parser === null ? null : this.parser.symbolicNames;
        console.log(`DFA=
` + m.toString(z, J));
      }
      return F;
    }
    addDFAState(m, y) {
      if (y === Ar.ERROR) return y;
      const S = m.states.get(y);
      return S !== null ? (this.trace_atn_sim && console.log("addDFAState " + y + " exists"), S) : (y.stateNumber = m.states.length, y.configs.readOnly || (y.configs.optimizeConfigs(this), y.configs.setReadonly(!0)), this.trace_atn_sim && console.log("addDFAState new " + y), m.states.add(y), this.debug && console.log("adding new DFA state: " + y), y);
    }
    reportAttemptingFullContext(m, y, S, F, z) {
      if (this.debug || this.retry_debug) {
        const J = new b(F, z + 1);
        console.log("reportAttemptingFullContext decision=" + m.decision + ":" + S + ", input=" + this.parser.getTokenStream().getText(J));
      }
      this.parser !== null && this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, m, F, z, y, S);
    }
    reportContextSensitivity(m, y, S, F, z) {
      if (this.debug || this.retry_debug) {
        const J = new b(F, z + 1);
        console.log("reportContextSensitivity decision=" + m.decision + ":" + S + ", input=" + this.parser.getTokenStream().getText(J));
      }
      this.parser !== null && this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, m, F, z, y, S);
    }
    reportAmbiguity(m, y, S, F, z, J, fe) {
      if (this.debug || this.retry_debug) {
        const _e = new b(S, F + 1);
        console.log("reportAmbiguity " + J + ":" + fe + ", input=" + this.parser.getTokenStream().getText(_e));
      }
      this.parser !== null && this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, m, S, F, z, J, fe);
    }
  }
  class Xi {
    constructor() {
      this.cache = new be();
    }
    add(m) {
      if (m === W.EMPTY) return W.EMPTY;
      const y = this.cache.get(m) || null;
      return y !== null ? y : (this.cache.set(m, m), m);
    }
    get(m) {
      return this.cache.get(m) || null;
    }
    get length() {
      return this.cache.length;
    }
  }
  const Ki = { ATN: he, ATNDeserializer: ft, LexerATNSimulator: It, ParserATNSimulator: Co, PredictionMode: tr, PredictionContextCache: Xi };
  class ws {
    constructor(m, y, S) {
      this.dfa = m, this.literalNames = y || [], this.symbolicNames = S || [];
    }
    toString() {
      if (this.dfa.s0 === null) return null;
      let m = "";
      const y = this.dfa.sortedStates();
      for (let S = 0; S < y.length; S++) {
        const F = y[S];
        if (F.edges !== null) {
          const z = F.edges.length;
          for (let J = 0; J < z; J++) {
            const fe = F.edges[J] || null;
            fe !== null && fe.stateNumber !== 2147483647 && (m = m.concat(this.getStateString(F)), m = m.concat("-"), m = m.concat(this.getEdgeLabel(J)), m = m.concat("->"), m = m.concat(this.getStateString(fe)), m = m.concat(`
`));
          }
        }
      }
      return m.length === 0 ? null : m;
    }
    getEdgeLabel(m) {
      return m === 0 ? "EOF" : this.literalNames !== null || this.symbolicNames !== null ? this.literalNames[m - 1] || this.symbolicNames[m - 1] : String.fromCharCode(m - 1);
    }
    getStateString(m) {
      const y = (m.isAcceptState ? ":" : "") + "s" + m.stateNumber + (m.requiresFullContext ? "^" : "");
      return m.isAcceptState ? m.predicates !== null ? y + "=>" + u(m.predicates) : y + "=>" + m.prediction.toString() : y;
    }
  }
  class Cg extends ws {
    constructor(m) {
      super(m, null);
    }
    getEdgeLabel(m) {
      return "'" + String.fromCharCode(m) + "'";
    }
  }
  class Tg {
    constructor(m, y) {
      if (y === void 0 && (y = 0), this.atnStartState = m, this.decision = y, this._states = new l(), this.s0 = null, this.precedenceDfa = !1, m instanceof Ae && m.isPrecedenceDecision) {
        this.precedenceDfa = !0;
        const S = new sr(null, new Kt());
        S.edges = [], S.isAcceptState = !1, S.requiresFullContext = !1, this.s0 = S;
      }
    }
    getPrecedenceStartState(m) {
      if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
      return m < 0 || m >= this.s0.edges.length ? null : this.s0.edges[m] || null;
    }
    setPrecedenceStartState(m, y) {
      if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
      m < 0 || (this.s0.edges[m] = y);
    }
    setPrecedenceDfa(m) {
      if (this.precedenceDfa !== m) {
        if (this._states = new l(), m) {
          const y = new sr(null, new Kt());
          y.edges = [], y.isAcceptState = !1, y.requiresFullContext = !1, this.s0 = y;
        } else this.s0 = null;
        this.precedenceDfa = m;
      }
    }
    sortedStates() {
      return this._states.values().sort(function(m, y) {
        return m.stateNumber - y.stateNumber;
      });
    }
    toString(m, y) {
      return m = m || null, y = y || null, this.s0 === null ? "" : new ws(this, m, y).toString();
    }
    toLexerString() {
      return this.s0 === null ? "" : new Cg(this).toString();
    }
    get states() {
      return this._states;
    }
  }
  const MS = { DFA: Tg, DFASerializer: ws, LexerDFASerializer: Cg, PredPrediction: So }, OS = { PredictionContext: W }, FS = { Interval: b, IntervalSet: C };
  class Cm {
    visitTerminal(m) {
    }
    visitErrorNode(m) {
    }
    enterEveryRule(m) {
    }
    exitEveryRule(m) {
    }
  }
  class _g {
    visit(m) {
      return Array.isArray(m) ? m.map(function(y) {
        return y.accept(this);
      }, this) : m.accept(this);
    }
    visitChildren(m) {
      return m.children ? this.visit(m.children) : null;
    }
    visitTerminal(m) {
    }
    visitErrorNode(m) {
    }
  }
  class To {
    walk(m, y) {
      if (y instanceof L || y.isErrorNode !== void 0 && y.isErrorNode()) m.visitErrorNode(y);
      else if (y instanceof k) m.visitTerminal(y);
      else {
        this.enterRule(m, y);
        for (let S = 0; S < y.getChildCount(); S++) {
          const F = y.getChild(S);
          this.walk(m, F);
        }
        this.exitRule(m, y);
      }
    }
    enterRule(m, y) {
      const S = y.ruleContext;
      m.enterEveryRule(S), S.enterRule(m);
    }
    exitRule(m, y) {
      const S = y.ruleContext;
      S.exitRule(m), m.exitEveryRule(S);
    }
  }
  To.DEFAULT = new To();
  const qS = { Trees: G, RuleNode: U, ErrorNode: L, TerminalNode: k, ParseTreeListener: Cm, ParseTreeVisitor: _g, ParseTreeWalker: To };
  class Ns extends Fr {
    constructor(m) {
      super({ message: "", recognizer: m, input: m.getInputStream(), ctx: m._ctx }), this.offendingToken = m.getCurrentToken();
    }
  }
  class Tm extends Fr {
    constructor(m, y, S) {
      super({ message: IS(y, S || null), recognizer: m, input: m.getInputStream(), ctx: m._ctx });
      const F = m._interp.atn.states[m.state].transitions[0];
      F instanceof Be ? (this.ruleIndex = F.ruleIndex, this.predicateIndex = F.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = y, this.offendingToken = m.getCurrentToken();
    }
  }
  function IS(ae, m) {
    return m !== null ? m : "failed predicate: {" + ae + "}?";
  }
  class Mg extends lt {
    constructor(m) {
      super(), m = m || !0, this.exactOnly = m;
    }
    reportAmbiguity(m, y, S, F, z, J, fe) {
      if (this.exactOnly && !z) return;
      const _e = "reportAmbiguity d=" + this.getDecisionDescription(m, y) + ": ambigAlts=" + this.getConflictingAlts(J, fe) + ", input='" + m.getTokenStream().getText(new b(S, F)) + "'";
      m.notifyErrorListeners(_e);
    }
    reportAttemptingFullContext(m, y, S, F, z, J) {
      const fe = "reportAttemptingFullContext d=" + this.getDecisionDescription(m, y) + ", input='" + m.getTokenStream().getText(new b(S, F)) + "'";
      m.notifyErrorListeners(fe);
    }
    reportContextSensitivity(m, y, S, F, z, J) {
      const fe = "reportContextSensitivity d=" + this.getDecisionDescription(m, y) + ", input='" + m.getTokenStream().getText(new b(S, F)) + "'";
      m.notifyErrorListeners(fe);
    }
    getDecisionDescription(m, y) {
      const S = y.decision, F = y.atnStartState.ruleIndex, z = m.ruleNames;
      if (F < 0 || F >= z.length) return "" + S;
      const J = z[F] || null;
      return J === null || J.length === 0 ? "" + S : `${S} (${J})`;
    }
    getConflictingAlts(m, y) {
      if (m !== null) return m;
      const S = new ue();
      for (let F = 0; F < y.items.length; F++) S.add(y.items[F].alt);
      return `{${S.values().join(", ")}}`;
    }
  }
  class _m extends Error {
    constructor() {
      super(), Error.captureStackTrace(this, _m);
    }
  }
  class BS {
    reset(m) {
    }
    recoverInline(m) {
    }
    recover(m, y) {
    }
    sync(m) {
    }
    inErrorRecoveryMode(m) {
    }
    reportError(m) {
    }
  }
  class Mm extends BS {
    constructor() {
      super(), this.errorRecoveryMode = !1, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
    }
    reset(m) {
      this.endErrorCondition(m);
    }
    beginErrorCondition(m) {
      this.errorRecoveryMode = !0;
    }
    inErrorRecoveryMode(m) {
      return this.errorRecoveryMode;
    }
    endErrorCondition(m) {
      this.errorRecoveryMode = !1, this.lastErrorStates = null, this.lastErrorIndex = -1;
    }
    reportMatch(m) {
      this.endErrorCondition(m);
    }
    reportError(m, y) {
      this.inErrorRecoveryMode(m) || (this.beginErrorCondition(m), y instanceof Pt ? this.reportNoViableAlternative(m, y) : y instanceof Ns ? this.reportInputMismatch(m, y) : y instanceof Tm ? this.reportFailedPredicate(m, y) : (console.log("unknown recognition error type: " + y.constructor.name), console.log(y.stack), m.notifyErrorListeners(y.getOffendingToken(), y.getMessage(), y)));
    }
    recover(m, y) {
      this.lastErrorIndex === m.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(m.state) >= 0 && m.consume(), this.lastErrorIndex = m._input.index, this.lastErrorStates === null && (this.lastErrorStates = []), this.lastErrorStates.push(m.state);
      const S = this.getErrorRecoverySet(m);
      this.consumeUntil(m, S);
    }
    sync(m) {
      if (this.inErrorRecoveryMode(m)) return;
      const y = m._interp.atn.states[m.state], S = m.getTokenStream().LA(1), F = m.atn.nextTokens(y);
      if (F.contains(S)) return this.nextTokensContext = null, void (this.nextTokenState = x.INVALID_STATE_NUMBER);
      if (F.contains(t.EPSILON)) this.nextTokensContext === null && (this.nextTokensContext = m._ctx, this.nextTokensState = m._stateNumber);
      else switch (y.stateType) {
        case x.BLOCK_START:
        case x.STAR_BLOCK_START:
        case x.PLUS_BLOCK_START:
        case x.STAR_LOOP_ENTRY:
          if (this.singleTokenDeletion(m) !== null) return;
          throw new Ns(m);
        case x.PLUS_LOOP_BACK:
        case x.STAR_LOOP_BACK: {
          this.reportUnwantedToken(m);
          const z = new C();
          z.addSet(m.getExpectedTokens());
          const J = z.addSet(this.getErrorRecoverySet(m));
          this.consumeUntil(m, J);
        }
      }
    }
    reportNoViableAlternative(m, y) {
      const S = m.getTokenStream();
      let F;
      F = S !== null ? y.startToken.type === t.EOF ? "<EOF>" : S.getText(new b(y.startToken.tokenIndex, y.offendingToken.tokenIndex)) : "<unknown input>";
      const z = "no viable alternative at input " + this.escapeWSAndQuote(F);
      m.notifyErrorListeners(z, y.offendingToken, y);
    }
    reportInputMismatch(m, y) {
      const S = "mismatched input " + this.getTokenErrorDisplay(y.offendingToken) + " expecting " + y.getExpectedTokens().toString(m.literalNames, m.symbolicNames);
      m.notifyErrorListeners(S, y.offendingToken, y);
    }
    reportFailedPredicate(m, y) {
      const S = "rule " + m.ruleNames[m._ctx.ruleIndex] + " " + y.message;
      m.notifyErrorListeners(S, y.offendingToken, y);
    }
    reportUnwantedToken(m) {
      if (this.inErrorRecoveryMode(m)) return;
      this.beginErrorCondition(m);
      const y = m.getCurrentToken(), S = "extraneous input " + this.getTokenErrorDisplay(y) + " expecting " + this.getExpectedTokens(m).toString(m.literalNames, m.symbolicNames);
      m.notifyErrorListeners(S, y, null);
    }
    reportMissingToken(m) {
      if (this.inErrorRecoveryMode(m)) return;
      this.beginErrorCondition(m);
      const y = m.getCurrentToken(), S = "missing " + this.getExpectedTokens(m).toString(m.literalNames, m.symbolicNames) + " at " + this.getTokenErrorDisplay(y);
      m.notifyErrorListeners(S, y, null);
    }
    recoverInline(m) {
      const y = this.singleTokenDeletion(m);
      if (y !== null) return m.consume(), y;
      if (this.singleTokenInsertion(m)) return this.getMissingSymbol(m);
      throw new Ns(m);
    }
    singleTokenInsertion(m) {
      const y = m.getTokenStream().LA(1), S = m._interp.atn, F = S.states[m.state].transitions[0].target;
      return !!S.nextTokens(F, m._ctx).contains(y) && (this.reportMissingToken(m), !0);
    }
    singleTokenDeletion(m) {
      const y = m.getTokenStream().LA(2);
      if (this.getExpectedTokens(m).contains(y)) {
        this.reportUnwantedToken(m), m.consume();
        const S = m.getCurrentToken();
        return this.reportMatch(m), S;
      }
      return null;
    }
    getMissingSymbol(m) {
      const y = m.getCurrentToken(), S = this.getExpectedTokens(m).first();
      let F;
      F = S === t.EOF ? "<missing EOF>" : "<missing " + m.literalNames[S] + ">";
      let z = y;
      const J = m.getTokenStream().LT(-1);
      return z.type === t.EOF && J !== null && (z = J), m.getTokenFactory().create(z.source, S, F, t.DEFAULT_CHANNEL, -1, -1, z.line, z.column);
    }
    getExpectedTokens(m) {
      return m.getExpectedTokens();
    }
    getTokenErrorDisplay(m) {
      if (m === null) return "<no token>";
      let y = m.text;
      return y === null && (y = m.type === t.EOF ? "<EOF>" : "<" + m.type + ">"), this.escapeWSAndQuote(y);
    }
    escapeWSAndQuote(m) {
      return "'" + (m = (m = (m = m.replace(/\n/g, "\\n")).replace(/\r/g, "\\r")).replace(/\t/g, "\\t")) + "'";
    }
    getErrorRecoverySet(m) {
      const y = m._interp.atn;
      let S = m._ctx;
      const F = new C();
      for (; S !== null && S.invokingState >= 0; ) {
        const z = y.states[S.invokingState].transitions[0], J = y.nextTokens(z.followState);
        F.addSet(J), S = S.parentCtx;
      }
      return F.removeOne(t.EPSILON), F;
    }
    consumeUntil(m, y) {
      let S = m.getTokenStream().LA(1);
      for (; S !== t.EOF && !y.contains(S); ) m.consume(), S = m.getTokenStream().LA(1);
    }
  }
  class Og extends Mm {
    constructor() {
      super();
    }
    recover(m, y) {
      let S = m._ctx;
      for (; S !== null; ) S.exception = y, S = S.parentCtx;
      throw new _m(y);
    }
    recoverInline(m) {
      this.recover(m, new Ns(m));
    }
    sync(m) {
    }
  }
  const RS = { RecognitionException: Fr, NoViableAltException: Pt, LexerNoViableAltException: Dr, InputMismatchException: Ns, FailedPredicateException: Tm, DiagnosticErrorListener: Mg, BailErrorStrategy: Og, DefaultErrorStrategy: Mm, ErrorListener: lt };
  class Ds {
    constructor(m, y) {
      if (this.name = "<empty>", this.strdata = m, this.decodeToUnicodeCodePoints = y || !1, this._index = 0, this.data = [], this.decodeToUnicodeCodePoints) for (let S = 0; S < this.strdata.length; ) {
        const F = this.strdata.codePointAt(S);
        this.data.push(F), S += F <= 65535 ? 1 : 2;
      }
      else {
        this.data = new Array(this.strdata.length);
        for (let S = 0; S < this.strdata.length; S++) this.data[S] = this.strdata.charCodeAt(S);
      }
      this._size = this.data.length;
    }
    reset() {
      this._index = 0;
    }
    consume() {
      if (this._index >= this._size) throw "cannot consume EOF";
      this._index += 1;
    }
    LA(m) {
      if (m === 0) return 0;
      m < 0 && (m += 1);
      const y = this._index + m - 1;
      return y < 0 || y >= this._size ? t.EOF : this.data[y];
    }
    LT(m) {
      return this.LA(m);
    }
    mark() {
      return -1;
    }
    release(m) {
    }
    seek(m) {
      m <= this._index ? this._index = m : this._index = Math.min(m, this._size);
    }
    getText(m, y) {
      if (y >= this._size && (y = this._size - 1), m >= this._size) return "";
      if (this.decodeToUnicodeCodePoints) {
        let S = "";
        for (let F = m; F <= y; F++) S += String.fromCodePoint(this.data[F]);
        return S;
      }
      return this.strdata.slice(m, y + 1);
    }
    toString() {
      return this.strdata;
    }
    get index() {
      return this._index;
    }
    get size() {
      return this._size;
    }
  }
  class As extends Ds {
    constructor(m, y) {
      super(m, y);
    }
  }
  var Fg = ta(92);
  const qg = typeof process < "u" && process.versions != null && process.versions.node != null;
  class Ig extends As {
    static fromPath(m, y, S) {
      if (!qg) throw new Error("FileStream is only available when running in Node!");
      Fg.readFile(m, y, function(F, z) {
        let J = null;
        z !== null && (J = new Ds(z, !0)), S(F, J);
      });
    }
    constructor(m, y, S) {
      if (!qg) throw new Error("FileStream is only available when running in Node!");
      super(Fg.readFileSync(m, y || "utf-8"), S), this.fileName = m;
    }
  }
  const Bg = { fromString: function(ae) {
    return new Ds(ae, !0);
  }, fromBlob: function(ae, m, y, S) {
    const F = new window.FileReader();
    F.onload = function(z) {
      const J = new Ds(z.target.result, !0);
      y(J);
    }, F.onerror = S, F.readAsText(ae, m);
  }, fromBuffer: function(ae, m) {
    return new Ds(ae.toString(m), !0);
  }, fromPath: function(ae, m, y) {
    Ig.fromPath(ae, m, y);
  }, fromPathSync: function(ae, m) {
    return new Ig(ae, m);
  } }, LS = { arrayToString: u, stringToCharArray: function(ae) {
    let m = new Uint16Array(ae.length);
    for (let y = 0; y < ae.length; y++) m[y] = ae.charCodeAt(y);
    return m;
  } };
  class PS {
  }
  class Rg extends PS {
    constructor(m) {
      super(), this.tokenSource = m, this.tokens = [], this.index = -1, this.fetchedEOF = !1;
    }
    mark() {
      return 0;
    }
    release(m) {
    }
    reset() {
      this.seek(0);
    }
    seek(m) {
      this.lazyInit(), this.index = this.adjustSeekIndex(m);
    }
    get size() {
      return this.tokens.length;
    }
    get(m) {
      return this.lazyInit(), this.tokens[m];
    }
    consume() {
      let m = !1;
      if (m = this.index >= 0 && (this.fetchedEOF ? this.index < this.tokens.length - 1 : this.index < this.tokens.length), !m && this.LA(1) === t.EOF) throw "cannot consume EOF";
      this.sync(this.index + 1) && (this.index = this.adjustSeekIndex(this.index + 1));
    }
    sync(m) {
      const y = m - this.tokens.length + 1;
      return !(y > 0) || this.fetch(y) >= y;
    }
    fetch(m) {
      if (this.fetchedEOF) return 0;
      for (let y = 0; y < m; y++) {
        const S = this.tokenSource.nextToken();
        if (S.tokenIndex = this.tokens.length, this.tokens.push(S), S.type === t.EOF) return this.fetchedEOF = !0, y + 1;
      }
      return m;
    }
    getTokens(m, y, S) {
      if (S === void 0 && (S = null), m < 0 || y < 0) return null;
      this.lazyInit();
      const F = [];
      y >= this.tokens.length && (y = this.tokens.length - 1);
      for (let z = m; z < y; z++) {
        const J = this.tokens[z];
        if (J.type === t.EOF) break;
        (S === null || S.contains(J.type)) && F.push(J);
      }
      return F;
    }
    LA(m) {
      return this.LT(m).type;
    }
    LB(m) {
      return this.index - m < 0 ? null : this.tokens[this.index - m];
    }
    LT(m) {
      if (this.lazyInit(), m === 0) return null;
      if (m < 0) return this.LB(-m);
      const y = this.index + m - 1;
      return this.sync(y), y >= this.tokens.length ? this.tokens[this.tokens.length - 1] : this.tokens[y];
    }
    adjustSeekIndex(m) {
      return m;
    }
    lazyInit() {
      this.index === -1 && this.setup();
    }
    setup() {
      this.sync(0), this.index = this.adjustSeekIndex(0);
    }
    setTokenSource(m) {
      this.tokenSource = m, this.tokens = [], this.index = -1, this.fetchedEOF = !1;
    }
    nextTokenOnChannel(m, y) {
      if (this.sync(m), m >= this.tokens.length) return -1;
      let S = this.tokens[m];
      for (; S.channel !== this.channel; ) {
        if (S.type === t.EOF) return -1;
        m += 1, this.sync(m), S = this.tokens[m];
      }
      return m;
    }
    previousTokenOnChannel(m, y) {
      for (; m >= 0 && this.tokens[m].channel !== y; ) m -= 1;
      return m;
    }
    getHiddenTokensToRight(m, y) {
      if (y === void 0 && (y = -1), this.lazyInit(), m < 0 || m >= this.tokens.length) throw m + " not in 0.." + this.tokens.length - 1;
      const S = this.nextTokenOnChannel(m + 1, Zt.DEFAULT_TOKEN_CHANNEL), F = m + 1, z = S === -1 ? this.tokens.length - 1 : S;
      return this.filterForChannel(F, z, y);
    }
    getHiddenTokensToLeft(m, y) {
      if (y === void 0 && (y = -1), this.lazyInit(), m < 0 || m >= this.tokens.length) throw m + " not in 0.." + this.tokens.length - 1;
      const S = this.previousTokenOnChannel(m - 1, Zt.DEFAULT_TOKEN_CHANNEL);
      if (S === m - 1) return null;
      const F = S + 1, z = m - 1;
      return this.filterForChannel(F, z, y);
    }
    filterForChannel(m, y, S) {
      const F = [];
      for (let z = m; z < y + 1; z++) {
        const J = this.tokens[z];
        S === -1 ? J.channel !== Zt.DEFAULT_TOKEN_CHANNEL && F.push(J) : J.channel === S && F.push(J);
      }
      return F.length === 0 ? null : F;
    }
    getSourceName() {
      return this.tokenSource.getSourceName();
    }
    getText(m) {
      this.lazyInit(), this.fill(), m || (m = new b(0, this.tokens.length - 1));
      let y = m.start;
      y instanceof t && (y = y.tokenIndex);
      let S = m.stop;
      if (S instanceof t && (S = S.tokenIndex), y === null || S === null || y < 0 || S < 0) return "";
      S >= this.tokens.length && (S = this.tokens.length - 1);
      let F = "";
      for (let z = y; z < S + 1; z++) {
        const J = this.tokens[z];
        if (J.type === t.EOF) break;
        F += J.text;
      }
      return F;
    }
    fill() {
      for (this.lazyInit(); this.fetch(1e3) === 1e3; ) ;
    }
  }
  Object.defineProperty(Rg, "size", { get: function() {
    return this.tokens.length;
  } });
  class Lg extends Rg {
    constructor(m, y) {
      super(m), this.channel = y === void 0 ? t.DEFAULT_CHANNEL : y;
    }
    adjustSeekIndex(m) {
      return this.nextTokenOnChannel(m, this.channel);
    }
    LB(m) {
      if (m === 0 || this.index - m < 0) return null;
      let y = this.index, S = 1;
      for (; S <= m; ) y = this.previousTokenOnChannel(y - 1, this.channel), S += 1;
      return y < 0 ? null : this.tokens[y];
    }
    LT(m) {
      if (this.lazyInit(), m === 0) return null;
      if (m < 0) return this.LB(-m);
      let y = this.index, S = 1;
      for (; S < m; ) this.sync(y + 1) && (y = this.nextTokenOnChannel(y + 1, this.channel)), S += 1;
      return this.tokens[y];
    }
    getNumberOfOnChannelTokens() {
      let m = 0;
      this.fill();
      for (let y = 0; y < this.tokens.length; y++) {
        const S = this.tokens[y];
        if (S.channel === this.channel && (m += 1), S.type === t.EOF) break;
      }
      return m;
    }
  }
  class kS extends Cm {
    constructor(m) {
      super(), this.parser = m;
    }
    enterEveryRule(m) {
      console.log("enter   " + this.parser.ruleNames[m.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
    visitTerminal(m) {
      console.log("consume " + m.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
    }
    exitEveryRule(m) {
      console.log("exit    " + this.parser.ruleNames[m.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
  }
  class Om extends An {
    constructor(m) {
      super(), this._input = null, this._errHandler = new Mm(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = !0, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.setInputStream(m);
    }
    reset() {
      this._input !== null && this._input.seek(0), this._errHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(!1), this._precedenceStack = [], this._precedenceStack.push(0), this._interp !== null && this._interp.reset();
    }
    match(m) {
      let y = this.getCurrentToken();
      return y.type === m ? (this._errHandler.reportMatch(this), this.consume()) : (y = this._errHandler.recoverInline(this), this.buildParseTrees && y.tokenIndex === -1 && this._ctx.addErrorNode(y)), y;
    }
    matchWildcard() {
      let m = this.getCurrentToken();
      return m.type > 0 ? (this._errHandler.reportMatch(this), this.consume()) : (m = this._errHandler.recoverInline(this), this.buildParseTrees && m.tokenIndex === -1 && this._ctx.addErrorNode(m)), m;
    }
    getParseListeners() {
      return this._parseListeners || [];
    }
    addParseListener(m) {
      if (m === null) throw "listener";
      this._parseListeners === null && (this._parseListeners = []), this._parseListeners.push(m);
    }
    removeParseListener(m) {
      if (this._parseListeners !== null) {
        const y = this._parseListeners.indexOf(m);
        y >= 0 && this._parseListeners.splice(y, 1), this._parseListeners.length === 0 && (this._parseListeners = null);
      }
    }
    removeParseListeners() {
      this._parseListeners = null;
    }
    triggerEnterRuleEvent() {
      if (this._parseListeners !== null) {
        const m = this._ctx;
        this._parseListeners.forEach(function(y) {
          y.enterEveryRule(m), m.enterRule(y);
        });
      }
    }
    triggerExitRuleEvent() {
      if (this._parseListeners !== null) {
        const m = this._ctx;
        this._parseListeners.slice(0).reverse().forEach(function(y) {
          m.exitRule(y), y.exitEveryRule(m);
        });
      }
    }
    getTokenFactory() {
      return this._input.tokenSource._factory;
    }
    setTokenFactory(m) {
      this._input.tokenSource._factory = m;
    }
    getATNWithBypassAlts() {
      const m = this.getSerializedATN();
      if (m === null) throw "The current parser does not support an ATN with bypass alternatives.";
      let y = this.bypassAltsAtnCache[m];
      if (y === null) {
        const S = new rt();
        S.generateRuleBypassTransitions = !0, y = new ft(S).deserialize(m), this.bypassAltsAtnCache[m] = y;
      }
      return y;
    }
    getInputStream() {
      return this.getTokenStream();
    }
    setInputStream(m) {
      this.setTokenStream(m);
    }
    getTokenStream() {
      return this._input;
    }
    setTokenStream(m) {
      this._input = null, this.reset(), this._input = m;
    }
    get syntaxErrorsCount() {
      return this._syntaxErrors;
    }
    getCurrentToken() {
      return this._input.LT(1);
    }
    notifyErrorListeners(m, y, S) {
      S = S || null, (y = y || null) === null && (y = this.getCurrentToken()), this._syntaxErrors += 1;
      const F = y.line, z = y.column;
      this.getErrorListenerDispatch().syntaxError(this, y, F, z, m, S);
    }
    consume() {
      const m = this.getCurrentToken();
      m.type !== t.EOF && this.getInputStream().consume();
      const y = this._parseListeners !== null && this._parseListeners.length > 0;
      if (this.buildParseTrees || y) {
        let S;
        S = this._errHandler.inErrorRecoveryMode(this) ? this._ctx.addErrorNode(m) : this._ctx.addTokenNode(m), S.invokingState = this.state, y && this._parseListeners.forEach(function(F) {
          S instanceof L || S.isErrorNode !== void 0 && S.isErrorNode() ? F.visitErrorNode(S) : S instanceof k && F.visitTerminal(S);
        });
      }
      return m;
    }
    addContextToParseTree() {
      this._ctx.parentCtx !== null && this._ctx.parentCtx.addChild(this._ctx);
    }
    enterRule(m, y, S) {
      this.state = y, this._ctx = m, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
    }
    exitRule() {
      this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parentCtx;
    }
    enterOuterAlt(m, y) {
      m.setAltNumber(y), this.buildParseTrees && this._ctx !== m && this._ctx.parentCtx !== null && (this._ctx.parentCtx.removeLastChild(), this._ctx.parentCtx.addChild(m)), this._ctx = m;
    }
    getPrecedence() {
      return this._precedenceStack.length === 0 ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
    }
    enterRecursionRule(m, y, S, F) {
      this.state = y, this._precedenceStack.push(F), this._ctx = m, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
    }
    pushNewRecursionContext(m, y, S) {
      const F = this._ctx;
      F.parentCtx = m, F.invokingState = y, F.stop = this._input.LT(-1), this._ctx = m, this._ctx.start = F.start, this.buildParseTrees && this._ctx.addChild(F), this.triggerEnterRuleEvent();
    }
    unrollRecursionContexts(m) {
      this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
      const y = this._ctx, S = this.getParseListeners();
      if (S !== null && S.length > 0) for (; this._ctx !== m; ) this.triggerExitRuleEvent(), this._ctx = this._ctx.parentCtx;
      else this._ctx = m;
      y.parentCtx = m, this.buildParseTrees && m !== null && m.addChild(y);
    }
    getInvokingContext(m) {
      let y = this._ctx;
      for (; y !== null; ) {
        if (y.ruleIndex === m) return y;
        y = y.parentCtx;
      }
      return null;
    }
    precpred(m, y) {
      return y >= this._precedenceStack[this._precedenceStack.length - 1];
    }
    inContext(m) {
      return !1;
    }
    isExpectedToken(m) {
      const y = this._interp.atn;
      let S = this._ctx;
      const F = y.states[this.state];
      let z = y.nextTokens(F);
      if (z.contains(m)) return !0;
      if (!z.contains(t.EPSILON)) return !1;
      for (; S !== null && S.invokingState >= 0 && z.contains(t.EPSILON); ) {
        const J = y.states[S.invokingState].transitions[0];
        if (z = y.nextTokens(J.followState), z.contains(m)) return !0;
        S = S.parentCtx;
      }
      return !(!z.contains(t.EPSILON) || m !== t.EOF);
    }
    getExpectedTokens() {
      return this._interp.atn.getExpectedTokens(this.state, this._ctx);
    }
    getExpectedTokensWithinCurrentRule() {
      const m = this._interp.atn, y = m.states[this.state];
      return m.nextTokens(y);
    }
    getRuleIndex(m) {
      const y = this.getRuleIndexMap()[m];
      return y !== null ? y : -1;
    }
    getRuleInvocationStack(m) {
      (m = m || null) === null && (m = this._ctx);
      const y = [];
      for (; m !== null; ) {
        const S = m.ruleIndex;
        S < 0 ? y.push("n/a") : y.push(this.ruleNames[S]), m = m.parentCtx;
      }
      return y;
    }
    getDFAStrings() {
      return this._interp.decisionToDFA.toString();
    }
    dumpDFA() {
      let m = !1;
      for (let y = 0; y < this._interp.decisionToDFA.length; y++) {
        const S = this._interp.decisionToDFA[y];
        S.states.length > 0 && (m && console.log(), this.printer.println("Decision " + S.decision + ":"), this.printer.print(S.toString(this.literalNames, this.symbolicNames)), m = !0);
      }
    }
    getSourceName() {
      return this._input.sourceName;
    }
    setTrace(m) {
      m ? (this._tracer !== null && this.removeParseListener(this._tracer), this._tracer = new kS(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
    }
  }
  Om.bypassAltsAtnCache = {};
  class Pg extends k {
    constructor(m) {
      super(), this.parentCtx = null, this.symbol = m;
    }
    getChild(m) {
      return null;
    }
    getSymbol() {
      return this.symbol;
    }
    getParent() {
      return this.parentCtx;
    }
    getPayload() {
      return this.symbol;
    }
    getSourceInterval() {
      if (this.symbol === null) return b.INVALID_INTERVAL;
      const m = this.symbol.tokenIndex;
      return new b(m, m);
    }
    getChildCount() {
      return 0;
    }
    accept(m) {
      return m.visitTerminal(this);
    }
    getText() {
      return this.symbol.text;
    }
    toString() {
      return this.symbol.type === t.EOF ? "<EOF>" : this.symbol.text;
    }
  }
  class kg extends Pg {
    constructor(m) {
      super(m);
    }
    isErrorNode() {
      return !0;
    }
    accept(m) {
      return m.visitErrorNode(this);
    }
  }
  class Fm extends P {
    constructor(m, y) {
      super(m, y), this.children = null, this.start = null, this.stop = null, this.exception = null;
    }
    copyFrom(m) {
      this.parentCtx = m.parentCtx, this.invokingState = m.invokingState, this.children = null, this.start = m.start, this.stop = m.stop, m.children && (this.children = [], m.children.map(function(y) {
        y instanceof kg && (this.children.push(y), y.parentCtx = this);
      }, this));
    }
    enterRule(m) {
    }
    exitRule(m) {
    }
    addChild(m) {
      return this.children === null && (this.children = []), this.children.push(m), m;
    }
    removeLastChild() {
      this.children !== null && this.children.pop();
    }
    addTokenNode(m) {
      const y = new Pg(m);
      return this.addChild(y), y.parentCtx = this, y;
    }
    addErrorNode(m) {
      const y = new kg(m);
      return this.addChild(y), y.parentCtx = this, y;
    }
    getChild(m, y) {
      if (y = y || null, this.children === null || m < 0 || m >= this.children.length) return null;
      if (y === null) return this.children[m];
      for (let S = 0; S < this.children.length; S++) {
        const F = this.children[S];
        if (F instanceof y) {
          if (m === 0) return F;
          m -= 1;
        }
      }
      return null;
    }
    getToken(m, y) {
      if (this.children === null || y < 0 || y >= this.children.length) return null;
      for (let S = 0; S < this.children.length; S++) {
        const F = this.children[S];
        if (F instanceof k && F.symbol.type === m) {
          if (y === 0) return F;
          y -= 1;
        }
      }
      return null;
    }
    getTokens(m) {
      if (this.children === null) return [];
      {
        const y = [];
        for (let S = 0; S < this.children.length; S++) {
          const F = this.children[S];
          F instanceof k && F.symbol.type === m && y.push(F);
        }
        return y;
      }
    }
    getTypedRuleContext(m, y) {
      return this.getChild(y, m);
    }
    getTypedRuleContexts(m) {
      if (this.children === null) return [];
      {
        const y = [];
        for (let S = 0; S < this.children.length; S++) {
          const F = this.children[S];
          F instanceof m && y.push(F);
        }
        return y;
      }
    }
    getChildCount() {
      return this.children === null ? 0 : this.children.length;
    }
    getSourceInterval() {
      return this.start === null || this.stop === null ? b.INVALID_INTERVAL : new b(this.start.tokenIndex, this.stop.tokenIndex);
    }
  }
  P.EMPTY = new Fm();
  class Ai {
    static DEFAULT_PROGRAM_NAME = "default";
    constructor(m) {
      this.tokens = m, this.programs = /* @__PURE__ */ new Map();
    }
    getTokenStream() {
      return this.tokens;
    }
    insertAfter(m, y) {
      let S, F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ai.DEFAULT_PROGRAM_NAME;
      S = typeof m == "number" ? m : m.tokenIndex;
      let z = this.getProgram(F), J = new zg(this.tokens, S, z.length, y);
      z.push(J);
    }
    insertBefore(m, y) {
      let S, F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ai.DEFAULT_PROGRAM_NAME;
      S = typeof m == "number" ? m : m.tokenIndex;
      const z = this.getProgram(F), J = new Ea(this.tokens, S, z.length, y);
      z.push(J);
    }
    replaceSingle(m, y) {
      let S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ai.DEFAULT_PROGRAM_NAME;
      this.replace(m, m, y, S);
    }
    replace(m, y, S) {
      let F = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Ai.DEFAULT_PROGRAM_NAME;
      if (typeof m != "number" && (m = m.tokenIndex), typeof y != "number" && (y = y.tokenIndex), m > y || m < 0 || y < 0 || y >= this.tokens.size) throw new RangeError(`replace: range invalid: ${m}..${y}(size=${this.tokens.size})`);
      let z = this.getProgram(F), J = new _o(this.tokens, m, y, z.length, S);
      z.push(J);
    }
    delete(m, y) {
      let S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ai.DEFAULT_PROGRAM_NAME;
      y === void 0 && (y = m), this.replace(m, y, null, S);
    }
    getProgram(m) {
      let y = this.programs.get(m);
      return y == null && (y = this.initializeProgram(m)), y;
    }
    initializeProgram(m) {
      const y = [];
      return this.programs.set(m, y), y;
    }
    getText(m) {
      let y, S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ai.DEFAULT_PROGRAM_NAME;
      y = m instanceof b ? m : new b(0, this.tokens.size - 1), typeof m == "string" && (S = m);
      const F = this.programs.get(S);
      let z = y.start, J = y.stop;
      if (J > this.tokens.size - 1 && (J = this.tokens.size - 1), z < 0 && (z = 0), F == null || F.length === 0) return this.tokens.getText(new b(z, J));
      let fe = [], _e = this.reduceToSingleOperationPerIndex(F), Fe = z;
      for (; Fe <= J && Fe < this.tokens.size; ) {
        let $e = _e.get(Fe);
        _e.delete(Fe);
        let je = this.tokens.get(Fe);
        $e == null ? (je.type !== t.EOF && fe.push(String(je.text)), Fe++) : Fe = $e.execute(fe);
      }
      if (J === this.tokens.size - 1) for (const $e of _e.values()) $e.index >= this.tokens.size - 1 && fe.push($e.text.toString());
      return fe.join("");
    }
    reduceToSingleOperationPerIndex(m) {
      for (let S = 0; S < m.length; S++) {
        let F = m[S];
        if (F == null || !(F instanceof _o)) continue;
        let z = F, J = this.getKindOfOps(m, Ea, S);
        for (let _e of J) _e.index === z.index ? (m[_e.instructionIndex] = void 0, z.text = _e.text.toString() + (z.text != null ? z.text.toString() : "")) : _e.index > z.index && _e.index <= z.lastIndex && (m[_e.instructionIndex] = void 0);
        let fe = this.getKindOfOps(m, _o, S);
        for (let _e of fe) {
          if (_e.index >= z.index && _e.lastIndex <= z.lastIndex) {
            m[_e.instructionIndex] = void 0;
            continue;
          }
          let Fe = _e.lastIndex < z.index || _e.index > z.lastIndex;
          if (_e.text != null || z.text != null || Fe) {
            if (!Fe) throw new Error(`replace op boundaries of ${z} overlap with previous ${_e}`);
          } else m[_e.instructionIndex] = void 0, z.index = Math.min(_e.index, z.index), z.lastIndex = Math.max(_e.lastIndex, z.lastIndex);
        }
      }
      for (let S = 0; S < m.length; S++) {
        let F = m[S];
        if (F == null || !(F instanceof Ea)) continue;
        let z = F, J = this.getKindOfOps(m, Ea, S);
        for (let _e of J) _e.index === z.index && (_e instanceof zg ? (z.text = this.catOpText(_e.text, z.text), m[_e.instructionIndex] = void 0) : _e instanceof Ea && (z.text = this.catOpText(z.text, _e.text), m[_e.instructionIndex] = void 0));
        let fe = this.getKindOfOps(m, _o, S);
        for (let _e of fe) if (z.index !== _e.index) {
          if (z.index >= _e.index && z.index <= _e.lastIndex) throw new Error(`insert op ${z} within boundaries of previous ${_e}`);
        } else _e.text = this.catOpText(z.text, _e.text), m[S] = void 0;
      }
      let y = /* @__PURE__ */ new Map();
      for (let S of m) if (S != null) {
        if (y.get(S.index) != null) throw new Error("should only be one op per index");
        y.set(S.index, S);
      }
      return y;
    }
    catOpText(m, y) {
      let S = "", F = "";
      return m != null && (S = m.toString()), y != null && (F = y.toString()), S + F;
    }
    getKindOfOps(m, y, S) {
      return m.slice(0, S).filter((F) => F && F instanceof y);
    }
  }
  class $g {
    constructor(m, y, S, F) {
      this.tokens = m, this.instructionIndex = S, this.index = y, this.text = F === void 0 ? "" : F;
    }
    toString() {
      let m = this.constructor.name;
      const y = m.indexOf("$");
      return m = m.substring(y + 1, m.length), "<" + m + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
    }
  }
  class Ea extends $g {
    constructor(m, y, S, F) {
      super(m, y, S, F);
    }
    execute(m) {
      return this.text && m.push(this.text.toString()), this.tokens.get(this.index).type !== t.EOF && m.push(String(this.tokens.get(this.index).text)), this.index + 1;
    }
  }
  class zg extends Ea {
    constructor(m, y, S, F) {
      super(m, y + 1, S, F);
    }
  }
  class _o extends $g {
    constructor(m, y, S, F, z) {
      super(m, y, F, z), this.lastIndex = S;
    }
    execute(m) {
      return this.text && m.push(this.text.toString()), this.lastIndex + 1;
    }
    toString() {
      return this.text == null ? "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">" : "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
    }
  }
  const $S = { atn: Ki, dfa: MS, context: OS, misc: FS, tree: qS, error: RS, Token: t, CommonToken: Or, CharStreams: Bg, CharStream: As, InputStream: As, CommonTokenStream: Lg, Lexer: Zt, Parser: Om, ParserRuleContext: Fm, Interval: b, IntervalSet: C, LL1Analyzer: ve, Utils: LS, TokenStreamRewriter: Ai };
})();
var ra = zt.dx, DS = zt.q2;
zt.FO;
zt.xf;
zt.Gy;
zt.s4;
var uk = zt.c7, AS = zt._7;
zt.gp;
var hg = zt.cK;
zt.zs;
var lk = zt.AV;
zt.Xp;
zt.VS;
zt.ul;
var ck = zt.hW, fk = zt.x1;
zt.z5;
var pk = zt.oN;
zt.TB;
var hk = zt.u1, mk = zt._b, dk = zt.$F, Mr = zt._T, ES = zt.db;
zt.Zx;
var Sr = zt._x;
zt.r8;
zt.JI;
zt.TP;
var SS = zt.WU;
zt.Nj;
zt.ZP;
var vk = [
  "悋Ꜫ脳맭䅼㯧瞆奤",
  "-Ĥ\b		",
  "			\x07	",
  `\x07\b	\b			
	
\v	\v`,
  "\f	\f\r	\r		",
  "				",
  "			",
  "				",
  "\x1B	\x1B		",
  '		 	 !	!"	"#',
  "	#$	$%	%&	&'	'(	()	)",
  "*	*+	+,	,",
  "",
  "\x07",
  "\x07\x07\b\b\b		",
  `						


`,
  `





\v\v`,
  "\v\v\v\v\v\v",
  "\f\f\f\f\f\r\r",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\x1B\x1B",
  "",
  " ",
  '   !!!""""',
  '"###$$$$$',
  `$$$á
$%%%%æ
%\r%`,
  `%ç&&&&í
&\r&&î'`,
  `'ò
'\r''ó((\x07(ø
(\f`,
  `((û\v())þ
)\r))ÿ)`,
  `)***Ć
*\r**ć**`,
  `++++\x07+Đ
+\f++ē\v+`,
  "+++++,,,,\x07",
  `,Ğ
,\f,,ġ\v,,,đ-`,
  "\x07	\v\x07\r\b	",
  `
\v\f\r\x1B`,
  "!#%')+-/1",
  `3\x1B579;= ?!A"C#E$G%I&K'M(O)Q*S+U,W-`,
  `
2;GGgg--//c`,
  '|2;C\\aac|\v\f""\x07',
  "/02;C\\aac|\f\fĭ",
  "\x07",
  "	\v",
  "\r",
  "",
  "",
  "\x1B",
  "",
  "!#",
  "%'",
  ")+",
  "-/",
  "135",
  "79",
  ";=",
  "?A",
  "CE",
  "GIK",
  "MO",
  "QS",
  "UW",
  "Y[\x07",
  "b	d\vf",
  "\rhk",
  "nv",
  "",
  "\x1B",
  "!",
  "#%¤",
  "'§)­",
  "+¯-²",
  "/´1¶",
  "3¸5º",
  "7¼9¾;Â",
  "=Æ?Ê",
  "AÎCÑ",
  "EÖGà",
  "IâKé",
  "MñOõQý",
  "SăUċ",
  "WęYZ\x07",
  "Z[\\\x07q\\]\x07",
  "r]^\x07c^_\x07s_`\x07w",
  "`a\x07gabc\x07=",
  `c\bde\x07*e
`,
  "fg\x07+g\fh",
  "i\x07kij\x07hj",
  "kl\x07?lm\x07?m",
  "no\x07dop\x07cpq\x07t",
  "qr\x07trs\x07kst\x07gtu\x07",
  "tuvw\x07Qwx",
  "\x07Rxy\x07Gyz\x07Pz{\x07",
  "S{|\x07C|}\x07U}~\x07O",
  "~\x07k",
  "\x07p\x07e",
  "\x07n\x07w",
  "\x07f\x07g",
  "\x07s\x07",
  "t\x07g\x07i",
  "\x07]",
  "\x07_",
  "\x07e",
  "\x07t\x07g",
  "\x07i",
  "\x07i\x07c",
  "\x07v\x07g ",
  '\x07}"',
  "\x07o\x07g",
  "\x07c \x07u",
  " ¡\x07w¡¢\x07t¢",
  "£\x07g£$¤¥",
  "\x07/¥¦\x07@¦&",
  "§¨\x07t¨©\x07g",
  "©ª\x07uª«\x07g",
  "«¬\x07v¬(­",
  "®\x07W®*¯°",
  "\x07E°±\x07Z±,",
  "²³\x07.³.",
  "´µ\x07`µ0",
  "¶·\x07,·2¸",
  "¹\x071¹4º»",
  "\x07-»6¼½\x07",
  "/½8¾¿\x07u",
  "¿À\x07kÀÁ\x07p",
  "Á:ÂÃ\x07eÃ",
  "Ä\x07qÄÅ\x07uÅ<",
  "ÆÇ\x07vÇÈ\x07",
  "cÈÉ\x07pÉ>",
  "ÊË\x07gËÌ\x07z",
  "ÌÍ\x07rÍ@Î",
  "Ï\x07nÏÐ\x07pÐB",
  "ÑÒ\x07uÒÓ\x07",
  "sÓÔ\x07tÔÕ\x07v",
  "ÕDÖ×\x07r",
  "×Ø\x07kØFÙ",
  "ÚI%ÚÛK&Ûá",
  "ÜÝM'ÝÞK&Þ",
  "áßáI%àÙ",
  "àÜàß",
  "áHâã",
  "M'ãå\x070äæ	",
  "åäæç",
  "çåçè",
  "èJéê	",
  "êì	ëí	ì",
  "ëíîî",
  "ìîïï",
  "Lðò	ñð",
  "òóóñ",
  "óôôN",
  "õù	öø",
  "	÷öøû",
  "ù÷ùú",
  "úPûù",
  "üþ	\x07ýü",
  "þÿÿý",
  "ÿĀĀā",
  "āĂ\b)ĂR",
  "ăą\x07$ĄĆ	\b",
  "ąĄĆć",
  "ćąćĈ",
  "ĈĉĉĊ\x07$",
  "ĊTċČ\x071Č",
  "č\x07,čđĎ",
  "Đ\vďĎĐ",
  "ēđĒđ",
  "ďĒĔē",
  "đĔĕ\x07,ĕ",
  "Ė\x071Ėėė",
  "Ę\b+ĘVęĚ\x07",
  "1Ěě\x071ěğ",
  `ĜĞ
	ĝĜ`,
  "Ğġğĝ",
  "ğĠĠĢ",
  "ġğĢģ\b,",
  "ģX\fàçîóù",
  "ÿćđğ\b"
].join(""), mg = new DS().deserialize(vk), gk = mg.decisionToState.map(function(t, e) {
  return new AS(t, e);
});
class vt extends ck {
  constructor(e) {
    super(e), this._interp = new fk(this, mg, gk, new ES());
  }
  channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
  modeNames = ["DEFAULT_MODE"];
  literalNames = [
    null,
    "'}'",
    "'opaque'",
    "';'",
    "'('",
    "')'",
    "'if'",
    "'=='",
    "'barrier'",
    "'OPENQASM'",
    "'include'",
    "'qreg'",
    "'['",
    "']'",
    "'creg'",
    "'gate'",
    "'{'",
    "'measure'",
    "'->'",
    "'reset'",
    "'U'",
    "'CX'",
    "','",
    "'^'",
    "'*'",
    "'/'",
    "'+'",
    "'-'",
    "'sin'",
    "'cos'",
    "'tan'",
    "'exp'",
    "'ln'",
    "'sqrt'",
    "'pi'"
  ];
  symbolicNames = [
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "PI",
    "REAL",
    "SUBREAL",
    "EXPREAL",
    "INT",
    "ID",
    "WS",
    "FILENAME",
    "COMMENT",
    "LINE_COMMENT"
  ];
  ruleNames = [
    "T__0",
    "T__1",
    "T__2",
    "T__3",
    "T__4",
    "T__5",
    "T__6",
    "T__7",
    "T__8",
    "T__9",
    "T__10",
    "T__11",
    "T__12",
    "T__13",
    "T__14",
    "T__15",
    "T__16",
    "T__17",
    "T__18",
    "T__19",
    "T__20",
    "T__21",
    "T__22",
    "T__23",
    "T__24",
    "T__25",
    "T__26",
    "T__27",
    "T__28",
    "T__29",
    "T__30",
    "T__31",
    "T__32",
    "PI",
    "REAL",
    "SUBREAL",
    "EXPREAL",
    "INT",
    "ID",
    "WS",
    "FILENAME",
    "COMMENT",
    "LINE_COMMENT"
  ];
  grammarFileName = "QASM.g4";
}
Object.defineProperty(vt.prototype, "atn", {
  get: function() {
    return mg;
  }
});
vt.EOF = SS.EOF;
vt.T__0 = 1;
vt.T__1 = 2;
vt.T__2 = 3;
vt.T__3 = 4;
vt.T__4 = 5;
vt.T__5 = 6;
vt.T__6 = 7;
vt.T__7 = 8;
vt.T__8 = 9;
vt.T__9 = 10;
vt.T__10 = 11;
vt.T__11 = 12;
vt.T__12 = 13;
vt.T__13 = 14;
vt.T__14 = 15;
vt.T__15 = 16;
vt.T__16 = 17;
vt.T__17 = 18;
vt.T__18 = 19;
vt.T__19 = 20;
vt.T__20 = 21;
vt.T__21 = 22;
vt.T__22 = 23;
vt.T__23 = 24;
vt.T__24 = 25;
vt.T__25 = 26;
vt.T__26 = 27;
vt.T__27 = 28;
vt.T__28 = 29;
vt.T__29 = 30;
vt.T__30 = 31;
vt.T__31 = 32;
vt.T__32 = 33;
vt.PI = 34;
vt.REAL = 35;
vt.SUBREAL = 36;
vt.EXPREAL = 37;
vt.INT = 38;
vt.ID = 39;
vt.WS = 40;
vt.FILENAME = 41;
vt.COMMENT = 42;
vt.LINE_COMMENT = 43;
class Mt extends pk {
  constructor() {
    super();
  }
  enterMainprog = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mainprog.
  exitMainprog = function(e) {
  };
  // Enter a parse tree produced by QASMParser#statement.
  enterStatement = function(e) {
  };
  // Exit a parse tree produced by QASMParser#statement.
  exitStatement = function(e) {
  };
  // Enter a parse tree produced by QASMParser#version.
  enterVersion = function(e) {
  };
  // Exit a parse tree produced by QASMParser#version.
  exitVersion = function(e) {
  };
  // Enter a parse tree produced by QASMParser#include.
  enterInclude = function(e) {
  };
  // Exit a parse tree produced by QASMParser#include.
  exitInclude = function(e) {
  };
  // Enter a parse tree produced by QASMParser#filename.
  enterFilename = function(e) {
  };
  // Exit a parse tree produced by QASMParser#filename.
  exitFilename = function(e) {
  };
  // Enter a parse tree produced by QASMParser#decl.
  enterDecl = function(e) {
  };
  // Exit a parse tree produced by QASMParser#decl.
  exitDecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#gatedecl.
  enterGatedecl = function(e) {
  };
  // Exit a parse tree produced by QASMParser#gatedecl.
  exitGatedecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#goplist.
  enterGoplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#goplist.
  exitGoplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#qop.
  enterQop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#qop.
  exitQop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#uop.
  enterUop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#uop.
  exitUop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#anylist.
  enterAnylist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#anylist.
  exitAnylist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#idlist.
  enterIdlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#idlist.
  exitIdlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#mixedlist.
  enterMixedlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mixedlist.
  exitMixedlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#argument.
  enterArgument = function(e) {
  };
  // Exit a parse tree produced by QASMParser#argument.
  exitArgument = function(e) {
  };
  // Enter a parse tree produced by QASMParser#explist.
  enterExplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#explist.
  exitExplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#exp.
  enterExp = function(e) {
  };
  // Exit a parse tree produced by QASMParser#exp.
  exitExp = function(e) {
  };
  // Enter a parse tree produced by QASMParser#atom.
  enterAtom = function(e) {
  };
  // Exit a parse tree produced by QASMParser#atom.
  exitAtom = function(e) {
  };
  // Enter a parse tree produced by QASMParser#unaryop.
  enterUnaryop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#unaryop.
  exitUnaryop = function(e) {
  };
}
var yk = [
  "悋Ꜫ脳맭䅼㯧瞆奤",
  "-İ			",
  "		\x07	\x07",
  `\b	\b			
	
\v	\v\f	\f`,
  "\r	\r			",
  "			",
  `\x07)
\f,\v`,
  "",
  "",
  "",
  "",
  "",
  "",
  `W
`,
  "",
  "\x07\x07",
  "\x07\x07\x07\x07\x07\x07",
  `\x07\x07\x07\x07\x07o
\x07`,
  "\b\b\b\b\b\b\b\b",
  "\b\b\b\b\b\b\b\b\b",
  `\b\b\b\b
\b				`,
  `		
	\r		


`,
  `







`,
  `


\v\v\v\v\v`,
  "\v\v\v\v\v\v",
  "\v\v\v\v\v\v",
  "\v\v\v\v\v\v",
  "\v\v\v\v\v\v",
  `\v\v»
\v\f\f\f¿`,
  `
\f\r\r\x07\rÃ
\r\f\r\rÆ\v\r`,
  "\r\r",
  `\x07Ï
\fÒ\v`,
  "\x07",
  `Ú
\fÝ\v`,
  "\x07",
  `å
\fè\v`,
  `\x07ì
\fï\v`,
  `õ
`,
  "",
  `ü
\x07`,
  `ā
\fĄ\v`,
  `Ċ
`,
  `đ
`,
  "",
  `ę
Ĝ
`,
  "",
  `\x07ħ
\f`,
  "Ī\v",
  ` \b
\f`,
  ' "$',
  "\x1B$%()",
  "#ń&V",
  "X\b\\",
  "\n`\fn",
  "",
  "º¾",
  "Äô",
  "ûĂ",
  ' ě"ī',
  "$ĭ&*",
  "')('),",
  "*(*++",
  ",*-W\f\x07",
  "./\b/0	01\x07",
  "1W23\b34\x07",
  "4W56\x0767\x07)",
  "78\r89\x079W",
  ":;\x07;<\x07)<=",
  "\x07=>\x07\x07>?\r",
  "?@\x07@WAB\x07",
  "BC\x07)CD\x07DE",
  "\rEF\x07\x07FG\rGH\x07",
  `HWIW
JK\x07`,
  "\bKL\x07LM\x07)MN\x07",
  "	NO\x07(OP\x07\x07PW",
  `
QR\x07
RS\fST\x07`,
  "TWUW\bV-",
  "V.V2",
  "V5V:VA",
  "VIVJVQ",
  "VUW",
  "XY\x07\vYZ\x07%Z[\x07",
  "[\x07\\]\x07\f]^",
  `
^_\x07_	`,
  "`a\x07+a\vbc\x07\r",
  "cd\x07)de\x07ef\x07(",
  "fg\x07go\x07hi\x07",
  "ij\x07)jk\x07kl\x07",
  "(lm\x07mo\x07nb",
  "nho\r",
  "pq\x07qr\x07)rs",
  "\rst\x07tuv",
  "\x07vw\x07)wx\x07",
  "xy\x07\x07yz\rz{\x07",
  "{|}\x07}~\x07",
  ")~\x07",
  "\r\x07\x07",
  "\r\x07",
  "pu",
  "|",
  `\v\x07
`,
  "\r\x07",
  "",
  "",
  "",
  "\v",
  "\x07",
  "\x07",
  "\x07",
  "\x07",
  "\x07",
  "",
  "",
  "\x07\x07",
  " \x07\x07",
  " ¡¡¢\x07",
  "¢»£¤\x07",
  "¤¥¥¦\x07",
  "¦§§¨\x07",
  "¨»©ª\x07)",
  "ª«\f«¬\x07",
  "¬»­®\x07)",
  "®¯\x07¯°\x07\x07",
  "°±\f±²\x07",
  "²»³´\x07)",
  "´µ\x07µ¶",
  "¶·\x07\x07·¸\f",
  "¸¹\x07¹»",
  "ºº£",
  "º©º­",
  "º³»",
  "¼¿\r½¿",
  "¾¼¾½",
  "¿ÀÁ\x07)",
  "ÁÃ\x07ÂÀ",
  "ÃÆÄÂ",
  "ÄÅÅÇ",
  "ÆÄÇÈ\x07)",
  "ÈÉÊ\x07)",
  "ÊË\x07ËÌ\x07(",
  "ÌÍ\x07ÍÏ\x07",
  "ÎÉÏÒ",
  "ÐÎÐÑ",
  "ÑÓÒÐ",
  "Óõ\x07)ÔÕ\x07)",
  "ÕÖ\x07Ö×\x07(",
  "×Ø\x07ØÚ\x07",
  "ÙÔÚÝ",
  "ÛÙÛÜ",
  "ÜÞÝÛ",
  "Þß\x07)ßà\x07",
  "àá\x07(áõ\x07",
  "âã\x07)ãå\x07",
  "äâåè",
  "æäæç",
  "çéèæ",
  "éê\x07)êì\x07",
  "ëæìï",
  "íëíî",
  "îðïí",
  "ðñ\x07)ñò\x07",
  "òó\x07(óõ\x07",
  "ôÐôÛ",
  "ôíõ\x1B",
  "öü\x07)÷ø\x07)ø",
  "ù\x07ùú\x07(ú",
  "ü\x07ûöû",
  "÷üý",
  "þ þÿ\x07ÿ",
  "āĀýā",
  "ĄĂĀĂ",
  "ăăąĄ",
  "ĂąĆ Ć",
  "ćĉ\bĈ",
  "Ċ	ĉĈĉ",
  "ĊĊċċ",
  "Č\x07Čč č",
  "Ď\x07\x07ĎĜď",
  "đ	ĐďĐ",
  "đđĒĒ",
  "ē$ēĔ\x07Ĕ",
  "ĕ ĕĖ\x07\x07Ė",
  "Ĝėę	Ę",
  "ėĘęę",
  'ĚĚĜ"ě',
  "ćěĐě",
  "ĘĜĨĝ",
  "Ğ\f\bĞğ\x07ğħ",
  " 	Ġġ\f\x07ġĢ	",
  "Ģħ \bģĤ\f",
  "Ĥĥ	ĥħ \x07Ħ",
  "ĝĦĠĦ",
  "ģħĪĨ",
  "ĦĨĩĩ",
  "!ĪĨī",
  "Ĭ	Ĭ#ĭĮ",
  "	Į%*Vn",
  "º¾ÄÐÛæíôûĂ",
  "ĉĐĘěĦĨ"
].join(""), dg = new DS().deserialize(yk), xk = dg.decisionToState.map(function(t, e) {
  return new AS(t, e);
}), bk = new ES(), wk = [
  null,
  "'}'",
  "'opaque'",
  "';'",
  "'('",
  "')'",
  "'if'",
  "'=='",
  "'barrier'",
  "'OPENQASM'",
  "'include'",
  "'qreg'",
  "'['",
  "']'",
  "'creg'",
  "'gate'",
  "'{'",
  "'measure'",
  "'->'",
  "'reset'",
  "'U'",
  "'CX'",
  "','",
  "'^'",
  "'*'",
  "'/'",
  "'+'",
  "'-'",
  "'sin'",
  "'cos'",
  "'tan'",
  "'exp'",
  "'ln'",
  "'sqrt'",
  "'pi'"
], Nk = [
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "PI",
  "REAL",
  "SUBREAL",
  "EXPREAL",
  "INT",
  "ID",
  "WS",
  "FILENAME",
  "COMMENT",
  "LINE_COMMENT"
], Dk = [
  "mainprog",
  "statement",
  "version",
  "include",
  "filename",
  "decl",
  "gatedecl",
  "goplist",
  "qop",
  "uop",
  "anylist",
  "idlist",
  "mixedlist",
  "argument",
  "explist",
  "exp",
  "atom",
  "unaryop"
];
class Y extends mk {
  constructor(e) {
    super(e), this._interp = new dk(this, dg, xk, bk), this.ruleNames = Dk, this.literalNames = wk, this.symbolicNames = Nk;
  }
  unaryop = function() {
    var e = new Sg(this, this._ctx, this.state);
    this.enterRule(e, 34, Y.RULE_unaryop);
    var r = 0;
    try {
      this.enterOuterAlt(e, 1), this.state = 299, r = this._input.LA(1), !(r - 28 & -32) && 1 << r - 28 & (1 << Y.T__27 - 28 | 1 << Y.T__28 - 28 | 1 << Y.T__29 - 28 | 1 << Y.T__30 - 28 | 1 << Y.T__31 - 28 | 1 << Y.T__32 - 28) ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this);
    } catch (n) {
      if (n instanceof Sr)
        e.exception = n, this._errHandler.reportError(this, n), this._errHandler.recover(this, n);
      else
        throw n;
    } finally {
      this.exitRule();
    }
    return e;
  };
  sempred = function(e, r, n) {
    switch (r) {
      case 15:
        return this.exp_sempred(e, n);
      default:
        throw "No predicate with index:" + r;
    }
  };
  exp_sempred = function(e, r) {
    switch (r) {
      case 0:
        return this.precpred(this._ctx, 6);
      case 1:
        return this.precpred(this._ctx, 5);
      case 2:
        return this.precpred(this._ctx, 4);
      default:
        throw "No predicate with index:" + r;
    }
  };
  qop = function() {
    var e = new Ng(this, this._ctx, this.state);
    this.enterRule(e, 16, Y.RULE_qop);
    try {
      switch (this.state = 152, this._errHandler.sync(this), this._input.LA(1)) {
        case Y.T__19:
        case Y.T__20:
        case Y.ID:
          this.enterOuterAlt(e, 1), this.state = 141, this.uop();
          break;
        case Y.T__16:
          this.enterOuterAlt(e, 2), this.state = 142, this.match(Y.T__16), this.state = 143, this.argument(), this.state = 144, this.match(Y.T__17), this.state = 145, this.argument(), this.state = 146, this.match(Y.T__2);
          break;
        case Y.T__18:
          this.enterOuterAlt(e, 3), this.state = 148, this.match(Y.T__18), this.state = 149, this.argument(), this.state = 150, this.match(Y.T__2);
          break;
        default:
          throw new NoViableAltException(this);
      }
    } catch (r) {
      if (r instanceof Sr)
        e.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
      else
        throw r;
    } finally {
      this.exitRule();
    }
    return e;
  };
  exp = function(e) {
    e === void 0 && (e = 0);
    var r = this._ctx, n = this.state, a = new ci(this, this._ctx, n), s = a, o = 30;
    this.enterRecursionRule(a, 30, Y.RULE_exp, e);
    var p = 0;
    try {
      this.enterOuterAlt(a, 1), this.state = 281, this._errHandler.sync(this);
      var u = this._interp.adaptivePredict(this._input, 20, this._ctx);
      switch (u) {
        case 1:
          this.state = 263, this._errHandler.sync(this), p = this._input.LA(1), (p === Y.T__25 || p === Y.T__26) && (this.state = 262, p = this._input.LA(1), p === Y.T__25 || p === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this)), this.state = 265, this.match(Y.T__3), this.state = 266, this.exp(0), this.state = 267, this.match(Y.T__4);
          break;
        case 2:
          this.state = 270, this._errHandler.sync(this), p = this._input.LA(1), (p === Y.T__25 || p === Y.T__26) && (this.state = 269, p = this._input.LA(1), p === Y.T__25 || p === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this)), this.state = 272, this.unaryop(), this.state = 273, this.match(Y.T__3), this.state = 274, this.exp(0), this.state = 275, this.match(Y.T__4);
          break;
        case 3:
          this.state = 278, this._errHandler.sync(this), p = this._input.LA(1), (p === Y.T__25 || p === Y.T__26) && (this.state = 277, p = this._input.LA(1), p === Y.T__25 || p === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this)), this.state = 280, this.atom();
          break;
      }
      this._ctx.stop = this._input.LT(-1), this.state = 294, this._errHandler.sync(this);
      for (var f = this._interp.adaptivePredict(this._input, 22, this._ctx); f != 2 && f != ra.INVALID_ALT_NUMBER; ) {
        if (f === 1) {
          this._parseListeners !== null && this.triggerExitRuleEvent(), s = a, this.state = 292, this._errHandler.sync(this);
          var u = this._interp.adaptivePredict(this._input, 21, this._ctx);
          switch (u) {
            case 1:
              if (a = new ci(this, r, n), this.pushNewRecursionContext(a, o, Y.RULE_exp), this.state = 283, !this.precpred(this._ctx, 6))
                throw new FailedPredicateException(this, "this.precpred(this._ctx, 6)");
              this.state = 284, this.match(Y.T__22), this.state = 285, this.exp(7);
              break;
            case 2:
              if (a = new ci(this, r, n), this.pushNewRecursionContext(a, o, Y.RULE_exp), this.state = 286, !this.precpred(this._ctx, 5))
                throw new FailedPredicateException(this, "this.precpred(this._ctx, 5)");
              this.state = 287, p = this._input.LA(1), p === Y.T__23 || p === Y.T__24 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this), this.state = 288, this.exp(6);
              break;
            case 3:
              if (a = new ci(this, r, n), this.pushNewRecursionContext(a, o, Y.RULE_exp), this.state = 289, !this.precpred(this._ctx, 4))
                throw new FailedPredicateException(this, "this.precpred(this._ctx, 4)");
              this.state = 290, p = this._input.LA(1), p === Y.T__25 || p === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this), this.state = 291, this.exp(5);
              break;
          }
        }
        this.state = 296, this._errHandler.sync(this), f = this._interp.adaptivePredict(this._input, 22, this._ctx);
      }
    } catch (l) {
      if (l instanceof Sr)
        a.exception = l, this._errHandler.reportError(this, l), this._errHandler.recover(this, l);
      else
        throw l;
    } finally {
      this.unrollRecursionContexts(r);
    }
    return a;
  };
  statement = function() {
    var e = new bu(this, this._ctx, this.state);
    this.enterRule(e, 2, Y.RULE_statement);
    try {
      this.state = 84, this._errHandler.sync(this);
      var r = this._interp.adaptivePredict(this._input, 1, this._ctx);
      switch (r) {
        case 1:
          this.enterOuterAlt(e, 1), this.state = 43, this.decl();
          break;
        case 2:
          this.enterOuterAlt(e, 2), this.state = 44, this.gatedecl(), this.state = 45, this.goplist(), this.state = 46, this.match(Y.T__0);
          break;
        case 3:
          this.enterOuterAlt(e, 3), this.state = 48, this.gatedecl(), this.state = 49, this.match(Y.T__0);
          break;
        case 4:
          this.enterOuterAlt(e, 4), this.state = 51, this.match(Y.T__1), this.state = 52, this.match(Y.ID), this.state = 53, this.idlist(), this.state = 54, this.match(Y.T__2);
          break;
        case 5:
          this.enterOuterAlt(e, 5), this.state = 56, this.match(Y.T__1), this.state = 57, this.match(Y.ID), this.state = 58, this.match(Y.T__3), this.state = 59, this.match(Y.T__4), this.state = 60, this.idlist(), this.state = 61, this.match(Y.T__2);
          break;
        case 6:
          this.enterOuterAlt(e, 6), this.state = 63, this.match(Y.T__1), this.state = 64, this.match(Y.ID), this.state = 65, this.match(Y.T__3), this.state = 66, this.idlist(), this.state = 67, this.match(Y.T__4), this.state = 68, this.idlist(), this.state = 69, this.match(Y.T__2);
          break;
        case 7:
          this.enterOuterAlt(e, 7), this.state = 71, this.qop();
          break;
        case 8:
          this.enterOuterAlt(e, 8), this.state = 72, this.match(Y.T__5), this.state = 73, this.match(Y.T__3), this.state = 74, this.match(Y.ID), this.state = 75, this.match(Y.T__6), this.state = 76, this.match(Y.INT), this.state = 77, this.match(Y.T__4), this.state = 78, this.qop();
          break;
        case 9:
          this.enterOuterAlt(e, 9), this.state = 79, this.match(Y.T__7), this.state = 80, this.anylist(), this.state = 81, this.match(Y.T__2);
          break;
        case 10:
          this.enterOuterAlt(e, 10), this.state = 83, this.include();
          break;
      }
    } catch (n) {
      if (n instanceof Sr)
        e.exception = n, this._errHandler.reportError(this, n), this._errHandler.recover(this, n);
      else
        throw n;
    } finally {
      this.exitRule();
    }
    return e;
  };
}
Object.defineProperty(Y.prototype, "atn", {
  get: function() {
    return dg;
  }
});
Y.EOF = SS.EOF;
Y.T__0 = 1;
Y.T__1 = 2;
Y.T__2 = 3;
Y.T__3 = 4;
Y.T__4 = 5;
Y.T__5 = 6;
Y.T__6 = 7;
Y.T__7 = 8;
Y.T__8 = 9;
Y.T__9 = 10;
Y.T__10 = 11;
Y.T__11 = 12;
Y.T__12 = 13;
Y.T__13 = 14;
Y.T__14 = 15;
Y.T__15 = 16;
Y.T__16 = 17;
Y.T__17 = 18;
Y.T__18 = 19;
Y.T__19 = 20;
Y.T__20 = 21;
Y.T__21 = 22;
Y.T__22 = 23;
Y.T__23 = 24;
Y.T__24 = 25;
Y.T__25 = 26;
Y.T__26 = 27;
Y.T__27 = 28;
Y.T__28 = 29;
Y.T__29 = 30;
Y.T__30 = 31;
Y.T__31 = 32;
Y.T__32 = 33;
Y.PI = 34;
Y.REAL = 35;
Y.SUBREAL = 36;
Y.EXPREAL = 37;
Y.INT = 38;
Y.ID = 39;
Y.WS = 40;
Y.FILENAME = 41;
Y.COMMENT = 42;
Y.LINE_COMMENT = 43;
Y.RULE_mainprog = 0;
Y.RULE_statement = 1;
Y.RULE_version = 2;
Y.RULE_include = 3;
Y.RULE_filename = 4;
Y.RULE_decl = 5;
Y.RULE_gatedecl = 6;
Y.RULE_goplist = 7;
Y.RULE_qop = 8;
Y.RULE_uop = 9;
Y.RULE_anylist = 10;
Y.RULE_idlist = 11;
Y.RULE_mixedlist = 12;
Y.RULE_argument = 13;
Y.RULE_explist = 14;
Y.RULE_exp = 15;
Y.RULE_atom = 16;
Y.RULE_unaryop = 17;
class CS extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.contextType = "MainprogContext", this.parser = e, this.ruleIndex = Y.RULE_mainprog;
  }
  version = function() {
    return this.getTypedRuleContext(vg, 0);
  };
  statement = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(bu) : this.getTypedRuleContext(bu, e);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterMainprog(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitMainprog(this);
  };
}
Y.MainprogContext = CS;
Y.prototype.mainprog = function() {
  var t = new CS(this, this._ctx, this.state);
  this.enterRule(t, 0, Y.RULE_mainprog);
  var e = 0;
  try {
    for (this.enterOuterAlt(t, 1), this.state = 36, this.version(), this.state = 40, this._errHandler.sync(this), e = this._input.LA(1); !(e & -32) && 1 << e & (1 << Y.T__1 | 1 << Y.T__5 | 1 << Y.T__7 | 1 << Y.T__9 | 1 << Y.T__10 | 1 << Y.T__13 | 1 << Y.T__14 | 1 << Y.T__16 | 1 << Y.T__18 | 1 << Y.T__19 | 1 << Y.T__20) || e === Y.ID; )
      this.state = 37, this.statement(), this.state = 42, this._errHandler.sync(this), e = this._input.LA(1);
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class bu extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_statement;
  }
  decl = function() {
    return this.getTypedRuleContext(xg, 0);
  };
  gatedecl = function() {
    return this.getTypedRuleContext(bg, 0);
  };
  goplist = function() {
    return this.getTypedRuleContext(wg, 0);
  };
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  idlist = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(mi) : this.getTypedRuleContext(mi, e);
  };
  qop = function() {
    return this.getTypedRuleContext(Ng, 0);
  };
  INT = function() {
    return this.getToken(Y.INT, 0);
  };
  anylist = function() {
    return this.getTypedRuleContext(Em, 0);
  };
  include = function() {
    return this.getTypedRuleContext(gg, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterStatement(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitStatement(this);
  };
}
Y.StatementContext = bu;
class vg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.contextType = "VersionContext", this.parser = e, this.ruleIndex = Y.RULE_version;
  }
  REAL = function() {
    return this.getToken(Y.REAL, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterVersion(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitVersion(this);
  };
}
Y.VersionContext = vg;
Y.prototype.version = function() {
  var t = new vg(this, this._ctx, this.state);
  this.enterRule(t, 4, Y.RULE_version);
  try {
    this.enterOuterAlt(t, 1), this.state = 86, this.match(Y.T__8), this.state = 87, this.match(Y.REAL), this.state = 88, this.match(Y.T__2);
  } catch (e) {
    if (e instanceof Sr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class gg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_include;
  }
  filename = function() {
    return this.getTypedRuleContext(yg, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterInclude(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitInclude(this);
  };
}
Y.IncludeContext = gg;
Y.prototype.include = function() {
  var t = new gg(this, this._ctx, this.state);
  this.enterRule(t, 6, Y.RULE_include);
  try {
    this.enterOuterAlt(t, 1), this.state = 90, this.match(Y.T__9), this.state = 91, this.filename(), this.state = 92, this.match(Y.T__2);
  } catch (e) {
    if (e instanceof Sr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class yg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_filename;
  }
  FILENAME = function() {
    return this.getToken(Y.FILENAME, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterFilename(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitFilename(this);
  };
}
Y.FilenameContext = yg;
Y.prototype.filename = function() {
  var t = new yg(this, this._ctx, this.state);
  this.enterRule(t, 8, Y.RULE_filename);
  try {
    this.enterOuterAlt(t, 1), this.state = 94, this.match(Y.FILENAME);
  } catch (e) {
    if (e instanceof Sr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class xg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_decl;
  }
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  INT = function() {
    return this.getToken(Y.INT, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterDecl(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitDecl(this);
  };
}
Y.DeclContext = xg;
Y.prototype.decl = function() {
  var t = new xg(this, this._ctx, this.state);
  this.enterRule(t, 10, Y.RULE_decl);
  try {
    switch (this.state = 108, this._errHandler.sync(this), this._input.LA(1)) {
      case Y.T__10:
        this.enterOuterAlt(t, 1), this.state = 96, this.match(Y.T__10), this.state = 97, this.match(Y.ID), this.state = 98, this.match(Y.T__11), this.state = 99, this.match(Y.INT), this.state = 100, this.match(Y.T__12), this.state = 101, this.match(Y.T__2);
        break;
      case Y.T__13:
        this.enterOuterAlt(t, 2), this.state = 102, this.match(Y.T__13), this.state = 103, this.match(Y.ID), this.state = 104, this.match(Y.T__11), this.state = 105, this.match(Y.INT), this.state = 106, this.match(Y.T__12), this.state = 107, this.match(Y.T__2);
        break;
      default:
        throw new NoViableAltException(this);
    }
  } catch (e) {
    if (e instanceof Sr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class bg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_gatedecl;
  }
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  idlist = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(mi) : this.getTypedRuleContext(mi, e);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterGatedecl(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitGatedecl(this);
  };
}
Y.GatedeclContext = bg;
Y.prototype.gatedecl = function() {
  var t = new bg(this, this._ctx, this.state);
  this.enterRule(t, 12, Y.RULE_gatedecl);
  try {
    this.state = 130, this._errHandler.sync(this);
    var e = this._interp.adaptivePredict(this._input, 3, this._ctx);
    switch (e) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 110, this.match(Y.T__14), this.state = 111, this.match(Y.ID), this.state = 112, this.idlist(), this.state = 113, this.match(Y.T__15);
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 115, this.match(Y.T__14), this.state = 116, this.match(Y.ID), this.state = 117, this.match(Y.T__3), this.state = 118, this.match(Y.T__4), this.state = 119, this.idlist(), this.state = 120, this.match(Y.T__15);
        break;
      case 3:
        this.enterOuterAlt(t, 3), this.state = 122, this.match(Y.T__14), this.state = 123, this.match(Y.ID), this.state = 124, this.match(Y.T__3), this.state = 125, this.idlist(), this.state = 126, this.match(Y.T__4), this.state = 127, this.idlist(), this.state = 128, this.match(Y.T__15);
        break;
    }
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class wg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_goplist;
  }
  uop = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(Ps) : this.getTypedRuleContext(Ps, e);
  };
  idlist = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(mi) : this.getTypedRuleContext(mi, e);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterGoplist(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitGoplist(this);
  };
}
Y.GoplistContext = wg;
Y.prototype.goplist = function() {
  var t = new wg(this, this._ctx, this.state);
  this.enterRule(t, 14, Y.RULE_goplist);
  var e = 0;
  try {
    this.enterOuterAlt(t, 1), this.state = 137, this._errHandler.sync(this), e = this._input.LA(1);
    do {
      switch (this.state = 137, this._errHandler.sync(this), this._input.LA(1)) {
        case Y.T__19:
        case Y.T__20:
        case Y.ID:
          this.state = 132, this.uop();
          break;
        case Y.T__7:
          this.state = 133, this.match(Y.T__7), this.state = 134, this.idlist(), this.state = 135, this.match(Y.T__2);
          break;
        default:
          throw new NoViableAltException(this);
      }
      this.state = 139, this._errHandler.sync(this), e = this._input.LA(1);
    } while (!(e - 8 & -32) && 1 << e - 8 & (1 << Y.T__7 - 8 | 1 << Y.T__19 - 8 | 1 << Y.T__20 - 8 | 1 << Y.ID - 8));
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class Ng extends Mr {
  constructor(e, r, n) {
    return r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_qop, this;
  }
  uop = function() {
    return this.getTypedRuleContext(Ps, 0);
  };
  argument = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(Qa) : this.getTypedRuleContext(Qa, e);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterQop(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitQop(this);
  };
}
Y.QopContext = Ng;
class Ps extends Mr {
  constructor(e, r, n) {
    return r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_uop, this;
  }
  explist = function() {
    return this.getTypedRuleContext(Ag, 0);
  };
  argument = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(Qa) : this.getTypedRuleContext(Qa, e);
  };
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  anylist = function() {
    return this.getTypedRuleContext(Em, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterUop(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitUop(this);
  };
}
Y.UopContext = Ps;
Y.prototype.uop = function() {
  var t = new Ps(this, this._ctx, this.state);
  this.enterRule(t, 18, Y.RULE_uop);
  try {
    this.state = 184, this._errHandler.sync(this);
    var e = this._interp.adaptivePredict(this._input, 7, this._ctx);
    switch (e) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 154, this.match(Y.T__19), this.state = 155, this.match(Y.T__3), this.state = 156, this.explist(), this.state = 157, this.match(Y.T__4), this.state = 158, this.argument(), this.state = 159, this.match(Y.T__2);
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 161, this.match(Y.T__20), this.state = 162, this.argument(), this.state = 163, this.match(Y.T__21), this.state = 164, this.argument(), this.state = 165, this.match(Y.T__2);
        break;
      case 3:
        this.enterOuterAlt(t, 3), this.state = 167, this.match(Y.ID), this.state = 168, this.anylist(), this.state = 169, this.match(Y.T__2);
        break;
      case 4:
        this.enterOuterAlt(t, 4), this.state = 171, this.match(Y.ID), this.state = 172, this.match(Y.T__3), this.state = 173, this.match(Y.T__4), this.state = 174, this.anylist(), this.state = 175, this.match(Y.T__2);
        break;
      case 5:
        this.enterOuterAlt(t, 5), this.state = 177, this.match(Y.ID), this.state = 178, this.match(Y.T__3), this.state = 179, this.explist(), this.state = 180, this.match(Y.T__4), this.state = 181, this.anylist(), this.state = 182, this.match(Y.T__2);
        break;
    }
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class Em extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_anylist;
  }
  idlist = function() {
    return this.getTypedRuleContext(mi, 0);
  };
  mixedlist = function() {
    return this.getTypedRuleContext(Dg, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterAnylist(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitAnylist(this);
  };
}
Y.AnylistContext = Em;
Y.prototype.anylist = function() {
  var t = new Em(this, this._ctx, this.state);
  this.enterRule(t, 20, Y.RULE_anylist);
  try {
    this.state = 188, this._errHandler.sync(this);
    var e = this._interp.adaptivePredict(this._input, 8, this._ctx);
    switch (e) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 186, this.idlist();
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 187, this.mixedlist();
        break;
    }
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class mi extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_idlist;
  }
  ID = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTokens(Y.ID) : this.getToken(Y.ID, e);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterIdlist(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitIdlist(this);
  };
}
Y.IdlistContext = mi;
Y.prototype.idlist = function() {
  var t = new mi(this, this._ctx, this.state);
  this.enterRule(t, 22, Y.RULE_idlist);
  try {
    this.enterOuterAlt(t, 1), this.state = 194, this._errHandler.sync(this);
    for (var e = this._interp.adaptivePredict(this._input, 9, this._ctx); e !== 2 && e !== ra.INVALID_ALT_NUMBER; )
      e === 1 && (this.state = 190, this.match(Y.ID), this.state = 191, this.match(Y.T__21)), this.state = 196, this._errHandler.sync(this), e = this._interp.adaptivePredict(this._input, 9, this._ctx);
    this.state = 197, this.match(Y.ID);
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class Dg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_mixedlist;
  }
  ID = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTokens(Y.ID) : this.getToken(Y.ID, e);
  };
  INT = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTokens(Y.INT) : this.getToken(Y.INT, e);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterMixedlist(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitMixedlist(this);
  };
}
Y.MixedlistContext = Dg;
Y.prototype.mixedlist = function() {
  var t = new Dg(this, this._ctx, this.state);
  this.enterRule(t, 24, Y.RULE_mixedlist);
  try {
    this.state = 242, this._errHandler.sync(this);
    var e = this._interp.adaptivePredict(this._input, 14, this._ctx);
    switch (e) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 206, this._errHandler.sync(this);
        for (var r = this._interp.adaptivePredict(this._input, 10, this._ctx); r !== 2 && r !== ra.INVALID_ALT_NUMBER; )
          r === 1 && (this.state = 199, this.match(Y.ID), this.state = 200, this.match(Y.T__11), this.state = 201, this.match(Y.INT), this.state = 202, this.match(Y.T__12), this.state = 203, this.match(Y.T__21)), this.state = 208, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 10, this._ctx);
        this.state = 209, this.match(Y.ID);
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 217, this._errHandler.sync(this);
        for (var r = this._interp.adaptivePredict(this._input, 11, this._ctx); r != 2 && r != ra.INVALID_ALT_NUMBER; )
          r === 1 && (this.state = 210, this.match(Y.ID), this.state = 211, this.match(Y.T__11), this.state = 212, this.match(Y.INT), this.state = 213, this.match(Y.T__12), this.state = 214, this.match(Y.T__21)), this.state = 219, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 11, this._ctx);
        this.state = 220, this.match(Y.ID), this.state = 221, this.match(Y.T__11), this.state = 222, this.match(Y.INT), this.state = 223, this.match(Y.T__12);
        break;
      case 3:
        this.enterOuterAlt(t, 3), this.state = 235, this._errHandler.sync(this);
        for (var r = this._interp.adaptivePredict(this._input, 13, this._ctx); r != 2 && r != ra.INVALID_ALT_NUMBER; ) {
          if (r === 1) {
            this.state = 228, this._errHandler.sync(this);
            for (var r = this._interp.adaptivePredict(this._input, 12, this._ctx); r != 2 && r != ra.INVALID_ALT_NUMBER; )
              r === 1 && (this.state = 224, this.match(Y.ID), this.state = 225, this.match(Y.T__21)), this.state = 230, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 12, this._ctx);
            this.state = 231, this.match(Y.ID), this.state = 232, this.match(Y.T__21);
          }
          this.state = 237, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 13, this._ctx);
        }
        this.state = 238, this.match(Y.ID), this.state = 239, this.match(Y.T__11), this.state = 240, this.match(Y.INT), this.state = 241, this.match(Y.T__12);
        break;
    }
  } catch (n) {
    if (n instanceof Sr)
      t.exception = n, this._errHandler.reportError(this, n), this._errHandler.recover(this, n);
    else
      throw n;
  } finally {
    this.exitRule();
  }
  return t;
};
class Qa extends Mr {
  constructor(e, r, n) {
    return r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_argument, this;
  }
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  INT = function() {
    return this.getToken(Y.INT, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterArgument(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitArgument(this);
  };
}
Y.ArgumentContext = Qa;
Y.prototype.argument = function() {
  var t = new Qa(this, this._ctx, this.state);
  this.enterRule(t, 26, Y.RULE_argument);
  try {
    this.state = 249, this._errHandler.sync(this);
    var e = this._interp.adaptivePredict(this._input, 15, this._ctx);
    switch (e) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 244, this.match(Y.ID);
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 245, this.match(Y.ID), this.state = 246, this.match(Y.T__11), this.state = 247, this.match(Y.INT), this.state = 248, this.match(Y.T__12);
        break;
    }
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class Ag extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_explist;
  }
  exp = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(ci) : this.getTypedRuleContext(ci, e);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterExplist(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitExplist(this);
  };
}
Y.ExplistContext = Ag;
Y.prototype.explist = function() {
  var t = new Ag(this, this._ctx, this.state);
  this.enterRule(t, 28, Y.RULE_explist);
  try {
    this.enterOuterAlt(t, 1), this.state = 256, this._errHandler.sync(this);
    for (var e = this._interp.adaptivePredict(this._input, 16, this._ctx); e != 2 && e != ra.INVALID_ALT_NUMBER; )
      e === 1 && (this.state = 251, this.exp(0), this.state = 252, this.match(Y.T__21)), this.state = 258, this._errHandler.sync(this), e = this._interp.adaptivePredict(this._input, 16, this._ctx);
    this.state = 259, this.exp(0);
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class ci extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_exp;
  }
  exp = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(ci) : this.getTypedRuleContext(ci, e);
  };
  unaryop = function() {
    return this.getTypedRuleContext(Sg, 0);
  };
  atom = function() {
    return this.getTypedRuleContext(Eg, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterExp(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitExp(this);
  };
}
class Eg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_atom;
  }
  INT = function() {
    return this.getToken(Y.INT, 0);
  };
  REAL = function() {
    return this.getToken(Y.REAL, 0);
  };
  PI = function() {
    return this.getToken(Y.PI, 0);
  };
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  enterRule = function(e) {
    e instanceof Mt && e.enterAtom(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitAtom(this);
  };
}
Y.AtomContext = Eg;
Y.prototype.atom = function() {
  var t = new Eg(this, this._ctx, this.state);
  this.enterRule(t, 32, Y.RULE_atom);
  var e = 0;
  try {
    this.enterOuterAlt(t, 1), this.state = 297, e = this._input.LA(1), !(e - 34 & -32) && 1 << e - 34 & (1 << Y.PI - 34 | 1 << Y.REAL - 34 | 1 << Y.INT - 34 | 1 << Y.ID - 34) ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this);
  } catch (r) {
    if (r instanceof Sr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class Sg extends Mr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_unaryop;
  }
  enterRule = function(e) {
    e instanceof Mt && e.enterUnaryop(this);
  };
  exitRule = function(e) {
    e instanceof Mt && e.exitUnaryop(this);
  };
}
Y.UnaryopContext = Sg;
/**
 * @license
 *
 * Copyright (c) 2016, Petar Korponaić <petar.korponaic@gmail.com>
 *
 * This source code is licensed under the MIT License, found in
 * the LICENSE.txt file in the root directory of this source tree.
 */
var wu = function(t) {
  return hg.call(this), this.errors = t, this;
};
wu.prototype = Object.create(wu.prototype);
wu.prototype.constructor = hg;
wu.prototype.syntaxError = function(t, e, r, n, a, s) {
  this.errors.push({
    line: r,
    col: n,
    msg: a
  });
};
class Ak extends Mt {
  constructor(e, r) {
    super(), this.circuit = e, this.qregMap = {}, this.condition = {}, this.compatibilityMode = r;
  }
  numQbit = function() {
    var e = 0;
    for (var r in this.qregMap)
      e += this.qregMap[r];
    return e;
  };
  qregBase = function(e) {
    var r = 0;
    for (var n in this.qregMap) {
      if (n == e)
        return r;
      r += this.qregMap[n];
    }
    return r;
  };
  qregLen = function(e) {
    return this.qregMap[e] || 0;
  };
  // Enter a parse tree produced by QASMParser#mainprog.
  enterMainprog = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mainprog.
  exitMainprog = function(e) {
  };
  // Enter a parse tree produced by QASMParser#statement.
  enterStatement = function(e) {
    var r = this, n = e.getChildCount() ? e.getChild(0).getText() : "";
    if (n == "if" && (this.condition = {
      creg: e.ID().getText(),
      value: parseInt(e.INT().getText())
    }), e.gatedecl()) {
      var a = e.gatedecl(), s = [], o = [], p = a.getChildCount();
      p > 2 && a.getChild(2).ID ? s = a.getChild(2).ID() : (p > 3 && a.getChild(3).ID && (o = a.getChild(3).ID()), p > 5 && a.getChild(5).ID && (s = a.getChild(5).ID()));
      var u = Object.getPrototypeOf(this.circuit), f = new u.constructor(s.length), l = a.ID().getText(), c = [];
      if (s.map(function(d) {
        c.push(d.getText());
      }), o.map(function(d) {
        var g = d.getText();
        f.params.push(g);
      }), e.goplist()) {
        var h = e.goplist();
        h.uop().map(function(d) {
          var g = d.ID() ? d.ID().getText() : "";
          if (g) {
            var v = d.anylist() ? d.anylist().idlist() : null;
            d.anylist() && d.anylist().mixedlist();
            var N = d.explist();
            switch (g) {
              case "CX":
                g = "cx";
                break;
              case "U":
                g = "u3";
                break;
            }
            if (!r.circuit.basicGates[g] && !r.circuit.customGates[g])
              for (var b in r.circuit.basicGates) {
                var C = r.circuit.basicGates[b];
                if (C.exportInfo && C.exportInfo.qasm && C.exportInfo.qasm.name && C.exportInfo.qasm.name == g) {
                  g = b;
                  break;
                }
                if (C.exportInfo && C.exportInfo.qiskit && C.exportInfo.qiskit.name && C.exportInfo.qiskit.name == g) {
                  g = b;
                  break;
                }
              }
            var x = {};
            if (N && N.exp()) {
              var E = r.circuit.basicGates[g];
              if (E || (E = r.circuit.customGates[g]), E) {
                var D = N.exp(), A = E.params || [];
                D.map(function(q, $) {
                  var U = q.getText(), k = A.length >= $ ? A[$] : "";
                  k && (x[k] = U);
                });
              }
            }
            var M = { params: x }, _ = [];
            if (v)
              for (var O = v.ID().length, T = 0; T < O; T++)
                _.push(c.indexOf(v.ID()[T].getText()));
            var I = r.circuit.customGates[g];
            I && f.registerGate(g, JSON.parse(JSON.stringify(I))), f.addGate(g, -1, _, M);
          }
        });
      }
      this.circuit.registerGate(l, f.save(!1));
    }
  };
  // Exit a parse tree produced by QASMParser#statement.
  exitStatement = function(e) {
  };
  // Enter a parse tree produced by QASMParser#version.
  enterVersion = function(e) {
  };
  // Exit a parse tree produced by QASMParser#version.
  exitVersion = function(e) {
  };
  // Enter a parse tree produced by QASMParser#decl.
  enterDecl = function(e) {
    switch (e.getChild(0).getText()) {
      case "qreg":
        this.qregMap[e.getChild(1).getText()] = parseInt(e.getChild(3).getText());
        break;
      case "creg":
        this.circuit.createCreg(e.getChild(1).getText(), parseInt(e.getChild(3).getText()));
        break;
    }
  };
  // Exit a parse tree produced by QASMParser#decl.
  exitDecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#gatedecl.
  enterGatedecl = function(e) {
  };
  // Exit a parse tree produced by QASMParser#gatedecl.
  exitGatedecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#goplist.
  enterGoplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#goplist.
  exitGoplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#qop.
  enterQop = function(e) {
    var r = this, n = JSON.parse(JSON.stringify(this.condition));
    this.condition = {};
    var a = e.getChildCount() ? e.getChild(0).getText() : "";
    if (a == "reset") {
      for (var s = "", o = -1, p = e.argument().length, u = 0; u < p; u++) {
        var f = e.argument()[u];
        u == 0 && (s = f.ID().getText(), o = f.INT() ? parseInt(f.INT().getText()) : -1);
      }
      if (s) {
        var l = r.qregLen(s);
        if (o < 0)
          for (var c = 0; c < l; c++)
            r.circuit.addGate("reset", -1, c + r.qregBase(s), { condition: n || {} });
        else
          r.circuit.addGate("reset", -1, o + r.qregBase(s), { condition: n || {} });
      }
    }
    if (a == "measure") {
      for (var s = "", o = -1, h = "", d = -1, p = e.argument().length, u = 0; u < p; u++) {
        var f = e.argument()[u];
        u == 0 && (s = f.ID().getText(), o = f.INT() ? parseInt(f.INT().getText()) : -1), u == 1 && (h = f.ID().getText(), d = f.INT() ? parseInt(f.INT().getText()) : -1);
      }
      if (s && h) {
        var l = r.qregLen(s);
        if (o < 0 && d < 0)
          for (var c = 0; c < l; c++)
            r.circuit.addGate("measure", -1, c + r.qregBase(s), { creg: { name: h, bit: c }, condition: n || {} });
        else if (o >= 0 && d >= 0)
          r.circuit.addGate("measure", -1, o + r.qregBase(s), { creg: { name: h, bit: d }, condition: n || {} });
        else if (o >= 0 && d < 0)
          for (var c = 0; c < l; c++)
            r.circuit.addGate("measure", -1, o + r.qregBase(s), { creg: { name: h, bit: c }, condition: n || {} });
        else
          for (var c = 0; c < l; c++)
            r.circuit.addGate("measure", -1, c + r.qregBase(s), { creg: { name: h, bit: d }, condition: n || {} });
      }
    }
    var g = e.uop();
    if (g && g.ID()) {
      var v = g.ID().getText(), N = g.anylist() ? g.anylist().idlist() : null, b = g.anylist() ? g.anylist().mixedlist() : null, C = g.explist();
      switch (v) {
        case "CX":
          v = "cx";
          break;
        case "U":
          v = "u3";
          break;
      }
      if (!r.circuit.basicGates[v] && !r.circuit.customGates[v])
        for (var x in r.circuit.basicGates) {
          var E = r.circuit.basicGates[x];
          if (E.exportInfo && E.exportInfo.qasm && E.exportInfo.qasm.name && E.exportInfo.qasm.name == v) {
            v = x;
            break;
          }
          if (E.exportInfo && E.exportInfo.qiskit && E.exportInfo.qiskit.name && E.exportInfo.qiskit.name == v) {
            v = x;
            break;
          }
        }
      var D = {};
      if (C && C.exp()) {
        var A = r.circuit.basicGates[v];
        if (A || (A = r.circuit.customGates[v]), A) {
          var M = C.exp(), _ = A.params || [];
          M.map(function(q, $) {
            var U = q.getText(), k = _.length >= $ ? _[$] : "";
            k && (D[k] = U);
          });
        }
      }
      var O = { params: D, condition: n || {} };
      if (N)
        for (var l = r.qregLen(N.ID()[0].getText()), c = 0; c < l; c++) {
          for (var T = [], p = N.ID().length, u = 0; u < p; u++)
            T.push({ reg: N.ID()[u].getText(), bit: c });
          var I = [];
          T.map(function(k) {
            I.push(k.bit + r.qregBase(k.reg));
          }), r.circuit.addGate(v, -1, I, O);
        }
      if (b && b.ID().length == b.INT().length) {
        for (var T = [], p = b.ID().length, u = 0; u < p; u++)
          T.push({ reg: b.ID()[u].getText(), bit: parseInt(b.INT()[u].getText()) });
        var I = [];
        T.map(function(k) {
          I.push(k.bit + r.qregBase(k.reg));
        }), r.circuit.addGate(v, -1, I, O);
      }
    }
  };
  // Exit a parse tree produced by QASMParser#qop.
  exitQop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#uop.
  enterUop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#uop.
  exitUop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#anylist.
  enterAnylist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#anylist.
  exitAnylist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#idlist.
  enterIdlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#idlist.
  exitIdlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#mixedlist.
  enterMixedlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mixedlist.
  exitMixedlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#argument.
  enterArgument = function(e) {
  };
  // Exit a parse tree produced by QASMParser#argument.
  exitArgument = function(e) {
  };
  // Enter a parse tree produced by QASMParser#explist.
  enterExplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#explist.
  exitExplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#exp.
  enterExp = function(e) {
  };
  // Exit a parse tree produced by QASMParser#exp.
  exitExp = function(e) {
  };
  // Enter a parse tree produced by QASMParser#unaryop.
  enterUnaryop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#unaryop.
  exitUnaryop = function(e) {
  };
}
const Ek = function(e, r, n, a) {
  var s = new lk(r), o = new vt(s), p = new uk(o), u = new Y(p);
  u.buildParseTrees = !0, u.removeErrorListeners();
  var f = [], l = new hg(f);
  u.addErrorListener(l);
  var c = u.mainprog(), h = new Ak(e, a);
  hk.DEFAULT.walk(h, c), n && n(f);
};
/**
 * @license
 *
 * Copyright (c) 2016, Petar Korponaić <petar.korponaic@gmail.com>
 *
 * This source code is licensed under the MIT License, found in
 * the LICENSE.txt file in the root directory of this source tree.
 */
var _s = function(t, e, r) {
  r = r || {};
  var n = Nu(t, r), a = JSON.parse(JSON.stringify(r));
  a.plusChar = "+";
  var s = Nu(e, a);
  return n + s + (r.iotaChar ? r.iotaChar : "i");
}, Nu = function(t, e) {
  e = e || {}, e.decimalPlaces && (t = kt(t, e.decimalPlaces));
  var r = t + "";
  e.fixedWidth && (r = t.toFixed(e.decimalPlaces || 14));
  var n = e.plusChar;
  return e.fixedWidth && !n && (n = " "), n && t >= 0 && (r = n + r), r;
}, Cr = function(t, e) {
  maxN = e || t + 1, maxN > 0 && (maxN = maxN - 1), maxLen = maxN.toString(26).length;
  for (var r = t.toString(26); r.length < maxLen; )
    r = "0" + r;
  for (var n = "", a = 0; a < r.length; a++) {
    var s = r.charCodeAt(a);
    n += String.fromCharCode(s < 97 ? s + 49 : s + 10);
  }
  return n;
};
const ge = function(e) {
  this.basicGates = {
    id: {
      description: "Single qubit identity gate",
      matrix: [
        [1, 0],
        [0, 1]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "ID"
      },
      exportInfo: {
        quil: {
          name: "I"
        },
        cirq: {
          name: "I",
          notTfqSupported: !0
        },
        quest: {
          name: "compactUnitary",
          params: {
            alpha: "(Complex) { .real = 1, .imag = 0 }",
            beta: "(Complex) {.real = 0, .imag = 0}"
          }
        },
        qsharp: {
          name: "I"
        },
        qiskit: {
          name: "id"
        },
        braket: {
          name: "i"
        },
        aqasm: {
          name: "I"
        }
      }
    },
    x: {
      description: 'Pauli X (PI rotation over X-axis) aka "NOT" gate',
      matrix: [
        [0, 1],
        [1, 0]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "X"
      },
      exportInfo: {
        quil: {
          name: "X"
        },
        cirq: {
          name: "X"
        },
        quest: {
          name: "pauliX"
        },
        qsharp: {
          name: "X"
        },
        quirk: {
          name: "X"
        },
        braket: {
          name: "x"
        },
        aqasm: {
          name: "X"
        },
        ionq: {
          names: ["x", "not"]
        }
      }
    },
    y: {
      description: "Pauli Y (PI rotation over Y-axis)",
      matrix: [
        [0, "-i"],
        ["i", 0]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Y"
      },
      exportInfo: {
        quil: {
          name: "Y"
        },
        cirq: {
          name: "Y"
        },
        quest: {
          name: "pauliY"
        },
        qsharp: {
          name: "Y"
        },
        quirk: {
          name: "Y"
        },
        braket: {
          name: "y"
        },
        aqasm: {
          name: "Y"
        },
        ionq: {
          name: "y"
        }
      }
    },
    z: {
      description: "Pauli Z (PI rotation over Z-axis)",
      matrix: [
        [1, 0],
        [0, -1]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z"
      },
      exportInfo: {
        quil: {
          name: "Z"
        },
        cirq: {
          name: "Z"
        },
        quest: {
          name: "pauliZ"
        },
        qsharp: {
          name: "Z"
        },
        quirk: {
          name: "Z"
        },
        braket: {
          name: "z"
        },
        aqasm: {
          name: "Z"
        },
        ionq: {
          name: "z"
        }
      }
    },
    h: {
      description: "Hadamard gate",
      matrix: [
        ["1 / sqrt(2)", "1 / sqrt(2)"],
        ["1 / sqrt(2)", "-1 / sqrt(2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "H"
      },
      exportInfo: {
        quil: {
          name: "H"
        },
        cirq: {
          name: "H"
        },
        quest: {
          name: "hadamard"
        },
        qsharp: {
          name: "H"
        },
        quirk: {
          name: "H"
        },
        braket: {
          name: "h"
        },
        aqasm: {
          name: "H"
        },
        ionq: {
          name: "h"
        }
      }
    },
    srn: {
      description: "Square root of NOT",
      matrix: [
        ["0.5+0.5i", "0.5-0.5i"],
        ["0.5-0.5i", "0.5+0.5i"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "&#x221A;X"
      },
      exportInfo: {
        quil: {
          name: "srn",
          defgate: `DEFGATE srn:
    0.5+0.5i, 0.5-0.5i
    0.5-0.5i, 0.5+0.5i`
        },
        pyquil: {
          name: "srn",
          array: "[[0.5+0.5j, 0.5-0.5j], [0.5-0.5j, 0.5+0.5j]]"
        },
        cirq: {
          name: "X**(1/2)"
        },
        quest: {
          name: "unitary",
          matrix: [
            [["0.5", "0.5"], ["0.5", "-0.5"]],
            [["0.5", "-0.5"], ["0.5", "0.5"]]
          ]
        },
        qasm: {
          name: "sx"
        },
        qiskit: {
          name: "sx"
        },
        braket: {
          name: "v"
        },
        aqasm: {
          matrix: [["0.5+0.5i", "0.5-0.5i"], ["0.5-0.5i", "0.5+0.5i"]],
          array: "[[0.5+0.5j, 0.5-0.5j], [0.5-0.5j, 0.5+0.5j]]"
        },
        ionq: {
          name: "v"
        }
      }
    },
    srndg: {
      description: "Inverse square root of NOT",
      matrix: [
        ["0.5-0.5i", "0.5+0.5i"],
        ["0.5+0.5i", "0.5-0.5i"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "&#x221A;X&#8224;"
      },
      exportInfo: {
        quil: {
          name: "srndg",
          defgate: `DEFGATE srndg:
    0.5-0.5i, 0.5+0.5i
    0.5+0.5i, 0.5-0.5i`
        },
        pyquil: {
          name: "srndg",
          array: "[[0.5-0.5j, 0.5+0.5j], [0.5+0.5j, 0.5-0.5j]]"
        },
        cirq: {
          name: "X**(-1/2)"
        },
        quest: {
          name: "unitary",
          matrix: [
            [["0.5", "-0.5"], ["0.5", "0.5"]],
            [["0.5", "0.5"], ["0.5", "-0.5"]]
          ]
        },
        qasm: {
          name: "sxdg"
        },
        qiskit: {
          name: "sxdg"
        },
        braket: {
          name: "vi"
        },
        aqasm: {
          matrix: [["0.5-0.5i", "0.5+0.5i"], ["0.5+0.5i", "0.5-0.5i"]],
          array: "[[0.5-0.5j, 0.5+0.5j], [0.5+0.5j, 0.5-0.5j]]"
        },
        ionq: {
          name: "vi"
        }
      }
    },
    r2: {
      description: 'PI/2 rotation over Z-axis aka "Phase PI/2"',
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z&#x1D6D1;/2"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "s"
          }
        },
        cirq: {
          replacement: {
            name: "s"
          }
        },
        quest: {
          name: "sGate"
        },
        qsharp: {
          replacement: {
            name: "s"
          }
        },
        qasm: {
          replacement: [
            { name: "s", params: {} }
          ]
        },
        qiskit: {
          replacement: [
            { name: "s", params: {} }
          ]
        },
        quirk: {
          name: "Z^½"
        },
        braket: {
          name: "s"
        },
        aqasm: {
          name: "S"
        }
      }
    },
    r4: {
      description: 'PI/4 rotation over Z-axis aka "Phase PI/4"',
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 4)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z&#x1D6D1;/4"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "t"
          }
        },
        cirq: {
          replacement: {
            name: "t"
          }
        },
        quest: {
          name: "tGate"
        },
        qsharp: {
          replacement: {
            name: "t"
          }
        },
        qasm: {
          replacement: [
            { name: "t", params: {} }
          ]
        },
        qiskit: {
          replacement: [
            { name: "t", params: {} }
          ]
        },
        quirk: {
          name: "Z^¼"
        },
        braket: {
          name: "t"
        },
        aqasm: {
          name: "T"
        }
      }
    },
    r8: {
      description: 'PI/8 rotation over Z-axis aka "Phase PI/8"',
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 8)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z&#x1D6D1;/8"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "u1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        cirq: {
          replacement: {
            name: "u1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        quest: {
          name: "phaseShift",
          params: { theta: "M_PI/8" }
        },
        qsharp: {
          replacement: {
            name: "u1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "u1", params: { lambda: "pi/8" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "u1", params: { lambda: "pi/8" } }
          ]
        },
        quirk: {
          name: "Z^⅛"
        },
        braket: {
          name: "phaseshift",
          params: { theta: "pi/8" }
        },
        aqasm: {
          matrix: [[1, 0], [0, "exp(i * pi / 8)"]],
          array: "[[1,0],[0,np.exp(1j * np.pi / 8)]]"
        }
      }
    },
    rx: {
      description: "Rotation around the X-axis by given angle",
      matrix: [
        ["cos(theta / 2)", "-i * sin(theta / 2)"],
        ["-i * sin(theta / 2)", "cos(theta / 2)"]
      ],
      params: ["theta"],
      drawingInfo: {
        connectors: ["box"],
        label: "RX"
      },
      exportInfo: {
        quil: {
          name: "RX",
          params: ["theta"]
        },
        cirq: {
          name: "rx",
          params: ["theta"]
        },
        quest: {
          name: "rotateX",
          params: ["theta"]
        },
        qsharp: {
          name: "Rx",
          params: ["theta"]
        },
        braket: {
          name: "rx",
          params: ["theta"]
        },
        aqasm: {
          name: "RX"
        },
        ionq: {
          name: "rx",
          paramsKey: "rotation"
        }
      }
    },
    ry: {
      description: "Rotation around the Y-axis by given angle",
      matrix: [
        ["cos(theta / 2)", "-1 * sin(theta / 2)"],
        ["sin(theta / 2)", "cos(theta / 2)"]
      ],
      params: ["theta"],
      drawingInfo: {
        connectors: ["box"],
        label: "RY"
      },
      exportInfo: {
        quil: {
          name: "RY",
          params: ["theta"]
        },
        cirq: {
          name: "ry",
          params: ["theta"]
        },
        quest: {
          name: "rotateY",
          params: ["theta"]
        },
        qsharp: {
          name: "Ry",
          params: ["theta"]
        },
        braket: {
          name: "ry",
          params: ["theta"]
        },
        aqasm: {
          name: "RY"
        },
        ionq: {
          name: "ry",
          paramsKey: "rotation"
        }
      }
    },
    rz: {
      description: "Rotation around the Z-axis by given angle",
      matrix: [
        ["cos(phi / 2) - i * sin(phi / 2)", 0],
        [0, "cos(phi / 2) + i * sin(phi / 2)"]
      ],
      params: ["phi"],
      drawingInfo: {
        connectors: ["box"],
        label: "RZ"
      },
      exportInfo: {
        quil: {
          name: "RZ",
          params: ["phi"]
        },
        cirq: {
          name: "rz",
          params: ["theta"]
        },
        qsharp: {
          name: "Rz",
          params: ["theta"]
        },
        braket: {
          name: "rz",
          params: ["phi"]
        },
        aqasm: {
          name: "RZ"
        },
        ionq: {
          name: "rz",
          paramsKey: "rotation"
        }
      }
    },
    u1: {
      description: "Single-qubit rotation about the Z axis",
      matrix: [
        [1, 0],
        [0, "exp(i * lambda)"]
      ],
      params: ["lambda"],
      drawingInfo: {
        connectors: ["box"],
        label: "U1"
      },
      exportInfo: {
        quil: {
          name: "PHASE",
          params: ["lambda"]
        },
        cirq: {
          name: "u1",
          params: ["lambda"],
          array: "[[1, 0], [0, np.exp(1j*p_lambda)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "phaseShift",
          params: ["lambda"]
        },
        braket: {
          name: "phaseshift",
          params: ["lambda"]
        },
        qiskit: {
          name: "p"
        },
        aqasm: {
          name: "PH"
        }
      }
    },
    u2: {
      description: "Single-qubit rotation about the X+Z axis",
      matrix: [
        ["1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"],
        ["exp(i * phi) * 1 / sqrt(2)", "exp(i * lambda + i * phi) * 1 / sqrt(2)"]
      ],
      params: ["phi", "lambda"],
      drawingInfo: {
        connectors: ["box"],
        label: "U2"
      },
      exportInfo: {
        quil: {
          name: "u2",
          params: ["phi", "lambda"],
          defgate: `DEFGATE u2(%phi, %lambda):
    1/SQRT(2), -1*EXP(i*%lambda)*1/SQRT(2)
    EXP(i*%phi)*1/SQRT(2), EXP(i*%lambda + i*%phi)*1/SQRT(2)`
        },
        pyquil: {
          name: "u2",
          params: ["phi", "lambda"],
          array: "[[1/quil_sqrt(2),-quil_exp(1j*p_lambda)*1/quil_sqrt(2)],[quil_exp(1j*p_phi)*1/quil_sqrt(2),quil_exp(1j*p_lambda+1j*p_phi)*1/quil_sqrt(2)]]"
        },
        cirq: {
          name: "u2",
          params: ["phi", "lambda"],
          array: "[[1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)], [np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "unitary",
          params: ["phi", "lambda"],
          matrix: [
            [["1/sqrt(2)", "0"], ["-cos(lambda)/sqrt(2)", "-sin(lambda)/sqrt(2)"]],
            [["cos(phi)/sqrt(2)", "sin(phi)/sqrt(2)"], ["cos(lambda+phi)/sqrt(2)", "sin(lambda+phi)/sqrt(2)"]]
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi", "lambda"],
          array: "[[1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)], [np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]"
        },
        aqasm: {
          matrix: [["1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"], ["exp(i * phi) * 1 / sqrt(2)", "exp(i * lambda + i * phi) * 1 / sqrt(2)"]],
          array: "[[1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)], [np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          params: ["phi", "lambda"]
        },
        qiskit: {
          replacement: [
            { name: "u3", params: { theta: "pi/2", phi: "phi", lambda: "lambda" } }
          ]
        }
      }
    },
    u3: {
      description: "Generic single-qubit rotation gate with 3 Euler angles",
      matrix: [
        ["cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"],
        ["exp(i * phi) * sin(theta / 2)", "exp(i * lambda + i * phi) * cos(theta / 2)"]
      ],
      params: ["theta", "phi", "lambda"],
      drawingInfo: {
        connectors: ["box"],
        label: "U3"
      },
      exportInfo: {
        quil: {
          name: "u3",
          params: ["theta", "phi", "lambda"],
          defgate: `DEFGATE u3(%theta, %phi, %lambda):
    COS(%theta/2), -1*EXP(i*%lambda)*SIN(%theta/2)
    EXP(i*%phi)*SIN(%theta/2), EXP(i*%lambda + i*%phi)*COS(%theta/2)`
        },
        pyquil: {
          name: "u3",
          params: ["theta", "phi", "lambda"],
          array: "[[quil_cos(p_theta/2),-quil_exp(1j*p_lambda)*quil_sin(p_theta/2)],[quil_exp(1j*p_phi)*quil_sin(p_theta/2),quil_exp(1j*p_lambda+1j*p_phi)*quil_cos(p_theta/2)]]"
        },
        cirq: {
          name: "u3",
          params: ["theta", "phi", "lambda"],
          array: "[[np.cos(p_theta/2), -np.exp(1j*p_lambda)*np.sin(p_theta/2)], [np.exp(1j*p_phi)*np.sin(p_theta/2), np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "unitary",
          params: ["theta", "phi", "lambda"],
          matrix: [
            [["cos(theta/2)", "0"], ["-cos(lambda)*sin(theta/2)", "-sin(lambda)*sin(theta/2)"]],
            [["cos(phi)*sin(theta/2)", "sin(phi)*sin(theta/2)"], ["cos(lambda+phi)*cos(theta/2)", "sin(lambda+phi)*cos(theta/2)"]]
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta", "phi", "lambda"],
          array: "[[np.cos(p_theta/2), -np.exp(1j*p_lambda)*np.sin(p_theta/2)], [np.exp(1j*p_phi)*np.sin(p_theta/2), np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]"
        },
        qiskit: {
          name: "u"
        },
        aqasm: {
          matrix: [["cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"], ["exp(i * phi) * sin(theta / 2)", "exp(i * lambda + i * phi) * cos(theta / 2)"]],
          array: "[[np.cos(p_theta/2), -np.exp(1j*p_lambda)*np.sin(p_theta/2)], [np.exp(1j*p_phi)*np.sin(p_theta/2), np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          params: ["theta", "phi", "lambda"]
        }
      }
    },
    s: {
      description: "PI/2 rotation over Z-axis (synonym for `r2`)",
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "S"
      },
      exportInfo: {
        quil: {
          name: "S"
        },
        cirq: {
          name: "S"
        },
        quest: {
          name: "sGate"
        },
        qsharp: {
          name: "S"
        },
        quirk: {
          name: "Z^½"
        },
        braket: {
          name: "s"
        },
        aqasm: {
          name: "S"
        },
        ionq: {
          name: "s"
        }
      }
    },
    t: {
      description: "PI/4 rotation over Z-axis (synonym for `r4`)",
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 4)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "T"
      },
      exportInfo: {
        quil: {
          name: "T"
        },
        cirq: {
          name: "T"
        },
        quest: {
          name: "tGate"
        },
        qsharp: {
          name: "T"
        },
        quirk: {
          name: "Z^¼"
        },
        braket: {
          name: "t"
        },
        aqasm: {
          name: "T"
        },
        ionq: {
          name: "t"
        }
      }
    },
    sdg: {
      description: "(-PI/2) rotation over Z-axis",
      matrix: [
        [1, 0],
        [0, "exp(-i * pi / 2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "S&#8224;"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        quest: {
          name: "phaseShift",
          params: { theta: "-M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        quirk: {
          name: "Z^-½"
        },
        braket: {
          name: "si"
        },
        aqasm: {
          name: "S",
          dagger: !0
        },
        ionq: {
          name: "si"
        }
      }
    },
    tdg: {
      description: "(-PI/4) rotation over Z-axis",
      matrix: [
        [1, 0],
        [0, "exp(-i * pi / 4)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "T&#8224;"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        quest: {
          name: "phaseShift",
          params: { theta: "-M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        quirk: {
          name: "Z^-¼"
        },
        braket: {
          name: "ti"
        },
        aqasm: {
          name: "T",
          dagger: !0
        },
        ionq: {
          name: "ti"
        }
      }
    },
    gpi: {
      description: "GPi gate",
      matrix: [
        [0, "exp(-i*phi)"],
        ["exp(i*phi)", 0]
      ],
      params: ["phi"],
      drawingInfo: {
        connectors: ["box"],
        label: "GPi"
      },
      exportInfo: {
        quil: {
          name: "gpi",
          params: ["phi"],
          defgate: `DEFGATE gpi(%phi):
    0, EXP(-i * %phi)
    EXP(i * %phi), 0`
        },
        pyquil: {
          name: "gpi",
          params: ["phi"],
          array: "[ [ 0, quil_exp(-1j*p_phi) ], [ quil_exp(1j*p_phi), 0 ] ]"
        },
        cirq: {
          name: "gpi"
        },
        quest: {
          name: "gpi",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          equivalent: [
            { name: "u3", params: { theta: "pi", phi: "phi", lambda: "pi-phi" }, wires: [0] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "u3", params: { theta: "pi", phi: "phi", lambda: "pi-phi" }, wires: [0] }
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi"],
          array: "[ [ 0, np.exp(-1j*p_phi) ], [ np.exp(1j*p_phi), 0 ] ]"
        },
        aqasm: {
          matrix: [[0, "exp(-i*phi)"], ["exp(i*phi)", 0]],
          array: "[ [ 0, np.exp(-1j*p_phi) ], [ np.exp(1j*p_phi), 0 ] ]",
          params: ["phi"]
        },
        ionq: {
          name: "gpi",
          paramsKey: "phase"
        }
      }
    },
    gpi2: {
      description: "GPi2 gate",
      matrix: [
        ["1/sqrt(2)", "(-i*exp(-i*phi))/sqrt(2)"],
        ["(-i*exp(i*phi))/sqrt(2)", "1/sqrt(2)"]
      ],
      params: ["phi"],
      drawingInfo: {
        connectors: ["box"],
        label: "GPi2"
      },
      exportInfo: {
        quil: {
          name: "gpi2",
          params: ["phi"],
          defgate: `DEFGATE gpi2(%phi):
    1/SQRT(2), (-i*EXP(-i * %phi)) / SQRT(2)
    (-i*EXP(i * %phi)) / SQRT(2), 1/SQRT(2)`
        },
        pyquil: {
          name: "gpi2",
          params: ["phi"],
          array: "[ [ 1/quil_sqrt(2), (-1j*quil_exp(-1j*p_phi))/quil_sqrt(2) ], [ (-1j*quil_exp(1j*p_phi))/quil_sqrt(2), 1/quil_sqrt(2) ] ]"
        },
        cirq: {
          name: "gpi2"
        },
        quest: {
          name: "gpi2",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          equivalent: [
            { name: "u3", params: { theta: "pi/2", phi: "phi-(pi/2)", lambda: "(pi/2)-phi" }, wires: [0] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "u3", params: { theta: "pi/2", phi: "phi-(pi/2)", lambda: "(pi/2)-phi" }, wires: [0] }
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi"],
          array: "[ [ 1/np.sqrt(2), (-1j*np.exp(-1j*p_phi))/np.sqrt(2) ], [ (-1j*np.exp(1j*p_phi))/np.sqrt(2), 1/np.sqrt(2) ] ]"
        },
        aqasm: {
          matrix: [["1/sqrt(2)", "(-i*exp(-i*phi))/sqrt(2)"], ["(-i*exp(i*phi))/sqrt(2)", "1/sqrt(2)"]],
          array: "[ [ 1/np.sqrt(2), (-1j*np.exp(-1j*p_phi))/np.sqrt(2) ], [ (-1j*np.exp(1j*p_phi))/np.sqrt(2), 1/np.sqrt(2) ] ]",
          params: ["phi"]
        },
        ionq: {
          name: "gpi2",
          paramsKey: "phase"
        }
      }
    },
    vz: {
      description: "VirtualZ gate",
      matrix: [
        ["exp(-i*theta/2)", 0],
        [0, "exp(i*theta/2)"]
      ],
      params: ["theta"],
      drawingInfo: {
        connectors: ["box"],
        label: "VrtZ"
      },
      exportInfo: {
        quil: {
          name: "vz",
          params: ["theta"],
          defgate: `DEFGATE vz(%theta):
    EXP(-i * %theta/2), 0
    0, EXP(-i * %theta/2)`
        },
        pyquil: {
          name: "vz",
          params: ["theta"],
          array: "[ [ quil_exp(-1j*p_theta/2), 0 ], [ 0, quil_exp(1j*p_theta/2) ] ]"
        },
        cirq: {
          name: "vz"
        },
        quest: {
          name: "vz",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          equivalent: [
            { name: "rz", params: { phi: "theta" }, wires: [0] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "rz", params: { phi: "theta" }, wires: [0] }
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[ [ np.exp(-1j*p_theta/2), 0 ], [ 0, np.exp(1j*p_theta/2) ] ]"
        },
        aqasm: {
          matrix: [["exp(-i*theta/2)", 0], [0, "exp(i*theta/2)"]],
          array: "[ [ np.exp(-1j*p_theta/2), 0 ], [ 0, np.exp(1j*p_theta/2) ] ]",
          params: ["theta"]
        },
        ionq: {
          name: "vz",
          paramsKey: "phase"
        }
      }
    },
    cx: {
      description: "Controlled NOT (CNOT) gate",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 1],
        [0, 0, 1, 0]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "not"],
        label: "X",
        root: "x"
      },
      exportInfo: {
        quil: {
          name: "CNOT"
        },
        cirq: {
          name: "CNOT"
        },
        quest: {
          name: "controlledNot"
        },
        qsharp: {
          name: "CNOT"
        },
        quirk: {
          name: "X",
          controlled: !0
        },
        braket: {
          name: "cnot"
        },
        aqasm: {
          name: "CNOT"
        },
        ionq: {
          name: "cnot"
        }
      }
    },
    cy: {
      description: "Controlled Y gate (controlled rotation over Y-axis by PI)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 0, "-i"],
        [0, 0, "i", 0]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Y",
        root: "y"
      },
      exportInfo: {
        quest: {
          name: "controlledPauliY"
        },
        cirq: {
          replacement: {
            name: "y",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "cy",
          defgate: `DEFGATE cy:
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 0, -i
    0, 0, i, 0`
        },
        pyquil: {
          name: "cy",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0,-1j],[0,0,1j,0]]"
        },
        qsharp: {
          name: "Controlled Y"
        },
        quirk: {
          name: "Y",
          controlled: !0
        },
        braket: {
          name: "cy"
        },
        aqasm: {
          name: "Y",
          controlled: !0
        }
      }
    },
    cz: {
      description: "Controlled Z gate (controlled rotation over Z-axis by PI)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, -1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "dot"],
        label: "Z",
        root: "z"
      },
      exportInfo: {
        quil: {
          name: "CZ"
        },
        cirq: {
          name: "CZ"
        },
        quest: {
          name: "controlledPhaseFlip"
        },
        qsharp: {
          name: "Controlled Z"
        },
        quirk: {
          name: "Z",
          controlled: !0
        },
        braket: {
          name: "cz"
        },
        aqasm: {
          name: "CSIGN"
        }
      }
    },
    ch: {
      description: "Controlled Hadamard gate",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "1 / sqrt(2)", "1 / sqrt(2)"],
        [0, 0, "1 / sqrt(2)", "-1 / sqrt(2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "H",
        root: "h"
      },
      exportInfo: {
        quest: {
          name: "controlledUnitary",
          matrix: [
            [["1/sqrt(2)", "0"], ["1/sqrt(2)", "0"]],
            [["1/sqrt(2)", "0"], ["-1/sqrt(2)", "0"]]
          ]
        },
        cirq: {
          replacement: {
            name: "h",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "ch",
          defgate: `DEFGATE ch:
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 0.7071067811865475, 0.7071067811865475
    0, 0, 0.7071067811865475, -0.7071067811865475`
        },
        pyquil: {
          name: "ch",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,1/np.sqrt(2),1/np.sqrt(2)],[0,0,1/np.sqrt(2),-1/np.sqrt(2)]]"
        },
        qsharp: {
          name: "Controlled H"
        },
        quirk: {
          name: "H",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,1/np.sqrt(2),1/np.sqrt(2)],[0,0,1/np.sqrt(2),-1/np.sqrt(2)]]"
        },
        aqasm: {
          name: "H",
          controlled: !0
        }
      }
    },
    csrn: {
      description: "Controlled square root of NOT",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "0.5+0.5i", "0.5-0.5i"],
        [0, 0, "0.5-0.5i", "0.5+0.5i"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "&#x221A;X",
        root: "srn"
      },
      exportInfo: {
        quest: {
          name: "controlledUnitary",
          matrix: [
            [["-1/sqrt(2)", "0"], ["-1/sqrt(2)", "0"]],
            [["-1/sqrt(2)", "0"], ["1/sqrt(2)", "0"]]
          ]
        },
        cirq: {
          replacement: {
            name: "srn",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "csrn",
          defgate: `DEFGATE csrn:
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 0.5+0.5i, 0.5-0.5i
    0, 0, 0.5-0.5i, 0.5+0.5i`
        },
        qasm: {
          name: "csx"
        },
        qiskit: {
          name: "csx"
        },
        pyquil: {
          name: "csrn",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0.5+0.5j,0.5-0.5j],[0,0,0.5-0.5j,0.5+0.5j]]"
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0.5+0.5j,0.5-0.5j],[0,0,0.5-0.5j,0.5+0.5j]]"
        },
        aqasm: {
          matrix: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, "0.5+0.5i", "0.5-0.5i"], [0, 0, "0.5-0.5i", "0.5+0.5i"]],
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0.5+0.5j,0.5-0.5j],[0,0,0.5-0.5j,0.5+0.5j]]"
        }
      }
    },
    swap: {
      description: "Swaps the state of two qubits.",
      matrix: [
        [1, 0, 0, 0],
        [0, 0, 1, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["x", "x"],
        label: "SWP"
      },
      exportInfo: {
        quil: {
          name: "SWAP"
        },
        cirq: {
          name: "SWAP"
        },
        quest: {
          name: "swap",
          func: `void swap(Qureg qubits, const int q1, const int q2) {
    controlledNot(qubits, q1, q2);
    controlledNot(qubits, q2, q1);
    controlledNot(qubits, q1, q2);
}`
        },
        qsharp: {
          name: "SWAP"
        },
        quirk: {
          name: "Swap"
        },
        braket: {
          name: "swap"
        },
        aqasm: {
          name: "SWAP"
        },
        ionq: {
          name: "swap"
        }
      }
    },
    srswap: {
      description: "Square root of swap",
      matrix: [
        [1, 0, 0, 0],
        [0, "0.5 * (1 + i)", "0.5 * (1 - i)", 0],
        [0, "0.5 * (1 - i)", "0.5 * (1 + i)", 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "&#x221A;SWP"
      },
      exportInfo: {
        quil: {
          name: "srswap",
          defgate: `DEFGATE srswap:
    1, 0, 0, 0
    0, 0.5+0.5i, 0.5-0.5i, 0
    0, 0.5-0.5i, 0.5+0.5i, 0
    0, 0, 0, 1`
        },
        cirq: {
          name: "SWAP**(1/2)"
        },
        pyquil: {
          name: "srswap",
          array: "[[1,0,0,0],[0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,1]]"
        },
        quest: {
          name: "srswap",
          func: `void srswap(Qureg qubits, const int q1, const int q2) {
    controlledNot(qubits, q2, q1);
    rotateY(qubits, q2, M_PI/2);
    rotateZ(qubits, q2, M_PI/16);
    controlledNot(qubits, q1, q2);
    rotateZ(qubits, q1, M_PI/8);
    rotateZ(qubits, q2, -M_PI/8);
    controlledNot(qubits, q1, q2);
    rotateZ(qubits, q2, M_PI/16);
    rotateY(qubits, q2, -M_PI/2);
    controlledNot(qubits, q2, q1);
}`
        },
        qasm: {
          equivalent: [
            { name: "u3", params: { theta: "pi/2", phi: "pi/2", lambda: "-1*pi" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/4", phi: "-1*pi/2", lambda: "-1*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "7*pi/4" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/4", phi: "-1*pi", lambda: "-1*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "pi", lambda: "pi/2" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "-3*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "pi/2", lambda: "0" }, wires: [1] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "u3", params: { theta: "pi/2", phi: "pi/2", lambda: "-1*pi" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/4", phi: "-1*pi/2", lambda: "-1*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "7*pi/4" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/4", phi: "-1*pi", lambda: "-1*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "pi", lambda: "pi/2" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "-3*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "pi/2", lambda: "0" }, wires: [1] }
          ]
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,1]]"
        },
        aqasm: {
          name: "SQRTSWAP"
        }
      }
    },
    iswap: {
      description: "Swaps the state of two qubits, applying a -i phase to q1 when it is in the 1 state and a -i phase to q2 when it is in the 0 state",
      matrix: [
        [1, 0, 0, 0],
        [0, 0, "0+i", 0],
        [0, "0+i", 0, 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "iSWP"
      },
      exportInfo: {
        quil: {
          name: "ISWAP"
        },
        cirq: {
          name: "ISWAP"
        },
        qasm: {
          equivalent: [
            { name: "u3", params: { theta: "pi/2", phi: "-1*pi/2", lambda: "-1*pi" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "3*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "3*pi/2", lambda: "0" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "0" }, wires: [0] },
            { name: "u3", params: { theta: "pi", phi: "pi/4", lambda: "-1*pi/4" }, wires: [1] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "u3", params: { theta: "pi/2", phi: "-1*pi/2", lambda: "-1*pi" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "3*pi/2" }, wires: [0] },
            { name: "u3", params: { theta: "pi/2", phi: "3*pi/2", lambda: "0" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "pi/2", phi: "0", lambda: "0" }, wires: [0] },
            { name: "u3", params: { theta: "pi", phi: "pi/4", lambda: "-1*pi/4" }, wires: [1] }
          ]
        },
        braket: {
          name: "iswap"
        },
        aqasm: {
          name: "ISWAP"
        }
      }
    },
    xx: {
      description: "XX gate",
      matrix: [
        ["cos(theta)", 0, 0, "-i*sin(theta)"],
        [0, "cos(theta)", "-i*sin(theta)", 0],
        [0, "-i*sin(theta)", "cos(theta)", 0],
        ["-i*sin(theta)", 0, 0, "cos(theta)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["theta"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "XX"
      },
      exportInfo: {
        quil: {
          name: "xx",
          params: ["theta"],
          defgate: `DEFGATE xx(%theta):
    COS(%theta), 0, 0, -i*SIN(%theta)
    0, COS(%theta), -i*SIN(%theta), 0
    0, -i*SIN(%theta), COS(%theta), 0
    -i*SIN(%theta), 0, 0, COS(%theta)`
        },
        pyquil: {
          name: "xx",
          params: ["theta"],
          array: "[ [quil_cos(p_theta), 0, 0, -1j*quil_sin(p_theta)], [0, quil_cos(p_theta), -1j*quil_sin(p_theta), 0], [0, -1j*quil_sin(p_theta), quil_cos(p_theta), 0], [-1j*quil_sin(p_theta), 0, 0, quil_cos(p_theta)] ]"
        },
        cirq: {
          name: "xx"
        },
        quest: {
          name: "xx",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          name: "rxx"
        },
        qiskit: {
          name: "rxx"
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[[np.cos(p_theta), 0, 0, -1j*np.sin(p_theta)], [0, np.cos(p_theta), -1j*np.sin(p_theta), 0], [0, -1j*np.sin(p_theta), np.cos(p_theta), 0], [-1j*np.sin(p_theta), 0, 0, np.cos(p_theta)] ]"
        },
        aqasm: {
          matrix: [["cos(theta)", 0, 0, "-i*sin(theta)"], [0, "cos(theta)", "-i*sin(theta)", 0], [0, "-i*sin(theta)", "cos(theta)", 0], ["-i*sin(theta)", 0, 0, "cos(theta)"]],
          array: "[[np.cos(p_theta), 0, 0, -1j*np.sin(p_theta)], [0, np.cos(p_theta), -1j*np.sin(p_theta), 0], [0, -1j*np.sin(p_theta), np.cos(p_theta), 0], [-1j*np.sin(p_theta), 0, 0, np.cos(p_theta)] ]",
          params: ["theta"]
        },
        ionq: {
          name: "xx",
          paramsKey: "phase"
        }
      }
    },
    yy: {
      description: "YY gate",
      matrix: [
        ["cos(theta)", 0, 0, "i*sin(theta)"],
        [0, "cos(theta)", "-i*sin(theta)", 0],
        [0, "-i*sin(theta)", "cos(theta)", 0],
        ["i*sin(theta)", 0, 0, "cos(theta)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["theta"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "YY"
      },
      exportInfo: {
        quil: {
          name: "yy",
          params: ["theta"],
          defgate: `DEFGATE yy(%theta):
    COS(%theta), 0, 0, i*SIN(%theta)
    0, COS(%theta), -i*SIN(%theta), 0
    0, -i*SIN(%theta), COS(%theta), 0
    i*SIN(%theta), 0, 0, COS(%theta)`
        },
        cirq: {
          name: "YY"
        },
        pyquil: {
          name: "yy",
          params: ["theta"],
          array: "[ [quil_cos(p_theta), 0, 0, 1j*quil_sin(p_theta)], [0, quil_cos(p_theta), -1j*quil_sin(p_theta), 0], [0, -1j*quil_sin(p_theta), quil_cos(p_theta), 0], [1j*quil_sin(p_theta), 0, 0, quil_cos(p_theta)] ]"
        },
        quest: {
          name: "yy",
          //@TODO add function
          func: "TODO"
        },
        braket: {
          name: "yy",
          params: ["theta"]
        },
        aqasm: {
          matrix: [["cos(theta)", 0, 0, "i*sin(theta)"], [0, "cos(theta)", "-i*sin(theta)", 0], [0, "-i*sin(theta)", "cos(theta)", 0], ["i*sin(theta)", 0, 0, "cos(theta)"]],
          array: "[[np.cos(p_theta), 0, 0, 1j*np.sin(p_theta)], [0, np.cos(p_theta), -1j*np.sin(p_theta), 0], [0, -1j*np.sin(p_theta), np.cos(p_theta), 0], [1j*np.sin(p_theta), 0, 0, np.cos(p_theta)] ]",
          params: ["theta"]
        },
        qasm: {
          name: "ryy"
        },
        qiskit: {
          name: "ryy"
        },
        ionq: {
          name: "yy",
          paramsKey: "phase"
        }
      }
    },
    zz: {
      description: "Parametric 2-qubit rotation about ZZ",
      matrix: [
        ["exp(-i * theta / 2)", 0, 0, 0],
        [0, "exp(i * theta / 2)", 0, 0],
        [0, 0, "exp(i * theta / 2)", 0],
        [0, 0, 0, "exp(-i * theta / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["theta"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "ZZ"
      },
      exportInfo: {
        quil: {
          name: "zz",
          params: ["theta"],
          defgate: `DEFGATE zz(%theta):
    EXP(-i * %theta / 2), 0, 0, 0
    0, EXP(i * %theta / 2), 0, 0
    0, 0, EXP(i * %theta / 2), 0
    0, 0, 0, EXP(-i * %theta / 2)`
        },
        pyquil: {
          name: "zz",
          params: ["theta"],
          array: "[ [ quil_exp(-1j * p_theta / 2), 0, 0, 0 ], [ 0, quil_exp(1j * p_theta / 2), 0, 0], [ 0, 0, quil_exp(1j * p_theta / 2), 0 ], [ 0, 0, 0, quil_exp(-1j * p_theta / 2) ] ]"
        },
        qasm: {
          name: "rzz"
        },
        qiskit: {
          name: "rzz"
        },
        ionq: {
          name: "zz",
          paramsKey: "phase"
        }
      }
    },
    xy: {
      description: "XY gate",
      matrix: [
        [1, 0, 0, 0],
        [0, "cos(phi / 2)", "i * sin(phi / 2)", 0],
        [0, "i * sin(phi / 2)", "cos(phi / 2)", 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["phi"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "XY"
      },
      exportInfo: {
        quil: {
          name: "XY",
          params: [
            "phi"
          ]
        },
        qasm: {
          equivalent: [
            { name: "rz", params: { phi: "3*pi/4" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "-3*pi/4" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "phi/2" }, wires: [0] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "phi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/4" }, wires: [0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "3*pi/4" }, wires: [1] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "rz", params: { phi: "3*pi/4" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "-3*pi/4" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "phi/2" }, wires: [0] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "phi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/4" }, wires: [0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "3*pi/4" }, wires: [1] }
          ]
        },
        cirq: {
          name: "xy",
          params: ["phi"],
          array: "[[1, 0, 0, 0], [0, np.cos(p_phi/2), 1j*np.sin(p_phi/2), 0], [0, 1j*np.sin(p_phi/2), np.cos(p_phi/2), 0], [0, 0, 0, 1]]",
          notTfqSupported: !0
        },
        braket: {
          name: "xy",
          params: ["phi"]
        },
        aqasm: {
          matrix: [[1, 0, 0, 0], [0, "cos(phi / 2)", "i * sin(phi / 2)", 0], [0, "i * sin(phi / 2)", "cos(phi / 2)", 0], [0, 0, 0, 1]],
          array: "[[1, 0, 0, 0], [0, np.cos(p_phi/2), 1j*np.sin(p_phi/2), 0], [0, 1j*np.sin(p_phi/2), np.cos(p_phi/2), 0], [0, 0, 0, 1]]",
          params: ["phi"]
        }
      }
    },
    ms: {
      description: "Mølmer-Sørensen gate",
      matrix: [
        ["1/sqrt(2)", 0, 0, "(-i*exp(-i*(phi0+phi1)))/sqrt(2)"],
        [0, "1/sqrt(2)", "(-i*exp(-i*(phi0-phi1)))/sqrt(2)", 0],
        [0, "(-i*exp(i*(phi0-phi1)))/sqrt(2)", "1/sqrt(2)", 0],
        ["(-i*exp(i*(phi0+phi1)))/sqrt(2)", 0, 0, "1/sqrt(2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["phi0", "phi1"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "MS"
      },
      exportInfo: {
        quil: {
          name: "ms",
          params: ["phi0", "phi1"],
          defgate: `DEFGATE ms(%phi0, %phi1):
    1/SQRT(2), 0, 0, (-i*EXP(-i*(%phi0+%phi1)))/SQRT(2)
    0, 1/SQRT(2), (-i*EXP(-i*(%phi0-%phi1)))/SQRT(2), 0
    0, (-i*EXP(i*(%phi0-%phi1)))/SQRT(2), 1/SQRT(2), 0
    (-i*EXP(i*(%phi0+%phi1)))/SQRT(2), 0, 0, 1/SQRT(2)`
        },
        pyquil: {
          name: "ms",
          params: ["phi0", "phi1"],
          array: "[ [ 1/quil_sqrt(2), 0, 0, (-1j*quil_exp(-1j*(p_phi0+p_phi1)))/quil_sqrt(2) ], [ 0, 1/quil_sqrt(2), (-1j*quil_exp(-1j*(p_phi0-p_phi1)))/quil_sqrt(2), 0 ], [ 0, (-1j*quil_exp(1j*(p_phi0-p_phi1)))/quil_sqrt(2), 1/quil_sqrt(2), 0 ], [ (-1j*quil_exp(1j*(p_phi0+p_phi1)))/quil_sqrt(2), 0, 0, 1/quil_sqrt(2) ] ]"
        },
        cirq: {
          name: "ms"
        },
        quest: {
          name: "ms",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          name: "ms"
        },
        qiskit: {
          name: "ms"
        },
        braket: {
          name: "unitary",
          params: ["phi0", "phi1"],
          array: "[ [ 1/np.sqrt(2), 0, 0, (-1j*np.exp(-1j*(p_phi0+p_phi1)))/np.sqrt(2) ], [ 0, 1/np.sqrt(2), (-1j*np.exp(-1j*(p_phi0-p_phi1)))/np.sqrt(2), 0 ], [ 0, (-1j*np.exp(1j*(p_phi0-p_phi1)))/np.sqrt(2), 1/np.sqrt(2), 0 ], [ (-1j*np.exp(1j*(p_phi0+p_phi1)))/np.sqrt(2), 0, 0, 1/np.sqrt(2) ] ]"
        },
        aqasm: {
          matrix: [["1/sqrt(2)", 0, 0, "(-1i*exp(-1i*(phi0+phi1)))/sqrt(2)"], [0, "1/sqrt(2)", "(-1i*exp(-1i*(phi0-phi1)))/sqrt(2)", 0], [0, "(-1i*exp(1i*(phi0-phi1)))/sqrt(2)", "1/sqrt(2)", 0], ["(-1i*exp(1i*(phi0+phi1)))/sqrt(2)", 0, 0, "1/sqrt(2)"]],
          array: "[ [ 1/np.sqrt(2), 0, 0, (-1j*np.exp(-1j*(p_phi0+p_phi1)))/np.sqrt(2) ], [ 0, 1/np.sqrt(2), (-1j*np.exp(-1j*(p_phi0-p_phi1)))/np.sqrt(2), 0 ], [ 0, (-1j*np.exp(1j*(p_phi0-p_phi1)))/np.sqrt(2), 1/np.sqrt(2), 0 ], [ (-1j*np.exp(1j*(p_phi0+p_phi1)))/np.sqrt(2), 0, 0, 1/np.sqrt(2) ] ]",
          params: ["phi0", "phi1"]
        },
        ionq: {
          name: "ms",
          paramsKey: "phases"
        }
      }
    },
    cr2: {
      description: "Controlled PI/2 rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Z&#x1D6D1;/2",
        root: "r2"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/2" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/2" } }
          ]
        },
        quirk: {
          name: "Z^½",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 2)] ]"
        },
        aqasm: {
          name: "S",
          controlled: !0
        }
      }
    },
    cr4: {
      description: "Controlled PI/4 rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 4)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Z&#x1D6D1;/4",
        root: "r4"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/4" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/4" } }
          ]
        },
        quirk: {
          name: "Z^¼",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 4)] ]"
        },
        aqasm: {
          name: "T",
          controlled: !0
        }
      }
    },
    cr8: {
      description: "Controlled PI/8 rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 8)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Z&#x1D6D1;/8",
        root: "r8"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/8" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/8" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/8" } }
          ]
        },
        quirk: {
          name: "Z^⅛",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 8)] ]"
        },
        aqasm: {
          matrix: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, "exp(i * pi / 8)"]],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 8)] ]"
        }
      }
    },
    crx: {
      description: "Controlled rotation around the X-axis by given angle",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(theta / 2)", "-i * sin(theta / 2)"],
        [0, 0, "-i * sin(theta / 2)", "cos(theta / 2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["theta"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "RX",
        root: "rx"
      },
      exportInfo: {
        quil: {
          name: "crx",
          params: ["theta"],
          defgate: `DEFGATE crx(%theta):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%theta/2), -i*SIN(%theta/2)
    0, 0, -i*SIN(%theta/2), COS(%theta/2)`
        },
        cirq: {
          replacement: {
            name: "rx",
            params: { theta: "theta" },
            type: "controlled",
            notTfqSupported: !0
          }
        },
        pyquil: {
          name: "crx",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, quil_cos(p_theta / 2), -1j*quil_sin(p_theta / 2) ], [ 0, 0, -1j*quil_sin(p_theta / 2), quil_cos(p_theta / 2) ]]"
        },
        quest: {
          name: "controlledUnitary",
          params: ["theta"],
          matrix: [
            [["cos(theta/2)", "0"], ["0", "-sin(theta/2)"]],
            [["0", "-sin(theta/2)"], ["cos(theta/2)", "0"]]
          ]
        },
        qsharp: {
          name: "Controlled Rx",
          params: ["theta"]
        },
        qasm: {
          replacement: [
            { name: "cu3", params: { theta: "theta", phi: "-1*pi/2", lambda: "pi/2" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu3", params: { theta: "theta", phi: "-1*pi/2", lambda: "pi/2" } }
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, np.cos(p_theta / 2), -1j*np.sin(p_theta / 2) ], [ 0, 0, -1j*np.sin(p_theta / 2), np.cos(p_theta / 2) ]]"
        },
        aqasm: {
          name: "RX",
          controlled: !0
        }
      }
    },
    cry: {
      description: "Controlled rotation around the Y-axis by given angle",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(theta / 2)", "-1 * sin(theta / 2)"],
        [0, 0, "sin(theta / 2)", "cos(theta / 2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["theta"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "RY",
        root: "ry"
      },
      exportInfo: {
        quil: {
          name: "cry",
          params: ["theta"],
          defgate: `DEFGATE cry(%theta):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%theta/2), -1*SIN(%theta/2)
    0, 0, SIN(%theta/2), COS(%theta/2)`
        },
        cirq: {
          replacement: {
            name: "ry",
            params: { theta: "theta" },
            type: "controlled",
            notTfqSupported: !0
          }
        },
        pyquil: {
          name: "cry",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ],[ 0, 1, 0, 0 ],[ 0, 0, quil_cos(p_theta / 2), -1*quil_sin(p_theta / 2) ],[ 0, 0, quil_sin(p_theta / 2), quil_cos(p_theta / 2) ]]"
        },
        quest: {
          name: "controlledUnitary",
          params: ["theta"],
          matrix: [
            [["cos(theta/2)", "0"], ["-sin(theta/2)", "0"]],
            [["sin(theta/2)", "0"], ["cos(theta/2)", "0"]]
          ]
        },
        qsharp: {
          name: "Controlled Ry",
          params: ["theta"]
        },
        qasm: {
          equivalent: [
            { name: "u3", params: { theta: "theta/2", phi: "0", lambda: "0" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "-1*theta / 2", phi: "0", lambda: "0" }, wires: [1] },
            { name: "cx", wires: [0, 1] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "u3", params: { theta: "theta/2", phi: "0", lambda: "0" }, wires: [1] },
            { name: "cx", wires: [0, 1] },
            { name: "u3", params: { theta: "-1*theta / 2", phi: "0", lambda: "0" }, wires: [1] },
            { name: "cx", wires: [0, 1] }
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ],[ 0, 1, 0, 0 ],[ 0, 0, np.cos(p_theta / 2), -1*np.sin(p_theta / 2) ],[ 0, 0, np.sin(p_theta / 2), np.cos(p_theta / 2) ]]"
        },
        aqasm: {
          name: "RY",
          controlled: !0
        }
      }
    },
    crz: {
      description: "Controlled rotation around the Z-axis by given angle",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(phi / 2) - i * sin(phi / 2)", 0],
        [0, 0, 0, "cos(phi / 2) + i * sin(phi / 2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["phi"],
      drawingInfo: {
        connectors: ["dot", "dot"],
        label: "RZ",
        root: "rz"
      },
      exportInfo: {
        quil: {
          name: "crz",
          params: ["phi"],
          defgate: `DEFGATE crz(%phi):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%phi / 2) - i * SIN(%phi / 2), 0
    0, 0, 0, COS(%phi / 2) + i * SIN(%phi / 2)`
        },
        pyquil: {
          name: "crz",
          params: ["phi"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, quil_cos(p_phi / 2) - 1j * quil_sin(p_phi / 2), 0], [0, 0, 0, quil_cos(p_phi / 2) + 1j * quil_sin(p_phi / 2)]]"
        },
        cirq: {
          replacement: {
            name: "rz",
            params: { phi: "phi" },
            type: "controlled"
          }
        },
        quest: {
          name: "controlledRotateZ",
          params: ["theta"]
        },
        qsharp: {
          name: "Controlled Rz",
          params: ["phi"]
        },
        braket: {
          name: "unitary",
          params: ["phi"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, np.cos(p_phi / 2) - 1j * np.sin(p_phi / 2), 0], [0, 0, 0, np.cos(p_phi / 2) + 1j * np.sin(p_phi / 2)]]"
        },
        aqasm: {
          name: "RZ",
          controlled: !0
        }
      }
    },
    cu1: {
      description: "Controlled rotation about the Z axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * lambda)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["lambda"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "CU1",
        root: "u1"
      },
      exportInfo: {
        quil: {
          name: "CPHASE",
          params: ["lambda"]
        },
        cirq: {
          name: "cu1",
          params: ["lambda"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j*p_lambda)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "controlledPhaseShift",
          params: ["theta"]
        },
        braket: {
          name: "unitary",
          params: ["lambda"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j*p_lambda)]]"
        },
        aqasm: {
          name: "PH",
          controlled: !0
        },
        qiskit: {
          name: "cp"
        }
      }
    },
    cu2: {
      description: "Controlled rotation about the X+Z axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"],
        [0, 0, "exp(i * phi) * 1 / sqrt(2)", "exp(i * lambda + i * phi) * 1 / sqrt(2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["phi", "lambda"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "CU2",
        root: "u2"
      },
      exportInfo: {
        quil: {
          name: "cu2",
          params: ["phi", "lambda"],
          defgate: `DEFGATE cu2(%phi, %lambda):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 1/SQRT(2), -1*EXP(i*%lambda)*1/SQRT(2)
    0, 0, EXP(i*%phi)*1/SQRT(2), EXP(i*%lambda + i*%phi)*1/SQRT(2)`
        },
        pyquil: {
          name: "cu2",
          params: ["phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/quil_sqrt(2), -quil_exp(1j*p_lambda)*1/quil_sqrt(2)],[0, 0, quil_exp(1j*p_phi)*1/quil_sqrt(2), quil_exp(1j*p_lambda+1j*p_phi)*1/quil_sqrt(2)]]"
        },
        cirq: {
          name: "cu2",
          params: ["phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)],[0, 0, np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "controlledUnitary",
          params: ["phi", "lambda"],
          matrix: [
            [["1/sqrt(2)", "0"], ["-cos(lambda)/sqrt(2)", "-sin(lambda)/sqrt(2)"]],
            [["cos(phi)/sqrt(2)", "sin(phi)/sqrt(2)"], ["cos(lambda+phi)/sqrt(2)", "sin(lambda+phi)/sqrt(2)"]]
          ]
        },
        qasm: {
          replacement: [
            { name: "cu3", params: { theta: "pi/2", phi: "phi", lambda: "lambda" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu3", params: { theta: "pi/2", phi: "phi", lambda: "lambda" } }
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)],[0, 0, np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]"
        },
        aqasm: {
          matrix: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, "1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"], [0, 0, "exp(i * phi) * 1 / sqrt(2)", "exp(i * lambda + i * phi) * 1 / sqrt(2)"]],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)],[0, 0, np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          params: ["phi", "lambda"]
        }
      }
    },
    cu3: {
      description: "Controlled rotation gate with 3 Euler angles",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"],
        [0, 0, "exp(i * phi) * sin(theta / 2)", "exp(i * lambda + i * phi) * cos(theta / 2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["theta", "phi", "lambda"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "CU3",
        root: "u3"
      },
      exportInfo: {
        quil: {
          name: "cu3",
          params: ["theta", "phi", "lambda"],
          defgate: `DEFGATE cu3(%theta, %phi, %lambda):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%theta/2), -1*EXP(i*%lambda)*SIN(%theta/2)
    0, 0, EXP(i*%phi)*SIN(%theta/2), EXP(i*%lambda + i*%phi)*COS(%theta/2)`
        },
        pyquil: {
          name: "cu3",
          params: ["theta", "phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, quil_cos(p_theta/2),-quil_exp(1j*p_lambda)*quil_sin(p_theta/2)],[0, 0, quil_exp(1j*p_phi)*quil_sin(p_theta/2),quil_exp(1j*p_lambda+1j*p_phi)*quil_cos(p_theta/2)]]"
        },
        cirq: {
          name: "cu3",
          params: ["theta", "phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, np.cos(p_theta/2),-np.exp(1j*p_lambda)*np.sin(p_theta/2)],[0, 0, np.exp(1j*p_phi)*np.sin(p_theta/2),np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "controlledUnitary",
          params: ["theta", "phi", "lambda"],
          matrix: [
            [["cos(theta/2)", "0"], ["-cos(lambda)*sin(theta/2)", "-sin(lambda)*sin(theta/2)"]],
            [["cos(phi)*sin(theta/2)", "sin(phi)*sin(theta/2)"], ["cos(lambda+phi)*cos(theta/2)", "sin(lambda+phi)*cos(theta/2)"]]
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta", "phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, np.cos(p_theta/2),-np.exp(1j*p_lambda)*np.sin(p_theta/2)],[0, 0, np.exp(1j*p_phi)*np.sin(p_theta/2),np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]"
        },
        aqasm: {
          matrix: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, "cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"], [0, 0, "exp(i * phi) * sin(theta / 2)", "exp(i * lambda + i * phi) * cos(theta / 2)"]],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, np.cos(p_theta/2),-np.exp(1j*p_lambda)*np.sin(p_theta/2)],[0, 0, np.exp(1j*p_phi)*np.sin(p_theta/2),np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          params: ["theta", "phi", "lambda"]
        },
        qiskit: {
          name: "cu"
        }
      }
    },
    cs: {
      description: "Controlled PI/2 rotation over Z-axis (synonym for `cr2`)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "S",
        root: "s"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/2" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/2" } }
          ]
        },
        quirk: {
          name: "Z^½",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(1j * np.pi / 2)]]"
        },
        aqasm: {
          name: "S",
          controlled: !0
        }
      }
    },
    ct: {
      description: "Controlled PI/4 rotation over Z-axis (synonym for `cr4`)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 4)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "T",
        root: "t"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/4" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu1", params: { lambda: "pi/4" } }
          ]
        },
        quirk: {
          name: "Z^¼",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(1j * np.pi / 4)]]"
        },
        aqasm: {
          name: "T",
          controlled: !0
        }
      }
    },
    csdg: {
      description: "Controlled (-PI/2) rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(-i * pi / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "S&#8224;",
        root: "sdg"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "-M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "cu1", params: { lambda: "-1*pi/2" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu1", params: { lambda: "-1*pi/2" } }
          ]
        },
        quirk: {
          name: "Z^-½",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(-1j * np.pi / 2)]]"
        },
        aqasm: {
          name: "S",
          controlled: !0,
          dagger: !0
        }
      }
    },
    ctdg: {
      description: "Controlled (-PI/4) rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(-i * pi / 4)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "T&#8224;",
        root: "tdg"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "-M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        qasm: {
          replacement: [
            { name: "cu1", params: { lambda: "-1*pi/4" } }
          ]
        },
        qiskit: {
          replacement: [
            { name: "cu1", params: { lambda: "-1*pi/4" } }
          ]
        },
        quirk: {
          name: "Z^-¼",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(-1j * np.pi / 4)]]"
        },
        aqasm: {
          name: "T",
          controlled: !0,
          dagger: !0
        }
      }
    },
    ccx: {
      description: 'Toffoli aka "CCNOT" gate',
      matrix: [
        [1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 0, 0, 1, 0]
      ],
      numTargetQubits: 1,
      numControlQubits: 2,
      params: [],
      drawingInfo: {
        connectors: ["dot", "dot", "not"],
        label: "CCNOT",
        root: "x"
      },
      exportInfo: {
        quil: {
          name: "CCNOT"
        },
        cirq: {
          name: "CCX",
          notTfqSupported: !0
        },
        quest: {
          name: "ccx",
          func: `void ccx(Qureg qubits, const int q1, const int q2, const int q3) {
    hadamard(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q2);
    tGate(qubits, q3);
    controlledNot(qubits, q1, q2);
    hadamard(qubits, q3);
    tGate(qubits, q1);
    phaseShift(qubits, q2, -M_PI/4);
    controlledNot(qubits, q1, q2);
}`
        },
        qsharp: {
          name: "CCNOT"
        },
        quirk: {
          name: "X",
          controlled: !0
        },
        braket: {
          name: "ccnot"
        },
        aqasm: {
          name: "CCNOT"
        }
      }
    },
    cswap: {
      description: 'Controlled swap aka "Fredkin" gate',
      matrix: [
        [1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "x", "x"],
        label: "SWP",
        root: "swap"
      },
      exportInfo: {
        cirq: {
          name: "CSWAP"
        },
        quest: {
          name: "cswap",
          func: `void cswap(Qureg qubits, const int q1, const int q2, const int q3) {
    controlledNot(qubits, q3, q2);
    hadamard(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q2);
    tGate(qubits, q3);
    hadamard(qubits, q3);
    controlledNot(qubits, q1, q2);
    tGate(qubits, q1);
    phaseShift(qubits, q2, -M_PI/4);
    controlledNot(qubits, q2, q3);
    controlledNot(qubits, q3, q2);
}`
        },
        qsharp: {
          name: "Controlled SWAP"
        },
        quil: {
          name: "CSWAP"
        },
        pyquil: {
          name: "CSWAP"
        },
        quirk: {
          name: "Swap",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0], [0,0,1,0,0,0,0,0], [0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0], [0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1]]"
        },
        aqasm: {
          name: "SWAP",
          controlled: !0
        }
      }
    },
    csrswap: {
      description: "Controlled square root of swap",
      matrix: [
        [1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, "0.5 * (1 + i)", "0.5 * (1 - i)", 0],
        [0, 0, 0, 0, 0, "0.5 * (1 - i)", "0.5 * (1 + i)", 0],
        [0, 0, 0, 0, 0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box", "box"],
        label: "&#x221A;SWP",
        root: "srswap"
      },
      exportInfo: {
        quest: {
          name: "csrswap",
          //@TODO add function
          func: "TODO"
        },
        cirq: {
          replacement: {
            name: "srswap",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "csrswap",
          defgate: `DEFGATE csrswap:
    1, 0, 0, 0, 0, 0, 0, 0
    0, 1, 0, 0, 0, 0, 0, 0
    0, 0, 1, 0, 0, 0, 0, 0
    0, 0, 0, 1, 0, 0, 0, 0
    0, 0, 0, 0, 1, 0, 0, 0
    0, 0, 0, 0, 0, 0.5+0.5i, 0.5-0.5i, 0
    0, 0, 0, 0, 0, 0.5-0.5i, 0.5+0.5i, 0
    0, 0, 0, 0, 0, 0, 0, 1`
        },
        pyquil: {
          name: "csrswap",
          array: "[[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0,0,0,0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,0,0,0,0,1]]"
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0,0,0,0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,0,0,0,0,1]]"
        },
        aqasm: {
          name: "SQRTSWAP",
          controlled: !0
        }
      }
    },
    reset: {
      description: "Resets qubit",
      matrix: [],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "RST"
      },
      exportInfo: {
        quil: {
          name: "RESET"
        },
        cirq: {
          name: "reset",
          notTfqSupported: !0
        },
        quest: {
          name: "reset",
          //@TODO add function
          func: "TODO"
        },
        qsharp: {
          name: "Reset"
        }
      }
    },
    measure: {
      description: "Measures qubit and stores chance (0 or 1) into classical bit",
      matrix: [],
      params: [],
      drawingInfo: {
        connectors: ["gauge"],
        label: ""
      },
      exportInfo: {
        quil: {
          name: "MEASURE"
        },
        cirq: {
          name: "measure"
        },
        quest: {
          name: "measure"
        },
        qsharp: {
          name: "M"
        }
      }
    }
  }, this.init(e);
};
ge.prototype.defaultHybridOptions = function() {
  return {
    optimizer: "Powell",
    tolerance: 1e-3,
    costFunction: {
      python: "",
      javascript: ""
    }
  };
};
ge.prototype.init = function(t, e) {
  e = e || {}, this.numQubits = t || 1, this.gates = [], this.partitionMap = [], this.partitionCount = 0, this.partitionInfo = {}, this.params = [], this.options = {
    params: {},
    hybrid: !1,
    hybridOptions: this.defaultHybridOptions()
  }, e.keepCustomGates || (this.customGates = {}), this.cregs = {}, this.collapsed = [], this.prob = [], this.measureResetsQubit = !1, this.reverseBitOrder = !1, this.clear();
};
ge.prototype.clearGates = function() {
  this.gates = [];
  for (var t = 0; t < this.numQubits; t++)
    this.gates.push([]);
};
ge.prototype.clear = function() {
  this.clearGates(), this.initState();
};
ge.prototype.resetState = function() {
  this.state = {}, this.stateBits = 0, this.partitionCache = {};
  for (var t in this.cregs) {
    var e = this.cregs[t].length || 0;
    this.cregs[t] = [];
    for (var r = 0; r < e; r++)
      this.cregs[t].push(0);
  }
  this.collapsed = [], this.prob = [], this.stats = {
    duration: 0
  };
};
ge.prototype.initState = function() {
  this.resetState(), this.state[0] = Wt(1, 0);
};
ge.prototype.formatComplex = function(t, e) {
  return _s(t.re, t.im, e);
};
ge.prototype.multiplySquareMatrices = function(t, e) {
  for (var r = t.length, n = r, a = r, s = r, o = []; n--; )
    for (o[n] = [], a = r; a--; )
      for (o[n][a] = 0, s = r; s--; )
        t[n][s] && e[s][a] && (o[n][a] ? o[n][a] = ut(o[n][a], it(t[n][s], e[s][a])) : o[n][a] = it(t[n][s], e[s][a]));
  return o;
};
ge.prototype.isIdentityMatrix = function(t, e) {
  typeof e > "u" && (e = 14);
  for (var r = 0; r < t.length; r++)
    for (var n = 0; n < t.length; n++)
      if (kt(t[r][n], e) != (r == n ? 1 : 0))
        return !1;
  return !0;
};
ge.prototype.isUnitaryMatrix = function(t, e) {
  return this.isIdentityMatrix(it(t, ss(t)), e);
};
ge.prototype.isHermitianMatrix = function(t, e) {
  var r = this.matrixDiff(t, ss(t));
  return r <= _t(10, -1 * (e || 14));
};
ge.prototype.matrixDiff = function(t, e) {
  for (var r = 0, n = 0, a = 0; a < t.length; a++)
    for (var s = t[a], o = e[a], p = 0; p < s.length; p++) {
      var u = s[p], f = o[p], l = typeof u == "object" ? u : Wt(u), c = typeof f == "object" ? f : Wt(f), h = $t(Xt(l, c));
      r += h, n++;
    }
  var d = n ? r / n : 0;
  return d;
};
ge.prototype.parseMathString = function(t) {
  var e = [], r = function(s, o) {
    if (s.isSymbolNode) {
      if (s.name == "j")
        return "i";
      e.indexOf(s.name) < 0 && e.push(s.name);
    }
  }, n = Et(t.replace(/[\t\n\r]/gm, "")), a = n.toString({ handler: r });
  return {
    expression: a,
    variables: e,
    node: n
  };
};
ge.prototype.evalMathString = function(t, e) {
  e = e || {};
  var r = this.parseMathString(t), n = Br(r.expression, e);
  return n instanceof rs ? n.toArray() : n;
};
ge.prototype.parseMatrix = function(t, e) {
  var r = this, n = null;
  typeof t == "string" ? n = r.evalMathString(t, e) : n = t;
  var a = [];
  return n.map(function(s, o) {
    Array.isArray(s) ? (a.push([]), s.map(function(p, u) {
      typeof p == "string" ? a[o].push(r.evalMathString(p, e)) : a[o].push(p);
    })) : typeof s == "string" ? a.push(r.evalMathString(s, e)) : a.push(s);
  }), a;
};
ge.prototype.matrixHasComplexElement = function(t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e];
    if (r instanceof Array)
      for (var n = 0; n < r.length; n++) {
        var a = r[n];
        if (a instanceof Ft || typeof a == "object" && (a.mathjs && a.mathjs == "Complex" || a.type && a.type == "Complex"))
          return !0;
      }
    else if (r instanceof Ft || typeof r == "object" && (r.mathjs && r.mathjs == "Complex" || r.type && r.type == "Complex"))
      return !0;
  }
  return !1;
};
ge.prototype.matrixZeroImagToReal = function(t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e];
    if (r instanceof Array)
      for (var n = 0; n < r.length; n++) {
        var a = r[n];
        (a instanceof Ft || typeof a == "object" && (a.mathjs && a.mathjs == "Complex" || a.type && a.type == "Complex")) && Ga(a) == 0 && (t[e][n] = Ha(a));
      }
    else
      (r instanceof Ft || typeof r == "object" && (r.mathjs && r.mathjs == "Complex" || r.type && r.type == "Complex")) && Ga(r) == 0 && (t[e] = Ha(r));
  }
  return t;
};
ge.prototype.stringifyMatrix = function(t, e) {
  var r = this, n = t.toArray ? t.toArray() : t;
  e = e || {};
  var a = !1;
  e.fixedWidth && (a = this.matrixHasComplexElement(n));
  var s = "";
  return s += "[", n.map(function(o, p) {
    p > 0 && (s += ","), e.minify ? s += " " : s += `
  `, o instanceof Array ? (s += "[", o.map(function(u, f) {
      f > 0 && (s += ", "), u instanceof Ft ? s += r.formatComplex(u, e) : typeof u == "object" && (u.mathjs && u.mathjs == "Complex" || u.type && u.type == "Complex") ? s += _s(u.re, u.im, e) : typeof u == "string" ? s += u : a ? s += _s(u, 0, e) : s += Nu(u, e);
    }), s += "]") : o instanceof Ft ? s += r.formatComplex(o, e) : typeof o == "object" && (o.mathjs && o.mathjs == "Complex" || o.type && o.type == "Complex") ? s += _s(el.re, el.im, e) : typeof o == "string" ? s += o : a ? s += _s(o, 0, e) : s += Nu(o, e);
  }), n.length && (e.minify ? s += " " : s += `
`), s += "]", s;
};
ge.prototype.matrixRe = function(t) {
  for (var e = [], r = 0; r < t.length; r++) {
    var n = t[r];
    if (Array.isArray(n)) {
      for (var a = [], s = 0; s < n.length; s++)
        typeof n[s] == "object" ? a.push(n[s].re) : a.push(n[s]);
      e.push(a);
    } else
      typeof n == "object" ? a.push(n.re) : a.push(n);
  }
  return e;
};
ge.prototype.matrixIm = function(t) {
  for (var e = [], r = 0; r < t.length; r++) {
    var n = t[r];
    if (Array.isArray(n)) {
      for (var a = [], s = 0; s < n.length; s++)
        typeof n[s] == "object" ? a.push(n[s].im) : a.push(0);
      e.push(a);
    } else
      typeof n == "object" ? a.push(n.im) : a.push(0);
  }
  return e;
};
ge.prototype.matrixAbs = function(t) {
  for (var e = [], r = 0; r < t.length; r++) {
    var n = t[r];
    if (Array.isArray(n)) {
      for (var a = [], s = 0; s < n.length; s++)
        a.push($t(n[s]));
      e.push(a);
    } else
      e.push($t(n));
  }
  return e;
};
ge.prototype.matrixArg = function(t) {
  for (var e = [], r = 0; r < t.length; r++) {
    var n = t[r];
    if (Array.isArray(n)) {
      for (var a = [], s = 0; s < n.length; s++)
        a.push(Rs(n[s]));
      e.push(a);
    } else
      e.push(Rs(n));
  }
  return e;
};
ge.prototype.setCombinedState = function(t) {
  for (var e = {}, r = 0, n = 0, a = 0; a < t.length; a++) {
    var s = t[a];
    s.wires.map(function(N) {
      N + 1 > n && (n = N + 1);
    });
  }
  for (var o = [], a = 0; a < t.length; a++) {
    var s = t[a], p = [];
    s.wires.map(function(C, x) {
      p.push({
        and: 1 << n - 1 - C,
        or: 1 << s.circuit.numQubits - 1 - x
      });
    }), o.push(p);
  }
  for (var u = 1 << n, f = 0; f < u; f++) {
    for (var l = null, a = 0; a < t.length; a++) {
      for (var c = o[a], h = 0, d = 0; d < c.length; d++)
        f & c[d].and && (h |= c[d].or);
      var s = t[a], g = s.circuit.state[h];
      g ? l == null ? l = g : l = it(g, l) : l = Wt(0, 0);
    }
    l && (l.re || l.im) && (e[f] = l, r |= f);
  }
  if (this.resetState(), this.numQubits < n) {
    for (this.numQubits = n; this.gates.length < this.numQubits; )
      this.gates.push([]);
    for (var v = this.numCols(), d = 0; d < this.gates.length; d++)
      for (; this.gates[d].length < v; )
        this.gates[d].push(null);
  }
  this.state = e, this.stateBits = r, this.stateBits == 0 && Object.keys(this.state).length == 0 && (this.state[0] = Wt(1, 0));
};
ge.prototype._setCombinedState = function(t, e, r) {
  r = r || {};
  var n = t.numQubits, a = e.numQubits;
  if (!r.wireMap) {
    r.wireMap = {
      c1: [],
      c2: []
    };
    for (var s = 0; s < n; s++)
      r.wireMap.c1.push(s);
    for (var s = 0; s < a; s++)
      r.wireMap.c2.push(s + n);
  }
  var o = 0;
  r.wireMap.c1.map(function(E) {
    E + 1 > o && (o = E + 1);
  }), r.wireMap.c2.map(function(E) {
    E + 1 > o && (o = E + 1);
  });
  var p = [];
  r.wireMap.c1.map(function(E, D) {
    p.push({ and: 1 << o - 1 - E, or: 1 << n - 1 - D });
  });
  var u = [];
  r.wireMap.c2.map(function(E, D) {
    u.push({ and: 1 << o - 1 - E, or: 1 << a - 1 - D });
  });
  for (var f = 0, s = 0; s < o; s++)
    r.wireMap.c1.indexOf(s) < 0 && r.wireMap.c2.indexOf(s) < 0 && (f |= 1 << o - 1 - s);
  for (var l = {}, c = 0, h = 1 << o, d = 0; d < h; d++)
    if (!(d & f)) {
      for (var g = 0, s = 0; s < p.length; s++)
        d & p[s].and && (g |= p[s].or);
      for (var v = 0, s = 0; s < u.length; s++)
        d & u[s].and && (v |= u[s].or);
      var N = t.state[g];
      if (N) {
        var b = e.state[v];
        if (b) {
          var C = it(N, b);
          (C.re || C.im) && (l[d] = C, c |= d);
        }
      }
    }
  if (this.resetState(), this.numQubits < o) {
    for (this.numQubits = o; this.gates.length < this.numQubits; )
      this.gates.push([]);
    for (var x = this.numCols(), s = 0; s < this.gates.length; s++)
      for (; this.gates[s].length < x; )
        this.gates[s].push(null);
  }
  this.state = l, this.stateBits = c, this.stateBits == 0 && Object.keys(this.state).length == 0 && (this.state[0] = Wt(1, 0));
};
ge.prototype.appendQubits = function(t) {
  var e = new ge(t);
  this._setCombinedState(this, e);
};
ge.prototype.numAmplitudes = function(t) {
  if (t) {
    var e = 0;
    for (var r in this.state) {
      var n = kt(this.state[r], 14);
      (n.re || n.im) && e++;
    }
    return e;
  }
  return _t(2, this.numQubits);
};
ge.prototype.numCols = function() {
  return this.gates.length ? this.gates[0].length : 0;
};
ge.prototype.numGates = function(t) {
  var e = null;
  t ? (e = new ge(), e.load(this.save(!0))) : e = this;
  for (var r = 0, n = e.numCols(), a = 0; a < n; a++)
    for (var s = 0; s < e.numQubits; s++) {
      var o = e.getGateAt(a, s);
      o && o.connector == 0 && r++;
    }
  return r;
};
ge.prototype.isEmptyCell = function(t, e) {
  if (this.gates[e] && this.gates[e][t])
    return !1;
  for (var r = 0; r < this.numQubits; r++) {
    var n = this.getGateAt(t, r);
    if (n && (n.name == "measure" || n.options && n.options.condition && n.options.condition.creg || Math.min.apply(null, n.wires) < e && Math.max.apply(null, n.wires) > e))
      return !1;
  }
  return !0;
};
ge.prototype.isEmptyPlace = function(t, e, r) {
  var n = Math.min.apply(null, e), a = Math.max.apply(null, e);
  if (r) {
    var s = this.numQubits - 1;
    s > a && (a = s);
  }
  for (var o = !0, p = n; p <= a; p++)
    if (!this.isEmptyCell(t, p)) {
      o = !1;
      break;
    }
  return o;
};
ge.prototype.lastNonEmptyPlace = function(t, e) {
  var r = this.numCols(), n = !0, a = Math.min.apply(null, t), s = Math.max.apply(null, t);
  if (e) {
    var o = this.numQubits - 1;
    o > s && (s = o);
  }
  for (; n && r--; )
    for (var p = a; p <= s; p++)
      if (!this.isEmptyCell(r, p)) {
        n = !1;
        break;
      }
  return r;
};
ge.prototype.insertColumn = function(t) {
  for (var e = 0; e < this.numQubits; e++)
    this.gates[e].splice(t || 0, 0, null);
};
ge.prototype.randomString = function(t) {
  t = t || 17;
  var e = "", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  e += r.charAt(Math.floor(Math.random() * r.length)), r += "0123456789";
  for (var n = 0; n < t; n++)
    e += r.charAt(Math.floor(Math.random() * r.length));
  return e;
};
ge.prototype.addGate = function(t, e, r, n) {
  var a = [];
  if (Array.isArray(r))
    for (var s = 0; s < r.length; s++)
      a.push(r[s]);
  else
    a.push(r);
  e < 0 && (e = this.lastNonEmptyPlace(a, t == "measure" || n && n.condition && n.condition.creg) + 1);
  for (var o = a.length, p = this.randomString(), u = 0; u < o; u++) {
    var f = a[u];
    for (f + 1 > this.numQubits && (this.numQubits = f + 1); this.gates.length < this.numQubits; )
      this.gates.push([]);
    var l = this.numCols();
    e + 1 > l && (l = e + 1);
    for (var s = 0; s < this.gates.length; s++)
      for (; this.gates[s].length < l; )
        this.gates[s].push(null);
    var c = {
      id: p,
      name: t,
      connector: u,
      options: {}
    };
    if (n && (c.options = n, n.creg && n.creg.name && typeof n.creg.bit < "u")) {
      var h = parseInt(n.creg.bit || 0);
      isNaN(h) && (h = 0);
      var d = this.cregs[n.creg.name] || [], g = d.length > h ? d[n.creg.bit] : 0;
      this.setCregBit(n.creg.name, h, g);
    }
    this.gates[f][e] = c;
  }
  return p;
};
ge.prototype.appendGate = function(t, e, r) {
  return this.addGate(t, -1, e, r);
};
ge.prototype.insertGate = function(t, e, r, n) {
  var a = [];
  if (Array.isArray(r))
    for (var s = 0; s < r.length; s++)
      a.push(r[s]);
  else
    a.push(r);
  e < 0 && (e = this.lastNonEmptyPlace(a, !!t && t == "measure" || n && n.condition && n.condition.creg) + 1);
  for (var o = a.length, p = 0; p < o; p++) {
    var u = a[p];
    for (u + 1 > this.numQubits && (this.numQubits = u + 1); this.gates.length < this.numQubits; )
      this.gates.push([]);
    var f = this.numCols();
    e + 1 > f && (f = e + 1);
    for (var s = 0; s < this.gates.length; s++)
      for (; this.gates[s].length < f; )
        this.gates[s].push(null);
  }
  this.isEmptyPlace(e, a, !!t && t == "measure" || n && n.condition && n.condition.creg) || this.insertColumn(e);
  var l = null;
  return t && (l = this.addGate(t, e, a, n)), l;
};
ge.prototype.insertSpace = function(t, e) {
  return this.insertGate(null, t, e, null);
};
ge.prototype.removeGateAt = function(t, e) {
  if (this.gates[e]) {
    var r = this.gates[e][t];
    if (r)
      for (var n = r.id, a = this.gates.length, s = 0; s < a; s++) {
        var o = this.gates[s][t];
        o && o.id == n && (this.gates[s][t] = null);
      }
  }
};
ge.prototype.removeGate = function(t) {
  var e = this.getGatePosById(t);
  !e || e.col < 0 || !e.wires.length || this.removeGateAt(e.col, e.wires[0]);
};
ge.prototype.addMeasure = function(t, e, r) {
  this.addGate("measure", -1, t, { creg: { name: e, bit: r } });
};
ge.prototype.appendCircuit = function(t, e) {
  for (var r = this.numCols(), n = t.numCols(), a = 0; a < n; a++)
    for (var s = 0; s < t.numQubits; s++) {
      var o = t.getGateAt(a, s);
      o && o.connector == 0 && (!this.basicGates[o.name] && t.customGates[o.name] && this.registerGate(o.name, t.customGates[o.name]), this.addGate(o.name, a + r, o.wires, o.options));
    }
};
ge.prototype.removeTrailingColumns = function() {
  for (var t = this.numCols(), e = t - 1; e >= 0; e--) {
    for (var r = !0, n = 0; n < this.numQubits; n++) {
      var a = this.gates[n][e];
      if (a) {
        r = !1;
        break;
      }
    }
    if (!r)
      return;
    for (var n = 0; n < this.numQubits; n++)
      this.gates[n].pop();
  }
};
ge.prototype.removeLeadingColumns = function() {
  for (var t = 0, e = this.numCols(), r = 0; r < e; r++) {
    for (var n = !0, a = 0; a < this.numQubits; a++) {
      var s = this.gates[a][r];
      if (s) {
        n = !1;
        break;
      }
    }
    if (!n)
      break;
    t++;
  }
  for (var o = 0; o < t; o++)
    for (var a = 0; a < this.numQubits; a++)
      this.gates[a].shift();
};
ge.prototype.removeTrailingRows = function() {
  for (var t = this.numCols(), e = this.numQubits - 1; e >= 0; e--) {
    for (var r = !0, n = 0; n < t; n++) {
      var a = this.gates[e][n];
      if (a) {
        r = !1;
        break;
      }
    }
    if (!r)
      return;
    this.gates.pop(), this.numQubits--;
  }
};
ge.prototype.removeQubit = function(t) {
  if (this.gates[t]) {
    this.resetState();
    for (var e = this.numCols(), r = 0; r < e; r++)
      this.removeGateAt(r, t);
    for (var n = t + 1; n < this.numQubits; n++)
      for (var r = 0; r < e; r++)
        this.gates[n - 1][r] = this.gates[n][r];
    this.gates.pop(), this.numQubits--;
  }
};
ge.prototype.flipVertically = function() {
  this.resetState();
  for (var t = this.numCols(), e = this.numQubits - 1, r = 0; r < this.numQubits / 2; r++)
    for (var n = 0; n < t; n++) {
      var a = this.gates[r][n];
      this.gates[r][n] = this.gates[e - r][n], this.gates[e - r][n] = a;
    }
};
ge.prototype.flipHorizontally = function() {
  this.resetState();
  for (var t = this.numCols(), e = t - 1, r = 0; r < this.numQubits; r++)
    for (var n = 0; n < t / 2; n++) {
      var a = this.gates[r][n];
      this.gates[r][n] = this.gates[r][e - n], this.gates[r][e - n] = a;
    }
};
ge.prototype.applyTransform = function(t, e) {
  var r = {}, n = 0;
  if (e = e.slice(0), this.reverseBitOrder)
    for (var a = 0; a < e.length; a++)
      e[a] = this.numQubits - 1 - e[a];
  e.reverse();
  for (var s = [], a = 0; a < this.numQubits; a++)
    e.indexOf(a) < 0 && s.push(a);
  var o = s.length, p = 1 << o;
  function u(O) {
    var T = 0;
    return e.map(function(I, q) {
      O & 1 << q && (T |= 1 << I);
    }), T;
  }
  function f() {
    var O = 0;
    return e.map(function(T, I) {
      O |= 1 << T;
    }), O + 1;
  }
  function l() {
    var O = 0;
    return s.map(function(T, I) {
      O |= 1 << T;
    }), O;
  }
  for (var c = Wt(0, 0), h = 0; h < t.length; h++)
    for (var d = u(h), g = 0; g < t[h].length; g++) {
      var v = u(g);
      if ((this.stateBits & v) == v) {
        var N = t[h][g];
        if (N)
          for (var b = d, C = v, x = p, E = u(0), D = f(), A = l(), M = E; x--; ) {
            var _ = this.state[C];
            _ && (b = M | d, N == 1 ? r[b] = ut(r[b] || c, _) : r[b] = ut(r[b] || c, it(N, _)), n |= b), M = M + D & A, C = M | v;
          }
      }
    }
  this.state = r, this.stateBits = n, this.stateBits == 0 && Object.keys(this.state).length == 0 && (this.state[0] = Wt(1, 0));
};
ge.prototype.transformMatrix = function(t, e, r, n) {
  r = r.slice(0);
  var a = !1;
  if (n ? a = n == "big" : a = !this.reverseBitOrder, a)
    for (var s = 0; s < r.length; s++)
      r[s] = t - 1 - r[s];
  r.reverse();
  for (var o = [], s = 0; s < t; s++)
    r.indexOf(s) < 0 && o.push(s);
  var p = o.length, u = 1 << p;
  function f(O) {
    var T = 0;
    return r.map(function(I, q) {
      O & 1 << q && (T |= 1 << I);
    }), T;
  }
  function l() {
    var O = 0;
    return r.map(function(T, I) {
      O |= 1 << T;
    }), O + 1;
  }
  function c() {
    var O = 0;
    return o.map(function(T, I) {
      O |= 1 << T;
    }), O;
  }
  for (var h = yr([1 << t, 1 << t]), d = 0; d < e.length; d++)
    for (var g = f(d), v = 0; v < e[d].length; v++) {
      var N = f(v), b = e[d][v];
      if (b)
        for (var C = g, x = N, E = u, D = f(0), A = l(), M = c(), _ = D; E--; )
          C = _ | g, h[C][x] = b, _ = _ + A & M, x = _ | N;
    }
  return h;
};
ge.prototype.circuitMatrix = function(t) {
  var e = new ge();
  if (e.load(this.save(!0)), e.gotClassicalControl())
    return [];
  for (var r = [], n = e.numCols() - 1; n >= 0; n--)
    for (var a = e.numQubits - 1; a >= 0; a--) {
      var s = e.getGateAt(n, a);
      if (s && s.connector == 0) {
        var o = e.basicGates[s.name];
        if (!o)
          throw new Error('Unknown gate "' + s.name + '"');
        if (o.matrix && o.matrix.length) {
          var p = e.getRawGate(o, s.options), u = e.transformMatrix(e.numQubits, p, s.wires, t);
          !r || !r.length ? r = u : r = this.multiplySquareMatrices(r, u);
        }
      }
    }
  return r;
};
ge.prototype.eigenvalues2x2 = function(t) {
  var e = this.parseMatrix(t), r = [0, 0], n = ut(e[0][0], e[1][1]);
  return r[0] = ur(ut(n, dr(ut(it(it(4, e[0][1]), e[1][0]), _t(Xt(e[0][0], e[1][1]), 2)))), 2), r[1] = ur(Xt(n, dr(ut(it(it(4, e[0][1]), e[1][0]), _t(Xt(e[0][0], e[1][1]), 2)))), 2), r;
};
ge.prototype.getBipartiteState = function(t, e) {
  var r = {}, n = 0;
  function a(l, c) {
    var h = ut(l, c), d = h.arg();
    return Wt({ abs: dr(_t($t(l), 2) + _t($t(c), 2)), arg: d });
  }
  for (var s in this.state) {
    var o = parseInt(s), p = 0, u = o & 1 << t ? 1 : 0, f = o & 1 << e ? 2 : 0;
    p |= u, p |= f, typeof r[p] < "u" ? r[p] = a(r[p], this.state[s]) : r[p] = this.state[s], n++;
  }
  return n || (r[0] = Wt(1, 0)), r;
};
ge.prototype.chanceMap = function() {
  for (var t = {}, e = 0; e < this.numQubits; e++)
    for (var r = 0; r < this.numQubits; r++)
      t[e] || (t[e] = {}), r == e ? t[e][r] = null : t[e][r] = {};
  for (var e = 0; e < this.numQubits; e++)
    for (var r = e + 1; r < this.numQubits; r++) {
      var n = this.getBipartiteState(e, r), a = new ge(2);
      a.state = n;
      var s = $t(a.angles()[0].radius), o = kt(1 - _t(s, 2), 7);
      t[e][r].entangled = o > 0, t[e][r].concurence = o, t[e][r].concurencePercent = kt(o * 100, 2), t[r][e].entangled = o > 0, t[r][e].concurence = o, t[r][e].concurencePercent = kt(o * 100, 2);
    }
  return t;
};
function TS(t, e) {
  for (var r = t.toString(2); r.length < e; )
    r = "0" + r;
  return r;
}
function _S(t, e) {
  return parseInt(TS(t, e).split("").reverse().join(""), 2);
}
ge.prototype.resetQubit = function(t, e) {
  var r = [
    [0, 0],
    [0, 0]
  ], n = null;
  this.reverseBitOrder ? n = _t(2, this.numQubits - 1 - t) : n = _t(2, t);
  var a = 0;
  for (var s in this.state) {
    var o = parseInt(s);
    (e ? o & n : !(o & n)) && (a += _t($t(this.state[s]), 2));
  }
  a = kt(a, 14), a != 1 && (e ? a == 0 ? r[1][0] = 1 : r[1][1] = dr(1 / a) : a == 0 ? r[0][1] = 1 : r[0][0] = dr(1 / a), this.collapsed = [], this.prob = [], this.applyTransform(r, [t]));
};
ge.prototype.applyGate = function(t, e, r, n) {
  if (t == "measure") {
    if (!n.creg)
      throw 'Error: "measure" gate requires destination.';
    var a = this.measure(r[0], n.creg.name, n.creg.bit), s = this.measureResetsQubit;
    if (!s)
      for (var o = e; o < this.numCols(); o++) {
        for (var p = o == e ? r[0] : 0, u = p; u < this.numQubits; u++) {
          var f = this.gates[u][o];
          if (f && f.name != "measure") {
            s = !0;
            break;
          }
        }
        if (s)
          break;
      }
    s && this.resetQubit(r[0], a);
    return;
  }
  if (t == "reset") {
    this.resetQubit(r[0], 0);
    return;
  }
  var l = this.basicGates[t];
  if (!l) {
    console.log('Unknown gate "' + t + '".');
    return;
  }
  var c = this.getRawGate(l, n);
  this.collapsed = [], this.prob = [], this.applyTransform(c, r);
};
ge.prototype.getRawGate = function(t, e, r) {
  var n = r && r.params ? r.params : this.options && this.options.params ? this.options.params : {}, n = JSON.parse(JSON.stringify(n));
  for (var a in n)
    n[a] = Br(n[a]);
  var s = [];
  return t.matrix.map(function(o) {
    var p = [];
    o.map(function(u) {
      if (typeof u == "string") {
        var f = e ? e.params || {} : {}, l = {};
        t.params.map(function(h, d) {
          Array.isArray(f) ? l[h] = f.length > d ? Br(f[d], n) : null : l[h] = Br(String(f[h]), n);
        });
        var c = Br(u, l);
        p.push(c);
      } else
        p.push(u);
    }), s.push(p);
  }), s;
};
ge.prototype.countParameterizedGates = function() {
  for (var t = 0, e = this.numCols(), r = 0; r < e; r++)
    for (var n = 0; n < this.numQubits; n++) {
      var a = this.getGateAt(r, n);
      if (a && a.connector == 0 && a.options && a.options.params) {
        var s = 0;
        for (paramName in a.options.params)
          s++;
        s > 0 && t++;
      }
    }
  return t;
};
ge.prototype.findGlobalParams = function() {
  for (var t = {
    globalParams: [],
    cells: []
  }, e = function(h) {
    var d = [], g = function(N, b) {
      N.isSymbolNode && !N.isFunctionNode && !NS[N.name] && d.push(N.name);
    }, v = Et(h);
    return v.toString({ handler: g }), d;
  }, r = this.numCols(), n = 0; n < r; n++)
    for (var a = 0; a < this.numQubits; a++) {
      var s = this.getGateAt(n, a);
      if (s && s.connector == 0 && s.options && s.options.params) {
        var o = !1;
        for (var p in s.options.params) {
          var u = s.options.params[p];
          if (typeof u == "string") {
            var f = e(u);
            if (f.length) {
              for (var l = 0; l < f.length; l++)
                t.globalParams.indexOf(f[l]) < 0 && t.globalParams.push(f[l]);
              if (!o) {
                var c = Math.max.apply(null, s.wires);
                t.cells.push([n, c]), o = !0;
              }
            }
          }
        }
      }
    }
  return t;
};
ge.prototype.getGlobalParams = function() {
  var t = this.findGlobalParams().globalParams;
  return t;
};
ge.prototype.gotGlobalParams = function() {
  var t = this.getGlobalParams();
  return t.length > 0;
};
ge.prototype.updateGlobalParams = function() {
  this.params = this.getGlobalParams(), this.options = this.options || {}, this.options.params = this.options.params || {};
  for (var t = 0; t < this.params.length; t++) {
    var e = this.params[t];
    typeof this.options.params[e] > "u" && (this.options.params[e] = 0);
  }
  for (var e in this.options.params)
    this.params.indexOf(e) < 0 && delete this.options.params[e];
  return this.params;
};
ge.prototype.makeAllParamsGlobal = function() {
  for (var t = this.getGlobalParams(), e = function(g) {
    var v = [], N = function(C, x) {
      C.isSymbolNode && !C.isFunctionNode && !NS[C.name] && v.push(C.name);
    }, b = Et(g);
    return b.toString({ handler: N }), v;
  }, r = this.numCols(), n = 0; n < r; n++)
    for (var a = 0; a < this.numQubits; a++) {
      var s = this.getGateAt(n, a);
      if (s && s.connector == 0 && s.options && s.options.params)
        for (var o in s.options.params) {
          var p = s.options.params[o], u = !1;
          if (typeof p == "string") {
            var f = e(p);
            f.length && (u = !0);
          }
          if (!u) {
            for (var l = 0; t.indexOf("var" + l) >= 0; )
              l++;
            var c = "var" + l;
            t.push(c);
            for (var h = 0; h < s.wires.length; h++) {
              var d = this.gates[s.wires[h]][n];
              d.options.params[o] = c;
            }
            this.params.push(c), this.options.params[c] = p;
          }
        }
    }
};
ge.prototype.decompose = function(t) {
  if (!t.gates.length)
    return t;
  this.updateGlobalParams();
  function e(D, A, M) {
    return D.slice(0, M).concat(A).concat(D.slice(M));
  }
  for (var r = 0; r < t.gates[0].length; r++)
    for (var n = 0; n < t.numQubits; n++) {
      var a = t.gates[n][r];
      if (a && a.connector == 0 && !this.basicGates[a.name]) {
        var s = new ge(), o = t.customGates[a.name];
        if (o) {
          if (s.load(o), s.params.length && a.options && a.options.params)
            for (var p = a.options.params, u = 0; u < s.gates[0].length; u++)
              for (var f = 0; f < s.numQubits; f++) {
                var l = s.gates[f][u];
                if (l && l.connector == 0 && l.options && l.options.params)
                  for (var c in l.options.params) {
                    var h = Et(l.options.params[c]), d = h.transform(function(D, A, M) {
                      return D.isSymbolNode && p.hasOwnProperty(D.name) ? Et("(" + p[D.name] + ")") : D;
                    });
                    l.options.params[c] = d.toString();
                  }
              }
          if (a.options && a.options.condition)
            for (var u = 0; u < s.gates[0].length; u++)
              for (var f = 0; f < s.numQubits; f++) {
                var l = s.gates[f][u];
                l && (l.options = l.options || {}, l.options.condition = a.options.condition);
              }
          var g = s.save(!0);
          if (!g.gates[0].length)
            for (var v = 0; v < g.gates.length; v++)
              g.gates[v].push(null);
          for (var N = [], b = 0; b < g.gates[0].length - 1; b++)
            N.push(null);
          for (var C = 0; C < t.numQubits; C++) {
            var x = t.gates[C][r];
            if (x && x.id == a.id) {
              t.gates[C].splice(r, 1);
              for (var E = JSON.parse(JSON.stringify(g.gates[x.connector])), v = 0; v < E.length; v++)
                E[v] && (E[v].id = E[v].id + "_" + a.id);
              t.gates[C] = e(t.gates[C], E, r);
            } else
              t.gates[C] = e(t.gates[C], N, r + 1);
          }
        }
      }
    }
  return t.customGates = {}, t;
};
ge.prototype.decomposeGateAt = function(t, e) {
  var r = this, n = this.getGateAt(t, e);
  if (n && this.customGates[n.name]) {
    var a = new ge();
    a.load(this.save());
    for (var s = 0; s < a.gates[0].length; s++)
      for (var o = 0; o < a.numQubits; o++) {
        var p = a.gates[o][s];
        p && p.id != n.id && a.removeGateAt(s, o);
      }
    var u = new ge();
    u.load(a.save(!0)), u.removeLeadingColumns(), u.removeTrailingColumns();
    for (var f = 0; f < u.gates[0].length - 1; f++)
      this.insertSpace(t + f, n.wires);
    this.removeGate(n.id);
    for (var l = t, s = 0; s < u.gates[0].length; s++) {
      var c = u.getGatesAtColumn(s);
      c.map(function(d) {
        r.addGate(d.name, l, d.wires, d.options);
      }), l++;
    }
    return u;
  }
};
ge.prototype.removeMeasurementAndClassicalControl = function() {
  for (var t = this.numCols(), e = 0; e < t; e++)
    for (var r = 0; r < this.numQubits; r++) {
      var n = this.gates[r][e];
      n && n.name == "measure" && (this.gates[r][e] = null, n = null), n && n.options && n.options.condition && delete this.gates[r][e].options.condition;
    }
  this.cregs = {}, this.options && (this.options.hybrid = !1, this.options.hybridOptions && delete this.options.hybridOptions);
};
ge.prototype.convertToCustomGate = function(t, e, r) {
  for (var n = this.numCols(), a = 0; a < n; a++)
    for (var s = 0; s < this.numQubits; s++) {
      var o = this.gates[s][a];
      o && o.name == "measure" && (this.gates[s][a] = null, o = null), o && o.options && o.options.condition && delete this.gates[s][a].options.condition;
    }
  this.cregs = {};
  var p = this.save(e);
  if (p.options && (p.options.hybrid = !1, p.options.hybridOptions && delete p.options.hybridOptions), this.clear(), this.customGates[t] = p, r) {
    for (var u = [], f = 0; f < this.numQubits; f++)
      u.push(f);
    var l = JSON.parse(JSON.stringify(this.customGates[t].options));
    this.addGate(t, -1, u, l);
  } else
    this.removeTrailingRows();
};
ge.prototype.validCustomGateName = function(t) {
  t = (t || "sub") + "";
  var e = [];
  if (this.customGates) {
    if (!this.basicGates[t] && !this.customGates[t])
      return t;
    for (var r in this.basicGates)
      e.push(r);
    for (var r in this.customGates)
      e.push(r);
  }
  var n = 0, a = "";
  do
    n++, a = t + n;
  while (e.indexOf(a) >= 0);
  return a;
};
ge.prototype.splitIntoBlocks = function(t, e) {
  e = e || {};
  var r = [], n = "{}", a = !0, s = null, o = new ge();
  o.load(this.save(!0));
  for (var p = o.numCols(), u = 0; u < p; u++)
    for (var f = 0; f < o.numQubits; f++) {
      var l = o.getGateAt(u, f);
      if (l && l.connector == 0 && !l.addedToBlock) {
        var c = this.basicGates[l.name], h = l.options && l.options.condition ? JSON.stringify(l.options.condition) : "{}", d = c && !!(c.matrix && c.matrix.length), g = JSON.parse(JSON.stringify(s ? s.wires : []));
        if (l.wires.map(function(W) {
          g.indexOf(W) < 0 && g.push(W);
        }), !r.length || h != n || !d || !a || !(g.length <= t) ? (s = {
          wires: l.wires,
          gates: [l]
        }, r.push(s), l.options && l.options.condition && (s.condition = l.options.condition)) : (s.wires = g, s.gates.push(l)), l.wires.map(function(W) {
          o.gates[W][u].addedToBlock = !0;
        }), n = h, a = d, !e.verticalOnly) {
          var v = u + 1, N = JSON.parse(JSON.stringify(s.wires));
          for (N.sort(); v < p && N.length; ) {
            for (extWire = N[0]; N.length && extWire <= N[N.length - 1]; ) {
              var b = o.getGateAt(v, extWire);
              if (b && !b.addedToBlock) {
                var C = this.basicGates[b.name], x = b.options && b.options.condition ? JSON.stringify(b.options.condition) : "{}", E = C && !!(C.matrix && C.matrix.length), D = E && x == h;
                if (D) {
                  for (var A = 0; A < b.wires.length; A++)
                    if (N.indexOf(b.wires[A]) < 0) {
                      D = !1;
                      break;
                    }
                }
                if (D)
                  s.gates.push(b), b.wires.map(function(W) {
                    o.gates[W][v].addedToBlock = !0;
                  });
                else {
                  for (var M = [], A = 0; A < N.length; A++) {
                    var _ = N[A];
                    b.wires.indexOf(_) < 0 && M.push(_);
                  }
                  N = M;
                }
              }
              if (N.length) {
                for (var O = N[N.length - 1] + 1, A = N.length - 1; A >= 0; A--) {
                  var _ = N[A];
                  _ > extWire && (O = _);
                }
                extWire = O;
              }
            }
            v++;
          }
        }
      }
    }
  for (var T = new ge(), I = 0, q = 0; q < r.length; q++) {
    var $ = r[q], U = !1;
    if ($.wires.length <= t || e.flexibleBlockSize)
      for (var k = 0; k < $.gates.length; k++) {
        var l = $.gates[k], c = this.basicGates[l.name];
        c.matrix && c.matrix.length && (U = !0);
      }
    if (U) {
      I++;
      for (var L = new ge(), k = 0; k < $.gates.length; k++) {
        var l = $.gates[k];
        l.options.condition && delete l.options.condition;
        var R = [];
        l.wires.map(function(Z) {
          R.push($.wires.indexOf(Z));
        }), l.wires = R, L.appendGate(l.name, R, l.options);
      }
      var G = "block" + I;
      T.registerGate(G, L);
      var P = {};
      $.condition && (P.condition = $.condition), T.appendGate(G, $.wires, P);
    } else
      $.gates.map(function(W) {
        T.appendGate(W.name, W.wires, W.options);
      });
  }
  this.load(T.save(!1));
};
ge.prototype.usedGates = function(t) {
  t = t || {};
  var e = new ge();
  e.load(this.save(!0));
  for (var r = [], n = 0; n < e.numQubits; n++)
    for (var a = 0; a < e.numCols(); a++) {
      var s = e.gates[n][a];
      if (s && r.indexOf(s.name) < 0) {
        var o = !1;
        if (t.unitariesOnly) {
          var p = e.basicGates[s.name];
          (!p || !p.matrix || !p.matrix.length) && (o = !0);
        }
        o || r.push(s.name);
      }
    }
  if (!t.noCustomGates)
    for (var u in this.customGates)
      this.customGates[u], r.indexOf(u) < 0 && r.push(u);
  return r;
};
ge.prototype.countOps = function(t, e) {
  e = e || {}, e.shallow = e.shallow || !1, t || (t = this);
  for (var r = {}, n = 0; n < t.gates.length; n++)
    for (var a = 0; a < t.gates[n].length; a++) {
      var s = t.gates[n][a];
      if (s && s.connector == 0) {
        var o = this.basicGates[s.name];
        if (o)
          r[s.name] ? r[s.name]++ : r[s.name] = 1;
        else {
          var p = this.customGates[s.name];
          if (p && (r[s.name] ? r[s.name]++ : r[s.name] = 1, !e.shallow)) {
            var u = this.countOps(p, e);
            for (subName in u)
              r[subName] ? r[subName] += u[subName] : r[subName] = u[subName];
          }
        }
      }
    }
  return r;
};
ge.prototype.getCouplingMap = function(t) {
  t = t || {};
  var e = "", r = new ge();
  r.load(this.save(!0));
  for (var n = 0; n < r.numQubits; n++)
    for (var a = 0; a < r.numCols(); a++) {
      var s = r.getGateAt(a, n);
      if (s && s.connector == 0) {
        var o = !1;
        if (t.unitariesOnly) {
          var p = r.basicGates[s.name];
          (!p || !p.matrix || !p.matrix.length) && (o = !0);
        }
        if (!o) {
          var u = JSON.stringify(s.wires);
          e.indexOf(u) < 0 && (e && (e += ","), e += u);
        }
      }
    }
  return JSON.parse("[" + e + "]");
};
ge.prototype.getGateDef = function(t) {
  var e = this.basicGates[t];
  return e || (e = this.customGates[t]), e;
};
ge.prototype.importRaw = function(t, e) {
  var r = t && t.qubits || 0;
  if (this.init(r), !t)
    if (e)
      e([]);
    else
      return;
  if (t.cregs)
    for (var n = 0; n < t.cregs.length; n++) {
      var a = t.cregs[n];
      if (!a.name) {
        var s = "Classical register " + n + ` doesn't have a "name".`;
        if (e) {
          e([{ msg: s, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(s);
      }
      this.createCreg(a.name, a.len || 0);
    }
  if (t.program)
    for (var n = 0; n < t.program.length; n++) {
      var o = t.program[n];
      if (!o.name) {
        var s = "Gate " + n + ` doesn't have a "name". Name is optional and this is OK for QubitToaster but we cannot import gate from matrix. Not implemented yet.`;
        if (e) {
          e([{ msg: s, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(s);
      }
      var p = this.basicGates[o.name];
      if (!p) {
        var s = 'Unknown gate "' + o.name + '". Name is optional and this is OK for QubitToaster but we cannot import gate from matrix. We can import only gates by name from set of known gates.';
        if (e) {
          e([{ msg: s, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(s);
      }
      var u = JSON.parse(JSON.stringify(o.wires || [])), f = JSON.parse(JSON.stringify(o.options || {})), l = p.matrix && p.matrix.length ? vi(p.matrix.length) : 1;
      if (u.length != l) {
        var s = 'Gate "' + o.name + '" has ' + u.length + " wires but should have " + l + " wires.";
        if (e) {
          e([{ msg: s, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(s);
      }
      if (p.params && p.params.length) {
        if (!f.params) {
          var s = 'Missing parameters for gate "' + o.name + '". Expecting ' + p.params.length + " parameters.";
          if (e) {
            e([{ msg: s, line: 0, col: 0 }]);
            return;
          } else
            throw new Error(s);
        }
        for (var c = 0; c < p.params.length; c++) {
          var h = p.params[c];
          if (typeof f.params[h] > "u") {
            var s = 'Missing parameter "' + h + '" for gate "' + o.name + '".';
            if (e) {
              e([{ msg: s, line: 0, col: 0 }]);
              return;
            } else
              throw new Error(s);
          }
        }
      }
      this.appendGate(o.name, u, f);
    }
  e && e([]);
};
ge.prototype.exportRaw = function() {
  var t = this.options && this.options.params ? this.options.params : {}, t = JSON.parse(JSON.stringify(t));
  for (var e in t)
    t[e] = Br(t[e]);
  var r = new ge();
  r.load(this.save(!0));
  for (var n = r.numCols(), a = [], s = 0; s < n; s++)
    for (var o = 0; o < r.numQubits; o++) {
      var p = r.getGateAt(s, o);
      if (p && p.connector == 0) {
        var u = r.basicGates[p.name];
        if (!u) {
          console.log('Unknown gate "' + p.name + '".');
          return;
        }
        var f = r.getRawGate(u, p.options), l = [];
        f.map(function(v) {
          var N = [];
          v.map(function(b) {
            b = JSON.parse(JSON.stringify(b)), typeof b == "object" && b.mathjs && typeof b.mathjs == "string" && (b.type = b.mathjs.toLowerCase(), delete b.mathjs), N.push(b);
          }), l.push(N);
        });
        var c = {};
        if (p.options && (c = JSON.parse(JSON.stringify(p.options))), c.params)
          for (var h in c.params)
            c.params[h] = Br(c.params[h], t);
        a.push({
          name: p.name,
          matrix: l,
          wires: p.wires,
          options: c
        });
      }
    }
  var d = [];
  for (var g in r.cregs)
    d.push({
      name: g,
      len: r.cregs[g].length || 0
    });
  return {
    qubits: r.numQubits,
    cregs: d,
    program: a
  };
};
ge.prototype.exportToGenerator = function(t) {
  t = t || {};
  var e = this.exportQASM(null, !1, null, !1, !0), r = this.usedGates({ noCustomGates: !0, unitariesOnly: !0 }), n = this.getCouplingMap({ unitariesOnly: !0 }), a = {
    source: {
      circuit: {
        qasm: e
      }
    },
    problem: [],
    type: "circuit",
    settings: {
      allowed_gates: r.join(","),
      coupling_map: n
    }
  }, s = new ge();
  if (s.load(this.save(!0)), t.fromMatrix) {
    var o = s.circuitMatrix(), p = [];
    return o.map(function(d) {
      d.map(function(g) {
        typeof g == "object" ? p.push([g.re, g.im]) : p.push(g);
      });
    }), a.problem.push({
      unitary: p
    }), a;
  }
  if (!t.noVectors) {
    for (var u = new ge(), f = t.numSamples || (this.numQubits < 3 ? 8 : this.numQubits < 5 ? (1 << this.numQubits) + 1 : this.numQubits < 9 ? this.numQubits * 4 : this.numQubits), l = 0; l < f + 1; l++) {
      var c = { input: [], output: [] }, h = [];
      l > 0 ? (u.randomCircuit(this.numQubits, 20, { useGates: t.useGates || ["u3", "cx"], noClassicControl: !0, noMeasure: !0, noReset: !0 }), u.run(), u.stateAsArray().map(function(d) {
        c.input.push([d.amplitude.re, d.amplitude.im]);
      }), h = u.state) : (s.initState(), s.stateAsArray().map(function(d) {
        c.input.push([d.amplitude.re, d.amplitude.im]);
      }), h = s.state), s.run(null, { initialState: h }), s.stateAsArray().map(function(d) {
        c.output.push([d.amplitude.re, d.amplitude.im]);
      }), a.problem.push(c);
    }
    return a;
  }
  return a;
};
ge.prototype.save = function(t, e) {
  this.updateGlobalParams();
  var r = {
    numQubits: this.numQubits,
    params: JSON.parse(JSON.stringify(this.params)),
    options: JSON.parse(JSON.stringify(this.options)),
    gates: JSON.parse(JSON.stringify(this.gates)),
    customGates: JSON.parse(JSON.stringify(this.customGates)),
    cregs: JSON.parse(JSON.stringify(this.cregs))
  }, n = null;
  if (t ? n = this.decompose(r) : n = r, e && (n.gates && n.gates.map(function(o) {
    o && o.map(function(p) {
      p && p.id && delete p.id;
    });
  }), n.customGates))
    for (var a in n.customGates) {
      var s = n.customGates[a];
      s && s.gates && s.gates.map(function(o) {
        o && o.map(function(p) {
          p && p.id && delete p.id;
        });
      });
    }
  return n;
};
ge.prototype.load = function(t) {
  this.numQubits = t.numQubits || 1, this.clear(), this.params = JSON.parse(JSON.stringify(t.params || [])), this.options = JSON.parse(JSON.stringify(t.options || {})), this.gates = JSON.parse(JSON.stringify(t.gates || [])), this.customGates = JSON.parse(JSON.stringify(t.customGates || {})), this.cregs = JSON.parse(JSON.stringify(t.cregs || {})), this.options.params = this.options.params || {}, this.options.hybrid = this.options.hybrid || !1, this.options.hybridOptions || (this.options.hybridOptions = this.defaultHybridOptions());
};
var Sk = function(t) {
  if (t <= 0)
    throw new Error("Cannot generate the gray code for less than 1 bit.");
  var e = [0];
  for (i = 0; i < t; i++) {
    var r = [].concat(e).reverse();
    r.map(function(a) {
      e.push(a + _t(2, i));
    });
  }
  var n = [];
  return e.map(function(a) {
    n.push(TS(a, t));
  }), n;
};
ge.prototype.grayCodeChain = function(t, e, r) {
  function n(h, d) {
    for (var g = [], v = 0; v < h.length; v++)
      g.push(h[v] != d[v]);
    return g;
  }
  function a(h, d) {
    for (var g = [], v = 0; v < h.length; v++)
      h[v] == d && g.push(v);
    return g;
  }
  function s(h, d) {
    for (var g = 0, v = 0; v < h.length; v++)
      h[v] == d && g++;
    return g;
  }
  for (var o = [], p = 0; p < t; p++)
    o.push(p);
  var u = t, f = Sk(t), l = null, c = [];
  return f.map(function(h) {
    var d = h.indexOf("1");
    if (d >= 0) {
      l || (l = h);
      var g = n(h, l), v = g.indexOf(!0);
      if (v >= 0)
        if (v != d)
          c.push({ gateName: "cx", wires: [o[v], o[d]], options: null });
        else
          for (var N = a(h, "1"), b = 1; b < N.length; b++)
            c.push({ gateName: "cx", wires: [o[N[b]], o[d]], options: null });
      if (s(h, "1") % 2)
        c.push({ gateName: e, wires: [o[d], u], options: r });
      else {
        var C = null;
        if (r && (C = JSON.parse(JSON.stringify(r)), C.params))
          for (key in C.params) {
            var x = C.params[key];
            typeof x == "number" ? x = 0 - x : x = "-(" + x + ")", C.params[key] = x;
          }
        c.push({ gateName: e, wires: [o[d], u], options: C });
      }
      l = h;
    }
  }), c;
};
ge.prototype.MCU1Circuit = function(t) {
  var e = 0, r = [];
  if (typeof t == "number")
    e = t;
  else {
    e = t.length || 0;
    for (var n = 0; n < e; n++)
      (!t[n] || typeof t[n] == "number" && t[n] < 0) && r.push(n);
  }
  if (e == 0)
    throw new Error("Cannot create multi-controlled gate with zero control qubits.");
  function a(f, l) {
    l.map(function(c) {
      f.appendGate("x", c);
    });
  }
  var s = "lambda / " + _t(2, e - 1), o = { params: { lambda: s } }, p = new ge();
  if (e == 1)
    return a(p, r), p.appendGate("cu1", [0, 1], o), a(p, r), p;
  a(p, r);
  var u = this.grayCodeChain(e, "cu1", o);
  return u.map(function(f) {
    p.appendGate(f.gateName, f.wires, f.options);
  }), a(p, r), p;
};
ge.prototype.MCXCircuit = function(t) {
  var e = 0, r = [];
  if (typeof t == "number")
    e = t;
  else {
    e = t.length || 0;
    for (var n = 0; n < e; n++)
      (!t[n] || typeof t[n] == "number" && t[n] < 0) && r.push(n);
  }
  var a = new ge();
  if (e == 0)
    throw new Error("Cannot create multi-controlled gate with zero control qubits.");
  function s(f, l) {
    l.map(function(c) {
      f.appendGate("x", c);
    });
  }
  if (e == 1)
    return s(a, r), a.appendGate("cx", [0, 1]), s(a, r), a;
  if (e == 2)
    return s(a, r), a.appendGate("ccx", [0, 1, 2]), s(a, r), a;
  for (var o = a.MCU1Circuit(e), p = "mcu1_" + e, u = [], n = 0; n < e + 1; n++)
    u.push(n);
  return a.registerGate(p, o), s(a, r), a.appendGate("h", e), a.appendGate(p, u, { params: { lambda: "pi" } }), s(a, r), a.appendGate("h", e), a;
};
ge.prototype.registerGate = function(t, e) {
  if (e instanceof ge ? this.customGates[t] = e.save() : this.customGates[t] = e, this.isMultiControlledGate(t)) {
    var r = this.decodeMultiControlledGateName(t);
    if (r.numCtrlQubits != this.customGates[t].numQubits - 1) {
      r.numCtrlQubits = this.customGates[t].numQubits - 1;
      for (var n = [], a = 0; a < r.numCtrlQubits; a++)
        n.push(typeof r.ctrlQubits[a] > "u" ? !0 : r.ctrlQubits[a]);
      r.ctrlQubits = n;
    }
    var s = this.basicGates[r.rootName];
    if (s && s.drawingInfo && s.drawingInfo.connectors) {
      this.customGates[t].drawingInfo || (this.customGates[t].drawingInfo = {});
      var o = [];
      r.ctrlQubits.map(function(p) {
        p ? o.push("dot") : o.push("ndot");
      }), o.push(s.drawingInfo.connectors[s.drawingInfo.connectors.length - 1]), this.customGates[t].drawingInfo.connectors = o, this.customGates[t].drawingInfo.root = s.drawingInfo.root;
    }
  }
};
ge.prototype.registerMCXGate = function(t) {
  var e = this.multiControlledGateName("mcx", t);
  return this.registerGate(e, this.MCXCircuit(t).save(!0)), e;
};
ge.prototype.registerMCU1Gate = function(t) {
  var e = this.multiControlledGateName("mcu1", t);
  return this.registerGate(e, this.MCU1Circuit(t).save(!0)), e;
};
ge.prototype.registerMultiControlledGate = function(t, e) {
  switch (t) {
    case "cx":
      return this.registerMCXGate(e);
    case "cu1":
      return this.registerMCU1Gate(e);
  }
  return "";
};
ge.prototype.getOrRegisterMultiControlledEquivalent = function(t, e) {
  var r = this.basicGates[t];
  if (r) {
    if (r.drawingInfo && (t == "x" || t == "u1" || r.drawingInfo.root == "x" || r.drawingInfo.root == "u1"))
      if (!this.basicGates["c" + t] || e) {
        for (var n = "c" + (r.drawingInfo.root || t), a = vi(r.matrix.length), s = [], o = 0; o < a - 1; o++)
          s.push(!0);
        return s.unshift(!e), this.registerMultiControlledGate(n, s);
      } else
        return "c" + t;
    for (var p in this.basicGates) {
      var u = this.basicGates[p];
      if (u && u.drawingInfo && u.drawingInfo.root && u.drawingInfo.root == t && !e)
        return p;
    }
    return null;
  }
  if (this.customGates[t]) {
    var f = this.decodeMultiControlledGateName(t);
    return !f || !f.numCtrlQubits ? null : f.rootName == "cx" || f.rootName == "cu1" ? (f.ctrlQubits.unshift(!e), this.registerMultiControlledGate(f.rootName, f.ctrlQubits)) : null;
  }
  return null;
};
ge.prototype.removeUnusedMultiControlledGates = function() {
  var t = this.countOps(null, { shallow: !1 });
  for (gateName in this.customGates)
    t[gateName] || this.isMultiControlledGate(gateName) && delete this.customGates[gateName];
};
ge.prototype.decodeMultiControlledGateName = function(t) {
  if (!t)
    return null;
  var e = {}, r = t.split("_");
  if (r.length > 0 && (e.name = r[0], e.rootName = e.name.substring(1), e.rootName != "cx" && e.rootName != "cu1"))
    return null;
  if (r.length > 1) {
    var n = parseInt(r[1]);
    !isNaN(n) && n <= 20 && (e.numCtrlQubits = n);
  }
  if (e.numCtrlQubits) {
    var a = [];
    if (r.length > 2)
      for (var s = 0; s < r[2].length; s++)
        r[2][s] == "0" && a.push(!1), r[2][s] == "1" && a.push(!0);
    if (!a.length)
      for (var s = 0; s < n; s++)
        a.push(!0);
    e.ctrlQubits = a;
  }
  return e;
};
ge.prototype.multiControlledGateName = function(t, e) {
  var r = t + "_";
  if (typeof e == "number")
    r += e;
  else {
    r += e.length || 0;
    var n = "";
    e.map(function(a) {
      !a || typeof a == "number" && a < 0 ? n += "0" : n += "1";
    }), n.indexOf("0") < 0 && (n = ""), n && (r += "_" + n);
  }
  return r;
};
ge.prototype.isMultiControlledGate = function(t) {
  var e = this.decodeMultiControlledGateName(t), r = !!this.customGates[t] && !!e && !!e.numCtrlQubits;
  return r;
};
ge.prototype.isControllableGate = function(t) {
  var e = this.basicGates[t];
  if (e) {
    if (e.drawingInfo && (e.drawingInfo.root == "x" || e.drawingInfo.root == "u1"))
      return !0;
    for (var r in this.basicGates) {
      var e = this.basicGates[r];
      if (e && e.drawingInfo && e.drawingInfo.root && e.drawingInfo.root == t)
        return !0;
    }
  }
  return this.isMultiControlledGate(t);
};
ge.prototype.getGatePosById = function(t) {
  for (var e = this, r = e.numCols(), n = 0; n < r; n++)
    for (var a = 0; a < e.numQubits; a++) {
      var s = e.getGateAt(n, a);
      if (s && s.id == t)
        return {
          wires: s.wires,
          col: n
        };
    }
  return {
    wires: [],
    col: -1
  };
};
ge.prototype.getGateById = function(t) {
  for (var e = this, r = e.numCols(), n = 0; n < r; n++)
    for (var a = 0; a < e.numQubits; a++) {
      var s = e.getGateAt(n, a);
      if (s && s.id == t)
        return s;
    }
  return null;
};
ge.prototype.getGateBefore = function(t, e) {
  for (var r = null, n = t - 1; n >= 0 && !r; )
    r = this.getGateAt(n, e), n--;
  return r;
};
ge.prototype.getGateAt = function(t, e) {
  if (!this.gates[e] || !this.gates[e][t])
    return null;
  var r = JSON.parse(JSON.stringify(this.gates[e][t]));
  if (!r)
    return null;
  r.column = t, r.wires = [];
  for (var n = r.id, a = this.gates.length, e = 0; e < a; e++) {
    var s = this.gates[e][t];
    s && s.id == n && (r.wires[s.connector] = e);
  }
  return r;
};
ge.prototype.getGatesAtColumn = function(t) {
  for (var e = [], r = this.gates.length, n = 0; n < r; n++) {
    var a = this.getGateAt(t, n);
    a && a.connector == 0 && e.push(a);
  }
  return e;
};
ge.prototype.getControllableGatesAtColumn = function(t) {
  for (var e = this.getGatesAtColumn(t), r = [], n = 0; n < e.length; n++) {
    var a = e[n];
    this.isControllableGate(a.name) && r.push(a);
  }
  return r;
};
ge.prototype.exportJavaScript = function(t, e, r, n) {
  var a = this, s = null;
  e ? (s = new ge(), s.load(this.save(!0))) : s = this;
  var o = "";
  if (t) {
    var p = (t || "").split(`
`);
    p.map(function(O) {
      O.length >= 2 && O[0] != "/" && O[1] != "/" && (o += "// "), o += O, o += `
`;
    });
  }
  var u = "", f = "";
  if (r)
    u = "    ", f = "circ", o += "const " + r + ` = function() {
`, o += u + "const " + f + " = new QuantumCircuit(" + s.numQubits + `);

`, s.params && s.params.length && (o += u + f + ".params = " + JSON.stringify(s.params) + `

`);
  else {
    u = "", f = "circuit", o += u + `const QuantumCircuit = require("quantum-circuit");

`, o += u + "const " + f + " = new QuantumCircuit(" + s.numQubits + `);

`;
    var l = s.usedGates();
    if (!e) {
      var c = [];
      l.map(function(O) {
        var T = s.basicGates[O];
        if (!T) {
          var I = a.customGates[O];
          if (I) {
            var q = new ge();
            q.load(I), o += q.exportJavaScript("", !0, O), c.push(O);
          }
        }
      }), c.map(function(O) {
        o += u + f + '.registerGate("' + O + '", ' + O + `());
`;
      }), c.length > 0 && (o += `
`);
    }
  }
  var h = 0;
  for (var d in this.cregs)
    o += u + f + '.createCreg("' + d + '", ' + (this.cregs[d].length || 1) + `);
`, h++;
  h > 0 && (o += `
`);
  for (var g = s.numCols(), v = 0; v < g; v++)
    for (var N = 0; N < this.numQubits; N++) {
      var b = s.getGateAt(v, N);
      if (b && b.connector == 0) {
        var C = b.name;
        if (C == "measure" && b.options && b.options.creg)
          o += u + f + ".addMeasure(" + N + ', "' + b.options.creg.name + '", ' + b.options.creg.bit + `);
`;
        else {
          if (o += u + f + '.appendGate("' + b.name + '"', b.wires.length == 1)
            o += ", ", o += b.wires[0];
          else {
            o += ", [";
            for (var x = 0; x < b.wires.length; x++)
              x > 0 && (o += ","), o += b.wires[x];
            o += "]";
          }
          if (b.options) {
            var E = {};
            for (var D in b.options)
              if (b.options[D]) {
                var A = b.options[D], M = !1;
                typeof A == "object" && Object.keys(A).length === 0 && A.constructor === Object && (M = !0), M || (E[D] = A);
              }
            o += ", " + JSON.stringify(E);
          }
          o += `);
`;
        }
      }
    }
  if (r ? (o += `
`, o += u + "return " + f + `;
`, o += `};

`) : (o += `
`, o += u + f + `.run();

`, o += u + `console.log("Probabilities:");
`, o += u + `console.log(JSON.stringify(circuit.probabilities()));

`, o += u + `console.log("Measure all:");
`, o += u + `console.log(JSON.stringify(circuit.measureAll()));

`, s.cregCount() && (o += u + `console.log("Classical registers:");
`, o += u + `console.log(circuit.cregsAsString());

`)), n) {
    var _ = {
      metadata: {
        kernelspec: {
          display_name: "Javascript (Node.js)",
          language: "javascript",
          name: "javascript"
        },
        language_info: {
          file_extension: ".js",
          mimetype: "application/javascript",
          name: "javascript"
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: o,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(_);
  }
  return o;
};
ge.prototype.exportQiskit = function(t, e, r, n, a, s, o, p, u, f, l) {
  var c = {
    comment: t,
    decompose: e,
    versionStr: n,
    providerName: a,
    backendName: s,
    asJupyter: o,
    shots: p,
    hybrid: l
  };
  return this.exportToQiskit(c, r, u, f);
};
ge.prototype.exportQuEST = function(t, e, r, n) {
  var a = {
    comment: t,
    decompose: e
  };
  return this.exportToQuEST(a, r, n);
};
ge.prototype.exportQASM = function(t, e, r, n, a, s) {
  var o = {
    comment: t,
    decompose: e,
    compatibilityMode: a
  };
  return this.exportToQASM(o, r, n, s);
};
ge.prototype.importQASM = function(t, e, r) {
  this.init(), Ek(this, t, e, r);
};
ge.prototype.exportPyquil = function(t, e, r, n, a, s, o, p, u) {
  var f = {
    comment: t,
    decompose: e,
    versionStr: n,
    lattice: a,
    asQVM: s,
    asJupyter: o,
    shots: p,
    hybrid: u
  };
  return this.exportToPyquil(f, r);
};
ge.prototype.exportQuil = function(t, e, r, n) {
  var a = {
    comment: t,
    decompose: e,
    versionStr: n
  };
  return this.exportToQuil(a, r);
};
ge.prototype.importQuil = function(t, e, r, n, a, s) {
  var o = this;
  r = r || {}, o.init(), a = a || {}, s = s || 0;
  function p(R) {
    if (o.customGates && o.customGates[R])
      return { name: R, customGate: o.customGates[R] };
    for (var G in o.basicGates) {
      var P = o.basicGates[G];
      if (P.exportInfo) {
        if (P.exportInfo.quil && P.exportInfo.quil.name == R)
          return { name: G, gateDef: P, quilDef: P.exportInfo.quil };
        if (P.exportInfo.pyquil && P.exportInfo.pyquil.name == R)
          return { name: G, gateDef: P, quilDef: P.exportInfo.pyquil };
      }
    }
    return null;
  }
  var u = t.split(`
`), f = [], l = !1;
  u.map(function(R, G) {
    if (R = R.split("#")[0], R.length ? R = R.trim() : l = !1, l) {
      var W = R.split(";");
      W.map(function(Z) {
        Z.trim().length && f[f.length - 1].body.push(Z.trim());
      });
    } else if (R.length) {
      var P = R.split(";"), W = [];
      P.map(function(le) {
        le.trim().length && W.push(le.trim());
      }), W.map(function(le) {
        var Z = le.split(" "), H = Z[Z.length - 1];
        if (H.length && (H[H.length - 1] == ":" && (l = !0, H = H.substring(0, H.length - 1), Z[Z.length - 1] = H), Z.length)) {
          var te = "GATE";
          (Z[0] == "DEFGATE" || Z[0] == "DEFCIRCUIT") && (te = Z[0], Z.splice(0, 1));
          var be = Z.join(" "), K = [], ce = be.indexOf("(");
          if (ce >= 0) {
            var de = be.indexOf(")");
            if (de > ce) {
              if (K = be.substring(ce + 1, de).split(","), K.map(function(we, Se) {
                for (we = we.trim(); we.length && we[0] == "%"; )
                  we = we.slice(1);
                K[Se] = we;
              }), de + 1 <= be.length) {
                const we = be.substring(de + 1, be.length).split(" ");
                Z = [], we.map(function(Se) {
                  Se = Se.trim(), Se.length && Z.push(Se);
                });
              } else
                Z = [];
              be = be.substring(0, ce).trim();
            }
          } else
            be = Z.splice(0, 1)[0].trim();
          for (var ue = [], ve = 0; ve < Z.length; ve++) {
            var he = Z[ve];
            if (n) {
              var Ne = n.indexOf(he);
              Ne >= 0 ? ue.push(Ne) : ue.push(he);
            } else
              ue.push(he);
          }
          f.push({ type: te, name: be, params: K, args: ue, body: [], line: G, col: 0 });
        }
      });
    }
  });
  for (var c = f.length, h = 0; h < c; h++) {
    var d = f[h];
    switch (a[d.name] && (d.name = a[d.name]), d.type) {
      case "DEFGATE":
        if (d.name == d.name.toUpperCase()) {
          var g = d.name.toLowerCase();
          a[d.name] = g, d.name = g;
        }
        break;
      case "DEFCIRCUIT":
        {
          if (d.name == d.name.toUpperCase()) {
            var g = d.name.toLowerCase();
            a[d.name] = g, d.name = g;
          }
          var v = d.body.join(`
`), N = d.args, b = new ge();
          b.importQuil(v, e, r, N, a, d.line + 1), b.params = JSON.parse(JSON.stringify(d.params)), o.registerGate(d.name, b.save());
        }
        break;
      case "GATE":
        switch (d.name) {
          case "DECLARE":
            break;
          case "HALT":
            break;
          case "PRAGMA":
            break;
          default: {
            var C = p(d.name);
            if (C) {
              var E = {};
              if (C.gateDef) {
                var D = C.gateDef, A = C.quilDef;
                if ((A.params || []).length != (d.params || []).length) {
                  var x = "Invalid number of params. Expected " + (A.params || []).length + " got " + (d.params || []).length + ".";
                  if (e) {
                    e([{ msg: x, line: s + d.line, col: d.col }]);
                    return;
                  } else
                    throw new Error(x);
                } else
                  for (var M = 0; M < D.params.length; M++) {
                    var _ = D.params[M], O = A.params.indexOf(_);
                    if (O < 0 || O >= d.params.length) {
                      var x = 'Internal error: QUIL definition for gate "' + d.name + " is invalid.";
                      if (e) {
                        e([{ msg: x, line: s + d.line, col: d.col }]);
                        return;
                      } else
                        throw new Error(x);
                    } else
                      E[_] = d.params[O];
                  }
              } else {
                var D = C.customGate;
                if ((D.params || []).length != (d.params || []).length) {
                  var x = "Invalid number of params. Expected " + (D.params || []).length + " got " + (d.params || []).length + ".";
                  if (e) {
                    e([{ msg: x, line: s + d.line, col: d.col }]);
                    return;
                  } else
                    throw new Error(x);
                } else
                  for (var M = 0; M < D.params.length; M++) {
                    var _ = D.params[M];
                    E[_] = d.params[M];
                  }
              }
              if (d.name == "MEASURE") {
                if (d.args.length != 2) {
                  var x = "Expecting 2 arguments (qubit and target register) but found " + d.args.length + ".";
                  if (e) {
                    e([{ msg: x, line: s + d.line, col: d.col }]);
                    return;
                  } else
                    throw new Error(x);
                }
              } else {
                var T = 1;
                if (D.numQubits ? T = D.numQubits : D.matrix && D.matrix.length && (T = vi(D.matrix.length)), d.args.length != T) {
                  var x = "Expecting " + T + " arguments but found " + d.args.length + ".";
                  if (e) {
                    e([{ msg: x, line: s + d.line, col: d.col }]);
                    return;
                  } else
                    throw new Error(x);
                }
              }
              for (var I = [], q = {}, M = 0; M < d.args.length; M++) {
                var $ = d.args[M];
                if (d.name == "MEASURE") {
                  var U = $.indexOf("[");
                  if (U >= 0) {
                    var k = $.indexOf("]");
                    k > U && (cregBit = $.substring(U + 1, k), cregName = $.substring(0, U), q = {
                      bit: cregBit,
                      name: cregName
                    });
                  } else {
                    var L = parseInt($);
                    if (isNaN(L))
                      if (M > 0)
                        I.push($);
                      else {
                        var x = 'Invalid argument "' + $ + '"';
                        if (e) {
                          e([{ msg: x, line: s + d.line, col: d.col }]);
                          return;
                        } else
                          throw new Error(x);
                      }
                    I.push(L);
                  }
                } else {
                  var L = parseInt($);
                  if (isNaN(L)) {
                    var x = 'Invalid argument "' + $ + '"';
                    if (e) {
                      e([{ msg: x, line: s + d.line, col: d.col }]);
                      return;
                    } else
                      throw new Error(x);
                  }
                  I.push(L);
                }
              }
              o.appendGate(C.name, I, { params: E, creg: q });
            } else {
              var x = 'Cannot recognize "' + d.name + '".';
              if (e) {
                e([{ msg: x, line: s + d.line, col: d.col }]);
                return;
              } else
                throw new Error(x);
            }
          }
        }
        break;
    }
  }
  e && e([]);
};
ge.prototype.importIonq = function(t, e) {
  var r = this, n = t.qubits || 1;
  if (r.init(n), !t.circuit) {
    var a = "Invalid file format.";
    if (e) {
      e([{ msg: a, line: -1, col: -1 }]);
      return;
    } else
      throw new Error(a);
  }
  function s(o) {
    if (r.customGates && r.customGates[o])
      return { name: o, customGate: r.customGates[o] };
    for (var p in r.basicGates) {
      var u = r.basicGates[p];
      if (u.exportInfo && u.exportInfo.ionq && (u.exportInfo.ionq.name && u.exportInfo.ionq.name == o || u.exportInfo.ionq.names && u.exportInfo.ionq.names.indexOf(o) >= 0))
        return { name: p, gateDef: u };
    }
    return null;
  }
  t.circuit.map(function(o) {
    var p = s(o.gate);
    if (!p) {
      var u = 'Unknown gate "' + o.gate + '"';
      if (e) {
        e([{ msg: u, line: -1, col: -1 }]);
        return;
      } else
        throw new Error(u);
    }
    var f = [];
    typeof o.control < "u" && f.push(o.control), typeof o.controls < "u" && (f = f.concat(o.controls)), typeof o.target < "u" && f.push(o.target), typeof o.targets < "u" && (f = f.concat(o.targets));
    var l = [];
    typeof o.rotation < "u" && l.push(o.rotation), typeof o.phase < "u" && l.push(o.phase), typeof o.phases < "u" && (l = l.concat(o.phases));
    var c = p.gateDef ? p.gateDef.matrix ? vi(p.gateDef.matrix.length) : 1 : p.customGate.numQubits || 1, h = p.gateDef ? p.gateDef.params || [] : p.customGate.params || [];
    if (f.length != c) {
      var u = 'Gate "' + o.gate + '": invalid number of qubits. Expected ' + c + " but got " + f.length + ".";
      if (e) {
        e([{ msg: u, line: -1, col: -1 }]);
        return;
      } else
        throw new Error(u);
    }
    if (l.length != h.length) {
      var u = 'Gate "' + o.gate + '": invalid number of params. Expected ' + h.length + " but got " + l.length + ".";
      if (e) {
        e([{ msg: u, line: -1, col: -1 }]);
        return;
      } else
        throw new Error(u);
    }
    var d = {};
    l.length && (d.params = {}, h.map(function(g, v) {
      d.params[g] = o.rotation ? l[v] : 2 * Oi * l[v];
    })), r.appendGate(p.name, f, d);
  }), e && e([]);
};
ge.prototype.exportToIonq = function(t, e) {
  var r = this.options && this.options.params ? this.options.params : {}, r = JSON.parse(JSON.stringify(r));
  for (var n in r)
    r[n] = Br(r[n]);
  var a = new ge();
  a.load(this.save(!0));
  for (var s = {
    qubits: a.numQubits,
    circuit: []
  }, o = a.numCols(), p = 0; p < o; p++)
    for (var u = 0; u < a.numQubits; u++) {
      var f = a.getGateAt(p, u);
      if (f && f.connector == 0) {
        var l = a.getGateDef(f.name);
        if (l.exportInfo && l.exportInfo.ionq)
          if (l.exportInfo.ionq.name || l.exportInfo.ionq.names) {
            var c = {
              gate: l.exportInfo.ionq.name || l.exportInfo.ionq.names[0]
            };
            l.params && l.params.length && (c[l.exportInfo.ionq.paramsKey] = [], l.params.map(function(h) {
              var d = Br(f.options.params[h], r);
              l.exportInfo.ionq.paramsKey != "rotation" && (d = d / (2 * Oi)), c[l.exportInfo.ionq.paramsKey].push(d);
            })), s.circuit.push(c);
          } else {
            var c = {
              gate: 'Export gate "' + f.name + '" to IONQ not supported yet. Comming soon.'
            };
            s.circuit.push(c);
          }
        else {
          var c = {
            gate: 'Export gate "' + f.name + '" to IONQ not supported yet. Comming soon.'
          };
          s.circuit.push(c);
        }
      }
    }
  return s;
};
ge.prototype.exportQuirk = function(t) {
  var e = this, s = null;
  function r(he) {
    for (var Ne = [], we = 0; we < he; we++)
      Ne.push(we);
    return Ne;
  }
  function n(he, Ne) {
    return Ne.indexOf(he) > -1;
  }
  t = !0;
  var a = this.save(t), s = new ge(), o = new ge();
  s.load(a), o.load(a);
  var p = {
    cols: [],
    gates: []
  }, u = null, f = this.options && this.options.params ? this.options.params : {}, l = new ge(), c = {};
  if (!t)
    for (var T = o.numCols(), h = T - 1; h >= 0; h--)
      for (var d = 0; d < o.numQubits; d++) {
        var g = o.gates[d][h];
        if (g && g.connector == 0 && !o.basicGates[g.name]) {
          customDecomposedCircuit = o.decomposeGateAt(h, d);
          var v = !1;
          c[g.name] = { info: [], isDecomposeCustomCircuit: null };
          for (var N = 0; N < customDecomposedCircuit.numCols(); N++)
            for (var b = 0; b < customDecomposedCircuit.numQubits; b++) {
              var C = customDecomposedCircuit.getGateAt(N, b);
              if (C) {
                var x = customDecomposedCircuit.basicGates[C.name];
                x.exportInfo && !x.exportInfo.quirk && (v = v || !0), C.connector == 0 && c[g.name].info.push({ gateInCustomCircuit: C, column: h });
              }
              c[g.name].isDecomposeCustomCircuit = v;
            }
          v && s.gates.map(function(Ne, we) {
            Ne.map(function(Se) {
              Se && Se.name == g.name && s.removeGate(Se.id);
            });
          });
        }
      }
  gateKeys = Object.keys(c);
  for (var E = 0; E < gateKeys.length; E++)
    if (gateKey = gateKeys[E], c[gateKey].isDecomposeCustomCircuit)
      for (var D = c[gateKey].info.length - 1; D >= 0; D--) {
        var A = c[gateKey].info[D], M = A.gateInCustomCircuit;
        s.insertGate(M.name, A.column, M.wires, M.options);
      }
  for (var _ = null, O = null, h = 0; h < T; h++)
    for (var d = 0; d < s.numQubits; d++) {
      var g = s.getGateAt(h, d);
      g && (O && O.name != g.name && O.connector != 0 && _ == h && (s.removeGate(g.id), s.insertGate(g.name, g.column + 1, g.wires, g.options)), O = g, _ = h);
    }
  for (var T = s.numCols(), h = 0; h < T; h++) {
    for (var I = [], q = [], $ = !1, d = 0; d < s.numQubits; d++) {
      var g = s.getGateAt(h, d);
      if (!g || g.name == "measure" || g.name == "reset")
        ($ || !n(d, q)) && I.push(1);
      else {
        var U = s.basicGates[g.name], k = yo(g.wires), L = fv(g.wires), R = g.wires.slice(), q = r(k);
        if (U) {
          var G = "", P = !1;
          if ($ = !0, U.exportInfo && U.exportInfo.quirk && (G = U.exportInfo.quirk.name, P = U.exportInfo.quirk.controlled), U.matrix.length == 4 && (G && g.name == "swap" && g.connector < g.wires.length - 2 && P || g.name != "swap" && g.connector < g.wires.length - 1 && P) && (G = "•"), U.matrix.length == 8 && (G && g.name == "cswap" && g.connector < g.wires.length - 2 && P || g.name != "cswap" && g.connector < g.wires.length - 1 && P) && (G = "•"), G && I.push(G), !G) {
            G = "~" + g.name, U.params.length && g.options.params && U.params.map(function(V) {
              angle = kt(Br(g.options.params[V], f), 7), G += "_" + angle;
            });
            var W = "";
            W += "{";
            var le = e.getRawGate(U, g.options), Z = R.sort(), H = [];
            if (g.wires.map(function(V) {
              H.push(Z.indexOf(V));
            }), k - L + 1 > g.wires.length || g.wires[0] > g.wires[1] ? u = s.transformMatrix(k - L + 1, le, H) : u = le, u.map(function(V, re) {
              re > 0 && (W += ","), W += "{", V.map(function(pe, X) {
                X > 0 && (W += ","), typeof pe != "object" ? pe = Wt(pe).toString() : pe = pe.toString(), W += pe;
              }), W += "}";
            }), W += "}", g.connector == 0) {
              var te = p.gates.find(function(V) {
                return V.id == G;
              });
              te || p.gates.push({
                id: G,
                matrix: W
              });
              for (var be = !1, K = 0; K < I.length; K++)
                I[K] == G && (be = !0);
              be ? I.push(1) : I.push(G);
            } else if (d < g.wires[0]) {
              p.gates.push({
                id: G,
                matrix: W
              });
              var te = p.gates.find(function(pe) {
                return pe.id == G;
              });
              te || p.gates.push({
                id: G,
                matrix: W
              });
              for (var be = !1, K = 0; K < I.length; K++)
                I[K] == G && (be = !0);
              be ? I.push(1) : I.push(G);
            }
          }
        } else {
          var ce = [];
          if ($ = !1, g.connector == 0) {
            var de = l.gates.find(function(V) {
              return V && V[0] && V[0].name == g.name;
            });
            if (!de) {
              var ue = g.wires[0];
              g.wires.map(function(V) {
                ce.push(V - ue);
              }), l.registerGate(g.name, e.customGates[g.name]), l.appendGate(g.name, ce);
            }
            I.push("~" + g.name);
          } else
            I.push(1);
        }
      }
    }
    p.cols.push(I);
  }
  if (!t) {
    var ve = s.usedGates();
    ve.map(function(he) {
      var Ne = s.basicGates[he];
      if (!Ne) {
        var we = e.customGates[he];
        if (we) {
          var Se = new ge();
          for (customCol = 0; customCol < l.numCols(); customCol++)
            for (customWire = 0; customWire < l.numGates(); customWire++) {
              var V = l.getGateAt(customCol, customWire);
              V && V.name == he && (customGateObj = l.decomposeGateAt(customCol, customWire), Se.load(customGateObj));
            }
          p.gates.push({
            id: "~" + he,
            circuit: Se.exportQuirk(!0)
          });
        }
      }
    });
  }
  return p;
};
ge.prototype.exportCirq = function(t, e, r, n, a, s, o) {
  var p = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: a,
    shots: s,
    exportTfq: o
  };
  return this.exportToCirq(p, r);
};
ge.prototype.exportQSharp = function(t, e, r, n, a, s, o) {
  var p = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: a,
    circuitName: s,
    indentDepth: o
  };
  return this.exportToQSharp(p, r);
};
ge.prototype.exportQobj = function(t, e, r, n) {
  var a = {
    circuitName: t,
    experimentName: e,
    numShots: r
  };
  return this.exportToQobj(a, n);
};
ge.prototype.importQobj = function(t, e) {
  var r = this;
  if (this.init(), !t || !t.experiments || !t.experiments.length) {
    e && e([{ msg: "Invalid input file: no experiments found." }]);
    return;
  }
  var n = t.experiments[0], a = n.header || {};
  this.init(parseInt(a.n_qubits || 0));
  var s = {};
  if (a.creg_sizes && a.creg_sizes.length)
    for (var o = 0, p = 0; p < a.creg_sizes.length; p++) {
      var u = a.creg_sizes[p];
      if (u.length > 1) {
        var f = u[0] + "", l = parseInt(u[1]);
        this.createCreg(f, l);
        var c = (1 << o + l) - (1 << o);
        s[f] = {
          mask: c,
          offset: o
        }, o += l;
      }
    }
  function h(q, $) {
    for (var U in s) {
      var k = s[U];
      if (k.mask == q)
        return {
          creg: U,
          value: $ >> k.offset
        };
    }
  }
  function d(q) {
    var $ = 0;
    for (var U in r.cregs) {
      var k = r.cregs[U];
      if ($ + k.length > q)
        return {
          name: U,
          bit: q - $
        };
      $ += k.length;
    }
    return null;
  }
  n.instructions;
  for (var g = {}, v = 0; v < n.instructions.length; v++) {
    var N = n.instructions[v];
    switch (N.name) {
      case "bfunc":
        {
          var b = h(parseInt(N.mask), parseInt(N.val));
          if (!b) {
            var C = "Invalid classical condition.";
            if (e) {
              e([{ msg: C }]);
              return;
            } else
              throw new Error(C);
          }
          g[N.register] = b;
        }
        break;
      case "measure":
        for (var x = 0; x < N.qubits.length; x++) {
          var E = N.qubits[x], D = N.memory[x], A = d(D);
          if (!A) {
            var C = "Invalid measurement destination.";
            if (e) {
              e([{ msg: C }]);
              return;
            } else
              throw new Error(C);
          }
          var M = { creg: A };
          this.appendGate("measure", E, M);
        }
        break;
      case "barrier":
        break;
      default: {
        var M = {
          params: {},
          condition: {}
        }, _ = N.name;
        switch (_) {
          case "iden":
            _ = "id";
            break;
        }
        var O = this.basicGates[_];
        if (!O) {
          var C = 'Unknown gate "' + N.name + '".';
          if (e) {
            e([{ msg: C }]);
            return;
          } else
            throw new Error(C);
        }
        if (O.params && O.params.length) {
          if (!N.params || !N.params.length || N.params.length != O.params.length) {
            var C = 'Invalid number of params for gate "' + N.name + '".';
            if (e) {
              e([{ msg: C }]);
              return;
            } else
              throw new Error(C);
          }
          for (var T = 0; T < O.params.length; T++) {
            var I = O.params[T];
            M.params[I] = N.params[T];
          }
        }
        if (typeof N.conditional < "u") {
          var b = g[N.conditional];
          if (!b) {
            var C = "Invalid classical condition.";
            if (e) {
              e([{ msg: C }]);
              return;
            } else
              throw new Error(C);
          }
          M.condition = b;
        }
        this.appendGate(_, N.qubits, M);
      }
    }
  }
  e && e([]);
};
ge.prototype.exportTFQ = function(t, e, r, n, a, s) {
  var o = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: a,
    shots: s
  };
  return this.exportToTFQ(o, r);
};
ge.prototype.exportBraket = function(t, e, r, n, a, s, o, p) {
  var u = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: a,
    shots: s,
    hybrid: o,
    indentDepth: p
  };
  return this.exportToBraket(u, r);
};
ge.prototype.exportSVG = function(t, e) {
  var r = e || {};
  return r.embedded = !!t, this.exportToSVG(r);
};
ge.prototype.exportToSVG = function(r) {
  var e = this, r = r || {};
  r.embedded = r.embedded || !1, r.cellWidth = r.cellWidth || 40, r.cellHeight = r.cellHeight || 40, r.hSpacing = r.hSpacing || 28, r.vSpacing = r.vSpacing || 34, r.blackboxPaddingX = r.blackboxPaddingX || 2, r.blackboxPaddingY = r.blackboxPaddingY || 2, r.blackboxLineColor = r.blackboxLineColor || "black", r.blackboxSelectedLineColor = r.blackboxSelectedLineColor || "black", r.wireColor = r.wireColor || "black", r.gateLineColor = r.gateLineColor || "black", r.gateSelectedLineColor = r.gateSelectedLineColor || "black", r.cWireColor = r.cWireColor || "silver", r.cWireSelectedColor = r.cWireSelectedColor || "silver", r.cArrowSize = r.cArrowSize || 10, r.hWireColor = r.hWireColor || "black", r.wireWidth = r.wireWidth || 1, r.wireTextHeight = r.wireTextHeight || 8, r.wireTextDown = r.wireTextDown || 16, r.wireMargin = r.wireMargin || 20, r.wireLabelWidth = r.wireLabelWidth || 40, r.dotRadius = r.dotRadius || 5, r.paramTextHeight = r.paramTextHeight || 6, r.selectionPaddingX = r.selectionPaddingX || 4, r.selectionPaddingY = r.selectionPaddingY || 4, r.selectionLineColor = r.selectionLineColor || "#2185D0", r.drawBlochSpheres = r.drawBlochSpheres || !1, typeof r.drawHybrid > "u" && (r.drawHybrid = this.options ? !!this.options.hybrid : !1);
  var n = function(Ie) {
    var B = 0;
    for (var ne in e.cregs) {
      if (ne == Ie)
        return B;
      B++;
    }
    return B;
  }, a = function(Ie) {
    return r.wireLabelWidth + (r.cellWidth + r.hSpacing) * Ie + r.hSpacing;
  }, s = function(Ie) {
    return (r.cellHeight + r.vSpacing) * Ie + r.vSpacing;
  }, o = this.numQubits, p = this.numCols(), u = this.cregCount(), f = p;
  r.drawBlochSpheres && f++;
  var l = f;
  r.drawHybrid && (f += 2);
  var c = a(f), h = a(l), d = (r.cellHeight + r.vSpacing) * (o + u + (r.drawHybrid ? 1 : 0)) + r.vSpacing;
  (r.cellHeight + r.vSpacing) * (o + u) + r.vSpacing;
  var g = (r.cellHeight + r.vSpacing) * (o + u) + (r.vSpacing + r.cellHeight / 2);
  function v(Ie, B, ne, xe) {
    var Te = (xe - 90) * Math.PI / 180;
    return {
      x: Ie + ne * Math.cos(Te),
      y: B + ne * Math.sin(Te)
    };
  }
  function N(Ie, B, ne, xe, Te) {
    var Pe = v(Ie, B, ne, Te), Ge = v(Ie, B, ne, xe), Ve = "0", ft = [
      "M",
      Pe.x,
      Pe.y,
      "A",
      ne,
      ne,
      0,
      Ve,
      0,
      Ge.x,
      Ge.y
    ].join(" ");
    return ft;
  }
  var b = function(Ie) {
    return (r.cellHeight + r.vSpacing) * Ie + (r.vSpacing + r.cellHeight / 2);
  }, C = function(Ie) {
    return (r.cellHeight + r.vSpacing) * Ie + r.vSpacing;
  }, x = function(Ie) {
    return (r.cellHeight + r.vSpacing) * (o + n(Ie)) + (r.vSpacing + r.cellHeight / 2);
  };
  function E(Ie, B, ne, xe, Te) {
    var Pe = r.cellWidth, Ge = r.cellHeight, Ve = "";
    return Ve += '<rect class="qc-gate-box" x="' + Ie + '" y="' + B + '" width="' + Pe + '" height="' + Ge + '" stroke="' + (Te ? r.gateSelectedLineColor : r.gateLineColor) + '" fill="white" stroke-width="1" />', xe && (Ve += '<text class="qc-gate-label" x="' + (Ie + Pe / 2) + '" y="' + (B + Ge / 2) + '" dominant-baseline="middle" text-anchor="middle" fill="' + (Te ? r.gateSelectedLineColor : r.gateLineColor) + '">' + xe + "</text>"), Ve;
  }
  function D(Ie, B, ne, xe, Te) {
    var Pe = r.cellWidth * 2, Ge = r.cellHeight, Ve = "";
    return Ve += '<rect class="qc-gate-rect" x="' + Ie + '" y="' + B + '" width="' + Pe + '" height="' + Ge + '" stroke="' + r.gateLineColor + '" fill="white" stroke-width="1" />', xe && (Ve += '<text class="qc-gate-label" x="' + (Ie + Pe / 2) + '" y="' + (B + Ge / 2) + '" dominant-baseline="middle" text-anchor="middle">' + xe + "</text>"), Ve;
  }
  function A(Ie, B, ne, xe, Te) {
    var Pe = Ie + r.cellWidth / 2, Ge = B + r.cellHeight / 2, Ve = r.cellWidth * 0.8, ft = r.cellHeight * 0.8, lt = Ie + (r.cellWidth - Ve) / 2, Nr = B + (r.cellHeight - ft) / 2, Ur = "";
    return Ur += '<ellipse class="qc-gate-not" cx="' + Pe + '" cy="' + Ge + '" rx="' + Ve / 2 + '" ry="' + ft / 2 + '" stroke="' + (Te ? r.gateSelectedLineColor : r.gateLineColor) + '" fill="white" stroke-width="1" />', xe && (Ur += '<text class="qc-gate-label" x="' + (lt + Ve / 2) + '" y="' + (Nr + ft / 2) + '" dominant-baseline="middle" text-anchor="middle">' + xe + "</text>"), Ur;
  }
  function M(Ie, B, ne, xe) {
    var Te = Ie + r.cellWidth / 2, Pe = B + r.cellHeight / 2, Ge = r.cellWidth * 0.8, Ve = r.cellHeight * 0.8, ft = Ie + (r.cellWidth - Ge) / 2, lt = B + (r.cellHeight - Ve) / 2, Nr = "";
    return Nr += '<ellipse class="qc-gate-not" cx="' + Te + '" cy="' + Pe + '" rx="' + Ge / 2 + '" ry="' + Ve / 2 + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" fill="white" stroke-width="1" />', Nr += '<line class="qc-gate-not-line" x1="' + Te + '" x2="' + Te + '" y1="' + lt + '" y2="' + (lt + Ve) + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" stroke-width="1" />', Nr += '<line class="qc-gate-not-line" x1="' + ft + '" x2="' + (ft + Ge) + '" y1="' + Pe + '" y2="' + Pe + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" stroke-width="1" />', Nr;
  }
  function _(Ie, B, ne, xe) {
    var Te = r.cellWidth, Pe = r.cellHeight, Ge = Ie + Te / 2, Ve = B + Pe / 2, ft = Pe / 5, lt = "";
    return lt += '<rect class="qc-gate-box" x="' + Ie + '" y="' + B + '" width="' + Te + '" height="' + Pe + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" fill="white" stroke-width="1" />', lt += '<path class="gc-gate-gauge-arc" d="' + N(Ge, Ve + ft, Te / 2.3, 300, 60) + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" fill="none" stroke-width="1" />', lt += '<line class="qc-gate-gauge-scale" x1="' + Ge + '" x2="' + (Ie + Te - ft) + '" y1="' + (Ve + ft) + '" y2="' + (B + ft) + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" stroke-width="1" />', lt;
  }
  function O(Ie, B, ne, xe) {
    var Te = r.cellWidth * 0.4, Pe = r.cellHeight * 0.4, Ge = Ie + (r.cellWidth - Te) / 2, Ve = B + (r.cellHeight - Pe) / 2, ft = "";
    return ft += '<line class="qc-gate-x" x1="' + Ge + '" x2="' + (Ge + Te) + '" y1="' + Ve + '" y2="' + (Ve + Pe) + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" stroke-width="1" />', ft += '<line class="qc-gate-x" x1="' + Ge + '" x2="' + (Ge + Te) + '" y1="' + (Ve + Pe) + '" y2="' + Ve + '" stroke="' + (xe ? r.gateSelectedLineColor : r.gateLineColor) + '" stroke-width="1" />', ft;
  }
  function T(Ie, B, ne, xe) {
    var Te = r.cellWidth, Pe = r.cellHeight, Ge = Ie + Te / 2, Ve = B + Pe / 2, ft = "";
    return ft += '<circle class="qc-gate-dot" cx="' + Ge + '" cy="' + Ve + '" r="' + r.dotRadius + '" stroke="' + (xe ? r.gateSelectedLineColor : r.wireColor) + '" fill="' + (xe ? r.gateSelectedLineColor : r.wireColor) + '" stroke-width="1" />', ft;
  }
  function I(Ie, B, ne, xe) {
    var Te = r.cellWidth, Pe = r.cellHeight, Ge = Ie + Te / 2, Ve = B + Pe / 2, ft = "";
    return ft += '<circle class="qc-gate-ndot" cx="' + Ge + '" cy="' + Ve + '" r="' + r.dotRadius + '" stroke="' + (xe ? r.gateSelectedLineColor : r.wireColor) + '" fill="white" stroke-width="1" />', ft;
  }
  function q(Ie, B, ne, xe, Te, Pe, Ge) {
    var Ve = "";
    switch (Te != "box" && Pe && (Ve += E(Ie, B, ne, "", Ge)), Te) {
      case "box":
        Ve += E(Ie, B, ne, xe, Ge);
        break;
      case "rect":
        Ve += D(Ie, B, ne, xe);
        break;
      case "circle":
        Ve += A(Ie, B, ne, xe, Ge);
        break;
      case "not":
        Ve += M(Ie, B, ne, Ge);
        break;
      case "x":
        Ve += O(Ie, B, ne, Ge);
        break;
      case "dot":
        Ve += T(Ie, B, ne, Ge);
        break;
      case "ndot":
        Ve += I(Ie, B, ne, Ge);
        break;
      case "gauge":
        Ve += _(Ie, B, ne, Ge);
        break;
    }
    return Ve;
  }
  function $(Ie, B, ne) {
    var xe = e.basicGates[Ie.name] ? e.basicGates[Ie.name].drawingInfo : null;
    xe || (xe = e.customGates[Ie.name] ? e.customGates[Ie.name].drawingInfo : null);
    var Te = !1, Pe = r && r.selection && r.selection.indexOf(Ie.id) >= 0;
    for (xe || (Ie.wires.length == 1 ? xe = { connectors: ["box"] } : (xe = { connectors: [] }, Te = !0)); xe.connectors.length < Ie.wires.length; )
      xe.connectors.push("box");
    var Ge = Math.min.apply(null, Ie.wires), Ve = Math.max.apply(null, Ie.wires), ft = x(Ve), lt = "";
    if (lt += '<g class="qc-gate-group" data-id="' + Ie.id + '" data-gate="' + Ie.name + '">', Te) {
      var Nr = a(B) - r.blackboxPaddingX, Ur = C(Ge) - r.blackboxPaddingY, An = r.cellWidth + 2 * r.blackboxPaddingX, Or = C(Ve) + r.cellHeight - Ur + r.blackboxPaddingY, Aa = Nr + An / 2;
      ft = Ur + Or, lt += '<text class="qc-blackbox-label" x="' + Aa + '" y="' + (Ur - r.wireTextHeight - r.blackboxPaddingY * 2) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">' + (xe.label || Ie.name) + "</text>", lt += '<rect class="qc-gate-blackbox" x="' + Nr + '" y="' + Ur + '" width="' + An + '" height="' + Or + '" stroke="' + (Pe ? r.blackboxSelectedLineColor : r.blackboxLineColor) + '" fill="transparent" stroke-width="1" />';
    }
    if (Pe) {
      var Nr = a(B) - r.selectionPaddingX, Ur = C(Ge) - r.selectionPaddingY, An = r.cellWidth + 2 * r.selectionPaddingX, Or = C(Ve) + r.cellHeight - Ur + r.selectionPaddingY, Aa = Nr + An / 2;
      ft = Ur + Or, lt += '<rect class="qc-gate-selection" x="' + Nr + '" y="' + Ur + '" width="' + An + '" height="' + Or + '" stroke="' + r.selectionLineColor + '" fill="transparent" stroke-dasharray="4" stroke-width="1" />';
    }
    if (Ge != Ve && !Te) {
      var fr = a(B) + r.cellWidth / 2, Fr = s(Ge) + r.cellHeight / 2, Dr = s(Ve) + r.cellHeight / 2;
      lt += '<line class="qc-gate-link" x1="' + fr + '" x2="' + fr + '" y1="' + Fr + '" y2="' + Dr + '" stroke="' + (Pe ? r.gateSelectedLineColor : r.wireColor) + '" stroke-width="1" />';
    }
    var Zt = Math.max.apply(null, Ie.wires);
    if (Ie.wires.map(function(pr, Ji) {
      switch (xe.connectors[Ji]) {
        case "box":
          {
            var Kt = a(B), sr = s(pr);
            lt = lt + E(Kt, sr, Ie.name, Te ? Cr(Ji, o) : xe.label || Ie.name, Pe), !Te && pr == Ve && (ft = sr + r.cellHeight);
          }
          break;
        case "circle":
          {
            var Kt = a(B), sr = s(pr);
            if (lt = lt + A(Kt, sr, Ie.name, Te ? Cr(Ji, o) : xe.label || Ie.name, Pe), !Te && pr == Ve) {
              var Ar = r.cellHeight * 0.8;
              ft = sr + Ar + (r.cellHeight - Ar) / 2;
            }
          }
          break;
        case "not":
          {
            var En = a(B), er = s(pr);
            if (lt = lt + M(En, er, Ie.name, Pe), !Te && pr == Ve) {
              var Ar = r.cellHeight * 0.8;
              ft = er + Ar + (r.cellHeight - Ar) / 2;
            }
          }
          break;
        case "x":
          {
            var En = a(B), er = s(pr);
            lt = lt + O(En, er, Ie.name, Pe), !Te && pr == Ve && (ft = b(Ve));
          }
          break;
        case "dot":
          {
            var En = a(B), er = s(pr);
            lt = lt + T(En, er, Ie.name, Pe), !Te && pr == Ve && (ft = b(Ve) + r.dotRadius);
          }
          break;
        case "ndot":
          {
            var En = a(B), er = s(pr);
            lt = lt + I(En, er, Ie.name, Pe), !Te && pr == Ve && (ft = b(Ve) + r.dotRadius);
          }
          break;
        case "gauge":
          {
            var Kt = a(B), sr = s(pr);
            lt = lt + _(Kt, sr, Ie.name, Pe), !Te && pr == Ve && (ft = sr + r.cellHeight);
          }
          break;
      }
      if (Ie.options && Ie.options.params && pr == Zt) {
        var Kt = a(B), sr = s(pr), ii = Kt + r.cellWidth / 2, Yr = "", Yi = 0;
        for (var bs in Ie.options.params) {
          Yr && (Yr += ", ");
          var It = Ie.options.params[bs];
          typeof It == "string" && It.match(/^[\+\-]?\d*\.?\d+(?:[Ee][\+\-]?\d+)?$/) && (It = parseFloat(It)), typeof It == "number" && (It = kt(It, 3)), Yr += It, Yi++;
        }
        Yr.length > 26 && (Yr = "(" + Yi + " params)"), lt += '<text class="qc-gate-params" x="' + ii + '" y="' + (sr + r.cellHeight + r.paramTextHeight) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">' + Yr + "</text>";
      }
    }), Ie.name == "measure" && Ie.options && Ie.options.creg && Ie.options.creg.name) {
      var fr = a(B) + r.cellWidth / 2, Fr = ft, Dr = x(Ie.options.creg.name);
      lt += '<line class="qc-gate-link-c" x1="' + fr + '" x2="' + fr + '" y1="' + Fr + '" y2="' + Dr + '" stroke="' + (Pe ? r.cWireSelectedColor : r.cWireColor) + '" stroke-width="1" />', lt += '<line class="qc-gate-link-c" x2="' + fr + '" x1="' + (fr - r.cArrowSize / 2) + '" y1="' + (Dr - r.cArrowSize) + '" y2="' + Dr + '" stroke="' + (Pe ? r.cWireSelectedColor : r.cWireColor) + '" stroke-width="1" />', lt += '<line class="qc-gate-link-c" x2="' + fr + '" x1="' + (fr + r.cArrowSize / 2) + '" y1="' + (Dr - r.cArrowSize) + '" y2="' + Dr + '" stroke="' + (Pe ? r.cWireSelectedColor : r.cWireColor) + '" stroke-width="1" />', lt += '<text class="qc-wire-label" x="' + fr + '" y="' + (Dr + r.wireTextHeight) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">' + Ie.options.creg.bit + "</text>";
    }
    if (Ie.options && Ie.options.condition && Ie.options.condition.creg) {
      var fr = a(B) + r.cellWidth / 2, Fr = ft, Dr = x(Ie.options.condition.creg);
      lt += '<line class="qc-gate-link-c" x1="' + fr + '" x2="' + fr + '" y1="' + Fr + '" y2="' + Dr + '" stroke="' + (Pe ? r.cWireSelectedColor : r.cWireColor) + '" stroke-width="1" />', lt += '<circle class="qc-gate-dot-c" cx="' + fr + '" cy="' + Dr + '" r="' + r.dotRadius + '" stroke="' + (Pe ? r.cWireSelectedColor : r.cWireColor) + '" fill="' + (Pe ? r.cWireSelectedColor : r.cWireColor) + '" stroke-width="1" />', lt += '<text class="qc-wire-label" x="' + fr + '" y="' + (Dr + r.wireTextHeight) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">== ' + Ie.options.condition.value + "</text>";
    }
    return lt += "</g>", lt;
  }
  function U(Ie, B) {
    var ne = "", xe = r.cellWidth + r.hSpacing, Te = r.cellHeight + r.vSpacing, Pe = a(Ie) - r.hSpacing, Ge = s(B) - r.vSpacing;
    return B == o && (Te = r.vSpacing), Ie == p && (xe = r.hSpacing), ne += '<rect class="qc-gate-placeholder" data-row="' + B + '" data-col="' + Ie + '" x="' + Pe + '" y="' + Ge + '" width="' + xe + '" height="' + Te + '" stroke="none" fill="transparent" stroke-width="0" />', ne;
  }
  function k(Ie, B, ne) {
    var xe = "", Te = r.cellWidth, Pe = r.cellHeight, Ge = a(B), Ve = s(ne);
    return xe += '<rect class="qc-gate-handle" data-id="' + Ie.id + '" data-gate="' + Ie.name + '" data-row="' + ne + '" data-col="' + B + '" x="' + Ge + '" y="' + Ve + '" width="' + Te + '" height="' + Pe + '" stroke="none" fill="transparent" stroke-width="0" />', xe;
  }
  function L(Ie, B, ne, xe) {
    var Te = "", Pe = r.cellWidth, Ge = r.cellHeight, Ve = a(Ie), ft = s(B);
    return Te += '<g class="' + ne + '" data-row="' + B + '">', Te += '<rect class="qc-canvas-box" x="' + Ve + '" y="' + ft + '" width="' + Pe + '" height="' + Ge + '" stroke="transparent" fill="white" stroke-width="1" />', Te += '<foreignObject class="qc-canvas-object" x="' + Ve + '" y="' + ft + '" width="' + Pe + '" height="' + Ge + '">', Te += '<div style="position:relative;">', Te += '<canvas id="' + xe + "-" + B + '" class="' + xe + '" width="' + Pe + '" height="' + Ge + '">', Te += "</canvas>", Te += "</div>", Te += "</foreignObject>", Te += "</g>", Te;
  }
  function R(Ie) {
    return Ie.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  if (r.gateGallery || r.gateGalleryRaw || r.customGateGallery) {
    var G = [];
    if (r.gateGallery || r.gateGalleryRaw) {
      var P = [];
      for (var W in this.basicGates) {
        var le = this.basicGates[W], Z = JSON.parse(JSON.stringify(le.drawingInfo || { connectors: ["box"] }));
        if (Z.connectors) {
          var H = Z.label || W, te = Z.connectors ? Z.connectors[Z.connectors.length - 1] : "box";
          r.gateGallery && (te == "x" || te == "dot") && (te = "box");
          var be = H + "|" + te;
          if (P.indexOf(be) < 0 && W != "ccx") {
            P.push(be);
            var K = "";
            r.embedded || (K += '<?xml version="1.0"?>', K += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), K += '<svg class="qc-gate-gallery-item" data-gate="' + R(W) + '" data-content="' + R(le.description) + '" width="' + r.cellWidth + '" height="' + r.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', K = K + q(0, 0, W, H, te, !!r.gateGallery, !1), K += "</svg>", r.gateGallery ? G.push(K) : G.push({ name: W, svg: K });
          }
        }
      }
      var ce = "";
      r.embedded || (ce += '<?xml version="1.0"?>', ce += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), ce += '<svg class="qc-gate-gallery-item" data-gate="dot" data-content="Control" width="' + r.cellWidth + '" height="' + r.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', ce = ce + q(0, 0, "dot", "dot", "dot", !!r.gateGallery, !1), ce += "</svg>", r.gateGallery ? G.push(ce) : G.push({ name: "dot", svg: ce });
      var de = "";
      r.embedded || (de += '<?xml version="1.0"?>', de += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), de += '<svg class="qc-gate-gallery-item" data-gate="ndot" data-content="Control" width="' + r.cellWidth + '" height="' + r.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', de = de + q(0, 0, "ndot", "ndot", "ndot", !!r.gateGallery, !1), de += "</svg>", r.gateGallery ? G.push(de) : G.push({ name: "dot", svg: de });
    }
    if (r.customGateGallery)
      for (var W in this.customGates) {
        var K = "";
        r.embedded || (K += '<?xml version="1.0"?>', K += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), K += '<svg class="qc-custom-gate-gallery-item" data-gate="' + W + '" width="' + r.cellWidth * 2 + '" height="' + r.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', K = K + q(0, 0, W, W, "rect", !1, !1), K += "</svg>", G.push(K);
      }
    return G;
  } else {
    var K = "";
    if (r.embedded || (K += '<?xml version="1.0"?>', K += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), K += '<svg class="qc-circuit" width="' + c + '" height="' + d + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', r.placeholders)
      for (var ue = 0; ue <= p; ue++)
        for (var ve = 0; ve <= this.numQubits; ve++)
          K += U(ue, ve);
    for (var ve = 0; ve < o; ve++) {
      var he = b(ve), Ne = "0";
      r.customGate && (Ne = Cr(ve, o)), K += '<text class="qc-wire-init" x="0" y="' + he + '" dominant-baseline="middle" text-anchor="start">|' + Ne + "&#x27E9;</text>", K += '<line class="qc-wire" x1="' + r.wireMargin + '" x2="' + h + '" y1="' + he + '" y2="' + he + '" stroke="' + r.wireColor + '" stroke-width="' + r.wireWidth + '" />', K += '<text class="qc-wire-label" x="' + r.wireMargin + '" y="' + (he - r.wireTextHeight * 2) + '" dominant-baseline="hanging" text-anchor="start" font-size="75%">q' + ve + "</text>";
    }
    for (var we in this.cregs) {
      var he = x(we);
      K += '<text class="qc-wire-init" x="0" y="' + he + '" dominant-baseline="middle" text-anchor="start">0</text>', K += '<line class="qc-wire-c" x1="' + r.wireMargin + '" x2="' + h + '" y1="' + he + '" y2="' + he + '" stroke="' + r.cWireColor + '" stroke-width="' + r.wireWidth + '" />', K += '<text class="qc-wire-label" x="' + r.wireMargin + '" y="' + (he - r.wireTextHeight * 2) + '" dominant-baseline="hanging" text-anchor="start" font-size="75%">' + we + "</text>";
    }
    for (var ue = 0; ue < p; ue++)
      for (var ve = 0; ve < this.numQubits; ve++) {
        var le = this.getGateAt(ue, ve);
        le && le.connector == 0 && (K += $(le, ue));
      }
    for (var ue = 0; ue < p; ue++)
      for (var ve = 0; ve < this.numQubits; ve++) {
        var le = this.getGateAt(ue, ve);
        le && r.placeholders && (K += k(le, ue, ve));
      }
    if (r.drawBlochSpheres) {
      var Se = f - 1;
      r.drawHybrid && (Se -= 2);
      for (var ve = 0; ve < this.numQubits; ve++)
        K += L(Se, ve, "qc-bloch-group", "qc-bloch-canvas");
    }
    if (r.drawHybrid) {
      var Se = f - 2, V = Se, re = a(V) + r.blackboxPaddingX, pe = C(0) + r.blackboxPaddingY, X = r.cellWidth - 2 * r.blackboxPaddingX, ie = C(o + u - 1) + r.cellHeight - pe - r.blackboxPaddingY, me = re + X / 2, Ae = pe + ie / 2;
      cLinkTopY = pe + ie, K += '<rect class="qc-cost-h" x="' + re + '" y="' + pe + '" width="' + X + '" height="' + ie + '" stroke="' + r.hWireColor + '" fill="white" stroke-width="1" rx="8" />', K += '<text class="qc-label-h" x="' + me + '" y="' + Ae + '" dominant-baseline="middle" text-anchor="middle" fill="' + r.hWireColor + '" transform="rotate(-90, ' + me + ", " + Ae + ')">Cost</text>';
      var Me = a(V + 1) + r.blackboxPaddingX, Q = Me + X / 2;
      K += '<marker id="qc-arrow-head" orient="auto" markerWidth="8" markerHeight="10" refX="8" refY="5"><path d="M0,0 V10 L8,5 Z" fill="' + r.hWireColor + '"/></marker>', K += '<line class="qc-link-h" x1="' + (re + X) + '" x2="' + Me + '" y1="' + Ae + '" y2="' + Ae + '" stroke="' + r.hWireColor + '" stroke-width="' + r.wireWidth + '" marker-end="url(#qc-arrow-head)" />', K += '<rect class="qc-optimizer-h" x="' + Me + '" y="' + pe + '" width="' + X + '" height="' + ie + '" stroke="' + r.hWireColor + '" fill="white" stroke-width="1" rx="8" />', K += '<text class="qc-label-h" x="' + Q + '" y="' + Ae + '" dominant-baseline="middle" text-anchor="middle" fill="' + r.hWireColor + '" transform="rotate(-90, ' + Q + ", " + Ae + ')">Optimizer</text>';
      var ee = Q, ye = cLinkTopY, Ee = g;
      K += '<line class="qc-wire-h" x1="' + ee + '" x2="' + ee + '" y1="' + ye + '" y2="' + Ee + '" stroke="' + r.hWireColor + '" stroke-dasharray="4" stroke-width="1" />';
      var Ce = 0, De = this.findGlobalParams();
      if (De.globalParams.length) {
        Ce = a(De.cells[0][0]) + r.cellWidth + r.hSpacing / 2;
        for (var Oe = 0; Oe < De.cells.length; Oe++) {
          var Be = De.cells[Oe], Le = a(Be[0]) + r.cellWidth + r.hSpacing / 2, Re = s(Be[1]) + r.cellHeight + r.vSpacing - r.paramTextHeight / 2, rt = g, Ke = a(Be[0]) + r.cellWidth, Ze = s(Be[1]) + r.cellHeight + r.paramTextHeight * 2 + 4;
          K += '<line class="qc-wire-h" x1="' + Le + '" x2="' + Le + '" y1="' + rt + '" y2="' + Re + '" stroke="' + r.hWireColor + '" stroke-dasharray="4" stroke-width="1" />', K += '<line class="qc-wire-h" x1="' + Le + '" x2="' + Ke + '" y1="' + Re + '" y2="' + Ze + '" stroke="' + r.hWireColor + '" stroke-dasharray="4" stroke-width="1" marker-end="url(#qc-arrow-head)" />';
        }
        var he = g;
        K += '<line class="qc-wire-h" x1="' + Ce + '" x2="' + Q + '" y1="' + he + '" y2="' + he + '" stroke="' + r.hWireColor + '" stroke-dasharray="4" stroke-width="' + r.wireWidth + '" />';
      } else {
        Ce = a(l + 1);
        var he = g;
        K += '<line class="qc-wire-h" x1="' + Q + '" x2="' + Ce + '" y1="' + he + '" y2="' + he + '" stroke="' + r.hWireColor + '" stroke-dasharray="4" stroke-width="' + r.wireWidth + '"  marker-end="url(#qc-arrow-head)" />', K += '<text class="qc-warning-params-h" x="' + (Ce - 5) + '" y="' + he + '" dominant-baseline="middle" text-anchor="end">(no global params)</text>';
      }
    }
    K += "</svg>";
  }
  return K;
};
ge.prototype.exportToQiskit = function(t, e, r, n) {
  t = t || {};
  var a = t.comment, s = t.decompose, o = t.versionStr, p = t.providerName, u = t.backendName, f = t.asJupyter, l = t.shots, c = t.hybrid;
  typeof c > "u" && (c = this.options ? !!this.options.hybrid : !1);
  var h = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "", d = this;
  p = p || "Aer", u = u || "", p == "Aer" && (u || (c && h.indexOf("state") >= 0 ? u = "statevector_simulator" : u = "qasm_simulator"), u == "aer_simulator" && (u = "qasm_simulator"), u == "aer_simulator_statevector" && (u = "statevector_simulator")), p == "IONQ" && (u || (u = "ionq_simulator")), l = l || 1024;
  var g = new ge();
  g.load(this.save(s));
  var v = "";
  if (a) {
    var N = (a || "").split(`
`);
    N.map(function(pe) {
      pe.length >= 1 && pe[0] != "#" && (v += "# "), v += pe, v += `
`;
    });
  }
  var b = function(pe, X) {
    if (pe.isSymbolNode) {
      var ie = ["pi", "sin", "cos", "tan", "asin", "acos", "atan"];
      if (ie.indexOf(pe.name) >= 0)
        return "np." + pe.name;
      var me = pe.name;
      if (X.replaceVars && typeof X.replaceVars[me] < "u")
        return me = X.replaceVars[me], d.params.indexOf(me) >= 0 && c ? "params[" + d.params.indexOf(me) + "]" : me;
      if (d.params.indexOf(pe.name) >= 0 && c)
        return "params[" + d.params.indexOf(pe.name) + "]";
    }
  }, C = function(pe, X) {
    var ie = "", me = pe.split(`
`), Ae = -1;
    me.map(function(ee) {
      var ye = ee.search(/\S/);
      ye >= 0 && (Ae < 0 || ye < Ae) && (Ae = ye);
    }), Ae < 0 && (Ae = 0);
    var Me = "";
    if (Ae < X.length)
      for (var Q = 0; Q < X.length - Ae; Q++)
        Me += " ";
    return me.map(function(ee) {
      ie += Me + ee + `
`;
    }), ie;
  };
  if (e) {
    if (v += "def " + e + "(qc", g.params && g.params.length)
      for (var x = 0; x < g.params.length; x++)
        v += ", ", v += g.params[x];
    for (var E = 0; E < g.numQubits; E++)
      v += ", ", v += Cr(E, g.numQubits);
    v += `):
`;
  } else if (!r) {
    var D = g.usedGates();
    v += `from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
`;
    var A = !1, M = !1;
    switch (p) {
      case "Aer":
        v += "from qiskit import execute, " + p + `
`, c && h.indexOf("state") >= 0 && u != "statevector_simulator" && (v += `from qiskit_experiments.library import StateTomography
`);
        break;
      case "IBMQ":
        v += "from qiskit import execute, " + p + `
from qiskit.providers.ibmq import least_busy
`, c && h.indexOf("state") >= 0 && (v += `from qiskit_experiments.library import StateTomography
`);
        break;
      case "IONQ":
        A = !0, v += `from qiskit_ionq import IonQProvider
`, c && h.indexOf("state") >= 0 && (v += `from qiskit_experiments.library import StateTomography
`);
        break;
    }
    (D.indexOf("ms") >= 0 || D.indexOf("gpi") >= 0 || D.indexOf("gpi2") >= 0) && (A = !0, v += `from qiskit_ionq import GPIGate, GPI2Gate, MSGate
`), A && (v += `from qiskit import transpile
`), c && (v += `from scipy.optimize import minimize
`, v += `from collections import Counter
`), v += `import numpy as np
`, v += `
`;
    var _ = "";
    switch (p) {
      case "Aer":
        v += _ + "backend = Aer.get_backend('" + u + `')
`, v += `
`;
        break;
      case "IBMQ":
        v += _ + `IBMQ.load_account()
`, v += _ + `provider = IBMQ.get_provider(hub="ibm-q", group="open", project="main")
`, u ? v += _ + 'backend = provider.get_backend("' + u + `")
` : (v += _ + `backends = provider.backends()
`, v += _ + `backend = least_busy(backends)
`), v += `
`;
        break;
      case "IONQ":
        {
          var O = ["measure", "delay", "barrier", "reset", "snapshot", "ms", "gpi2", "gpi"];
          M = !0, D.map(function(pe) {
            O.indexOf(pe) < 0 && (M = !1);
          }), v += _ + `# Requires QISKIT_IONQ_API_TOKEN environment variable to be set
`, v += _ + `provider = IonQProvider()
`, v += _ + 'backend = provider.get_backend("' + u + '"', M && (v += ', gateset="native"'), v += `)

`;
        }
        break;
    }
    l && (v += "shots = " + l + `
`, v += `
`);
    var T = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (var E = 0; E < this.params.length; E++) {
        var I = this.params[E], q = Et(T[I]), $ = q.toString({ handler: b });
        v += I + " = " + $ + `
`;
      }
      v += `
`;
    }
    c && (v += "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, v += `
`), s || D.map(function(pe) {
      var X = g.basicGates[pe];
      if (!X) {
        var ie = d.customGates[pe];
        if (ie) {
          var me = new ge();
          me.load(ie);
          var Ae = {
            comment: "",
            decompose: !0,
            versionStr: o,
            providerName: "",
            backendName: !1,
            asJupyter: !1,
            shots: !1,
            hybrid: null
          };
          v += me.exportToQiskit(Ae, pe, r, n);
        }
      }
    }), c && (_ = "  ", v += `def objective_function(params):
`), v += _ + `qc = QuantumCircuit()
`, v += `
`, v += _ + "q = QuantumRegister(" + g.numQubits + `, 'q')
`;
    for (var U in this.cregs)
      v += _ + U + " = ClassicalRegister(" + (this.cregs[U].length || 1) + ", '" + U + `')
`;
    v += `
`, v += _ + `qc.add_register(q)
`;
    for (var U in this.cregs)
      v += _ + "qc.add_register(" + U + `)
`;
    v += `
`;
  }
  for (var k = g.numCols(), L = 0; L < k; L++)
    for (var R = 0; R < this.numQubits; R++) {
      var G = g.getGateAt(L, R), P = null, W = null, le = null;
      if (G && G.connector == 0) {
        le = G.options && G.options.condition && G.options.condition.creg ? G.options.condition : null;
        var Z = g.getGateDef(G.name);
        if (Z && Z.exportInfo && !M && (Z.exportInfo.qiskit && Z.exportInfo.qiskit.replacement ? (P = Z.exportInfo.qiskit.replacement, P.map(function(pe) {
          var X = new ge();
          if (G.options && G.options.params) {
            var ie = Object.keys(G.options.params), me = Object.keys(pe.params);
            ie.map(function(Me) {
              me.indexOf(Me) > -1 && (pe.params[Me] = G.options.params[Me]);
            });
          }
          X.addGate(pe.name, L, G.wires, { params: pe.params, condition: le });
          var Ae = {
            comment: "",
            decompose: !1,
            versionStr: !1,
            providerName: !1,
            backendName: !1,
            asJupyter: !1,
            shots: !1,
            hybrid: null
          };
          v += C(X.exportToQiskit(Ae, !1, !0, !!e || n), _);
        })) : Z.exportInfo.qiskit && Z.exportInfo.qiskit.equivalent && (W = Z.exportInfo.qiskit.equivalent, W.map(function(pe) {
          var X = new ge(), ie = pe.wires.length > 1 ? G.wires : G.wires[pe.wires[0]], me = {};
          if (pe.params) {
            var Ae = {};
            if (G.options && G.options.params)
              for (var Me in G.options.params) {
                var Q = Et(G.options.params[Me]), ee = Q.toString({ handler: b });
                Ae[Me] = ee;
              }
            for (var ye in pe.params) {
              var Q = Et(pe.params[ye]), ee = Q.toString({ handler: b, replaceVars: Ae });
              me[ye] = ee;
            }
          }
          X.addGate(pe.name, L, ie, { params: me, condition: le });
          var Ee = {
            comment: "",
            decompose: !1,
            versionStr: !1,
            providerName: !1,
            backendName: !1,
            asJupyter: !1,
            shots: !1,
            hybrid: null
          };
          v += C(X.exportToQiskit(Ee, !1, !0, !!e || n), _);
        }))), !P && !W && (e || n || c) && (v += "  "), !P && !W) {
          var H = G.name, te = G.options && G.options.params ? G.options.params : {};
          u == "statevector_simulator" && H == "measure" && c && (v += "# "), this.basicGates[H] && (v += "qc."), Z && Z.exportInfo && Z.exportInfo.qiskit && Z.exportInfo.qiskit.name ? H = Z.exportInfo.qiskit.name : H = G.name;
          var be = !1, K = !1;
          H == "ms" && (be = !0, K = !0, H = "MSGate"), H == "gpi" && M && (be = !0, K = !0, H = "GPIGate"), H == "gpi2" && M && (be = !0, K = !0, H = "GPI2Gate"), be && (v += "append("), v += H + "(";
          var ce = 0;
          if (te) {
            var Z = this.basicGates[G.name];
            if (Z || (Z = this.customGates[G.name], v += "qc", ce++), Z) {
              var de = Z.params || [], ue = de.length;
              if (ue) {
                for (var ve = 0; ve < ue; ve++) {
                  ce > 0 && (v += ", ");
                  var he = de[ve];
                  if (te[he] || te[he].toString()) {
                    var q = Et(te[he]), Ne = q.toString({ handler: b });
                    K && (Ne = "(" + Ne + ") / (2*np.pi)"), v += Ne;
                  }
                  ce++;
                }
                H == "cu" && !te.gamma && (v += ", 0", ce++);
              }
            }
          }
          if (be) {
            ce && (v += "), "), v += "[";
            for (var we = 0; we < G.wires.length; we++)
              we > 0 && (v += ", "), e || n ? v += Cr(G.wires[we], g.numQubits) : v += G.wires[we], ce++;
            v += "]";
          } else
            for (var we = 0; we < G.wires.length; we++)
              ce > 0 && (v += ", "), e || n ? v += Cr(G.wires[we], g.numQubits) : v += "q[" + G.wires[we] + "]", ce++;
          H == "measure" && G.options && G.options.creg && (ce > 0 && (v += ", "), v += G.options.creg.name + "[" + G.options.creg.bit + "]", ce++), v += ")", G.options && G.options.condition && G.options.condition.creg && (v += ".c_if(" + G.options.condition.creg + ", " + G.options.condition.value + ")"), v += `
`;
        }
      }
    }
  if (!r) {
    if (e)
      v += `
`;
    else {
      v += `
`, A && (v += _ + `qc = transpile(qc, backend)
`);
      var _ = "";
      if (c && (_ = "  "), p == "Aer") {
        var Se = "";
        Se += _ + "job = execute(qc, backend=backend", l && (Se += ", shots=shots"), Se += `)
`, Se += _ + `job_result = job.result()
`, c ? (u == "statevector_simulator" ? (v += Se, v += _ + `state = job_result.get_statevector(qc).data
`, v += `
`) : h.indexOf("state") >= 0 ? (v += _ + `qst = StateTomography(qc)
`, v += _ + `qst_analysis = qst.run(backend).block_for_results()
`, v += _ + `density = qst_analysis.analysis_results("state").value
`, v += _ + `state = np.diag(density)
`) : (v += Se, v += _ + `counts = Counter(job_result.get_counts(qc))
`, v += `
`), h.trim() || (h = `# CALCULATE COST HERE
cost = 0`), v += C(h, _), v += `
`, v += _ + `return cost
`) : (v += Se, v += _ + `print(job_result.get_counts(qc))
`);
      }
      if (p == "IBMQ") {
        var Se = "";
        Se += _ + "job = execute(qc, backend=backend", l && (Se += ", shots=shots"), Se += `)
`, Se += _ + `job_result = job.result()
`, c ? (h.indexOf("state") >= 0 ? (v += _ + `qst = StateTomography(qc)
`, v += _ + `qst_analysis = qst.run(backend).block_for_results()
`, v += _ + `density = qst_analysis.analysis_results("state").value
`, v += _ + `state = np.diag(density)
`, v += `
`) : (v += Se, v += _ + `counts = Counter(job_result.get_counts(qc))
`, v += `
`), h.trim() || (h = `# CALCULATE COST HERE
cost = 0`), v += C(h, _), v += `
`, v += _ + `return cost
`) : (v += Se, v += _ + `print(job_result.get_counts(qc))
`);
      }
      if (p == "IONQ") {
        var Se = "";
        Se += _ + "job = backend.run(qc", l && (Se += ", shots=shots"), Se += `)
`, Se += _ + `job_result = job.result()
`, c ? (h.indexOf("state") >= 0 ? (v += _ + `qst = StateTomography(qc)
`, v += _ + `qst_analysis = qst.run(backend).block_for_results()
`, v += _ + `density = qst_analysis.analysis_results("state").value
`, v += _ + `state = np.diag(density)
`) : (v += Se, v += _ + `counts = Counter(job.get_counts())
`, v += `
`), h.trim() || (h = `# CALCULATE COST HERE
cost = 0`), v += C(h, _), v += `
`, v += _ + `return cost
`) : (v += Se, v += _ + `print(job.get_counts())
`);
      }
      if (c) {
        var V = "";
        this.params.map(function(X, ie) {
          ie > 0 && (V += ", "), V += X;
        }), v += `
`, v += "params = np.array([" + V + `])
`, v += `
`, v += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, v += `print("cost:", minimum.fun, "params:", minimum.x)
`;
      }
    }
    if (f) {
      var re = {
        metadata: {
          kernelspec: {
            display_name: "Python 3",
            language: "python",
            name: "python3"
          }
        },
        nbformat: 4,
        nbformat_minor: 0,
        cells: [
          {
            cell_type: "code",
            source: v,
            metadata: {},
            outputs: [],
            execution_count: null
          }
        ]
      };
      return JSON.stringify(re);
    }
  }
  return v;
};
ge.prototype.exportToQuEST = function(t, e, r) {
  t = t || {};
  var n = t.comment, a = t.decompose, s = this;
  r = r || [];
  var p = null, o = ["unitary", "controlledUnitary"], p = new ge();
  p.load(this.save(a));
  var u = "";
  if (n) {
    var f = (n || "").split(`
`);
    f.map(function($) {
      $.length >= 2 && $[0] != "/" && $[1] != "/" && (u += "// "), u += $, u += `
`;
    });
  }
  for (var l = 0; l < this.numQubits; l++)
    for (var c = this.gates[l], h = 0; h < c.length; h++) {
      var d = c[h];
      if (!(!d || !this.basicGates[d.name]) && this.basicGates[d.name].exportInfo && this.basicGates[d.name].exportInfo.quest) {
        var g = this.basicGates[d.name].exportInfo.quest.name;
        if (r.includes(d.name))
          continue;
        (o.includes(g) || this.basicGates[d.name].exportInfo.quest.func) && r.push(d.name);
      }
    }
  if (e) {
    u += "Qureg " + e + "(Qureg qubits";
    for (var l = 0; l < p.numQubits; l++)
      u += ", const int q", u += l;
    if (p.params && p.params.length)
      for (var l = 0; l < p.params.length; l++)
        u += ", double " + p.params[l];
    u += `) {
`;
  } else {
    u += `#include <math.h>
#include "QuEST.h"

`, u += `#ifndef M_PI
#define M_PI 3.14159265
#endif

`;
    var v = [], N = p.usedGates();
    a || N.map(function($) {
      var U = p.basicGates[$];
      if (!U) {
        var k = s.customGates[$];
        if (k) {
          var L = new ge();
          L.load(k);
          var R = {
            comment: "",
            decompose: !1
          };
          v.push(L.exportToQuEST(R, $, r));
        }
      }
    });
    for (var l = 0; l < r.length; l++) {
      var b = r[l], g = this.basicGates[b].exportInfo.quest.name;
      switch (g) {
        case "unitary":
        case "controlledUnitary":
          {
            matrix = this.basicGates[b].exportInfo.quest.matrix;
            var C = this.basicGates[b].exportInfo.quest.params;
            if (u += "void " + b + "(Qureg qubits, const int q", g == "controlledUnitary" && (u += "1, const int q2"), C)
              for (var h = 0; h < C.length; h++)
                u += ", double " + C[h];
            u += `) {
`, u += `    ComplexMatrix2 u;
`, u += "    u.r0c0 = (Complex) {.real=" + matrix[0][0][0] + ", .imag= " + matrix[0][0][1] + `};
`, u += "    u.r0c1 = (Complex) {.real=" + matrix[0][1][0] + ", .imag= " + matrix[0][1][1] + `};
`, u += "    u.r1c0 = (Complex) {.real=" + matrix[1][0][0] + ", .imag= " + matrix[1][0][1] + `};
`, u += "    u.r1c1 = (Complex) {.real=" + matrix[1][1][0] + ", .imag= " + matrix[1][1][1] + `};
`, u += "    " + g + "(qubits, q", g == "controlledUnitary" && (u += "1, q2"), u += `, u);
}

`;
          }
          break;
        default:
          u += this.basicGates[b].exportInfo.quest.func + `

`;
          break;
      }
    }
    for (var l = 0; l < v.length; l++)
      u += v[l];
    u += `int main(int argc, char *argv[]) {
`, u += `    QuESTEnv env = createQuESTEnv();
`, u += "    Qureg qubits = createQureg(" + p.numQubits + `, env);
`, u += "    int measured[" + p.numQubits + `];

`;
  }
  u += `
`;
  for (var x = p.numCols(), E = 0; E < x; E++)
    for (var D = 0; D < this.numQubits; D++) {
      var d = p.getGateAt(E, D);
      if (d && d.connector == 0) {
        d.options && d.options.condition && d.options.condition.creg && (u += "if(" + d.options.condition.creg + "==" + d.options.condition.value + `) {
`);
        var b = d.name, A = d.options && d.options.params ? d.options.params : {}, M = this.basicGates[b];
        if (b == "measure")
          u += "    measured[" + d.wires[0] + "] = measure(qubits, " + d.wires[0];
        else if (M) {
          var g = M.exportInfo.quest.name, C = M.exportInfo.quest.params;
          o.includes(g) ? u += "    " + b + "(qubits" : u += "    " + g + "(qubits";
          for (var _ = 0; _ < d.wires.length; _++)
            e ? u += ", q" + d.wires[_] : u += ", " + d.wires[_];
          if (C)
            switch (g) {
              case "compactUnitary":
                u += ", " + C.alpha, u += ", " + C.beta;
                break;
              case "phaseShift":
              case "controlledPhaseShift":
                C.theta && (u += ", " + C.theta);
                break;
            }
        } else {
          M = this.customGates[b], u += "    qubits = " + b + "(qubits";
          for (var _ = 0; _ < d.wires.length; _++)
            u += ", " + d.wires[_];
        }
        if (A) {
          var M = this.basicGates[b];
          if (M || (M = this.customGates[b]), M) {
            var O = M.params || [], T = O.length;
            if (T)
              for (var I = 0; I < T; I++) {
                var q = O[I];
                u += ", " + A[q];
              }
          }
        }
        u += `);
`, d.options && d.options.condition && d.options.condition.creg && (u += `}
`);
      }
    }
  return e ? u += `
    return qubits;
}

` : (u += `
    destroyQureg(qubits, env);
`, u += `    destroyQuESTEnv(env);
`, u += `    return 0;
}
`), u;
};
ge.prototype.exportToQASM = function(t, e, r, n) {
  t = t || {};
  var a = t.comment, s = t.decompose, o = t.compatibilityMode, p = this, u = this.options && this.options.params ? this.options.params : {}, f = function(G, P) {
    if (G.isSymbolNode) {
      var W = G.name;
      if (P.replaceVars && typeof P.replaceVars[W] < "u") {
        var W = P.replaceVars[W];
        return !o && p.params.indexOf(W) >= 0 ? "(" + u[W] + ")" : "(" + W + ")";
      }
      if (!o && p.params.indexOf(G.name) >= 0)
        return u[G.name];
    }
  }, l = null, l = new ge();
  l.load(this.save(s));
  var c = "";
  if (a) {
    var h = (a || "").split(`
`);
    h.map(function(G) {
      G.length >= 2 && G[0] != "/" && G[1] != "/" && (c += "// "), c += G, c += `
`;
    });
  }
  if (e) {
    if (c += "gate " + e, l.params && l.params.length) {
      c += "(";
      for (var d = 0; d < l.params.length; d++)
        d > 0 && (c += ", "), c += l.params[d];
      c += ")";
    }
    for (var g = 0; g < l.numQubits; g++)
      g == 0 && (c += " "), g > 0 && (c += ", "), c += Cr(g, l.numQubits);
    c += `
{
`;
  } else if (!r) {
    c += `OPENQASM 2.0;
`, c += `include "qelib1.inc";
`, c += "qreg q[" + l.numQubits + `];
`;
    for (var v in l.cregs)
      c += "creg " + v + "[" + (l.cregs[v].length || 1) + `];
`;
    var N = l.usedGates();
    s || N.map(function(G) {
      var P = l.basicGates[G];
      if (!P) {
        var W = p.customGates[G];
        if (W) {
          var le = new ge();
          le.load(W);
          var Z = {
            comment: "",
            decompose: !1,
            compatibilityMode: o
          };
          c += le.exportToQASM(Z, G, !1, !1);
        }
      }
    });
  }
  for (var b = l.numCols(), C = 0; C < b; C++)
    for (var x = 0; x < l.numQubits; x++) {
      var E = l.getGateAt(C, x), D = null, A = null;
      if (E && E.connector == 0) {
        var M = E.name;
        if (!o) {
          var _ = l.getGateDef(E.name);
          _ && _.exportInfo && (_.exportInfo.qasm && _.exportInfo.qasm.name ? M = _.exportInfo.qasm.name : _.exportInfo.qasm && _.exportInfo.qasm.replacement ? (D = _.exportInfo.qasm.replacement, D.map(function(G) {
            var P = new ge();
            if (P.cregs = JSON.parse(JSON.stringify(p.cregs)), E.options && E.options.params) {
              var W = Object.keys(E.options.params), le = Object.keys(G.params);
              W.map(function(te) {
                le.indexOf(te) >= 0 && (G.params[te] = E.options.params[te]);
              });
            }
            var Z = E.options && E.options.condition ? E.options.condition : {};
            P.addGate(G.name, C, E.wires, { params: G.params, condition: Z });
            var H = {
              comment: "",
              decompose: !1,
              compatibilityMode: o
            };
            c += P.exportToQASM(H, !1, !0, !!e || n);
          })) : _.exportInfo.qasm && _.exportInfo.qasm.equivalent && (A = _.exportInfo.qasm.equivalent, A.map(function(G) {
            var P = new ge();
            P.cregs = JSON.parse(JSON.stringify(p.cregs));
            var W = G.wires.length > 1 ? E.wires : E.wires[G.wires[0]], le = {};
            if (G.params) {
              var Z = {};
              if (E.options && E.options.params)
                for (var H in E.options.params) {
                  var te = Et(E.options.params[H]), be = te.toString({ handler: f });
                  Z[H] = be;
                }
              for (var K in G.params) {
                var te = Et(G.params[K]), be = te.toString({ handler: f, replaceVars: Z });
                le[K] = be;
              }
            }
            var ce = E.options && E.options.condition ? E.options.condition : {};
            P.addGate(G.name, C, W, { params: le, condition: ce });
            var de = {
              comment: "",
              decompose: !1,
              compatibilityMode: o
            };
            c += P.exportToQASM(de, "", !0, !!e || n);
          })));
        }
        if (!D && !A && ((e || n) && (c += "  "), E.options && E.options.condition && E.options.condition.creg && (c += "if(" + E.options.condition.creg + "==" + E.options.condition.value + ") ")), !D && !A || o) {
          var O = E.name, T = E.options && E.options.params ? E.options.params : {};
          if (c += o ? E.name : M, T) {
            var _ = l.basicGates[O];
            if (_ || (_ = l.customGates[O]), _) {
              var I = _.params || [], q = I.length;
              if (q) {
                c += " (";
                for (var $ = 0; $ < q; $++) {
                  $ > 0 && (c += ", ");
                  var U = I[$], k = T[U];
                  if (!e && !n && !o) {
                    var L = Et(T[U]);
                    k = L.toString({ handler: f });
                  }
                  c += k;
                }
                c += ")";
              }
            }
          }
          for (var R = 0; R < E.wires.length; R++)
            R > 0 && (c += ","), e || n ? c += " " + Cr(E.wires[R], l.numQubits) : c += " q[" + E.wires[R] + "]";
          O == "measure" && E.options && E.options.creg && (c += " -> ", c += E.options.creg.name + "[" + E.options.creg.bit + "]"), c += `;
`;
        }
      }
    }
  return e && (c += `}

`), c;
};
ge.prototype.exportToPyquil = function(t, e) {
  t = t || {};
  var r = t.comment, n = t.decompose, a = t.versionStr, s = t.lattice, o = t.asQVM, p = t.asJupyter, u = t.shots, f = t.hybrid, l = this, c = parseFloat(a || "2.12");
  isNaN(c) && (c = 2.1), u || (u = 1024), typeof f > "u" && (f = this.options ? !!this.options.hybrid : !1);
  var h = new ge();
  h.load(this.save(n));
  var d = function(Ce, De) {
    if (Ce.isSymbolNode) {
      var Oe = ["pi", "sin", "cos", "tan", "asin", "acos", "atan"];
      if (Oe.indexOf(Ce.name) >= 0)
        return "np." + Ce.name;
      if (l.params.indexOf(Ce.name) >= 0 && f)
        return "params[" + l.params.indexOf(Ce.name) + "]";
    }
  }, g = function(Ce, De) {
    var Oe = "", Be = Ce.split(`
`), Le = -1;
    Be.map(function(Ke) {
      var Ze = Ke.search(/\S/);
      Ze >= 0 && (Le < 0 || Ze < Le) && (Le = Ze);
    }), Le < 0 && (Le = 0);
    var Re = "";
    if (Le < De.length)
      for (var rt = 0; rt < De.length - Le; rt++)
        Re += " ";
    return Be.map(function(Ke) {
      Oe += Re + Ke + `
`;
    }), Oe;
  }, v = "", N = [], b = "", C = "", x = "", E = h.usedGates(), D = h.gotMeasurement(), A = [], M = [];
  E.map(function(Ce) {
    var De = h.basicGates[Ce];
    if (De) {
      if (De.exportInfo && De.exportInfo.pyquil) {
        var Oe = De.exportInfo.pyquil;
        if (Oe.array) {
          var Be = "";
          Oe.params && (Be += ", [", Oe.params.map(function(rt, Ke) {
            Ke > 0 && (Be += ", "), Be += "p_" + rt;
            var Ze = "p_" + rt + " = Parameter('" + rt + "')";
            N.indexOf(Ze) < 0 && N.push(Ze);
          }), Be += "]"), C += "p.inst(" + Oe.name + `_defgate)
`, x += Oe.name + "_array = np.array(" + Oe.array + `)
`, b += Oe.name + "_defgate = DefGate('" + Oe.name + "', " + Oe.name + "_array" + Be + `)
`, b += Oe.name + " = " + Oe.name + `_defgate.get_constructor()
`, A.push(Oe.name);
        } else {
          var Le = "";
          if (Oe.replacement) {
            var Re = h.basicGates[Oe.replacement.name];
            Re && Re.exportInfo && (Re.exportInfo.pyquil ? Le = Re.exportInfo.pyquil.name : Re.exportInfo.quil && (Le = Re.exportInfo.quil.name));
          } else
            Le = Oe.name;
          Le && (v && (v += ", "), v += Le);
        }
      } else if (De.exportInfo && De.exportInfo.quil) {
        var Oe = De.exportInfo.quil;
        if (!Oe.defgate) {
          var Le = "";
          if (Oe.replacement) {
            var Re = h.basicGates[Oe.replacement.name];
            Re && Re.exportInfo && (Re.exportInfo.pyquil ? Le = Re.exportInfo.pyquil.name : Re.exportInfo.quil && (Le = Re.exportInfo.quil.name));
          } else
            Le = Oe.name;
          Le && (v && (v += ", "), v += Le);
        }
      }
    }
  });
  var _ = h.gotClassicalControl();
  _ && (v && (v += ", "), c < 2 ? v += "FALSE, NOT, OR, AND" : v += "MOVE, NOT, IOR, AND");
  var O = "";
  b && (c < 2.12 ? O = `from pyquil.parameters import Parameter, quil_sin, quil_cos, quil_sqrt, quil_exp, quil_cis
from pyquil.quilbase import DefGate` : O = `from pyquil.quilatom import Parameter, quil_sin, quil_cos, quil_sqrt, quil_exp, quil_cis
from pyquil.quilbase import DefGate`);
  var T = "";
  if (r) {
    var I = (r || "").split(`
`);
    I.map(function(Ce) {
      Ce.length >= 1 && Ce[0] != "#" && (T += "# "), T += Ce, T += `
`;
    });
  }
  var q = "";
  if (e) {
    for (var $ = "", U = 0, k = 0; k < h.params.length; k++)
      U > 0 && ($ += ", "), $ += h.params[k], U++;
    for (var k = 0; k < h.numQubits; k++)
      U > 0 && ($ += ", "), $ += "q" + k, U++;
    T += "def " + e + ($ ? "(" + $ + ")" : "") + `:
`, q = "  ";
  } else {
    c < 2 ? (T += `from pyquil.api import QVMConnection
`, T += `from pyquil.quil import Program
`) : T += `from pyquil import Program, get_qc
`, v && (T += "from pyquil.gates import " + v + `
`), O && (T += O + `
`), T += `from functools import reduce
`, f && (T += `from scipy.optimize import minimize
`, T += `from collections import Counter
`), T += `import numpy as np
`, u && (T += `
`, T += "shots = " + u + `
`);
    var L = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      T += `
`;
      for (var k = 0; k < this.params.length; k++) {
        var R = this.params[k], G = Et(L[R]), P = G.toString({ handler: d });
        T += R + " = " + P + `
`;
      }
      T += `
`;
    }
    f && (T += "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, T += `
`), b && (N.map(function(De, Oe) {
      Oe == 0 && (T += `
`), T += De + `
`;
    }), T += `
`, T += x + `
`, T += `
`, T += b + `
`), T += `
`;
    var E = h.usedGates();
    n || E.map(function(De) {
      var Oe = h.basicGates[De];
      if (!Oe) {
        var Be = l.customGates[De];
        if (Be) {
          var Le = new ge();
          Le.load(Be);
          var Re = {
            comment: "",
            decompose: !1,
            versionStr: a
          };
          T += Le.exportToPyquil(Re, De), M.push(De);
        }
      }
    });
  }
  if (f && (q += "  ", T += `def objective_function(params):
`), c >= 2 && !e) {
    o || s ? T += q + `p = Program('PRAGMA INITIAL_REWIRING "PARTIAL"')

` : T += q + `p = Program()

`;
    var W = h.cregTotalBits();
    _ && (W += 1), W && (T += q + "ro = p.declare('ro', memory_type='BIT', memory_size=" + W + `)
`, T += `
`);
  } else
    T += q + `p = Program()

`;
  T += C ? q + C + `
` : "";
  for (var le = 0; le < h.numCols(); le++)
    for (var Z = 0; Z < h.numQubits; Z++) {
      var H = h.getGateAt(le, Z);
      if (H && H.connector == 0) {
        var te = h.getGateDef(H.name), be = be = H.options && H.options.params ? H.options.params : {}, K = null;
        if (te) {
          te.exportInfo && (te.exportInfo.pyquil && te.exportInfo.pyquil.replacement ? (te.exportInfo.pyquil.replacement.params && (be = te.exportInfo.pyquil.replacement.params), te = h.getGateDef(te.exportInfo.pyquil.replacement.name)) : te.exportInfo.quil && te.exportInfo.quil.replacement && (te.exportInfo.quil.replacement.params && (be = te.exportInfo.quil.replacement.params), te = h.getGateDef(te.exportInfo.quil.replacement.name)), te && te.exportInfo && (te.exportInfo.pyquil ? K = te.exportInfo.pyquil : te.exportInfo.quil && (K = te.exportInfo.quil)));
          var ce = !1;
          K ? (ce = A.indexOf(K.name) >= 0, M.indexOf(K.name) >= 0) : (ce = A.indexOf(H.name) >= 0, M.indexOf(H.name) >= 0);
          var de = !1;
          if (H.options && H.options.condition && H.options.condition.creg) {
            de = !0, T += `
`;
            var ue = l.cregTotalBits(), ve = H.options.condition, he = ve.value || 0, Ne = l.cregBase(ve.creg);
            if (he == 0) {
              var we = l.cregs[ve.creg].length;
              if (c < 2) {
                T += q + "p.inst(FALSE(" + ue + `))
`;
                for (var Se = 0; Se < we; Se++)
                  T += q + "p.inst(OR(" + (Se + Ne) + ", " + ue + `))
`;
                T += q + "p.inst(NOT(" + ue + `))
`, T += q + "p.if_then(" + ue + ", Program(";
              } else {
                T += q + "p.inst(MOVE(ro[" + ue + `], 0))
`;
                for (var Se = 0; Se < we; Se++)
                  T += q + "p.inst(IOR(ro[" + ue + "], ro[" + (Se + Ne) + `]))
`;
                T += q + "p.inst(NOT(ro[" + ue + `]))
`, T += q + "p.if_then(ro[" + ue + "], Program(";
              }
            } else {
              var V = he.toString(2).split("").reverse(), re = 0, pe = 0;
              if (V.map(function(Ce, De) {
                var Oe = parseInt(Ce);
                V[De] = Oe, Oe && (re++, pe = De);
              }), re == 1)
                c < 2 ? T += q + "p.if_then(" + (pe + Ne) + ", Program(" : T += q + "p.if_then(ro[" + (pe + Ne) + "], Program(";
              else if (c < 2) {
                T += q + "p.inst(FALSE(" + ue + `))
`;
                var X = !0;
                V.map(function(Ce, De) {
                  Ce && (X ? (X = !1, T += q + "p.inst(OR(" + (De + Ne) + ", " + ue + `))
`) : T += q + "p.inst(AND(" + (De + Ne) + ", " + ue + `))
`);
                }), T += q + "p.if_then(" + ue + ", Program(";
              } else {
                T += q + "p.inst(MOVE(ro[" + ue + `], 0))
`;
                var X = !0;
                V.map(function(De, Oe) {
                  De && (X ? (X = !1, T += q + "p.inst(IOR(ro[" + ue + "], ro[" + (Oe + Ne) + `]))
`) : T += q + "p.inst(AND(ro[" + ue + "], ro[" + (Oe + Ne) + `]))
`);
                }), T += q + "p.if_then(ro[" + ue + "], Program(";
              }
            }
          } else
            T += q + "p.inst(";
          K ? T += K.name : T += H.name;
          var ie = !1;
          if (K && K.params && K.params.length) {
            var U = 0;
            T += "(", ie = !0;
            for (var me = 0; me < K.params.length; me++) {
              if (U > 0 && (T += ", "), typeof be[K.params[me]] < "u") {
                var G = Et(String(be[K.params[me]]));
                T += G.toString({ handler: d });
              }
              U++;
            }
            c < 2 || ce ? T += ")" : T += ", ";
          } else if (te && te.params && te.params.length) {
            var U = 0;
            T += "(", ie = !0;
            for (var me = 0; me < te.params.length; me++) {
              if (U > 0 && (T += ", "), typeof be[te.params[me]] < "u") {
                var G = Et(be[te.params[me]]);
                T += G.toString({ handler: d });
              }
              U++;
            }
            c < 2 || ce ? T += ")" : T += ", ";
          }
          if (H.wires.length) {
            var U = 0;
            (c < 2 || !ie || ce) && (T += "(", ie = !0);
            for (var Ae = 0; Ae < H.wires.length; Ae++)
              U > 0 && (T += ", "), e ? T += "q" + H.wires[Ae] : T += "" + H.wires[Ae], U++;
            if (H.name == "measure" && H.options && H.options.creg) {
              var Me = parseInt(H.options.creg.bit) || 0;
              isNaN(Me) && (Me = 0), U > 0 && (T += ", "), c < 2 ? T += Me + l.cregBase(H.options.creg.name) : T += "ro[" + (Me + l.cregBase(H.options.creg.name)) + "]", U++;
            }
            T += ")";
          }
          T += ")", de && (T += `)
`), T += `
`;
        } else
          T += q + '# Export to pyquil WARNING: unknown gate "' + H.name + '".';
      }
    }
  if (e)
    T += q + `return p
`, T += `
`;
  else {
    if (T += `
`, c < 2)
      if (T += q + `qvm = QVMConnection()
`, f) {
        T += `
`, T += q + `# CALCULATE COST HERE
`;
        var Q = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
        Q.trim() || (Q = "cost = 0"), T += g(Q, q), T += `
`, T += q + `return cost
`;
      } else
        T += q + `print(qvm.run(p))
`;
    else {
      u && (T += q + `p.wrap_in_numshots_loop(shots)
`, T += `
`);
      var ee = s;
      if (ee || (c < 2.1 ? ee = this.numQubits + "q-generic-qvm" : ee = this.numQubits + "q-qvm"), T += q + "qc = get_qc('" + ee + "'" + (s ? ", as_qvm=" + (o ? "True" : "False") : "") + `)
`, s)
        if (T += q + `ep = qc.compile(p)
`, D)
          if (T += q + `results_list = qc.run(ep).readout_data.get("ro")
`, T += q + `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1], ""), results_list))
`, f) {
            T += q + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, T += `
`, T += q + `# CALCULATE COST HERE
`;
            var Q = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
            Q.trim() || (Q = "cost = 0"), T += g(Q, q), T += `
`, T += q + `return cost
`;
          } else
            T += q + `counts = dict(zip(results,[results.count(i) for i in results]))
`, T += q + `print(counts)
`;
        else if (f) {
          T += q + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, T += `
`, T += q + `# CALCULATE COST HERE
`;
          var Q = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
          Q.trim() || (Q = "cost = 0"), T += g(Q, q), T += `
`, T += q + `return cost
`;
        } else
          T += q + `print(qc.run(ep).readout_data.get("ro"))
`;
      else if (D)
        if (T += q + `results_list = qc.run(p).readout_data.get("ro")
`, T += q + `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1], ""), results_list))
`, f) {
          T += q + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, T += `
`, T += q + `# CALCULATE COST HERE
`;
          var Q = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
          Q.trim() || (Q = "cost = 0"), T += g(Q, q), T += `
`, T += q + `return cost
`;
        } else
          T += q + `counts = dict(zip(results,[results.count(i) for i in results]))
`, T += q + `print(counts)
`;
      else if (T += q + `results_list = qc.run(p).readout_data.get("ro")
`, T += q + `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1], ""), results_list))
`, f) {
        T += q + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, T += `
`, T += q + `# CALCULATE COST HERE
`;
        var Q = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
        Q.trim() || (Q = "cost = 0"), T += g(Q, q), T += `
`, T += q + `return cost
`;
      } else
        T += q + `print(results)
`;
    }
    if (f) {
      var ye = "";
      this.params.map(function(Ce, De) {
        De > 0 && (ye += ", "), ye += Ce;
      }), T += `
`, T += "params = np.array([" + ye + `])
`, T += `
`, T += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, T += `print("cost:", minimum.fun, "params:", minimum.x)
`;
    }
  }
  if (p) {
    var Ee = {
      metadata: {
        kernelspec: {
          display_name: "Python 3",
          language: "python",
          name: "python3"
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: T,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(Ee);
  }
  return T;
};
ge.prototype.exportToQuil = function(t, e) {
  t = t || {};
  var r = t.comment, n = !0, a = t.versionStr, s = this, o = parseFloat(a || "2.0");
  isNaN(o) && (o = 2);
  var p = new ge();
  p.load(this.save(n));
  var u = "";
  if (r) {
    var f = (r || "").split(`
`);
    f.map(function(ce) {
      ce.length >= 1 && ce[0] != "#" && (u += "# "), u += ce, u += `
`;
    });
  }
  var l = p.usedGates();
  l.map(function(ce) {
    var de = p.basicGates[ce];
    de && de.exportInfo && de.exportInfo.quil && de.exportInfo.quil.defgate && (u += de.exportInfo.quil.defgate, u += `

`);
  });
  var c = this.gotClassicalControl(), h = "";
  if (e) {
    var d = "";
    if (p.params.length) {
      d += "(";
      for (var g = 0; g < p.params.length; g++)
        g > 0 && (d += ", "), d += "%" + p.params[g];
      d += ")";
    }
    for (var v = "", g = 0; g < p.numQubits; g++)
      g > 0 && (v += " "), v += "q" + g;
    u += "DEFCIRCUIT " + e + (d ? " " + d : "") + (v ? " " + v : "") + `:
`, h = "    ";
  } else {
    if (u += `
`, o >= 2) {
      var N = p.cregTotalBits();
      c && (N += 1), N && (u += "DECLARE ro BIT[" + N + `]
`);
    }
    var b = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      u += `
`;
      for (var g = 0; g < this.params.length; g++) {
        var C = this.params[g], x = Et(b[C]);
        x.toString({ handler: E }), u += "DECLARE " + C + ` REAL[1]
`;
      }
      u += `
`;
    }
    var l = p.usedGates();
  }
  for (var E = function(ce, de) {
    if (ce.isSymbolNode && p.params.indexOf(ce.name) >= 0)
      return "%" + ce.name;
  }, D = 1, A = 0; A < p.numCols(); A++)
    for (var M = 0; M < p.numQubits; M++) {
      var _ = p.getGateAt(A, M);
      if (_ && _.connector == 0) {
        var O = p.getGateDef(_.name), T = _.options && _.options.params ? _.options.params : {}, I = null;
        if (O) {
          O.exportInfo && (O.exportInfo.quil && O.exportInfo.quil.replacement && (O.exportInfo.quil.replacement.params && (T = O.exportInfo.quil.replacement.params), O = p.getGateDef(O.exportInfo.quil.replacement.name)), I = O && O.exportInfo && O.exportInfo.quil ? O.exportInfo.quil : null);
          var q = !1;
          if (_.options && _.options.condition && _.options.condition.creg) {
            q = !0, u += `
`;
            var $ = s.cregTotalBits(), U = _.options.condition, k = U.value || 0, L = s.cregBase(U.creg);
            if (k == 0) {
              var R = s.cregs[U.creg].length;
              if (o < 2) {
                u += h + "FALSE [" + $ + `]
`;
                for (var G = 0; G < R; G++)
                  u += h + "OR [" + (G + L) + "] [" + $ + `]
`;
                u += h + "NOT [" + $ + `]
`, u += "JUMP-WHEN @THEN" + D + " [" + $ + `]
`, u += "JUMP @END" + (D + 1) + `
`, u += "LABEL @THEN" + D + `
`;
              } else {
                u += h + "FALSE ro[" + $ + `]
`;
                for (var G = 0; G < R; G++)
                  u += h + "OR ro[" + (G + L) + "] ro[" + $ + `]
`;
                u += h + "NOT ro[" + $ + `]
`, u += "JUMP-WHEN @THEN" + D + " ro[" + $ + `]
`, u += "JUMP @END" + (D + 1) + `
`, u += "LABEL @THEN" + D + `
`;
              }
            } else {
              var P = k.toString(2).split("").reverse(), W = 0, le = 0;
              if (P.map(function(ce, de) {
                var ue = parseInt(ce);
                P[de] = ue, ue && (W++, le = de);
              }), W == 1)
                o < 2 ? (u += "JUMP-WHEN @THEN" + D + " [" + (le + L) + `]
`, u += "JUMP @END" + (D + 1) + `
`, u += "LABEL @THEN" + D + `
`) : (u += "JUMP-WHEN @THEN" + D + " ro[" + (le + L) + `]
`, u += "JUMP @END" + (D + 1) + `
`, u += "LABEL @THEN" + D + `
`);
              else if (o < 2) {
                u += h + "FALSE [" + $ + `]
`;
                var Z = !0;
                P.map(function(ce, de) {
                  ce && (Z ? (Z = !1, u += h + "OR [" + (de + L) + "] [" + $ + `]
`) : u += h + "AND [" + (de + L) + "] [" + $ + `]
`);
                }), u += "JUMP-WHEN @THEN" + D + " [" + $ + `]
`, u += "JUMP @END" + (D + 1) + `
`, u += "LABEL @THEN" + D + `
`;
              } else {
                u += h + "FALSE ro[" + $ + `]
`;
                var Z = !0;
                P.map(function(de, ue) {
                  de && (Z ? (Z = !1, u += h + "OR ro[" + (ue + L) + "] ro[" + $ + `]
`) : u += h + "AND ro[" + (ue + L) + "] ro[" + $ + `]
`);
                }), u += "JUMP-WHEN @THEN" + D + " ro[" + $ + `]
`, u += "JUMP @END" + (D + 1) + `
`, u += "LABEL @THEN" + D + `
`;
              }
            }
          }
          I ? u += h + I.name : u += h + _.name, u += " ";
          var H = 0;
          if (I && I.params && I.params.length) {
            u += "(";
            for (var te = 0; te < I.params.length; te++) {
              if (H > 0 && (u += ", "), typeof T[I.params[te]] < "u") {
                var x = Et(String(T[I.params[te]]));
                u += x.toString({ handler: E });
              }
              H++;
            }
            u += ")";
          } else if (O && O.params && O.params.length) {
            u += "(";
            for (var te = 0; te < O.params.length; te++) {
              if (H > 0 && (u += ", "), typeof T[O.params[te]] < "u") {
                var x = Et(T[O.params[te]]);
                u += x.toString({ handler: E });
              }
              H++;
            }
            u += ")";
          }
          for (var be = 0; be < _.wires.length; be++)
            H > 0 && (u += " "), e ? u += "q" + _.wires[be] : u += "" + _.wires[be], H++;
          if (_.name == "measure" && _.options && _.options.creg) {
            var K = parseInt(_.options.creg.bit) || 0;
            isNaN(K) && (K = 0), H > 0 && (u += " "), o < 2 ? u += "[" + (K + s.cregBase(_.options.creg.name)) + "]" : u += "ro[" + (K + s.cregBase(_.options.creg.name)) + "]", H++;
          }
          u += `
`, q && (u += "LABEL @END" + (D + 1) + `
`, u += `
`, D += 2);
        } else
          console.log("unknown gate", _.name);
      }
    }
  return e && (u += `
`), u;
};
ge.prototype.exportToAQASM = function(t, e, r, n) {
  var a = this;
  t = t || {}, t.comment;
  var s = t.decompose, o = t.asJupyter, p = t.shots, u = e ? t.hybrid : !1, f = null, l = null;
  p = p || 1024, typeof u > "u" && (u = this.options ? !!this.options.hybrid : !1);
  var c = this.save(!!s);
  f = new ge(), l = new ge(), f.load(c), l.load(c);
  var h = function(we, Se) {
    if (we.isSymbolNode) {
      var V = ["pi"];
      if (V.indexOf(we.name) >= 0)
        return "np." + we.name;
      var re = we.name;
      if (Se.replaceVars && typeof Se.replaceVars[re] < "u") {
        var re = Se.replaceVars[re];
        return a.params.indexOf(re) >= 0 ? "(" + P[re] + ")" : "(" + re + ")";
      }
      if (a.params.indexOf(we.name) >= 0)
        return P[we.name];
    }
  }, d = function(we, Se) {
    var V = "", re = we.split(`
`), pe = -1;
    re.map(function(me) {
      var Ae = me.search(/\S/);
      Ae >= 0 && (pe < 0 || Ae < pe) && (pe = Ae);
    }), pe < 0 && (pe = 0);
    var X = "";
    if (pe < Se.length)
      for (var ie = 0; ie < Se.length - pe; ie++)
        X += " ";
    return re.map(function(me) {
      V += X + me + `
`;
    }), V;
  }, g = function(we) {
    for (var Se = "", V = 0; V < we; V++)
      Se += "    ";
    return Se;
  };
  n = n || 0;
  var v = [];
  if (!e) {
    if (!s)
      for (var N = l.numCols(), b = N - 1; b >= 0; b--)
        for (var C = 0; C < l.numQubits; C++) {
          var x = l.gates[C][b];
          if (x && x.connector == 0 && !l.basicGates[x.name]) {
            customDecomposedCircuit = l.decomposeGateAt(b, C);
            for (var E = 0; E < customDecomposedCircuit.numCols(); E++)
              for (var D = 0; D < customDecomposedCircuit.numQubits; D++) {
                var A = customDecomposedCircuit.getGateAt(E, D);
                A && A.connector == 0 && v.push(A), f.gates.map(function(we, Se) {
                  we.map(function(V) {
                    V && V.name == x.name && f.removeGate(V.id);
                  });
                });
              }
          }
        }
    v.map(function(we) {
      we && f.insertGate(we.name, we.column, we.wires, we.options);
    });
  }
  var M = "", _ = g(n), O = f.usedGates(), T = f.numQubits;
  if (e)
    if (r) {
      for (var $ = "", U = 0, k = 0; k < f.params.length; k++)
        U > 0 && ($ += ", "), $ += f.params[k], U++;
      for (var k = 0; k < f.numQubits; k++)
        U > 0 && ($ += ", "), $ += Cr(k, f.numQubits), U++;
    } else {
      M += _ + `from qat.lang.AQASM import *
`, M += _ + `from qat.qpus import get_default_qpu
`, M += _ + `from collections import Counter
`, u && (M += _ + `from scipy.optimize import minimize
`), M += _ + `import numpy as np
`, M += `
`;
      var L = "", R = 0;
      O.map(function(we) {
        var Se = f.basicGates[we];
        if (Se) {
          if (!s && f.basicGates[we].exportInfo.aqasm && f.basicGates[we].exportInfo.aqasm.array) {
            if (unsupportedAqasmInfo = f.basicGates[we].exportInfo.aqasm, gateUnitary = we + "_gate", M += _ + "def " + gateUnitary + "(", unsupportedAqasmInfo.params && unsupportedAqasmInfo.params.length) {
              var V = 0;
              unsupportedAqasmInfo.params.map(function(Ae) {
                V > 0 && (M += ", "), M += _ + "p_" + Ae, V++;
              });
            }
            M += `):
`, M += g(n + 1) + "return np.array(" + unsupportedAqasmInfo.array + `)

`, L += we + ' = AbstractGate("' + we + '", [';
            var re = 0;
            if (unsupportedAqasmInfo.params)
              for (var pe = 0; pe < unsupportedAqasmInfo.params.length; pe++)
                re > 0 && (L += ", "), L += "float", re++;
            Se.matrix && (arity = vi(Se.matrix.length)), L += "], matrix_generator=" + gateUnitary + ", arity=" + arity + `)
`;
          }
        } else {
          var X = a.customGates[we];
          if (X) {
            var ie = new ge();
            ie.load(X);
            var me = {
              comment: "",
              decompose: !0,
              asJupyter: !1,
              shots: null,
              hybrid: !1
            };
            M += ie.exportToAQASM(me, e, we, n), R++;
          }
        }
      }), M += L, M += `
`, p && (M += _ + "shots = " + p + `
`, M += `
`), M += _ + `program = Program()
`, M += _ + "qubits_reg = program.qalloc(" + f.numQubits + `)
`;
      for (var G in f.cregs)
        M += _ + G + " = program.calloc(" + f.cregs[G].length + `)
`;
      M += `
`;
      var P = this.options && this.options.params ? this.options.params : {};
      if (this.params.length) {
        for (var k = 0; k < this.params.length; k++) {
          var W = this.params[k], le = Et(P[W]), Z = le.toString({ handler: h });
          M += W + " = " + Z + `
`;
        }
        M += `
`;
      }
      u && (M += _ + "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, M += `
`);
    }
  else if (M += _ + `BEGIN
`, M += _ + "qubits " + T + `
`, f.cregs) {
    var I = 0;
    for (var q in f.cregs)
      I += f.cregs[q].length;
    M += _ + "cbits " + I + `
`;
  }
  r ? (M += "def " + r + ($ ? "(" + $ + ")" : "") + `:
`, n++, _ = g(n), M += _ + `circuit = QRoutine()
`) : u && (M += `def objective_function(params):
`, n++, _ = g(n)), r || R && (M += `
`, O.map(function(we) {
    !f.basicGates[we] && f.customGates[we] && (M += _ + we + "(");
  }));
  for (var b = 0; b < f.numCols(); b++)
    for (var C = 0; C < f.numQubits; C++) {
      var x = f.getGateAt(b, C);
      if (x && x.connector == 0) {
        var H = f.getGateDef(x.name), te = "";
        if (x.options && x.options.params && (gateParams = x.options.params), x.name == "measure" && (e ? te += "program.measure" : te += "MEAS"), x.name == "reset" && (e ? te += "program.reset" : te += "RESET"), H && H.exportInfo) {
          if (H.exportInfo.aqasm) {
            var be = H.exportInfo.aqasm, K = "";
            if (be.name)
              H.params.length ? H.params.map(function(pe) {
                var X = Et(gateParams[pe]), ie = X.toString({ handler: h });
                K = be.name, e ? K += "(" + ie + ")" : K += "[" + ie + "]";
              }) : K += be.name, be.controlled && be.dagger ? e ? te += K + ".dag().ctrl()" : te += "CTRL(DAG(" + K + "))" : be.controlled ? e ? te += K + ".ctrl()" : te += "CTRL(" + K + ")" : be.dagger ? e ? te += K + ".dag()" : te += "DAG(" + K + ")" : te += K;
            else if (be.matrix)
              if (e) {
                te += x.name + "(";
                var de = 0;
                H.params.map(function(pe) {
                  de > 0 && (te += ", ");
                  var X = Et(gateParams[pe]), ie = X.toString({ handler: h });
                  te += ie, de++;
                }), te += ")";
              } else {
                te = "[";
                for (var ce = 0; ce < be.matrix.length; ce++) {
                  row = be.matrix[ce], te += "[";
                  for (var k = 0; k < row.length; k++)
                    te += "(", row_element = row[k], be.params && be.params.map(function(X) {
                      var ie = gateParams[X];
                      row_element.toString().indexOf(X) > 0 && (row_element = row_element.replace(X, ie));
                    }), evaluated_expression = Br(row_element, a.options.params), matrix_element = Wt(evaluated_expression), matrix_element_real = matrix_element.re, matrix_element_im = matrix_element.im, te += matrix_element_real + ", " + matrix_element_im + ")", k < row.length - 1 && (te += " ");
                  te += "]", ce < be.matrix.length - 1 && (te += " ");
                }
                te += "]";
              }
          }
          M += _ + te, e ? M += "(" : M += " ";
        }
        for (var U = 0, ue = 0; ue < x.wires.length; ue++)
          U > 0 && (M += ", "), e ? r ? M += Cr(x.wires[ue], f.numQubits) : M += "qubits_reg[" + x.wires[ue] + "]" : M += "q[" + x.wires[ue] + "]", U = U + 1;
        x.options && x.options.creg && (M += ", " + x.options.creg.name + "[" + x.options.creg.bit + "]"), e && (M += ")"), M += `
`;
      }
    }
  if (r && (M += _ + `return circuit

`), !e)
    M += "END";
  else if (!r)
    if (M += _ + `
`, M += _ + `circuit = program.to_circ()
`, M += _ + `job = circuit.to_job(nbshots=shots, aggregate_data=False)
`, M += _ + `qpu = get_default_qpu()
`, M += _ + `job_result = qpu.submit(job)
`, M += _ + `counts = Counter()

`, M += _ + `for state in job_result:
`, M += _ + `    string_state = str(state.state)
`, M += _ + `    string_state = string_state[string_state.find('|') + 1: string_state.find('>')]
`, M += _ + `    string_state = string_state[::-1]
`, M += _ + `    counts[string_state] += 1

`, u) {
      M += _ + `# CALCULATE COST HERE
`;
      var ve = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
      if (ve.trim() || (ve = "cost = 0"), M += d(ve, _), M += `
`, M += _ + `return cost
`, n--, _ = g(n), u) {
        var he = "";
        this.params.map(function(we, Se) {
          Se > 0 && (he += ", "), he += we;
        }), M += `
`, M += "params = np.array([" + he + `])
`, M += `
`, M += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, M += `print("cost:", minimum.fun, "params:", minimum.x)
`;
      }
    } else
      M += _ + "print(counts)";
  if (o && e) {
    var Ne = {
      metadata: {
        kernelspec: {
          display_name: "Python 3",
          language: "python",
          name: "python3"
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: M,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(Ne);
  }
  return M;
};
ge.prototype.exportAQASM = function(t, e, r, n, a, s, o, p) {
  var u = {
    comment: t,
    decompose: e,
    asJupyter: a,
    shots: s,
    hybrid: o
  };
  return this.exportToAQASM(u, r, n, p);
};
ge.prototype.exportToPyAQASM = function(t, e) {
  return this.exportToAQASM(t, !0, e);
};
ge.prototype.exportPyAQASM = function(t, e, r, n, a, s) {
  var o = {
    comment: t,
    decompose: e,
    asJupyter: n,
    shots: a,
    hybrid: s
  };
  return this.exportToPyAQASM(o, r);
};
ge.prototype.exportToCirq = function(t, e) {
  t = t || {};
  var r = t.comment, n = t.decompose, a = t.versionStr, s = t.asJupyter, o = t.shots, p = t.exportTfq, u = this, f = "";
  p ? f = "TFQ" : f = "cirq";
  var l = parseFloat(a || "0.7");
  isNaN(l) && (l = 0.7), typeof o > "u" && (o = 1024);
  var c = new ge();
  c.load(this.save(n));
  var h = "", d = "";
  if (r) {
    var g = (r || "").split(`
`);
    g.map(function(he) {
      he.length >= 1 && he[0] != "#" && (h += "# "), h += he, h += `
`;
    });
  }
  var v = function(he, Ne) {
    if (he.isSymbolNode) {
      var we = ["pi", "sin", "cos", "tan", "asin", "acos", "atan"];
      if (we.indexOf(he.name) >= 0)
        return "np." + he.name;
    }
  };
  if (e) {
    for (var N = "", b = 0, C = 0; C < c.params.length; C++)
      b > 0 && (N += ", "), N += c.params[C], b++;
    for (var C = 0; C < c.numQubits; C++)
      b > 0 && (N += ", "), N += Cr(C, c.numQubits), b++;
    h += "def " + e + (N ? "(" + N + ")" : "") + `:
`, h += `    return [
`, d = "        ";
  } else {
    p && (h += `import tensorflow_quantum as tfq
`), h += `import cirq
`, h += `import numpy as np
`, h += `from functools import reduce
`, h += `
`;
    var x = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (var C = 0; C < this.params.length; C++) {
        var E = this.params[C], D = Et(x[E]), A = D.toString({ handler: v });
        h += E + " = " + A + `
`;
      }
      h += `
`;
    }
    var _ = c.usedGates();
    n || _.map(function(he) {
      var Ne = c.basicGates[he];
      if (!Ne) {
        var we = u.customGates[he];
        if (we) {
          var Se = new ge();
          Se.load(we);
          var V = {
            comment: "",
            decompose: !0,
            versionStr: a
          };
          h += Se.exportToCirq(V, e);
        }
      }
    });
    var M = "", _ = c.usedGates();
    _.map(function(he) {
      var Ne = c.basicGates[he];
      if (Ne && Ne.exportInfo && Ne.exportInfo.cirq) {
        var we = Ne.exportInfo.cirq, Se = !1;
        if (we.replacement) {
          var V = c.getGateDef(we.replacement.name);
          we = V.exportInfo.cirq, Se = !0;
        }
        if (we.array && !p) {
          var re = Se ? we.name : he;
          if (M.indexOf(re) < 0) {
            if (M += "def " + re + "(", we.params && we.params.map(function(pe, X) {
              X > 0 && (M += ", "), M += "p_" + pe;
            }), M += `):
`, Ne.matrix && Ne.matrix.length)
              if (l < 0.7)
                switch (Ne.matrix.length) {
                  case 2:
                    M += "    return cirq.SingleQubitMatrixGate(np.array(" + we.array + `))
`;
                    break;
                  case 4:
                    M += "    return cirq.TwoQubitMatrixGate(np.array(" + we.array + `))
`;
                    break;
                  default:
                    M += "    # Export to " + f + " WARNING: Cannot define " + Ne.matrix.length + " x " + Ne.matrix.length + ` matrix gate
`;
                }
              else
                M += "    return cirq.MatrixGate(np.array(" + we.array + `))
`;
            M += `
`;
          }
        }
      }
    }), h += M, p ? h += "q = cirq.GridQubit.rect(1, " + c.numQubits + `)
` : h += "q = [cirq.NamedQubit('q' + str(i)) for i in range(" + c.numQubits + `)]
`, h += `
`, l < 0.7 ? h += `circuit = cirq.Circuit.from_ops(
` : h += `circuit = cirq.Circuit(
`, d = "    ";
  }
  for (var O = c.numCols(), T = 0, I = "", q = !1, $ = 0; $ < O; $++)
    for (var U = 0; U < this.numQubits; U++) {
      var k = c.getGateAt($, U);
      if (k && k.connector == 0) {
        T > 0 && (h += ",", p && q && (h += d + "# Export to TFQ WARNING: Gate not yet supported by Tensorflow Quantum"), h += `
`);
        var L = c.getGateDef(k.name), R = k.options && k.options.params ? k.options.params : {}, G = null, P = !1, W = !!c.basicGates[k.name];
        if (L) {
          L.exportInfo && (q = !!L.exportInfo.cirq.notTfqSupported, L.exportInfo.cirq && L.exportInfo.cirq.replacement && (L.exportInfo.cirq.replacement.params && (R = L.exportInfo.cirq.replacement.params), P = !!(L.exportInfo.cirq.replacement.type && L.exportInfo.cirq.replacement.type == "controlled"), q = !!L.exportInfo.cirq.replacement.notTfqSupported, L = c.getGateDef(L.exportInfo.cirq.replacement.name)), G = L && L.exportInfo && L.exportInfo.cirq ? L.exportInfo.cirq : null), T++, k.options && k.options.condition && k.options.condition.creg && (h += d + "# Export to " + f + ` WARNING: classical control not implemented yet.
`);
          var le = 0, Z = "";
          if (R) {
            var H = L.params || [];
            k.name == "yy" && (H = []);
            var te = H.length;
            if (te)
              for (var be = 0; be < te; be++) {
                le == 0 && (Z += "("), le > 0 && (Z += ", ");
                var K = H[be];
                if (R[K]) {
                  var D = Et(R[K]);
                  if (!D.args)
                    for (var ce in k.options.params)
                      D = Et(k.options.params[ce]);
                  Z += D.toString({ handler: v });
                }
                le == te - 1 && (W ? Z += ")" : Z += ", "), le++;
              }
          }
          if (G) {
            var de = G.name.indexOf("**") >= 0;
            h += d, de && (h += "("), G.array || (h += "cirq."), p && G.tfqReplacement && G.tfqReplacement.name ? h += "cirq." + G.tfqReplacement.name : h += G.name, de && (h += ")");
          } else
            h += d + k.name;
          h += Z, P ? h += ".controlled().on(" : W && (h += "(");
          for (var b = 0, ue = 0; ue < k.wires.length; ue++)
            b > 0 && (h += ", "), e ? h += Cr(k.wires[ue], c.numQubits) : h += "q[" + k.wires[ue] + "]", b++;
          k.name == "measure" && k.options && k.options.creg && (b > 0 && (h += ", key="), h += "'" + k.options.creg.name + k.options.creg.bit + "'", $ == O - 1 && U == this.numQubits - 1 ? I += "'" + k.options.creg.name + k.options.creg.bit + "'" : I += "'" + k.options.creg.name + k.options.creg.bit + "', ", b++), h += ")";
        } else
          h += d + "# Export to " + f + ' WARNING: unknown gate "' + k.name + '".';
      }
    }
  if (p && q && (h += d + "# Export to TFQ WARNING: Gate not yet supported by Tensorflow Quantu"), e ? (h += `
    ]
`, h += `
`) : (h += `
)
`, h += `
`, p || (h += `simulator = cirq.Simulator()
`, h += "result = simulator.run(circuit, repetitions=" + o + `)
`, h += "result_dict = dict(result.multi_measurement_histogram(keys=[" + I + `]))
`, h += `keys = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1]), result_dict.keys()))
`, h += `counts = dict(zip(keys,[value for value in result_dict.values()]))
`, h += "print(counts)")), s) {
    var ve = {
      metadata: {
        kernelspec: {
          display_name: "Python 3",
          language: "python",
          name: "python3"
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: h,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(ve);
  }
  return h;
};
ge.prototype.exportToTFQ = function(t, e) {
  t = t || {};
  var r = t.comment, n = t.decompose, a = t.versionStr, s = t.asJupyter, o = t.shots;
  typeof o > "u" && (o = 1024);
  var p = new ge();
  p.load(this.save(n));
  var u = "";
  if (r) {
    var f = (r || "").split(`
`);
    f.map(function(h) {
      h.length >= 1 && h[0] != "#" && (cirq += "# "), cirq += h, cirq += `
`;
    });
  }
  var l = {
    comment: r,
    decompose: n,
    versionStr: a,
    asJupyter: !1,
    shots: o,
    exportTfq: !0
  };
  if (u += p.exportToCirq(l, e), u += "results_list = tfq.layers.Sample()(circuit, repetitions=" + o + `).to_list()[0]
`, u += `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1]), results_list))
`, u += `counts = dict(zip(results,[results.count(i) for i in results]))
`, u += "print(counts)", s) {
    var c = {
      metadata: {
        kernelspec: {
          display_name: "Python 3",
          language: "python",
          name: "python3"
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: u,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(c);
  }
  return u;
};
ge.prototype.exportToQSharp = function(t, e) {
  t = t || {}, t.comment;
  var r = t.decompose, n = t.versionStr, a = t.asJupyter, s = t.circuitName, o = t.indentDepth, p = this, u = function(Z, H) {
    if (Z.isSymbolNode) {
      var te = { pi: "PI()" };
      if (te[Z.name])
        return te[Z.name];
    }
    if (Z.isConstantNode && Number.isInteger(Z.value))
      return Z.value.toFixed(1);
  }, f = s || "Circuit";
  o = o || 0;
  function l(Z) {
    for (var H = "", te = 0; te < Z; te++)
      H += "    ";
    return H;
  }
  var c = new ge();
  c.load(this.save(r));
  var h = "", d = l(o);
  if (e || (a || (h += `namespace Quantum {
`, o++, d = l(o)), h += d + `open Microsoft.Quantum.Intrinsic;
`, h += d + `open Microsoft.Quantum.Canon;
`, h += d + `open Microsoft.Quantum.Math;
`, h += d + `open Microsoft.Quantum.Convert;
`, h += `
`, h += d + `function SetBitValue(reg: Int, bit: Int, value: Bool): Int {
`, h += d + `    if(value) {
`, h += d + `        return reg ||| (1 <<< bit);
`, h += d + `    } else {
`, h += d + `        return reg &&& ~~~(1 <<< bit);
`, h += d + `    }
`, h += d + `}
`, h += d + `
`), e) {
    for (var g = "", v = 0, N = 0; N < c.params.length; N++)
      v > 0 && (g += ", "), g += c.params[N], v++;
    for (var N = 0; N < c.numQubits; N++)
      v > 0 && (g += ", "), g += Cr(N, c.numQubits) + ": Qubit", v++;
    h += d + "operation " + e + (g ? "(" + g + ")" : "");
  } else {
    var x = c.usedGates();
    r || x.map(function(H) {
      var te = c.basicGates[H];
      if (!te) {
        var be = p.customGates[H];
        if (be) {
          var K = new ge();
          K.load(be);
          var ce = {
            comment: "",
            decompose: !0,
            versionStr: n,
            asJupyter: !1,
            circuitName: null,
            indentDepth: o
          };
          h += K.exportToQSharp(ce, e);
        }
      }
    }), h += d + "operation " + f + "()";
  }
  o++, d = l(o);
  var b = 0;
  for (cregName in c.cregs)
    b++;
  var C = "";
  if (b) {
    h += " : (";
    for (cregName in c.cregs)
      C && (h += ", ", C += ", "), h += "Int", C += cregName;
    h += ")";
  } else
    h += " : Unit";
  if (h += ` {
`, b)
    for (cregName in c.cregs)
      h += d + "mutable " + cregName + ` = 0;
`;
  qreg_name = "qubits", e || (h += d + "using(", h += qreg_name + " = Qubit[" + c.numQubits + "]", h += `) {
`, o++, d = l(o));
  for (var x = c.usedGates(), E = c.numCols(), D = 0; D < E; D++)
    for (var A = 0; A < c.numQubits; A++) {
      var M = c.getGateAt(D, A);
      if (M && M.connector == 0) {
        var _ = c.getGateDef(M.name);
        _ || (_ = c.customGates[M.name]);
        var O = M.options && M.options.params ? M.options.params : {}, T = null, I = !1, q = 0;
        if (_) {
          _.exportInfo && (_.exportInfo.qsharp && _.exportInfo.qsharp.replacement && (_.exportInfo.qsharp.replacement.params && (O = _.exportInfo.qsharp.replacement.params), _ = c.getGateDef(_.exportInfo.qsharp.replacement.name)), T = _ && _.exportInfo && _.exportInfo.qsharp ? _.exportInfo.qsharp : null), _.drawingInfo && _.drawingInfo.root && M.name != "cx" && M.name != "ccx" && (I = !0);
          var $ = 0, U = "";
          if (O) {
            var k = _.params || [], L = k.length;
            if (L)
              for (var R = 0; R < L; R++) {
                $ > 0 && (U += ", ");
                var G = k[R];
                if (O[G]) {
                  var P = Et(O[G]);
                  U += P.toString({ handler: u });
                }
                $++;
              }
          }
          if (M.name == "measure")
            M.options && M.options.creg ? (h += d + "set " + M.options.creg.name + " = SetBitValue(" + M.options.creg.name + ", " + M.options.creg.bit + ", ResultAsBool(M(", e ? h += Cr(M.wires[0], c.numQubits) + `)));
` : h += qreg_name + "[" + M.wires[0] + `])));
`) : h += d + `// Export to qsharp WARNING: missing destination register
`;
          else {
            h += d, M.options && M.options.condition && M.options.condition.creg && (h += "if(" + M.options.condition.creg + " == " + M.options.condition.value + `) {
`, o++, d = l(o), h += d), T ? h += T.name + "(" : h += M.name + "(", I ? (e ? h += "[" + Cr(M.wires[0], c.numQubits) + "], (" : h += "[" + qreg_name + "[" + M.wires[0] + "]], (", q = 1) : q = 0, U && (h += U + ", ");
            for (var v = 0, W = q; W < M.wires.length; W++)
              v > 0 && (h += ", "), e ? h += Cr(M.wires[W], c.numQubits) : h += qreg_name + "[" + M.wires[W] + "]", v++;
            I && (h += ")"), h += `);
`, M.options && M.options.condition && M.options.condition.creg && (o--, d = l(o), h += d + `}
`);
          }
        }
      }
    }
  if (e || (h += d + "ResetAll(" + qreg_name + `);
`, o--, d = l(o), h += d + `}
`), b && (h += d + "return (" + C + `);
`), o--, d = l(o), h += d + `}
`, e ? h += `
` : a || (h += `}
`), a) {
    var le = {
      metadata: {
        kernelspec: {
          display_name: "Q#",
          language: "qsharp",
          name: "iqsharp"
        },
        language_info: {
          name: ""
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: h,
          metadata: {},
          outputs: [],
          execution_count: null
        },
        {
          cell_type: "code",
          source: "%simulate " + f,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(le);
  }
  return h;
};
ge.prototype.exportToBraket = function(t, e) {
  t = t || {}, t.comment;
  var r = t.decompose, n = t.versionStr, a = t.asJupyter, s = t.shots, o = t.hybrid, p = t.indentDepth, u = this;
  s = s || 1024, typeof o > "u" && (o = this.options ? !!this.options.hybrid : !1);
  var f = new ge();
  f.load(this.save(r));
  var l = function(de, ue) {
    if (de.isSymbolNode) {
      var ve = ["pi", "sin", "cos", "tan", "asin", "acos", "atan"];
      if (ve.indexOf(de.name) >= 0)
        return "np." + de.name;
      if (u.params.indexOf(de.name) >= 0 && o)
        return "params[" + u.params.indexOf(de.name) + "]";
    }
  }, c = function(de, ue) {
    var ve = "", he = de.split(`
`), Ne = -1;
    he.map(function(V) {
      var re = V.search(/\S/);
      re >= 0 && (Ne < 0 || re < Ne) && (Ne = re);
    }), Ne < 0 && (Ne = 0);
    var we = "";
    if (Ne < ue.length)
      for (var Se = 0; Se < ue.length - Ne; Se++)
        we += " ";
    return he.map(function(V) {
      ve += we + V + `
`;
    }), ve;
  }, h = function(de) {
    for (var ue = "", ve = 0; ve < de; ve++)
      ue += "    ";
    return ue;
  };
  p = p || 0;
  var d = "", g = h(p), v = f.usedGates();
  v.map(function(de) {
    f.basicGates[de];
  });
  var N = "", b = 0;
  if (e) {
    for (var C = 0; C < f.numQubits; C++)
      b > 0 && (N += ", "), N += Cr(C, f.numQubits), b++;
    for (var C = 0; C < f.params.length; C++)
      b > 0 && (N += ", "), N += f.params[C], b++;
  } else {
    d += g + `import numpy as np
`, d += g + `from braket.devices import LocalSimulator
`, d += g + `from braket.circuits import Circuit
`, d += g + `from collections import Counter
`, o && (d += g + `from scipy.optimize import minimize
`), d += `
`, s && (d += g + "shots = " + s + `
`, d += `
`);
    var x = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (var C = 0; C < this.params.length; C++) {
        var E = this.params[C], D = Et(x[E]), A = D.toString({ handler: l });
        d += E + " = " + A + `
`;
      }
      d += `
`;
    }
    o && (d += g + "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, d += `
`);
  }
  var M = null, _ = null, O = 0;
  v.map(function(de) {
    var ue = f.basicGates[de];
    if (ue) {
      if (!r && f.basicGates[de].exportInfo.braket && f.basicGates[de].exportInfo.braket.array) {
        if (M = f.basicGates[de].exportInfo.braket, M.name == "unitary" && (_ = de + "_unitary", d += g + "def " + _ + "("), M.params && M.params.length) {
          var ve = 0;
          M.params.map(function(we) {
            ve > 0 && (d += ", "), d += g + "p_" + we, ve++;
          });
        }
        d += `):
`, d += h(p + 1) + "return np.array(" + M.array + `);

`;
      }
    } else {
      var he = u.customGates[de];
      if (he) {
        var Ne = new ge();
        Ne.load(he), d += Ne.exportBraket("", !0, de, n, !1, null, !1, p), O++;
      }
    }
  }), e ? (d += "def " + e + (N ? "(" + N + ")" : "") + `:
`, p++, g = h(p)) : o && (d += `def objective_function(params):
`, p++, g = h(p)), d += g + `circuit = Circuit()
`, e || O && (d += `
`, v.map(function(de) {
    !f.basicGates[de] && f.customGates[de] && (d += g + "circuit.register_subroutine(" + de + `)
`);
  }), d += `
`);
  for (var T = f.numCols(), I = 0; I < T; I++)
    for (var q = 0; q < f.numQubits; q++) {
      var $ = f.getGateAt(I, q);
      if ($ && $.connector == 0) {
        var U = f.getGateDef($.name), k = $.options && $.options.params ? $.options.params : {}, L = U.params || [], R = null, G = $.name, P = "", W = !1;
        if (U && U.exportInfo && U.exportInfo.braket && (R = U.exportInfo.braket, R.params && (Array.isArray(R.params) ? L = R.params : (k = R.params, L = Object.keys(k))), R.name == "unitary" ? W = !0 : G = R.name), !R && !f.customGates[$.name])
          d += g + '# Unsupported gate "' + $.name + `".
`;
        else {
          var le = 0;
          if (k) {
            var Z = L.length;
            if (Z)
              for (var H = 0; H < Z; H++) {
                le > 0 && (P += ", ");
                var te = L[H];
                if (typeof k[te] < "u") {
                  var D = Et(k[te]);
                  P += D.toString({ handler: l });
                }
                le++;
              }
          }
          d += g + "circuit.", W ? d += "unitary(matrix=" + G + "_unitary(" + P + "), targets=[" : d += G + "(";
          var b = 0;
          for (w = 0; w < $.wires.length; w++)
            b > 0 && (d += ", "), e ? d += Cr($.wires[w], f.numQubits) : d += $.wires[w], b++;
          W ? d += "]" : P && (d += ", ", d += P), d += ")", d += `
`;
        }
      }
    }
  if (e && (d += g + "return circuit"), d += `

`, !e)
    if (d += g + `local_sim = LocalSimulator()
`, d += g + `result = local_sim.run(circuit, shots=shots).result()
`, d += g + `counts = Counter({ "".join(reversed(k)): v for k, v in result.measurement_counts.items() })
`, d += `
`, o) {
      d += g + `# CALCULATE COST HERE
`;
      var be = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
      if (be.trim() || (be = "cost = 0"), d += c(be, g), d += `
`, d += g + `return cost
`, p--, g = h(p), o) {
        var K = "";
        this.params.map(function(de, ue) {
          ue > 0 && (K += ", "), K += de;
        }), d += `
`, d += "params = np.array([" + K + `])
`, d += `
`, d += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, d += `print("cost:", minimum.fun, "params:", minimum.x)
`;
      }
    } else
      d += g + "print(counts)";
  if (a) {
    var ce = {
      metadata: {
        kernelspec: {
          display_name: "Python 3",
          language: "python",
          name: "python3"
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: d,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(ce);
  }
  return d;
};
ge.prototype.exportToQobj = function(t, e) {
  t = t || {};
  var r = t.circuitName, n = t.experimentName, a = t.numShots, s = this, o = this.options && this.options.params ? this.options.params : {}, o = JSON.parse(JSON.stringify(o));
  for (var p in o)
    o[p] = Br(o[p]);
  r = r || "", n = n || "", a = a || 1;
  var u = new ge();
  u.load(this.save(!0));
  var f = this.randomString(), l = { qobj_id: "qobj_" + f, type: "QASM", schema_version: "1.0", experiments: [], header: { description: r }, config: { shots: a, memory_slots: 0 } }, c = { header: { memory_slots: 0, n_qubits: 0, qreg_sizes: [], qubit_labels: [], creg_sizes: [], clbit_labels: [], name: "circuit0" }, config: { n_qubits: 0, memory_slots: 0 }, instructions: [] }, h = Object.keys(u.cregs), d = function(K, ce) {
    if (K.isSymbolNode) {
      var de = K.name;
      if (ce.replaceVars && typeof ce.replaceVars[de] < "u") {
        var de = ce.replaceVars[de];
        return s.params.indexOf(de) >= 0 ? "(" + o[de] + ")" : "(" + de + ")";
      }
      if (s.params.indexOf(K.name) >= 0)
        return o[K.name];
    }
  };
  if (!e) {
    n && (c.header.description = n);
    for (cregName in u.cregs) {
      var g = u.cregs[cregName].length;
      l.config.memory_slots += g, c.header.creg_sizes.push([cregName, g]);
      for (var v = 0; v < g; v++)
        c.header.clbit_labels.push([cregName, v]);
    }
    c.header.memory_slots = l.config.memory_slots, c.header.n_qubits = u.numQubits, c.config.memory_slots = l.config.memory_slots, c.config.n_qubits = u.numQubits, c.header.qreg_sizes.push(["q", u.numQubits]);
  }
  var N = l.config.memory_slots, b = u.usedGates();
  b.map(function(K) {
    var ce = u.basicGates[K];
    if (!ce) {
      var de = s.customGates[K];
      if (de) {
        customCircuit = new ge(), customCircuit.load(de);
        var ue = {
          circuitName: r,
          experimentName: n,
          numShots: a
        };
        l += customCircuit.exportToQobj(ue, !1);
      }
    }
  });
  for (var C = u.numCols(), x = 0; x < C; x++)
    for (var E = 0; E < u.numQubits; E++) {
      var D = u.getGateAt(x, E), A = { name: "", qubits: [] }, M = null, _ = null;
      if (x == 0 && c.header.qubit_labels.push(["q", E]), D && D.connector == 0) {
        var O = u.getGateDef(D.name);
        if (O && O.exportInfo && (O.exportInfo.qasm && O.exportInfo.qasm.replacement ? (M = O.exportInfo.qasm.replacement, M.map(function(K) {
          var ce = new ge();
          if (ce.cregs = JSON.parse(JSON.stringify(s.cregs)), D.options && D.options.params) {
            var de = Object.keys(D.options.params), ue = Object.keys(K.params);
            de.map(function(Ne) {
              ue.indexOf(Ne) > -1 && (K.params[Ne] = D.options.params[Ne]);
            });
          }
          var ve = D.options && D.options.condition ? D.options.condition : {};
          ce.addGate(K.name, x, D.wires, { params: K.params, condition: ve });
          var he = {
            circuitName: "",
            experimentName: "",
            numShots: ""
          };
          c.instructions = c.instructions.concat(ce.exportToQobj(he, !0));
        })) : O.exportInfo.qasm && O.exportInfo.qasm.equivalent && (_ = O.exportInfo.qasm.equivalent, _.map(function(K) {
          var ce = new ge();
          ce.cregs = JSON.parse(JSON.stringify(s.cregs));
          var de = K.wires.length > 1 ? D.wires : D.wires[K.wires[0]], ue = {};
          if (K.params) {
            var ve = {};
            if (D.options && D.options.params)
              for (var he in D.options.params) {
                var Ne = Et(D.options.params[he]), we = Ne.toString({ handler: d });
                ve[he] = we;
              }
            for (var Se in K.params) {
              var Ne = Et(K.params[Se]), we = Ne.toString({ handler: d, replaceVars: ve });
              ue[Se] = we;
            }
          }
          var V = D.options && D.options.condition ? D.options.condition : {};
          ce.addGate(K.name, x, de, { params: ue, condition: V });
          var re = {
            circuitName: "",
            experimentName: "",
            numShots: ""
          };
          c.instructions = c.instructions.concat(ce.exportToQobj(re, !0));
        }))), !M && !_) {
          var T = D.name, I = D.options && D.options.params ? D.options.params : {};
          if (this.basicGates[T]) {
            switch (T) {
              case "id":
                T = "iden";
                break;
            }
            if (A.name = T, A.qubits = D.wires, D.options && D.options.condition && D.options.condition.creg) {
              for (var q = { name: "", register: N, relation: "==", mask: "", val: "" }, $ = u.cregs[D.options.condition.creg].length, U = 0, k = 0, L = "", R = "", G = h.indexOf(D.options.condition.creg), v = 0; v < G; v++)
                U += u.cregs[h[v]].length;
              var P = D.options.condition.value % Math.pow(2, $) * Math.pow(2, U);
              if (R = "0x" + P.toString(16).toUpperCase(), U > 0) {
                for (var W = Math.pow(2, U), le = 0; le < $; le++)
                  k += W, W *= 2;
                L = "0x" + k.toString(16).toUpperCase();
              } else
                L = "0x" + (Math.pow(2, $) - 1).toString(16).toUpperCase();
              q.name = "bfunc", A.conditional = N, q.mask = L, q.val = R, c.instructions.push(q), N += 1;
            }
            if (T == "measure" && D.options && D.options.creg) {
              A.memory = [], A.register = [];
              for (var Z = 0, G = h.indexOf(D.options.creg.name), v = 0; v < G; v++)
                Z += u.cregs[h[v]].length;
              var H = Z + D.options.creg.bit;
              A.memory.push(H), A.register.push(H);
            }
            if (I && (O = this.basicGates[T], O || (O = this.customGates[T]), O && (paramDef = O.params || [], paramCount = paramDef.length, paramCount))) {
              A.params = [];
              for (var te = 0; te < paramCount; te++)
                if (paramName = paramDef[te], I[paramName] || I[paramName].toString()) {
                  var be = Br(I[paramName], o);
                  A.params.push(be);
                }
            }
            c.instructions.push(A);
          }
        }
      }
    }
  return e ? c.instructions : (c.instructions.length && l.experiments.push(c), l);
};
ge.prototype.clearPartitions = function() {
  this.partitionMap = [], this.partitionCount = 0, this.partitionInfo = {};
  for (var t = this.numCols(), e = 0; e < this.numQubits; e++) {
    this.partitionMap.push([]);
    for (var r = 0; r < t; r++)
      this.partitionMap[e].push(-1);
  }
};
ge.prototype.createPartitions = function() {
  this.clearPartitions();
  for (var t = [], e = 0; e < this.numQubits; e++)
    t.push(-1);
  for (var r = 0, n = this.numCols(), a = 0; a < n; a++) {
    for (var s = 0; s < this.numQubits; s++) {
      var o = this.getGateAt(a, s);
      if (o && o.wires) {
        for (var p = [], u = 0; u < o.wires.length; u++) {
          var f = o.wires[u], l = t[f];
          p.indexOf(l) < 0 && p.push(l);
        }
        var c = -1;
        p.length != 1 || p[0] == -1 ? c = r++ : c = p[0];
        for (var u = 0; u < o.wires.length; u++) {
          var f = o.wires[u];
          if (oldPartition = t[f], oldPartition == -1)
            t[f] = c;
          else
            for (var e = 0; e < this.numQubits; e++)
              t[e] == oldPartition && (t[e] = c);
        }
      }
    }
    for (var s = 0; s < this.numQubits; s++)
      this.partitionMap[s][a] = t[s];
  }
  this.partitionCount = r;
  for (var c = 0; c < r; c++)
    this.partitionInfo[c] = this.partitionBounds(c);
};
ge.prototype.printPartitions = function() {
  for (var t = this.numCols(), e = 0; e < this.numQubits; e++) {
    for (var r = "", n = 0; n < t; n++) {
      var a = this.partitionMap[e][n];
      for (a == -1 && (a = " "), this.getGateAt(n, e) ? a = a + "*" : a = a + " "; a.length < 4; )
        a = " " + a;
      r += a;
    }
    for (var s = e + ""; s.length < 2; )
      s = "0" + s;
    r = "q" + s + r, console.log(r);
  }
};
ge.prototype.partitionBounds = function(t) {
  for (var e = {
    wire: {
      top: -1,
      bottom: -1
    },
    column: {
      left: -1,
      right: -1
    },
    wireMap: {},
    parents: {}
  }, r = !1, n = this.numCols(), a = 0; a < n; a++)
    for (var s = 0; s < this.numQubits; s++) {
      var o = this.partitionMap[s][a];
      o == t && (r = !0, e.wire.top < 0 && (e.wire.top = s), e.wire.bottom < s && (e.wire.bottom = s), e.column.left < 0 && (e.column.left = a), e.column.right < a && (e.column.right = a));
    }
  if (!r)
    return null;
  for (var p = 0, s = e.wire.top; s <= e.wire.bottom; s++) {
    var o = this.partitionMap[s][e.column.left];
    o == t && (e.wireMap[s] = p, p++);
  }
  if (e.numQubits = p, e.column.left > 0)
    for (var s in e.wireMap) {
      var u = this.partitionMap[s][e.column.left - 1];
      if (u >= 0) {
        e.parents[u] || (e.parents[u] = {}, e.parents[u].links = []);
        var f = this.partitionInfo[u];
        for (var l in f.wireMap)
          l == s && e.parents[u].links.push(e.wireMap[s]);
      }
    }
  return e;
};
ge.prototype.partitionCircuit = function(t) {
  var e = this.partitionInfo[t];
  if (!e)
    return null;
  var r = [], n = [];
  for (var a in e.parents) {
    var s = {};
    s.circuit = this.partitionCache[a], s.wires = [], s.wires = e.parents[a].links, n = n.concat(s.wires), r.push(s);
  }
  var o = new ge();
  if (r.length > 0) {
    if (e.numQubits > n.length) {
      var s = {};
      s.circuit = new ge(e.numQubits - n.length), s.wires = [];
      for (var p = 0; p < e.numQubits; p++)
        n.indexOf(p) < 0 && s.wires.push(p);
      r.push(s);
    }
    o.setCombinedState(r);
  }
  for (var u = e.column.left; u <= e.column.right; u++)
    for (var f = e.wire.top; f <= e.wire.bottom; f++) {
      var l = this.partitionMap[f][u];
      if (l == t) {
        var c = this.getGateAt(u, f);
        if (c && c.connector == 0) {
          for (var h = [], d = 0; d < c.wires.length; d++) {
            var g = c.wires[d];
            h.push(e.wireMap[g]);
          }
          o.addGate(c.name, u - e.column.left, h, c.options);
        }
      }
    }
  return o;
};
ge.prototype.run = function(t, e) {
  if (e = e || {}, this.measureResetsQubit = !!e.strictMode, e.continue || (this.initState(), this.stats.duration = 0), e.initialState) {
    if (Array.isArray(e.initialState)) {
      this.state = {};
      for (var r = 0; r < e.initialState.length; r++) {
        var n = e.initialState[r];
        Array.isArray(n) && n.length == 2 && (n = Wt(n[0], n[1])), typeof n == "string" && (n = this.evalMathString(n)), typeof n == "number" && (n = Wt(n, 0)), this.state[r + ""] = n;
      }
    } else
      this.state = e.initialState;
    this.stateBits = 0;
    for (var a in this.state)
      this.stateBits |= parseInt(a);
  }
  this.stats.start = /* @__PURE__ */ new Date();
  var s = new ge();
  if (s.load(this.save(!0)), t) {
    s.insertColumn(0);
    for (var o = 0; o < s.numQubits; o++)
      t[o] && s.addGate("x", 0, o, {});
  }
  var p = e.partitioning;
  p && s.createPartitions();
  for (var u = s.numCols(), f = 0, l = 0; l < u; l++) {
    for (var o = 0; o < s.numQubits; o++) {
      var c = s.getGateAt(l, o);
      if (c && c.connector == 0) {
        f++;
        var h = !0;
        if (c.options && c.options.condition && c.options.condition.creg) {
          var d = this.getCregValue(c.options.condition.creg);
          h = d === c.options.condition.value;
        }
        if (h)
          if (p) {
            var g = s.partitionMap[o][l];
            s.partitionCache[g] || (s.partitionCache[g] = s.partitionCircuit(g));
            var v = s.partitionCache[g], N = s.partitionInfo[g], b = l - N.column.left, C = v.getGateAt(b, N.wireMap[o]);
            v.cregs = JSON.parse(JSON.stringify(this.cregs)), v.applyGate(C.name, b, C.wires, C.options), this.cregs = JSON.parse(JSON.stringify(v.cregs));
          } else
            this.applyGate(c.name, l, c.wires, c.options);
        e && e.onGate && e.onGate(l, o, f);
      }
    }
    e && e.onColumn && e.onColumn(l);
  }
  if (p) {
    for (var x = [], o = 0; o < s.numQubits; o++) {
      var g = s.partitionMap[o][u - 1];
      g >= 0 && x.indexOf(g) < 0 && x.push(g);
    }
    if (x.length)
      if (x.length == 1)
        this.state = s.partitionCache[x[0]].state, this.stateBits = s.partitionCache[x[0]].stateBits;
      else {
        for (var E = this.stats.start, D = [], A = 0; A < x.length; A++) {
          var M = x[A], _ = {};
          _.circuit = s.partitionCache[M], _.wires = [];
          var O = s.partitionInfo[M];
          for (var o in O.wireMap)
            _.wires.push(parseInt(o));
          D.push(_);
        }
        this.setCombinedState(D), this.stats.start = E;
      }
  }
  this.stats.end = /* @__PURE__ */ new Date(), this.stats.duration += this.stats.end - this.stats.start;
};
ge.prototype.continue = function() {
  this.run(null, {
    continue: !0
  });
};
ge.prototype.stateAsArray = function(t, e, r, n) {
  var a = [], s = this.numAmplitudes();
  e = e || 0, r = r || (t ? this.numAmplitudes(t) : s);
  for (var o = 0, p = 0; p < s; p++) {
    var u = p;
    n && (u = _S(p, this.numQubits));
    var f = kt(this.state[u] || Wt(0, 0), 14);
    if (!t || f.re || f.im) {
      if (o >= e) {
        for (var l = p.toString(2); l.length < this.numQubits; )
          l = "0" + l;
        var c = this.formatComplex(f, { fixedWidth: !0, decimalPlaces: 8, iotaChar: "i" }), h = _t($t(f), 2), d = h * 100, g = d.toFixed(5), v = Rs(f), N = v.toFixed(5);
        a.push({
          index: p,
          indexBinStr: l,
          amplitude: f,
          amplitudeStr: c,
          magnitude: h,
          chance: d,
          chanceStr: g,
          phase: v,
          phaseStr: N
        });
      }
      if (o++, a.length == r)
        return a;
    }
  }
  return a;
};
ge.prototype.stateAsSimpleArray = function(t) {
  var e = this.numAmplitudes();
  if (!this.state)
    return [];
  for (var r = [], n = 0; n < e; n++) {
    var a = n;
    t && (a = _S(n, this.numQubits)), r.push(kt(this.state[a] || Wt(0, 0), 14));
  }
  return r;
};
ge.prototype.stateAsString = function(t) {
  var e = this.numAmplitudes();
  if (!this.state)
    return "Error: circuit is not initialized. Please call initState() or run() method.";
  for (var r = "", n = 0; n < e; n++) {
    var a = kt(this.state[n] || Wt(0, 0), 14);
    if (!t || a.re || a.im) {
      for (var s = _t($t(a), 2) * 100, o = n.toString(2); o.length < this.numQubits; )
        o = "0" + o;
      for (var p = s.toFixed(5); p.length < 9; )
        p = " " + p;
      r += this.formatComplex(a, { fixedWidth: !0, decimalPlaces: 8, iotaChar: "i" }) + "|" + o + ">	" + p + `%
`;
    }
  }
  return r;
};
ge.prototype.print = function(t) {
  console.log(this.stateAsString(t));
};
ge.prototype.gotClassicalControl = function() {
  for (var t = 0; t < this.numCols(); t++)
    for (var e = 0; e < this.numQubits; e++) {
      var r = this.getGateAt(t, e);
      if (r && r.connector == 0 && r.options && r.options.condition && r.options.condition.creg)
        return !0;
    }
  return !1;
};
ge.prototype.gotMeasurement = function() {
  for (var t = 0; t < this.numCols(); t++)
    for (var e = 0; e < this.numQubits; e++) {
      var r = this.getGateAt(t, e);
      if (r && r.connector == 0 && r.name == "measure")
        return !0;
    }
  return !1;
};
ge.prototype.cregCount = function() {
  var t = 0;
  for (var e in this.cregs)
    t++;
  return t;
};
ge.prototype.getCregs = function() {
  var t = {};
  for (var e in this.cregs)
    t[e] = this.getCregValue(e);
  return t;
};
ge.prototype.cregsAsString = function() {
  var t = `reg	bin	dec
`;
  for (var e in this.cregs) {
    for (var r = this.getCregValue(e), n = r.toString(2), a = this.cregs[e] && this.cregs[e].length || 1; n.length < a; )
      n = "0" + n;
    t += e + "	" + n + "	" + r + `
`;
  }
  return t;
};
ge.prototype.createCreg = function(t, e) {
  for (this.cregs[t] = []; this.cregs[t].length < (e || 1); )
    this.cregs[t].push(0);
};
ge.prototype.removeCreg = function(t) {
  for (var e = this.numCols(), r = [], n = 0; n < e; n++)
    for (var a = 0; a < this.numQubits; a++) {
      var s = this.gates[a][n];
      s && s.options && (s.options.creg && s.options.creg.name && s.options.creg.name == t && r.indexOf(s.id) < 0 && r.push(s.id), s.options.condition && s.options.condition.creg && s.options.condition.creg == t && delete s.options.condition);
    }
  delete this.cregs[t];
  for (var o = 0; o < r.length; o++)
    this.removeGate(r[o]);
};
ge.prototype.renameCreg = function(t, e) {
  for (var r = this.numCols(), n = 0; n < r; n++)
    for (var a = 0; a < this.numQubits; a++) {
      var s = this.gates[a][n];
      s && s.options && (s.options.creg && s.options.creg.name && s.options.creg.name == t && (s.options.creg.name = e), s.options.condition && s.options.condition.creg && s.options.condition.creg == t && (s.options.condition.creg = e));
    }
  this.cregs[e] = JSON.parse(JSON.stringify(this.cregs[t])), delete this.cregs[t];
};
ge.prototype.minCregSize = function(t) {
  for (var e = 0, r = this.numCols(), n = 0; n < r; n++)
    for (var a = 0; a < this.numQubits; a++) {
      var s = this.gates[a][n];
      if (s && s.options) {
        if (s.options.creg && s.options.creg.name && s.options.creg.name == t) {
          var o = parseInt(s.options.creg.bit || 0);
          isNaN(o) && (o = 0), o > e && (e = o);
        }
        if (s.options.condition && s.options.condition.creg && s.options.condition.creg == t) {
          var p = Math.floor(Math.log2(s.options.condition.value));
          p > e && (e = p);
        }
      }
    }
  return e + 1;
};
ge.prototype.resizeCreg = function(t, e) {
  if (!(e < this.minCregSize(t))) {
    for (; this.cregs[t].length < e; )
      this.cregs[t].push(0);
    for (; this.cregs[t].length > e; )
      this.cregs[t].pop();
  }
};
ge.prototype.getCreg = function(t) {
  return this.cregs[t];
};
ge.prototype.setCregBit = function(t, e, r) {
  var n = parseInt(e);
  if (isNaN(n))
    throw 'Error: invalid "cbit" argument to "setCregBit" method: expected "integer" got "' + typeof e + '".';
  for (this.cregs[t] || (this.cregs[t] = []); n >= this.cregs[t].length; )
    this.cregs[t].push(0);
  this.cregs[t][n] = r ? 1 : 0;
};
ge.prototype.getCregBit = function(t, e) {
  if (!this.cregs[t])
    throw 'Error: "getCregBit": unknown register "' + t + '".';
  var r = parseInt(e);
  if (isNaN(r) || r >= this.cregs[t].length)
    throw 'Error: "getCregBit": bit "' + e + '" not found.';
  return this.cregs[t][r];
};
ge.prototype.cregBase = function(t) {
  if (!this.cregs[t])
    throw 'Error: "getCregBit": unknown register "' + t + '".';
  var e = 0;
  for (var r in this.cregs) {
    if (r == t)
      return e;
    e += this.cregs[r].length;
  }
};
ge.prototype.cregTotalBits = function() {
  var t = 0;
  for (var e in this.cregs)
    t += this.cregs[e].length;
  return t;
};
ge.prototype.getCregValue = function(t) {
  if (!this.cregs[t])
    throw 'Error: "getCregBit": unknown register "' + t + '".';
  for (var e = this.cregs[t].length, r = 0, n = 0; n < e; n++)
    this.cregs[t][n] && (r += _t(2, n));
  return r;
};
ge.prototype.measureAll = function(t) {
  if (this.collapsed && this.collapsed.length == this.numQubits && !t)
    return this.collapsed;
  this.collapsed = [];
  var e = Math.random();
  for (var r in this.state) {
    var n = kt(this.state[r], 14);
    if (n.re || n.im) {
      var a = kt(_t($t(n), 2), 14);
      if (e -= a, e <= 0) {
        var s = parseInt(r);
        if (this.reverseBitOrder)
          for (var o = this.numQubits - 1; o >= 0; o--)
            this.collapsed.push(1 << o & s ? 1 : 0);
        else
          for (var o = 0; o < this.numQubits; o++)
            this.collapsed.push(1 << o & s ? 1 : 0);
        return this.collapsed;
      }
    }
  }
  if (!this.collapsed.length)
    for (; this.collapsed.length < this.numQubits; )
      this.collapsed.push(0);
  return this.collapsed;
};
ge.prototype.measureAllMultishot = function(t) {
  t = t || 1;
  for (var e = {}, r = [], n = 0; n < t; n++)
    r.push(Math.random());
  var a = 0;
  do
    for (var s in this.state) {
      var o = kt(this.state[s], 14);
      if (o.re || o.im) {
        for (var p = kt(_t($t(o), 2), 14), u = 0; u < t; u++)
          if (r[u] > 0 && (r[u] -= p, r[u] <= 0)) {
            for (var f = parseInt(s).toString(2); f.length < this.numQubits; )
              f = "0" + f;
            if (e[f] ? e[f]++ : e[f] = 1, a++, a == t)
              return e;
          }
      }
    }
  while (a < t);
};
ge.prototype.measure = function(t, e, r, n) {
  (n || !this.collapsed || this.collapsed.length != this.numQubits) && this.measureAll(n);
  var a = this.collapsed[t];
  return e && typeof r < "u" && this.setCregBit(e, r, a), a;
};
ge.prototype.probabilities = function() {
  this.prob = [];
  for (var t = 0; t < this.numQubits; t++)
    this.prob.push(0);
  for (var e in this.state)
    for (var r = parseInt(e), t = 0; t < this.numQubits; t++) {
      var n = null;
      if (this.reverseBitOrder ? n = _t(2, this.numQubits - 1 - t) : n = _t(2, t), r & n) {
        var a = this.state[e];
        (a.re || a.im) && (this.prob[t] += _t($t(a), 2));
      }
    }
  for (var t = 0; t < this.numQubits; t++)
    this.prob[t] = kt(this.prob[t], 14);
  return this.prob;
};
ge.prototype.probability = function(t) {
  return (!this.prob || this.prob.length != this.numQubits) && this.probabilities(), this.prob[t];
};
ge.prototype.densityMatrix = function() {
  var t = [], e = this.numAmplitudes();
  for (row = 0; row < e; row++) {
    for (var r = [], n = this.state[row] || Wt(0, 0), a = 0; a < e; a++) {
      var s = this.state[a] || Wt(0, 0);
      (s.re || s.im) && (s = Yn(s)), r.push(it(n, s));
    }
    t.push(r);
  }
  return t;
};
ge.prototype.partialTrace = function(t) {
  function e(l, c, h) {
    var v = l << 1, d = (2 << c) - 1, g = 1 << c, v = v ^ (v ^ l) & d | g;
    return h || (v = v ^ g), v;
  }
  var r = [], n = this.numQubits - 1, a = _t(2, n), s = null;
  this.reverseBitOrder ? s = this.numQubits - 1 - t : s = t;
  for (var o = 0; o < 4; o++) {
    r.push(Wt(0, 0));
    for (var p = a; p--; ) {
      var u = e(p, s, o & 2 ? 1 : 0);
      if (this.state[u]) {
        var f = e(p, s, o & 1 ? 1 : 0);
        this.state[f] && (r[o] = ut(r[o], it(this.state[u], Yn(this.state[f]))));
      }
    }
  }
  return [
    [r[0], r[1]],
    [r[2], r[3]]
  ];
};
ge.prototype.angles = function() {
  for (var t = [], e = 0; e < this.numQubits; e++)
    t.push({ theta: 0, phi: 0 });
  for (var e = 0; e < this.numQubits; e++) {
    var r = this.partialTrace(e), n = kt(dr(r[0][0]), 12), a = kt(it(r[1][0], dr(2)), 12), s = kt($t(dr(2 * $t(mv(_t(r, 2))) - 1)), 12), o = it(2, Zd(n)), p = 0;
    kt(a.re, 8) == 0 && kt(a.im, 8) == 0 || (p = it(Wt(0, -1), vo(it(a, Yd(ur(o, 2))))).re, isNaN(p) && (p = 0)), t[e].theta = kt($t(o), 12), t[e].phi = kt(p, 12), t[e].thetaDeg = kt(it($t(o), 180 / Oi), 7), t[e].phiDeg = kt(it(p, 180 / Oi), 7), t[e].radius = kt(s, 7);
  }
  return t;
};
ge.prototype.randomCircuit = function(t, e, r) {
  this.init(t), r = r || {};
  var n = r.useGates && r.useGates.length ? r.useGates : Object.keys(this.basicGates);
  r.noMeasure && n.indexOf("measure") >= 0 && n.splice(n.indexOf("measure"), 1), r.noReset && n.indexOf("reset") >= 0 && n.splice(n.indexOf("reset"), 1);
  for (var a = 0; a < e; ) {
    var s = n[Math.floor(Math.random() * n.length)], o = this.basicGates[s];
    if (o) {
      var p = o.matrix && o.matrix.length ? vi(o.matrix.length) : 1;
      if (p <= t) {
        for (var u = []; u.length < p; ) {
          var f = -1;
          do
            f = Math.floor(Math.random() * t);
          while (u.indexOf(f) >= 0);
          u.push(f);
        }
        var l = {};
        if (o.params && o.params.length) {
          var c = {};
          o.params.map(function(d) {
            c[d] = Math.PI * 2 * Math.random(), c[d] > Math.PI && (c[d] = Math.PI - c[d]);
          }), l.params = c;
        }
        if (s == "measure")
          l.creg = {
            name: "c",
            bit: u[0]
          };
        else if (!r.noClassicControl && Math.floor(Math.random() * 4) == 0) {
          var h = this.cregTotalBits();
          h && (l.condition = {
            creg: "c",
            value: Math.floor(Math.random() * _t(2, h))
          });
        }
        this.appendGate(s, u, l), a++;
      }
    }
  }
};
ge.prototype.randomUnitary = function(t) {
  var e = new ge();
  return e.randomCircuit(t || 1, (t || 1) * 8, {
    useGates: ["rx", "rz", "cz"],
    noMeasure: !0,
    noReset: !0,
    noClassicControl: !0
  }), e.circuitMatrix();
};
ge.prototype.eulerAnglesZYZ = function(t) {
  var e = { theta: null, phi: null, lambda: null, phase: null }, r = _t(lm(t), -0.5);
  e.phase = -1 * Wt(r).toPolar().phi;
  var n = it(r, t);
  e.theta = 2 * ov($t(n[1][0]), $t(n[0][0]));
  var a = 2 * Wt(n[1][1]).toPolar().phi, s = 2 * Wt(n[1][0]).toPolar().phi;
  return e.phi = (a + s) / 2, e.lambda = (a - s) / 2, e;
};
export {
  ge as QuantumCircuit
};

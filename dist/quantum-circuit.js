function nr() {
  return nr = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, nr.apply(null, arguments);
}
var gu = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  relTol: 1e-12,
  // minimum absolute difference between two compared values,
  // used by all comparison functions
  absTol: 1e-15,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', 'bigint', or 'Fraction'
  number: "number",
  // type of fallback used for config { number: 'bigint' } when a value cannot be represented
  // in the configured numeric type. Choose 'number' (default) or 'BigNumber'.
  numberFallback: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: !1,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null
};
function ot(t) {
  return typeof t == "number";
}
function at(t) {
  return !t || typeof t != "object" || typeof t.constructor != "function" ? !1 : t.isBigNumber === !0 && typeof t.constructor.prototype == "object" && t.constructor.prototype.isBigNumber === !0 || typeof t.constructor.isDecimal == "function" && t.constructor.isDecimal(t) === !0;
}
function ud(t) {
  return typeof t == "bigint";
}
function dn(t) {
  return t && typeof t == "object" && Object.getPrototypeOf(t).isComplex === !0 || !1;
}
function xi(t) {
  return t && typeof t == "object" && Object.getPrototypeOf(t).isFraction === !0 || !1;
}
function Lr(t) {
  return t && t.constructor.prototype.isUnit === !0 || !1;
}
function hr(t) {
  return typeof t == "string";
}
var _t = Array.isArray;
function Ye(t) {
  return t && t.constructor.prototype.isMatrix === !0 || !1;
}
function Yr(t) {
  return Array.isArray(t) || Ye(t);
}
function Ca(t) {
  return t && t.isDenseMatrix && t.constructor.prototype.isMatrix === !0 || !1;
}
function jn(t) {
  return t && t.isSparseMatrix && t.constructor.prototype.isMatrix === !0 || !1;
}
function Ms(t) {
  return t && t.constructor.prototype.isRange === !0 || !1;
}
function Ba(t) {
  return t && t.constructor.prototype.isIndex === !0 || !1;
}
function ld(t) {
  return typeof t == "boolean";
}
function cd(t) {
  return t && t.constructor.prototype.isResultSet === !0 || !1;
}
function vu(t) {
  return t && t.constructor.prototype.isHelp === !0 || !1;
}
function fd(t) {
  return typeof t == "function";
}
function pd(t) {
  return t instanceof Date;
}
function md(t) {
  return t instanceof RegExp;
}
function Ra(t) {
  return !!(t && typeof t == "object" && t.constructor === Object && !dn(t) && !xi(t));
}
function hd(t) {
  return t === null;
}
function dd(t) {
  return t === void 0;
}
function Kn(t) {
  return t && t.isAccessorNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Wr(t) {
  return t && t.isArrayNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function gd(t) {
  return t && t.isAssignmentNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function vd(t) {
  return t && t.isBlockNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function yd(t) {
  return t && t.isConditionalNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function wt(t) {
  return t && t.isConstantNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function kh(t) {
  return wt(t) || Kt(t) && t.args.length === 1 && wt(t.args[0]) && "-+~".includes(t.op);
}
function Xi(t) {
  return t && t.isFunctionAssignmentNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Bn(t) {
  return t && t.isFunctionNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function bi(t) {
  return t && t.isIndexNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Bt(t) {
  return t && t.isNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Pa(t) {
  return t && t.isObjectNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Kt(t) {
  return t && t.isOperatorNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function Cn(t) {
  return t && t.isParenthesisNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function xd(t) {
  return t && t.isRangeNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function bd(t) {
  return t && t.isRelationalNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function ir(t) {
  return t && t.isSymbolNode === !0 && t.constructor.prototype.isNode === !0 || !1;
}
function yu(t) {
  return t && t.constructor.prototype.isChain === !0 || !1;
}
function kt(t) {
  var e = typeof t;
  return e === "object" ? t === null ? "null" : at(t) ? "BigNumber" : t.constructor && t.constructor.name ? t.constructor.name : "Object" : e;
}
function Je(t) {
  var e = typeof t;
  if (e === "number" || e === "bigint" || e === "string" || e === "boolean" || t === null || t === void 0)
    return t;
  if (typeof t.clone == "function")
    return t.clone();
  if (Array.isArray(t))
    return t.map(function(r) {
      return Je(r);
    });
  if (t instanceof Date) return new Date(t.valueOf());
  if (at(t)) return t;
  if (Ra(t))
    return zA(t, Je);
  throw new TypeError("Cannot clone: unknown type of value (value: ".concat(t, ")"));
}
function zA(t, e) {
  var r = {};
  for (var n in t)
    $e(t, n) && (r[n] = e(t[n]));
  return r;
}
function h2(t, e) {
  for (var r in e)
    $e(e, r) && (t[r] = e[r]);
  return t;
}
function d2(t, e) {
  if (Array.isArray(e))
    throw new TypeError("Arrays are not supported by deepExtend");
  for (var r in e)
    if ($e(e, r) && !(r in Object.prototype) && !(r in Function.prototype))
      if (e[r] && e[r].constructor === Object)
        t[r] === void 0 && (t[r] = {}), t[r] && t[r].constructor === Object ? d2(t[r], e[r]) : t[r] = e[r];
      else {
        if (Array.isArray(e[r]))
          throw new TypeError("Arrays are not supported by deepExtend");
        t[r] = e[r];
      }
  return t;
}
function Wi(t, e) {
  var r, n, i;
  if (Array.isArray(t)) {
    if (!Array.isArray(e) || t.length !== e.length)
      return !1;
    for (n = 0, i = t.length; n < i; n++)
      if (!Wi(t[n], e[n]))
        return !1;
    return !0;
  } else {
    if (typeof t == "function")
      return t === e;
    if (t instanceof Object) {
      if (Array.isArray(e) || !(e instanceof Object))
        return !1;
      for (r in t)
        if (!(r in e) || !Wi(t[r], e[r]))
          return !1;
      for (r in e)
        if (!(r in t))
          return !1;
      return !0;
    } else
      return t === e;
  }
}
function $A(t) {
  var e = {};
  return g2(t, e), e;
}
function g2(t, e) {
  for (var r in t)
    if ($e(t, r)) {
      var n = t[r];
      typeof n == "object" && n !== null ? g2(n, e) : e[r] = n;
    }
}
function Go(t, e, r) {
  var n = !0, i;
  Object.defineProperty(t, e, {
    get: function() {
      return n && (i = r(), n = !1), i;
    },
    set: function(o) {
      i = o, n = !1;
    },
    configurable: !0,
    enumerable: !0
  });
}
function $e(t, e) {
  return t && Object.hasOwnProperty.call(t, e);
}
function UA(t) {
  return t && typeof t.factory == "function";
}
function GA(t, e) {
  for (var r = {}, n = 0; n < e.length; n++) {
    var i = e[n], a = t[i];
    a !== void 0 && (r[i] = a);
  }
  return r;
}
var zh = ["Matrix", "Array"], $h = ["number", "BigNumber", "Fraction"];
function HA(t, e) {
  function r(n) {
    if (n) {
      if (n.epsilon !== void 0) {
        console.warn('Warning: The configuration option "epsilon" is deprecated. Use "relTol" and "absTol" instead.');
        var i = Je(n);
        return i.relTol = n.epsilon, i.absTol = n.epsilon * 1e-3, delete i.epsilon, r(i);
      }
      var a = Je(t);
      $v(n, "matrix", zh), $v(n, "number", $h), d2(t, n);
      var o = Je(t), f = Je(n);
      return e("config", o, a, f), o;
    } else
      return Je(t);
  }
  return r.MATRIX_OPTIONS = zh, r.NUMBER_OPTIONS = $h, Object.keys(gu).forEach((n) => {
    Object.defineProperty(r, n, {
      get: () => t[n],
      enumerable: !0,
      configurable: !0
    });
  }), r;
}
function $v(t, e, r) {
  t[e] !== void 0 && !r.includes(t[e]) && console.warn('Warning: Unknown value "' + t[e] + '" for configuration option "' + e + '". Available options: ' + r.map((n) => JSON.stringify(n)).join(", ") + ".");
}
var Te = function(e) {
  if (e)
    throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);
  return Object.freeze(gu);
};
nr(Te, gu, {
  MATRIX_OPTIONS: zh,
  NUMBER_OPTIONS: $h
});
function Uv() {
  return !0;
}
function mn() {
  return !1;
}
function va() {
}
const Gv = "Argument is not a typed-function.";
function v2() {
  function t(G) {
    return typeof G == "object" && G !== null && G.constructor === Object;
  }
  const e = [{
    name: "number",
    test: function(G) {
      return typeof G == "number";
    }
  }, {
    name: "string",
    test: function(G) {
      return typeof G == "string";
    }
  }, {
    name: "boolean",
    test: function(G) {
      return typeof G == "boolean";
    }
  }, {
    name: "Function",
    test: function(G) {
      return typeof G == "function";
    }
  }, {
    name: "Array",
    test: Array.isArray
  }, {
    name: "Date",
    test: function(G) {
      return G instanceof Date;
    }
  }, {
    name: "RegExp",
    test: function(G) {
      return G instanceof RegExp;
    }
  }, {
    name: "Object",
    test: t
  }, {
    name: "null",
    test: function(G) {
      return G === null;
    }
  }, {
    name: "undefined",
    test: function(G) {
      return G === void 0;
    }
  }], r = {
    name: "any",
    test: Uv,
    isAny: !0
  };
  let n, i, a = 0, o = {
    createCount: 0
  };
  function f(G) {
    const Z = n.get(G);
    if (Z)
      return Z;
    let ge = 'Unknown type "' + G + '"';
    const be = G.toLowerCase();
    let Se;
    for (Se of i)
      if (Se.toLowerCase() === be) {
        ge += '. Did you mean "' + Se + '" ?';
        break;
      }
    throw new TypeError(ge);
  }
  function u(G) {
    let Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
    const ge = Z ? f(Z).index : i.length, be = [];
    for (let De = 0; De < G.length; ++De) {
      if (!G[De] || typeof G[De].name != "string" || typeof G[De].test != "function")
        throw new TypeError("Object with properties {name: string, test: function} expected");
      const Me = G[De].name;
      if (n.has(Me))
        throw new TypeError('Duplicate type name "' + Me + '"');
      be.push(Me), n.set(Me, {
        name: Me,
        test: G[De].test,
        isAny: G[De].isAny,
        index: ge + De,
        conversionsTo: []
        // Newly added type can't have any conversions to it
      });
    }
    const Se = i.slice(ge);
    i = i.slice(0, ge).concat(be).concat(Se);
    for (let De = ge + be.length; De < i.length; ++De)
      n.get(i[De]).index = De;
  }
  function s() {
    n = /* @__PURE__ */ new Map(), i = [], a = 0, u([r], !1);
  }
  s(), u(e);
  function c() {
    let G;
    for (G of i)
      n.get(G).conversionsTo = [];
    a = 0;
  }
  function l(G) {
    const Z = i.filter((ge) => {
      const be = n.get(ge);
      return !be.isAny && be.test(G);
    });
    return Z.length ? Z : ["any"];
  }
  function m(G) {
    return G && typeof G == "function" && "_typedFunctionData" in G;
  }
  function h(G, Z, ge) {
    if (!m(G))
      throw new TypeError(Gv);
    const be = ge && ge.exact, Se = Array.isArray(Z) ? Z.join(",") : Z, De = N(Se), Me = y(De);
    if (!be || Me in G.signatures) {
      const nt = G._typedFunctionData.signatureMap.get(Me);
      if (nt)
        return nt;
    }
    const Oe = De.length;
    let Be;
    if (be) {
      Be = [];
      let nt;
      for (nt in G.signatures)
        Be.push(G._typedFunctionData.signatureMap.get(nt));
    } else
      Be = G._typedFunctionData.signatures;
    for (let nt = 0; nt < Oe; ++nt) {
      const We = De[nt], Qe = [];
      let Gt;
      for (Gt of Be) {
        const P = A(Gt.params, nt);
        if (!(!P || We.restParam && !P.restParam)) {
          if (!P.hasAny) {
            const fe = x(P);
            if (We.types.some((Ne) => !fe.has(Ne.name)))
              continue;
          }
          Qe.push(Gt);
        }
      }
      if (Be = Qe, Be.length === 0) break;
    }
    let Ie;
    for (Ie of Be)
      if (Ie.params.length <= Oe)
        return Ie;
    throw new TypeError("Signature not found (signature: " + (G.name || "unnamed") + "(" + y(De, ", ") + "))");
  }
  function g(G, Z, ge) {
    return h(G, Z, ge).implementation;
  }
  function d(G, Z) {
    const ge = f(Z);
    if (ge.test(G))
      return G;
    const be = ge.conversionsTo;
    if (be.length === 0)
      throw new Error("There are no conversions to " + Z + " defined.");
    for (let Se = 0; Se < be.length; Se++)
      if (f(be[Se].from).test(G))
        return be[Se].convert(G);
    throw new Error("Cannot convert " + G + " to " + Z);
  }
  function y(G) {
    let Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
    return G.map((ge) => ge.name).join(Z);
  }
  function w(G) {
    const Z = G.indexOf("...") === 0, be = (Z ? G.length > 3 ? G.slice(3) : "any" : G).split("|").map((Oe) => f(Oe.trim()));
    let Se = !1, De = Z ? "..." : "";
    return {
      types: be.map(function(Oe) {
        return Se = Oe.isAny || Se, De += Oe.name + "|", {
          name: Oe.name,
          typeIndex: Oe.index,
          test: Oe.test,
          isAny: Oe.isAny,
          conversion: null,
          conversionIndex: -1
        };
      }),
      name: De.slice(0, -1),
      // remove trailing '|' from above
      hasAny: Se,
      hasConversion: !1,
      restParam: Z
    };
  }
  function E(G) {
    const Z = G.types.map((Me) => Me.name), ge = M(Z);
    let be = G.hasAny, Se = G.name;
    const De = ge.map(function(Me) {
      const Oe = f(Me.from);
      return be = Oe.isAny || be, Se += "|" + Me.from, {
        name: Me.from,
        typeIndex: Oe.index,
        test: Oe.test,
        isAny: Oe.isAny,
        conversion: Me,
        conversionIndex: Me.index
      };
    });
    return {
      types: G.types.concat(De),
      name: Se,
      hasAny: be,
      hasConversion: De.length > 0,
      restParam: G.restParam
    };
  }
  function x(G) {
    return G.typeSet || (G.typeSet = /* @__PURE__ */ new Set(), G.types.forEach((Z) => G.typeSet.add(Z.name))), G.typeSet;
  }
  function N(G) {
    const Z = [];
    if (typeof G != "string")
      throw new TypeError("Signatures must be strings");
    const ge = G.trim();
    if (ge === "")
      return Z;
    const be = ge.split(",");
    for (let Se = 0; Se < be.length; ++Se) {
      const De = w(be[Se].trim());
      if (De.restParam && Se !== be.length - 1)
        throw new SyntaxError('Unexpected rest parameter "' + be[Se] + '": only allowed for the last parameter');
      if (De.types.length === 0)
        return null;
      Z.push(De);
    }
    return Z;
  }
  function D(G) {
    const Z = se(G);
    return Z ? Z.restParam : !1;
  }
  function b(G) {
    if (!G || G.types.length === 0)
      return Uv;
    if (G.types.length === 1)
      return f(G.types[0].name).test;
    if (G.types.length === 2) {
      const Z = f(G.types[0].name).test, ge = f(G.types[1].name).test;
      return function(Se) {
        return Z(Se) || ge(Se);
      };
    } else {
      const Z = G.types.map(function(ge) {
        return f(ge.name).test;
      });
      return function(be) {
        for (let Se = 0; Se < Z.length; Se++)
          if (Z[Se](be))
            return !0;
        return !1;
      };
    }
  }
  function C(G) {
    let Z, ge, be;
    if (D(G)) {
      Z = ce(G).map(b);
      const Se = Z.length, De = b(se(G)), Me = function(Oe) {
        for (let Be = Se; Be < Oe.length; Be++)
          if (!De(Oe[Be]))
            return !1;
        return !0;
      };
      return function(Be) {
        for (let Ie = 0; Ie < Z.length; Ie++)
          if (!Z[Ie](Be[Ie]))
            return !1;
        return Me(Be) && Be.length >= Se + 1;
      };
    } else
      return G.length === 0 ? function(De) {
        return De.length === 0;
      } : G.length === 1 ? (ge = b(G[0]), function(De) {
        return ge(De[0]) && De.length === 1;
      }) : G.length === 2 ? (ge = b(G[0]), be = b(G[1]), function(De) {
        return ge(De[0]) && be(De[1]) && De.length === 2;
      }) : (Z = G.map(b), function(De) {
        for (let Me = 0; Me < Z.length; Me++)
          if (!Z[Me](De[Me]))
            return !1;
        return De.length === Z.length;
      });
  }
  function A(G, Z) {
    return Z < G.length ? G[Z] : D(G) ? se(G) : null;
  }
  function T(G, Z) {
    const ge = A(G, Z);
    return ge ? x(ge) : /* @__PURE__ */ new Set();
  }
  function _(G) {
    return G.conversion === null || G.conversion === void 0;
  }
  function O(G, Z) {
    const ge = /* @__PURE__ */ new Set();
    return G.forEach((be) => {
      const Se = T(be.params, Z);
      let De;
      for (De of Se)
        ge.add(De);
    }), ge.has("any") ? ["any"] : Array.from(ge);
  }
  function I(G, Z, ge) {
    let be, Se;
    const De = G || "unnamed";
    let Me = ge, Oe;
    for (Oe = 0; Oe < Z.length; Oe++) {
      const We = [];
      if (Me.forEach((Qe) => {
        const Gt = A(Qe.params, Oe), P = b(Gt);
        (Oe < Qe.params.length || D(Qe.params)) && P(Z[Oe]) && We.push(Qe);
      }), We.length === 0) {
        if (Se = O(Me, Oe), Se.length > 0) {
          const Qe = l(Z[Oe]);
          return be = new TypeError("Unexpected type of argument in function " + De + " (expected: " + Se.join(" or ") + ", actual: " + Qe.join(" | ") + ", index: " + Oe + ")"), be.data = {
            category: "wrongType",
            fn: De,
            index: Oe,
            actual: Qe,
            expected: Se
          }, be;
        }
      } else
        Me = We;
    }
    const Be = Me.map(function(We) {
      return D(We.params) ? 1 / 0 : We.params.length;
    });
    if (Z.length < Math.min.apply(null, Be))
      return Se = O(Me, Oe), be = new TypeError("Too few arguments in function " + De + " (expected: " + Se.join(" or ") + ", index: " + Z.length + ")"), be.data = {
        category: "tooFewArgs",
        fn: De,
        index: Z.length,
        expected: Se
      }, be;
    const Ie = Math.max.apply(null, Be);
    if (Z.length > Ie)
      return be = new TypeError("Too many arguments in function " + De + " (expected: " + Ie + ", actual: " + Z.length + ")"), be.data = {
        category: "tooManyArgs",
        fn: De,
        index: Z.length,
        expectedLength: Ie
      }, be;
    const nt = [];
    for (let We = 0; We < Z.length; ++We)
      nt.push(l(Z[We]).join("|"));
    return be = new TypeError('Arguments of type "' + nt.join(", ") + '" do not match any of the defined signatures of function ' + De + "."), be.data = {
      category: "mismatch",
      actual: nt
    }, be;
  }
  function B(G) {
    let Z = i.length + 1;
    for (let ge = 0; ge < G.types.length; ge++)
      _(G.types[ge]) && (Z = Math.min(Z, G.types[ge].typeIndex));
    return Z;
  }
  function k(G) {
    let Z = a + 1;
    for (let ge = 0; ge < G.types.length; ge++)
      _(G.types[ge]) || (Z = Math.min(Z, G.types[ge].conversionIndex));
    return Z;
  }
  function L(G, Z) {
    if (G.hasAny) {
      if (!Z.hasAny)
        return 1;
    } else if (Z.hasAny)
      return -1;
    if (G.restParam) {
      if (!Z.restParam)
        return 1;
    } else if (Z.restParam)
      return -1;
    if (G.hasConversion) {
      if (!Z.hasConversion)
        return 1;
    } else if (Z.hasConversion)
      return -1;
    const ge = B(G) - B(Z);
    if (ge < 0)
      return -1;
    if (ge > 0)
      return 1;
    const be = k(G) - k(Z);
    return be < 0 ? -1 : be > 0 ? 1 : 0;
  }
  function F(G, Z) {
    const ge = G.params, be = Z.params, Se = se(ge), De = se(be), Me = D(ge), Oe = D(be);
    if (Me && Se.hasAny) {
      if (!Oe || !De.hasAny)
        return 1;
    } else if (Oe && De.hasAny)
      return -1;
    let Be = 0, Ie = 0, nt;
    for (nt of ge)
      nt.hasAny && ++Be, nt.hasConversion && ++Ie;
    let We = 0, Qe = 0;
    for (nt of be)
      nt.hasAny && ++We, nt.hasConversion && ++Qe;
    if (Be !== We)
      return Be - We;
    if (Me && Se.hasConversion) {
      if (!Oe || !De.hasConversion)
        return 1;
    } else if (Oe && De.hasConversion)
      return -1;
    if (Ie !== Qe)
      return Ie - Qe;
    if (Me) {
      if (!Oe)
        return 1;
    } else if (Oe)
      return -1;
    const Gt = (ge.length - be.length) * (Me ? -1 : 1);
    if (Gt !== 0)
      return Gt;
    const P = [];
    let fe = 0;
    for (let Fe = 0; Fe < ge.length; ++Fe) {
      const Ze = L(ge[Fe], be[Fe]);
      P.push(Ze), fe += Ze;
    }
    if (fe !== 0)
      return fe;
    let Ne;
    for (Ne of P)
      if (Ne !== 0)
        return Ne;
    return 0;
  }
  function M(G) {
    if (G.length === 0)
      return [];
    const Z = G.map(f);
    G.length > 1 && Z.sort((Se, De) => Se.index - De.index);
    let ge = Z[0].conversionsTo;
    if (G.length === 1)
      return ge;
    ge = ge.concat([]);
    const be = new Set(G);
    for (let Se = 1; Se < Z.length; ++Se) {
      let De;
      for (De of Z[Se].conversionsTo)
        be.has(De.from) || (ge.push(De), be.add(De.from));
    }
    return ge;
  }
  function $(G, Z) {
    let ge = Z;
    if (G.some((Se) => Se.hasConversion)) {
      const Se = D(G), De = G.map(R);
      ge = function() {
        const Oe = [], Be = Se ? arguments.length - 1 : arguments.length;
        for (let Ie = 0; Ie < Be; Ie++)
          Oe[Ie] = De[Ie](arguments[Ie]);
        return Se && (Oe[Be] = arguments[Be].map(De[Be])), Z.apply(this, Oe);
      };
    }
    let be = ge;
    if (D(G)) {
      const Se = G.length - 1;
      be = function() {
        return ge.apply(this, he(arguments, 0, Se).concat([he(arguments, Se)]));
      };
    }
    return be;
  }
  function R(G) {
    let Z, ge, be, Se;
    const De = [], Me = [];
    switch (G.types.forEach(function(Oe) {
      Oe.conversion && (De.push(f(Oe.conversion.from).test), Me.push(Oe.conversion.convert));
    }), Me.length) {
      case 0:
        return function(Be) {
          return Be;
        };
      case 1:
        return Z = De[0], be = Me[0], function(Be) {
          return Z(Be) ? be(Be) : Be;
        };
      case 2:
        return Z = De[0], ge = De[1], be = Me[0], Se = Me[1], function(Be) {
          return Z(Be) ? be(Be) : ge(Be) ? Se(Be) : Be;
        };
      default:
        return function(Be) {
          for (let Ie = 0; Ie < Me.length; Ie++)
            if (De[Ie](Be))
              return Me[Ie](Be);
          return Be;
        };
    }
  }
  function Q(G) {
    function Z(ge, be, Se) {
      if (be < ge.length) {
        const De = ge[be];
        let Me = [];
        if (De.restParam) {
          const Oe = De.types.filter(_);
          Oe.length < De.types.length && Me.push({
            types: Oe,
            name: "..." + Oe.map((Be) => Be.name).join("|"),
            hasAny: Oe.some((Be) => Be.isAny),
            hasConversion: !1,
            restParam: !0
          }), Me.push(De);
        } else
          Me = De.types.map(function(Oe) {
            return {
              types: [Oe],
              name: Oe.name,
              hasAny: Oe.isAny,
              hasConversion: Oe.conversion,
              restParam: !1
            };
          });
        return ve(Me, function(Oe) {
          return Z(ge, be + 1, Se.concat([Oe]));
        });
      } else
        return [Se];
    }
    return Z(G, 0, []);
  }
  function ee(G, Z) {
    const ge = Math.max(G.length, Z.length);
    for (let Oe = 0; Oe < ge; Oe++) {
      const Be = T(G, Oe), Ie = T(Z, Oe);
      let nt = !1, We;
      for (We of Ie)
        if (Be.has(We)) {
          nt = !0;
          break;
        }
      if (!nt)
        return !1;
    }
    const be = G.length, Se = Z.length, De = D(G), Me = D(Z);
    return De ? Me ? be === Se : Se >= be : Me ? be >= Se : be === Se;
  }
  function j(G) {
    return G.map((Z) => ye(Z) ? V(Z.referToSelf.callback) : J(Z) ? _e(Z.referTo.references, Z.referTo.callback) : Z);
  }
  function U(G, Z, ge) {
    const be = [];
    let Se;
    for (Se of G) {
      let De = ge[Se];
      if (typeof De != "number")
        throw new TypeError('No definition for referenced signature "' + Se + '"');
      if (De = Z[De], typeof De != "function")
        return !1;
      be.push(De);
    }
    return be;
  }
  function pe(G, Z, ge) {
    const be = j(G), Se = new Array(be.length).fill(!1);
    let De = !0;
    for (; De; ) {
      De = !1;
      let Me = !0;
      for (let Oe = 0; Oe < be.length; ++Oe) {
        if (Se[Oe]) continue;
        const Be = be[Oe];
        if (ye(Be))
          be[Oe] = Be.referToSelf.callback(ge), be[Oe].referToSelf = Be.referToSelf, Se[Oe] = !0, Me = !1;
        else if (J(Be)) {
          const Ie = U(Be.referTo.references, be, Z);
          Ie ? (be[Oe] = Be.referTo.callback.apply(this, Ie), be[Oe].referTo = Be.referTo, Se[Oe] = !0, Me = !1) : De = !0;
        }
      }
      if (Me && De)
        throw new SyntaxError("Circular reference detected in resolving typed.referTo");
    }
    return be;
  }
  function X(G) {
    const Z = /\bthis(\(|\.signatures\b)/;
    Object.keys(G).forEach((ge) => {
      const be = G[ge];
      if (Z.test(be.toString()))
        throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
    });
  }
  function te(G, Z) {
    if (o.createCount++, Object.keys(Z).length === 0)
      throw new SyntaxError("No signatures provided");
    o.warnAgainstDeprecatedThis && X(Z);
    const ge = [], be = [], Se = {}, De = [];
    let Me;
    for (Me in Z) {
      if (!Object.prototype.hasOwnProperty.call(Z, Me))
        continue;
      const Ot = N(Me);
      if (!Ot) continue;
      ge.forEach(function(Ui) {
        if (ee(Ui, Ot))
          throw new TypeError('Conflicting signatures "' + y(Ui) + '" and "' + y(Ot) + '".');
      }), ge.push(Ot);
      const Mr = be.length;
      be.push(Z[Me]);
      const bo = Ot.map(E);
      let $i;
      for ($i of Q(bo)) {
        const Ui = y($i);
        De.push({
          params: $i,
          name: Ui,
          fn: Mr
        }), $i.every((ps) => !ps.hasConversion) && (Se[Ui] = Mr);
      }
    }
    De.sort(F);
    const Oe = pe(be, Se, jt);
    let Be;
    for (Be in Se)
      Object.prototype.hasOwnProperty.call(Se, Be) && (Se[Be] = Oe[Se[Be]]);
    const Ie = [], nt = /* @__PURE__ */ new Map();
    for (Be of De)
      nt.has(Be.name) || (Be.fn = Oe[Be.fn], Ie.push(Be), nt.set(Be.name, Be));
    const We = Ie[0] && Ie[0].params.length <= 2 && !D(Ie[0].params), Qe = Ie[1] && Ie[1].params.length <= 2 && !D(Ie[1].params), Gt = Ie[2] && Ie[2].params.length <= 2 && !D(Ie[2].params), P = Ie[3] && Ie[3].params.length <= 2 && !D(Ie[3].params), fe = Ie[4] && Ie[4].params.length <= 2 && !D(Ie[4].params), Ne = Ie[5] && Ie[5].params.length <= 2 && !D(Ie[5].params), Fe = We && Qe && Gt && P && fe && Ne;
    for (let Ot = 0; Ot < Ie.length; ++Ot)
      Ie[Ot].test = C(Ie[Ot].params);
    const Ze = We ? b(Ie[0].params[0]) : mn, it = Qe ? b(Ie[1].params[0]) : mn, pr = Gt ? b(Ie[2].params[0]) : mn, Li = P ? b(Ie[3].params[0]) : mn, ki = fe ? b(Ie[4].params[0]) : mn, ls = Ne ? b(Ie[5].params[0]) : mn, yh = We ? b(Ie[0].params[1]) : mn, da = Qe ? b(Ie[1].params[1]) : mn, wn = Gt ? b(Ie[2].params[1]) : mn, xh = P ? b(Ie[3].params[1]) : mn, cs = fe ? b(Ie[4].params[1]) : mn, Nn = Ne ? b(Ie[5].params[1]) : mn;
    for (let Ot = 0; Ot < Ie.length; ++Ot)
      Ie[Ot].implementation = $(Ie[Ot].params, Ie[Ot].fn);
    const fs = We ? Ie[0].implementation : va, Vt = Qe ? Ie[1].implementation : va, bh = Gt ? Ie[2].implementation : va, wh = P ? Ie[3].implementation : va, xr = fe ? Ie[4].implementation : va, Dn = Ne ? Ie[5].implementation : va, cn = We ? Ie[0].params.length : -1, vo = Qe ? Ie[1].params.length : -1, _r = Gt ? Ie[2].params.length : -1, zi = P ? Ie[3].params.length : -1, ci = fe ? Ie[4].params.length : -1, yo = Ne ? Ie[5].params.length : -1, Nh = Fe ? 6 : 0, Wt = Ie.length, xo = Ie.map((Ot) => Ot.test), Dh = Ie.map((Ot) => Ot.implementation), fn = function() {
      for (let Mr = Nh; Mr < Wt; Mr++)
        if (xo[Mr](arguments))
          return Dh[Mr].apply(this, arguments);
      return o.onMismatch(G, arguments, Ie);
    };
    function jt(Ot, Mr) {
      return arguments.length === cn && Ze(Ot) && yh(Mr) ? fs.apply(this, arguments) : arguments.length === vo && it(Ot) && da(Mr) ? Vt.apply(this, arguments) : arguments.length === _r && pr(Ot) && wn(Mr) ? bh.apply(this, arguments) : arguments.length === zi && Li(Ot) && xh(Mr) ? wh.apply(this, arguments) : arguments.length === ci && ki(Ot) && cs(Mr) ? xr.apply(this, arguments) : arguments.length === yo && ls(Ot) && Nn(Mr) ? Dn.apply(this, arguments) : fn.apply(this, arguments);
    }
    try {
      Object.defineProperty(jt, "name", {
        value: G
      });
    } catch {
    }
    return jt.signatures = Se, jt._typedFunctionData = {
      signatures: Ie,
      signatureMap: nt
    }, jt;
  }
  function ue(G, Z, ge) {
    throw I(G, Z, ge);
  }
  function ce(G) {
    return he(G, 0, G.length - 1);
  }
  function se(G) {
    return G[G.length - 1];
  }
  function he(G, Z, ge) {
    return Array.prototype.slice.call(G, Z, ge);
  }
  function le(G, Z) {
    for (let ge = 0; ge < G.length; ge++)
      if (Z(G[ge]))
        return G[ge];
  }
  function ve(G, Z) {
    return Array.prototype.concat.apply([], G.map(Z));
  }
  function Ee() {
    const G = ce(arguments).map((ge) => y(N(ge))), Z = se(arguments);
    if (typeof Z != "function")
      throw new TypeError("Callback function expected as last argument");
    return _e(G, Z);
  }
  function _e(G, Z) {
    return {
      referTo: {
        references: G,
        callback: Z
      }
    };
  }
  function V(G) {
    if (typeof G != "function")
      throw new TypeError("Callback function expected as first argument");
    return {
      referToSelf: {
        callback: G
      }
    };
  }
  function J(G) {
    return G && typeof G.referTo == "object" && Array.isArray(G.referTo.references) && typeof G.referTo.callback == "function";
  }
  function ye(G) {
    return G && typeof G.referToSelf == "object" && typeof G.referToSelf.callback == "function";
  }
  function K(G, Z) {
    if (!G)
      return Z;
    if (Z && Z !== G) {
      const ge = new Error("Function names do not match (expected: " + G + ", actual: " + Z + ")");
      throw ge.data = {
        actual: Z,
        expected: G
      }, ge;
    }
    return G;
  }
  function ae(G) {
    let Z;
    for (const ge in G)
      Object.prototype.hasOwnProperty.call(G, ge) && (m(G[ge]) || typeof G[ge].signature == "string") && (Z = K(Z, G[ge].name));
    return Z;
  }
  function de(G, Z) {
    let ge;
    for (ge in Z)
      if (Object.prototype.hasOwnProperty.call(Z, ge)) {
        if (ge in G && Z[ge] !== G[ge]) {
          const be = new Error('Signature "' + ge + '" is defined twice');
          throw be.data = {
            signature: ge,
            sourceFunction: Z[ge],
            destFunction: G[ge]
          }, be;
        }
        G[ge] = Z[ge];
      }
  }
  const xe = o;
  o = function(G) {
    const Z = typeof G == "string", ge = Z ? 1 : 0;
    let be = Z ? G : "";
    const Se = {};
    for (let De = ge; De < arguments.length; ++De) {
      const Me = arguments[De];
      let Oe = {}, Be;
      if (typeof Me == "function" ? (Be = Me.name, typeof Me.signature == "string" ? Oe[Me.signature] = Me : m(Me) && (Oe = Me.signatures)) : t(Me) && (Oe = Me, Z || (Be = ae(Me))), Object.keys(Oe).length === 0) {
        const Ie = new TypeError("Argument to 'typed' at index " + De + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
        throw Ie.data = {
          index: De,
          argument: Me
        }, Ie;
      }
      Z || (be = K(be, Be)), de(Se, Oe);
    }
    return te(be || "", Se);
  }, o.create = v2, o.createCount = xe.createCount, o.onMismatch = ue, o.throwMismatchError = ue, o.createError = I, o.clear = s, o.clearConversions = c, o.addTypes = u, o._findType = f, o.referTo = Ee, o.referToSelf = V, o.convert = d, o.findSignature = h, o.find = g, o.isTypedFunction = m, o.warnAgainstDeprecatedThis = !0, o.addType = function(G, Z) {
    let ge = "any";
    Z !== !1 && n.has("Object") && (ge = "Object"), o.addTypes([G], ge);
  };
  function Ce(G) {
    if (!G || typeof G.from != "string" || typeof G.to != "string" || typeof G.convert != "function")
      throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
    if (G.to === G.from)
      throw new SyntaxError('Illegal to define conversion from "' + G.from + '" to itself.');
  }
  return o.addConversion = function(G) {
    let Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      override: !1
    };
    Ce(G);
    const ge = f(G.to), be = ge.conversionsTo.find((Se) => Se.from === G.from);
    if (be)
      if (Z && Z.override)
        o.removeConversion({
          from: be.from,
          to: G.to,
          convert: be.convert
        });
      else
        throw new Error('There is already a conversion from "' + G.from + '" to "' + ge.name + '"');
    ge.conversionsTo.push({
      from: G.from,
      convert: G.convert,
      index: a++
    });
  }, o.addConversions = function(G, Z) {
    G.forEach((ge) => o.addConversion(ge, Z));
  }, o.removeConversion = function(G) {
    Ce(G);
    const Z = f(G.to), ge = le(Z.conversionsTo, (Se) => Se.from === G.from);
    if (!ge)
      throw new Error("Attempt to remove nonexistent conversion from " + G.from + " to " + G.to);
    if (ge.convert !== G.convert)
      throw new Error("Conversion to remove does not match existing conversion");
    const be = Z.conversionsTo.indexOf(ge);
    Z.conversionsTo.splice(be, 1);
  }, o.resolve = function(G, Z) {
    if (!m(G))
      throw new TypeError(Gv);
    const ge = G._typedFunctionData.signatures;
    for (let be = 0; be < ge.length; ++be)
      if (ge[be].test(Z))
        return ge[be];
    return null;
  }, o;
}
const Gi = v2();
function Ve(t) {
  return typeof t == "boolean" ? !0 : isFinite(t) ? t === Math.round(t) : !1;
}
function QA(t) {
  return /^-?\d+$/.test(t);
}
function wi(t, e) {
  return e.number === "bigint" && !QA(t) ? e.numberFallback : e.number;
}
var hi = Math.sign || function(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}, VA = Math.log2 || function(e) {
  return Math.log(e) / Math.LN2;
}, WA = Math.log10 || function(e) {
  return Math.log(e) / Math.LN10;
}, jA = Math.log1p || function(t) {
  return Math.log(t + 1);
}, YA = Math.cbrt || function(e) {
  if (e === 0)
    return e;
  var r = e < 0, n;
  return r && (e = -e), isFinite(e) ? (n = Math.exp(Math.log(e) / 3), n = (e / (n * n) + 2 * n) / 3) : n = e, r ? -n : n;
}, ZA = Math.expm1 || function(e) {
  return e >= 2e-4 || e <= -2e-4 ? Math.exp(e) - 1 : e + e * e / 2 + e * e * e / 6;
};
function Oh(t, e, r) {
  var n = {
    2: "0b",
    8: "0o",
    16: "0x"
  }, i = n[e], a = "";
  if (r) {
    if (r < 1)
      throw new Error("size must be in greater than 0");
    if (!Ve(r))
      throw new Error("size must be an integer");
    if (t > 2 ** (r - 1) - 1 || t < -(2 ** (r - 1)))
      throw new Error("Value must be in range [-2^".concat(r - 1, ", 2^").concat(r - 1, "-1]"));
    if (!Ve(t))
      throw new Error("Value must be an integer");
    t < 0 && (t = t + 2 ** r), a = "i".concat(r);
  }
  var o = "";
  return t < 0 && (t = -t, o = "-"), "".concat(o).concat(i).concat(t.toString(e)).concat(a);
}
function Vi(t, e) {
  if (typeof e == "function")
    return e(t);
  if (t === 1 / 0)
    return "Infinity";
  if (t === -1 / 0)
    return "-Infinity";
  if (isNaN(t))
    return "NaN";
  var {
    notation: r,
    precision: n,
    wordSize: i
  } = y2(e);
  switch (r) {
    case "fixed":
      return x2(t, n);
    case "exponential":
      return b2(t, n);
    case "engineering":
      return JA(t, n);
    case "bin":
      return Oh(t, 2, i);
    case "oct":
      return Oh(t, 8, i);
    case "hex":
      return Oh(t, 16, i);
    case "auto":
      return XA(t, n, e).replace(/((\.\d*?)(0+))($|e)/, function() {
        var a = arguments[2], o = arguments[4];
        return a !== "." ? a + o : o;
      });
    default:
      throw new Error('Unknown notation "' + r + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function y2(t) {
  var e = "auto", r, n;
  if (t !== void 0)
    if (ot(t))
      r = t;
    else if (at(t))
      r = t.toNumber();
    else if (Ra(t))
      t.precision !== void 0 && (r = Hv(t.precision, () => {
        throw new Error('Option "precision" must be a number or BigNumber');
      })), t.wordSize !== void 0 && (n = Hv(t.wordSize, () => {
        throw new Error('Option "wordSize" must be a number or BigNumber');
      })), t.notation && (e = t.notation);
    else
      throw new Error("Unsupported type of options, number, BigNumber, or object expected");
  return {
    notation: e,
    precision: r,
    wordSize: n
  };
}
function Os(t) {
  var e = String(t).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!e)
    throw new SyntaxError("Invalid number " + t);
  var r = e[1], n = e[2], i = parseFloat(e[4] || "0"), a = n.indexOf(".");
  i += a !== -1 ? a - 1 : n.length - 1;
  var o = n.replace(".", "").replace(/^0*/, function(f) {
    return i -= f.length, "";
  }).replace(/0*$/, "").split("").map(function(f) {
    return parseInt(f);
  });
  return o.length === 0 && (o.push(0), i++), {
    sign: r,
    coefficients: o,
    exponent: i
  };
}
function JA(t, e) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var r = Os(t), n = xu(r, e), i = n.exponent, a = n.coefficients, o = i % 3 === 0 ? i : i < 0 ? i - 3 - i % 3 : i - i % 3;
  if (ot(e))
    for (; e > a.length || i - o + 1 > a.length; )
      a.push(0);
  else
    for (var f = Math.abs(i - o) - (a.length - 1), u = 0; u < f; u++)
      a.push(0);
  for (var s = Math.abs(i - o), c = 1; s > 0; )
    c++, s--;
  var l = a.slice(c).join(""), m = ot(e) && l.length || l.match(/[1-9]/) ? "." + l : "", h = a.slice(0, c).join("") + m + "e" + (i >= 0 ? "+" : "") + o.toString();
  return n.sign + h;
}
function x2(t, e) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var r = Os(t), n = typeof e == "number" ? xu(r, r.exponent + 1 + e) : r, i = n.coefficients, a = n.exponent + 1, o = a + (e || 0);
  return i.length < o && (i = i.concat(Ea(o - i.length))), a < 0 && (i = Ea(-a + 1).concat(i), a = 1), a < i.length && i.splice(a, 0, a === 0 ? "0." : "."), n.sign + i.join("");
}
function b2(t, e) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var r = Os(t), n = e ? xu(r, e) : r, i = n.coefficients, a = n.exponent;
  i.length < e && (i = i.concat(Ea(e - i.length)));
  var o = i.shift();
  return n.sign + o + (i.length > 0 ? "." + i.join("") : "") + "e" + (a >= 0 ? "+" : "") + a;
}
function XA(t, e, r) {
  if (isNaN(t) || !isFinite(t))
    return String(t);
  var n = Qv(r?.lowerExp, -3), i = Qv(r?.upperExp, 5), a = Os(t), o = e ? xu(a, e) : a;
  if (o.exponent < n || o.exponent >= i)
    return b2(t, e);
  var f = o.coefficients, u = o.exponent;
  f.length < e && (f = f.concat(Ea(e - f.length))), f = f.concat(Ea(u - f.length + 1 + (f.length < e ? e - f.length : 0))), f = Ea(-u).concat(f);
  var s = u > 0 ? u : 0;
  return s < f.length - 1 && f.splice(s + 1, 0, "."), o.sign + f.join("");
}
function xu(t, e) {
  for (var r = {
    sign: t.sign,
    coefficients: t.coefficients,
    exponent: t.exponent
  }, n = r.coefficients; e <= 0; )
    n.unshift(0), r.exponent++, e++;
  if (n.length > e) {
    var i = n.splice(e, n.length - e);
    if (i[0] >= 5) {
      var a = e - 1;
      for (n[a]++; n[a] === 10; )
        n.pop(), a === 0 && (n.unshift(0), r.exponent++, a++), a--, n[a]++;
    }
  }
  return r;
}
function Ea(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push(0);
  return e;
}
function KA(t) {
  return t.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
function Er(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-8, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  if (r <= 0)
    throw new Error("Relative tolerance must be greater than 0");
  if (n < 0)
    throw new Error("Absolute tolerance must be at least 0");
  return isNaN(t) || isNaN(e) ? !1 : !isFinite(t) || !isFinite(e) ? t === e : t === e ? !0 : Math.abs(t - e) <= Math.max(r * Math.max(Math.abs(t), Math.abs(e)), n);
}
var eC = Math.acosh || function(t) {
  return Math.log(Math.sqrt(t * t - 1) + t);
}, tC = Math.asinh || function(t) {
  return Math.log(Math.sqrt(t * t + 1) + t);
}, rC = Math.atanh || function(t) {
  return Math.log((1 + t) / (1 - t)) / 2;
}, nC = Math.cosh || function(t) {
  return (Math.exp(t) + Math.exp(-t)) / 2;
}, iC = Math.sinh || function(t) {
  return (Math.exp(t) - Math.exp(-t)) / 2;
}, aC = Math.tanh || function(t) {
  var e = Math.exp(2 * t);
  return (e - 1) / (e + 1);
};
function sC(t, e) {
  var r = !0, n = e > 0 ? !0 : e < 0 ? !1 : 1 / e === 1 / 0;
  return r ^ n ? -t : t;
}
function Hv(t, e) {
  if (ot(t))
    return t;
  if (at(t))
    return t.toNumber();
  e();
}
function Qv(t, e) {
  return ot(t) ? t : at(t) ? t.toNumber() : e;
}
function H(t, e, r, n) {
  function i(a) {
    var o = GA(a, e.map(w2));
    return oC(t, e, a), r(o);
  }
  return i.isFactory = !0, i.fn = t, i.dependencies = e.slice().sort(), n && (i.meta = n), i;
}
function ws(t) {
  return typeof t == "function" && typeof t.fn == "string" && Array.isArray(t.dependencies);
}
function oC(t, e, r) {
  var n = e.filter((a) => !uC(a)).every((a) => r[a] !== void 0);
  if (!n) {
    var i = e.filter((a) => r[a] === void 0);
    throw new Error('Cannot create function "'.concat(t, '", ') + "some dependencies are missing: ".concat(i.map((a) => '"'.concat(a, '"')).join(", "), "."));
  }
}
function uC(t) {
  return t && t[0] === "?";
}
function w2(t) {
  return t && t[0] === "?" ? t.slice(1) : t;
}
function kr(t, e) {
  if (D2(t) && N2(t, e))
    return t[e];
  throw typeof t[e] == "function" && wd(t, e) ? new Error('Cannot access method "' + e + '" as a property') : new Error('No access to property "' + e + '"');
}
function Ta(t, e, r) {
  if (D2(t) && N2(t, e))
    return t[e] = r, r;
  throw new Error('No access to property "' + e + '"');
}
function lC(t, e) {
  return e in t;
}
function N2(t, e) {
  return !t || typeof t != "object" ? !1 : $e(fC, e) ? !0 : !(e in Object.prototype || e in Function.prototype);
}
function cC(t, e) {
  if (!wd(t, e))
    throw new Error('No access to method "' + e + '"');
  return t[e];
}
function wd(t, e) {
  return t == null || typeof t[e] != "function" || $e(t, e) && Object.getPrototypeOf && e in Object.getPrototypeOf(t) ? !1 : $e(pC, e) ? !0 : !(e in Object.prototype || e in Function.prototype);
}
function D2(t) {
  return typeof t == "object" && t && t.constructor === Object;
}
var fC = {
  length: !0,
  name: !0
}, pC = {
  toString: !0,
  valueOf: !0,
  toLocaleString: !0
};
class bu {
  constructor(e) {
    this.wrappedObject = e, this[Symbol.iterator] = this.entries;
  }
  keys() {
    return Object.keys(this.wrappedObject).values();
  }
  get(e) {
    return kr(this.wrappedObject, e);
  }
  set(e, r) {
    return Ta(this.wrappedObject, e, r), this;
  }
  has(e) {
    return lC(this.wrappedObject, e);
  }
  entries() {
    return S2(this.keys(), (e) => [e, this.get(e)]);
  }
  forEach(e) {
    for (var r of this.keys())
      e(this.get(r), r, this);
  }
  delete(e) {
    delete this.wrappedObject[e];
  }
  clear() {
    for (var e of this.keys())
      this.delete(e);
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
}
class E2 {
  /**
   * @param {Map} a
   * @param {Map} b
   * @param {Set} bKeys
   */
  constructor(e, r, n) {
    this.a = e, this.b = r, this.bKeys = n, this[Symbol.iterator] = this.entries;
  }
  get(e) {
    return this.bKeys.has(e) ? this.b.get(e) : this.a.get(e);
  }
  set(e, r) {
    return this.bKeys.has(e) ? this.b.set(e, r) : this.a.set(e, r), this;
  }
  has(e) {
    return this.b.has(e) || this.a.has(e);
  }
  keys() {
    return (/* @__PURE__ */ new Set([...this.a.keys(), ...this.b.keys()]))[Symbol.iterator]();
  }
  entries() {
    return S2(this.keys(), (e) => [e, this.get(e)]);
  }
  forEach(e) {
    for (var r of this.keys())
      e(this.get(r), r, this);
  }
  delete(e) {
    return this.bKeys.has(e) ? this.b.delete(e) : this.a.delete(e);
  }
  clear() {
    this.a.clear(), this.b.clear();
  }
  get size() {
    return [...this.keys()].length;
  }
}
function S2(t, e) {
  return {
    next: () => {
      var r = t.next();
      return r.done ? r : {
        value: e(r.value),
        done: !1
      };
    }
  };
}
function Ns() {
  return /* @__PURE__ */ new Map();
}
function Sa(t) {
  if (!t)
    return Ns();
  if (A2(t))
    return t;
  if (Ra(t))
    return new bu(t);
  throw new Error("createMap can create maps from objects or Maps");
}
function mC(t) {
  if (t instanceof bu)
    return t.wrappedObject;
  var e = {};
  for (var r of t.keys()) {
    var n = t.get(r);
    Ta(e, r, n);
  }
  return e;
}
function A2(t) {
  return t ? t instanceof Map || t instanceof bu || typeof t.set == "function" && typeof t.get == "function" && typeof t.keys == "function" && typeof t.has == "function" : !1;
}
var C2 = function() {
  return C2 = Gi.create, Gi;
}, hC = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"], wu = /* @__PURE__ */ H("typed", hC, function(e) {
  var {
    BigNumber: r,
    Complex: n,
    DenseMatrix: i,
    Fraction: a
  } = e, o = C2();
  return o.clear(), o.addTypes([
    {
      name: "number",
      test: ot
    },
    {
      name: "Complex",
      test: dn
    },
    {
      name: "BigNumber",
      test: at
    },
    {
      name: "bigint",
      test: ud
    },
    {
      name: "Fraction",
      test: xi
    },
    {
      name: "Unit",
      test: Lr
    },
    // The following type matches a valid variable name, i.e., an alphanumeric
    // string starting with an alphabetic character. It is used (at least)
    // in the definition of the derivative() function, as the argument telling
    // what to differentiate over must (currently) be a variable.
    {
      name: "identifier",
      test: (f) => hr && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(f)
    },
    {
      name: "string",
      test: hr
    },
    {
      name: "Chain",
      test: yu
    },
    {
      name: "Array",
      test: _t
    },
    {
      name: "Matrix",
      test: Ye
    },
    {
      name: "DenseMatrix",
      test: Ca
    },
    {
      name: "SparseMatrix",
      test: jn
    },
    {
      name: "Range",
      test: Ms
    },
    {
      name: "Index",
      test: Ba
    },
    {
      name: "boolean",
      test: ld
    },
    {
      name: "ResultSet",
      test: cd
    },
    {
      name: "Help",
      test: vu
    },
    {
      name: "function",
      test: fd
    },
    {
      name: "Date",
      test: pd
    },
    {
      name: "RegExp",
      test: md
    },
    {
      name: "null",
      test: hd
    },
    {
      name: "undefined",
      test: dd
    },
    {
      name: "AccessorNode",
      test: Kn
    },
    {
      name: "ArrayNode",
      test: Wr
    },
    {
      name: "AssignmentNode",
      test: gd
    },
    {
      name: "BlockNode",
      test: vd
    },
    {
      name: "ConditionalNode",
      test: yd
    },
    {
      name: "ConstantNode",
      test: wt
    },
    {
      name: "FunctionNode",
      test: Bn
    },
    {
      name: "FunctionAssignmentNode",
      test: Xi
    },
    {
      name: "IndexNode",
      test: bi
    },
    {
      name: "Node",
      test: Bt
    },
    {
      name: "ObjectNode",
      test: Pa
    },
    {
      name: "OperatorNode",
      test: Kt
    },
    {
      name: "ParenthesisNode",
      test: Cn
    },
    {
      name: "RangeNode",
      test: xd
    },
    {
      name: "RelationalNode",
      test: bd
    },
    {
      name: "SymbolNode",
      test: ir
    },
    {
      name: "Map",
      test: A2
    },
    {
      name: "Object",
      test: Ra
    }
    // order 'Object' last, it matches on other classes too
  ]), o.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function(u) {
      if (r || Do(u), KA(u) > 15)
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + u + "). Use function bignumber(x) to convert to BigNumber.");
      return new r(u);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function(u) {
      return n || Eo(u), new n(u, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function(u) {
      return n || Eo(u), new n(u.toNumber(), 0);
    }
  }, {
    from: "bigint",
    to: "number",
    convert: function(u) {
      if (u > Number.MAX_SAFE_INTEGER)
        throw new TypeError("Cannot implicitly convert bigint to number: value exceeds the max safe integer value (value: " + u + ")");
      return Number(u);
    }
  }, {
    from: "bigint",
    to: "BigNumber",
    convert: function(u) {
      return r || Do(u), new r(u.toString());
    }
  }, {
    from: "bigint",
    to: "Fraction",
    convert: function(u) {
      return a || So(u), new a(u.toString());
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function(u) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function(u) {
      return n || Eo(u), new n(u.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function(u) {
      a || So(u);
      var s = new a(u);
      if (s.valueOf() !== u)
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + u + "). Use function fraction(x) to convert to Fraction.");
      return s;
    }
  }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf()
    //  }
    // }, {
    from: "string",
    to: "number",
    convert: function(u) {
      var s = Number(u);
      if (isNaN(s))
        throw new Error('Cannot convert "' + u + '" to a number');
      return s;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function(u) {
      r || Do(u);
      try {
        return new r(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "bigint",
    convert: function(u) {
      try {
        return BigInt(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to BigInt');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function(u) {
      a || So(u);
      try {
        return new a(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function(u) {
      n || Eo(u);
      try {
        return new n(u);
      } catch {
        throw new Error('Cannot convert "' + u + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function(u) {
      return +u;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function(u) {
      return r || Do(u), new r(+u);
    }
  }, {
    from: "boolean",
    to: "bigint",
    convert: function(u) {
      return BigInt(+u);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function(u) {
      return a || So(u), new a(+u);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function(u) {
      return String(u);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function(u) {
      return i || dC(), new i(u);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function(u) {
      return u.valueOf();
    }
  }]), o.onMismatch = (f, u, s) => {
    var c = o.createError(f, u, s);
    if (["wrongType", "mismatch"].includes(c.data.category) && u.length === 1 && Yr(u[0]) && // check if the function can be unary:
    s.some((m) => !m.params.includes(","))) {
      var l = new TypeError("Function '".concat(f, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(f, ")'."));
      throw l.data = c.data, l;
    }
    throw c;
  }, o.onMismatch = (f, u, s) => {
    var c = o.createError(f, u, s);
    if (["wrongType", "mismatch"].includes(c.data.category) && u.length === 1 && Yr(u[0]) && // check if the function can be unary:
    s.some((m) => !m.params.includes(","))) {
      var l = new TypeError("Function '".concat(f, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(f, ")'."));
      throw l.data = c.data, l;
    }
    throw c;
  }, o;
});
function Do(t) {
  throw new Error("Cannot convert value ".concat(t, " into a BigNumber: no class 'BigNumber' provided"));
}
function Eo(t) {
  throw new Error("Cannot convert value ".concat(t, " into a Complex number: no class 'Complex' provided"));
}
function dC() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function So(t) {
  throw new Error("Cannot convert value ".concat(t, " into a Fraction, no class 'Fraction' provided."));
}
var gC = "ResultSet", vC = [], Nu = /* @__PURE__ */ H(gC, vC, () => {
  function t(e) {
    if (!(this instanceof t))
      throw new SyntaxError("Constructor must be called with the new operator");
    this.entries = e || [];
  }
  return t.prototype.type = "ResultSet", t.prototype.isResultSet = !0, t.prototype.valueOf = function() {
    return this.entries;
  }, t.prototype.toString = function() {
    return "[" + this.entries.join(", ") + "]";
  }, t.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  }, t.fromJSON = function(e) {
    return new t(e.entries);
  }, t;
}, {
  isClass: !0
});
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var wa = 9e15, Ni = 1e9, Uh = "0123456789abcdef", Vo = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", Wo = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", Gh = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -wa,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: wa,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, T2, Yn, ut = !0, Du = "[DecimalError] ", gi = Du + "Invalid argument: ", _2 = Du + "Precision limit exceeded", M2 = Du + "crypto unavailable", O2 = "[object Decimal]", Fr = Math.floor, or = Math.pow, yC = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, xC = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, bC = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, q2 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, An = 1e7, Ke = 7, wC = 9007199254740991, NC = Vo.length - 1, Hh = Wo.length - 1, qe = { toStringTag: O2 };
qe.absoluteValue = qe.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), je(t);
};
qe.ceil = function() {
  return je(new this.constructor(this), this.e + 1, 2);
};
qe.clampedTo = qe.clamp = function(t, e) {
  var r, n = this, i = n.constructor;
  if (t = new i(t), e = new i(e), !t.s || !e.s) return new i(NaN);
  if (t.gt(e)) throw Error(gi + e);
  return r = n.cmp(t), r < 0 ? t : n.cmp(e) > 0 ? e : new i(n);
};
qe.comparedTo = qe.cmp = function(t) {
  var e, r, n, i, a = this, o = a.d, f = (t = new a.constructor(t)).d, u = a.s, s = t.s;
  if (!o || !f)
    return !u || !s ? NaN : u !== s ? u : o === f ? 0 : !o ^ u < 0 ? 1 : -1;
  if (!o[0] || !f[0]) return o[0] ? u : f[0] ? -s : 0;
  if (u !== s) return u;
  if (a.e !== t.e) return a.e > t.e ^ u < 0 ? 1 : -1;
  for (n = o.length, i = f.length, e = 0, r = n < i ? n : i; e < r; ++e)
    if (o[e] !== f[e]) return o[e] > f[e] ^ u < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ u < 0 ? 1 : -1;
};
qe.cosine = qe.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + Ke, n.rounding = 1, r = DC(n, P2(n, r)), n.precision = t, n.rounding = e, je(Yn == 2 || Yn == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
qe.cubeRoot = qe.cbrt = function() {
  var t, e, r, n, i, a, o, f, u, s, c = this, l = c.constructor;
  if (!c.isFinite() || c.isZero()) return new l(c);
  for (ut = !1, a = c.s * or(c.s * c, 1 / 3), !a || Math.abs(a) == 1 / 0 ? (r = wr(c.d), t = c.e, (a = (t - r.length + 1) % 3) && (r += a == 1 || a == -2 ? "0" : "00"), a = or(r, 1 / 3), t = Fr((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), a == 1 / 0 ? r = "5e" + t : (r = a.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new l(r), n.s = c.s) : n = new l(a.toString()), o = (t = l.precision) + 3; ; )
    if (f = n, u = f.times(f).times(f), s = u.plus(c), n = Ht(s.plus(c).times(f), s.plus(u), o + 2, 1), wr(f.d).slice(0, o) === (r = wr(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (je(f, t + 1, 0), f.times(f).times(f).eq(c))) {
          n = f;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (je(n, t + 1, 1), e = !n.times(n).times(n).eq(c));
        break;
      }
  return ut = !0, je(n, t, l.rounding, e);
};
qe.decimalPlaces = qe.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Fr(this.e / Ke)) * Ke, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
qe.dividedBy = qe.div = function(t) {
  return Ht(this, new this.constructor(t));
};
qe.dividedToIntegerBy = qe.divToInt = function(t) {
  var e = this, r = e.constructor;
  return je(Ht(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
qe.equals = qe.eq = function(t) {
  return this.cmp(t) === 0;
};
qe.floor = function() {
  return je(new this.constructor(this), this.e + 1, 3);
};
qe.greaterThan = qe.gt = function(t) {
  return this.cmp(t) > 0;
};
qe.greaterThanOrEqualTo = qe.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
qe.hyperbolicCosine = qe.cosh = function() {
  var t, e, r, n, i, a = this, o = a.constructor, f = new o(1);
  if (!a.isFinite()) return new o(a.s ? 1 / 0 : NaN);
  if (a.isZero()) return f;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(a.e, a.sd()) + 4, o.rounding = 1, i = a.d.length, i < 32 ? (t = Math.ceil(i / 3), e = (1 / Su(4, t)).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), a = _a(o, 1, a.times(e), new o(1), !0);
  for (var u, s = t, c = new o(8); s--; )
    u = a.times(a), a = f.minus(u.times(c.minus(u.times(c))));
  return je(a, o.precision = r, o.rounding = n, !0);
};
qe.hyperbolicSine = qe.sinh = function() {
  var t, e, r, n, i = this, a = i.constructor;
  if (!i.isFinite() || i.isZero()) return new a(i);
  if (e = a.precision, r = a.rounding, a.precision = e + Math.max(i.e, i.sd()) + 4, a.rounding = 1, n = i.d.length, n < 3)
    i = _a(a, 2, i, i, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, i = i.times(1 / Su(5, t)), i = _a(a, 2, i, i, !0);
    for (var o, f = new a(5), u = new a(16), s = new a(20); t--; )
      o = i.times(i), i = i.times(f.plus(o.times(u.times(o).plus(s))));
  }
  return a.precision = e, a.rounding = r, je(i, e, r, !0);
};
qe.hyperbolicTangent = qe.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, Ht(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
qe.inverseCosine = qe.acos = function() {
  var t, e = this, r = e.constructor, n = e.abs().cmp(1), i = r.precision, a = r.rounding;
  return n !== -1 ? n === 0 ? e.isNeg() ? Sn(r, i, a) : new r(0) : new r(NaN) : e.isZero() ? Sn(r, i + 4, a).times(0.5) : (r.precision = i + 6, r.rounding = 1, e = e.asin(), t = Sn(r, i + 4, a).times(0.5), r.precision = i, r.rounding = a, t.minus(e));
};
qe.inverseHyperbolicCosine = qe.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, ut = !1, r = r.times(r).minus(1).sqrt().plus(r), ut = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
qe.inverseHyperbolicSine = qe.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, ut = !1, r = r.times(r).plus(1).sqrt().plus(r), ut = !0, n.precision = t, n.rounding = e, r.ln());
};
qe.inverseHyperbolicTangent = qe.atanh = function() {
  var t, e, r, n, i = this, a = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new a(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = a.precision, e = a.rounding, n = i.sd(), Math.max(n, t) < 2 * -i.e - 1 ? je(new a(i), t, e, !0) : (a.precision = r = n - i.e, i = Ht(i.plus(1), new a(1).minus(i), r + t, 1), a.precision = t + 4, a.rounding = 1, i = i.ln(), a.precision = t, a.rounding = e, i.times(0.5))) : new a(NaN);
};
qe.inverseSine = qe.asin = function() {
  var t, e, r, n, i = this, a = i.constructor;
  return i.isZero() ? new a(i) : (e = i.abs().cmp(1), r = a.precision, n = a.rounding, e !== -1 ? e === 0 ? (t = Sn(a, r + 4, n).times(0.5), t.s = i.s, t) : new a(NaN) : (a.precision = r + 6, a.rounding = 1, i = i.div(new a(1).minus(i.times(i)).sqrt().plus(1)).atan(), a.precision = r, a.rounding = n, i.times(2)));
};
qe.inverseTangent = qe.atan = function() {
  var t, e, r, n, i, a, o, f, u, s = this, c = s.constructor, l = c.precision, m = c.rounding;
  if (s.isFinite()) {
    if (s.isZero())
      return new c(s);
    if (s.abs().eq(1) && l + 4 <= Hh)
      return o = Sn(c, l + 4, m).times(0.25), o.s = s.s, o;
  } else {
    if (!s.s) return new c(NaN);
    if (l + 4 <= Hh)
      return o = Sn(c, l + 4, m).times(0.5), o.s = s.s, o;
  }
  for (c.precision = f = l + 10, c.rounding = 1, r = Math.min(28, f / Ke + 2 | 0), t = r; t; --t) s = s.div(s.times(s).plus(1).sqrt().plus(1));
  for (ut = !1, e = Math.ceil(f / Ke), n = 1, u = s.times(s), o = new c(s), i = s; t !== -1; )
    if (i = i.times(u), a = o.minus(i.div(n += 2)), i = i.times(u), o = a.plus(i.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === a.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), ut = !0, je(o, c.precision = l, c.rounding = m, !0);
};
qe.isFinite = function() {
  return !!this.d;
};
qe.isInteger = qe.isInt = function() {
  return !!this.d && Fr(this.e / Ke) > this.d.length - 2;
};
qe.isNaN = function() {
  return !this.s;
};
qe.isNegative = qe.isNeg = function() {
  return this.s < 0;
};
qe.isPositive = qe.isPos = function() {
  return this.s > 0;
};
qe.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
qe.lessThan = qe.lt = function(t) {
  return this.cmp(t) < 0;
};
qe.lessThanOrEqualTo = qe.lte = function(t) {
  return this.cmp(t) < 1;
};
qe.logarithm = qe.log = function(t) {
  var e, r, n, i, a, o, f, u, s = this, c = s.constructor, l = c.precision, m = c.rounding, h = 5;
  if (t == null)
    t = new c(10), e = !0;
  else {
    if (t = new c(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new c(NaN);
    e = t.eq(10);
  }
  if (r = s.d, s.s < 0 || !r || !r[0] || s.eq(1))
    return new c(r && !r[0] ? -1 / 0 : s.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      a = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      a = i !== 1;
    }
  if (ut = !1, f = l + h, o = di(s, f), n = e ? jo(c, f + 10) : di(t, f), u = Ht(o, n, f, 1), Ds(u.d, i = l, m))
    do
      if (f += 10, o = di(s, f), n = e ? jo(c, f + 10) : di(t, f), u = Ht(o, n, f, 1), !a) {
        +wr(u.d).slice(i + 1, i + 15) + 1 == 1e14 && (u = je(u, l + 1, 0));
        break;
      }
    while (Ds(u.d, i += 10, m));
  return ut = !0, je(u, l, m);
};
qe.minus = qe.sub = function(t) {
  var e, r, n, i, a, o, f, u, s, c, l, m, h = this, g = h.constructor;
  if (t = new g(t), !h.d || !t.d)
    return !h.s || !t.s ? t = new g(NaN) : h.d ? t.s = -t.s : t = new g(t.d || h.s !== t.s ? h : NaN), t;
  if (h.s != t.s)
    return t.s = -t.s, h.plus(t);
  if (s = h.d, m = t.d, f = g.precision, u = g.rounding, !s[0] || !m[0]) {
    if (m[0]) t.s = -t.s;
    else if (s[0]) t = new g(h);
    else return new g(u === 3 ? -0 : 0);
    return ut ? je(t, f, u) : t;
  }
  if (r = Fr(t.e / Ke), c = Fr(h.e / Ke), s = s.slice(), a = c - r, a) {
    for (l = a < 0, l ? (e = s, a = -a, o = m.length) : (e = m, r = c, o = s.length), n = Math.max(Math.ceil(f / Ke), o) + 2, a > n && (a = n, e.length = 1), e.reverse(), n = a; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = s.length, o = m.length, l = n < o, l && (o = n), n = 0; n < o; n++)
      if (s[n] != m[n]) {
        l = s[n] < m[n];
        break;
      }
    a = 0;
  }
  for (l && (e = s, s = m, m = e, t.s = -t.s), o = s.length, n = m.length - o; n > 0; --n) s[o++] = 0;
  for (n = m.length; n > a; ) {
    if (s[--n] < m[n]) {
      for (i = n; i && s[--i] === 0; ) s[i] = An - 1;
      --s[i], s[n] += An;
    }
    s[n] -= m[n];
  }
  for (; s[--o] === 0; ) s.pop();
  for (; s[0] === 0; s.shift()) --r;
  return s[0] ? (t.d = s, t.e = Eu(s, r), ut ? je(t, f, u) : t) : new g(u === 3 ? -0 : 0);
};
qe.modulo = qe.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? je(new n(r), n.precision, n.rounding) : (ut = !1, n.modulo == 9 ? (e = Ht(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = Ht(r, t, 0, n.modulo, 1), e = e.times(t), ut = !0, r.minus(e));
};
qe.naturalExponential = qe.exp = function() {
  return Qh(this);
};
qe.naturalLogarithm = qe.ln = function() {
  return di(this);
};
qe.negated = qe.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, je(t);
};
qe.plus = qe.add = function(t) {
  var e, r, n, i, a, o, f, u, s, c, l = this, m = l.constructor;
  if (t = new m(t), !l.d || !t.d)
    return !l.s || !t.s ? t = new m(NaN) : l.d || (t = new m(t.d || l.s === t.s ? l : NaN)), t;
  if (l.s != t.s)
    return t.s = -t.s, l.minus(t);
  if (s = l.d, c = t.d, f = m.precision, u = m.rounding, !s[0] || !c[0])
    return c[0] || (t = new m(l)), ut ? je(t, f, u) : t;
  if (a = Fr(l.e / Ke), n = Fr(t.e / Ke), s = s.slice(), i = a - n, i) {
    for (i < 0 ? (r = s, i = -i, o = c.length) : (r = c, n = a, o = s.length), a = Math.ceil(f / Ke), o = a > o ? a + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = s.length, i = c.length, o - i < 0 && (i = o, r = c, c = s, s = r), e = 0; i; )
    e = (s[--i] = s[i] + c[i] + e) / An | 0, s[i] %= An;
  for (e && (s.unshift(e), ++n), o = s.length; s[--o] == 0; ) s.pop();
  return t.d = s, t.e = Eu(s, n), ut ? je(t, f, u) : t;
};
qe.precision = qe.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(gi + t);
  return r.d ? (e = I2(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
qe.round = function() {
  var t = this, e = t.constructor;
  return je(new e(t), t.e + 1, e.rounding);
};
qe.sine = qe.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + Ke, n.rounding = 1, r = SC(n, P2(n, r)), n.precision = t, n.rounding = e, je(Yn > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
qe.squareRoot = qe.sqrt = function() {
  var t, e, r, n, i, a, o = this, f = o.d, u = o.e, s = o.s, c = o.constructor;
  if (s !== 1 || !f || !f[0])
    return new c(!s || s < 0 && (!f || f[0]) ? NaN : f ? o : 1 / 0);
  for (ut = !1, s = Math.sqrt(+o), s == 0 || s == 1 / 0 ? (e = wr(f), (e.length + u) % 2 == 0 && (e += "0"), s = Math.sqrt(e), u = Fr((u + 1) / 2) - (u < 0 || u % 2), s == 1 / 0 ? e = "5e" + u : (e = s.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + u), n = new c(e)) : n = new c(s.toString()), r = (u = c.precision) + 3; ; )
    if (a = n, n = a.plus(Ht(o, a, r + 2, 1)).times(0.5), wr(a.d).slice(0, r) === (e = wr(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !i && e == "4999") {
        if (!i && (je(a, u + 1, 0), a.times(a).eq(o))) {
          n = a;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (je(n, u + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return ut = !0, je(n, u, c.rounding, t);
};
qe.tangent = qe.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = Ht(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, je(Yn == 2 || Yn == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
qe.times = qe.mul = function(t) {
  var e, r, n, i, a, o, f, u, s, c = this, l = c.constructor, m = c.d, h = (t = new l(t)).d;
  if (t.s *= c.s, !m || !m[0] || !h || !h[0])
    return new l(!t.s || m && !m[0] && !h || h && !h[0] && !m ? NaN : !m || !h ? t.s / 0 : t.s * 0);
  for (r = Fr(c.e / Ke) + Fr(t.e / Ke), u = m.length, s = h.length, u < s && (a = m, m = h, h = a, o = u, u = s, s = o), a = [], o = u + s, n = o; n--; ) a.push(0);
  for (n = s; --n >= 0; ) {
    for (e = 0, i = u + n; i > n; )
      f = a[i] + h[n] * m[i - n - 1] + e, a[i--] = f % An | 0, e = f / An | 0;
    a[i] = (a[i] + e) % An | 0;
  }
  for (; !a[--o]; ) a.pop();
  return e ? ++r : a.shift(), t.d = a, t.e = Eu(a, r), ut ? je(t, l.precision, l.rounding) : t;
};
qe.toBinary = function(t, e) {
  return Nd(this, 2, t, e);
};
qe.toDecimalPlaces = qe.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (Zr(t, 0, Ni), e === void 0 ? e = n.rounding : Zr(e, 0, 8), je(r, t + r.e + 1, e));
};
qe.toExponential = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Rn(n, !0) : (Zr(t, 0, Ni), e === void 0 ? e = i.rounding : Zr(e, 0, 8), n = je(new i(n), t + 1, e), r = Rn(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
qe.toFixed = function(t, e) {
  var r, n, i = this, a = i.constructor;
  return t === void 0 ? r = Rn(i) : (Zr(t, 0, Ni), e === void 0 ? e = a.rounding : Zr(e, 0, 8), n = je(new a(i), t + i.e + 1, e), r = Rn(n, !1, t + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
qe.toFraction = function(t) {
  var e, r, n, i, a, o, f, u, s, c, l, m, h = this, g = h.d, d = h.constructor;
  if (!g) return new d(h);
  if (s = r = new d(1), n = u = new d(0), e = new d(n), a = e.e = I2(g) - h.e - 1, o = a % Ke, e.d[0] = or(10, o < 0 ? Ke + o : o), t == null)
    t = a > 0 ? e : s;
  else {
    if (f = new d(t), !f.isInt() || f.lt(s)) throw Error(gi + f);
    t = f.gt(e) ? a > 0 ? e : s : f;
  }
  for (ut = !1, f = new d(wr(g)), c = d.precision, d.precision = a = g.length * Ke * 2; l = Ht(f, e, 0, 1, 1), i = r.plus(l.times(n)), i.cmp(t) != 1; )
    r = n, n = i, i = s, s = u.plus(l.times(i)), u = i, i = e, e = f.minus(l.times(i)), f = i;
  return i = Ht(t.minus(r), n, 0, 1, 1), u = u.plus(i.times(s)), r = r.plus(i.times(n)), u.s = s.s = h.s, m = Ht(s, n, a, 1).minus(h).abs().cmp(Ht(u, r, a, 1).minus(h).abs()) < 1 ? [s, n] : [u, r], d.precision = c, ut = !0, m;
};
qe.toHexadecimal = qe.toHex = function(t, e) {
  return Nd(this, 16, t, e);
};
qe.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : Zr(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (ut = !1, r = Ht(r, t, 0, e, 1).times(t), ut = !0, je(r)) : (t.s = r.s, r = t), r;
};
qe.toNumber = function() {
  return +this;
};
qe.toOctal = function(t, e) {
  return Nd(this, 8, t, e);
};
qe.toPower = qe.pow = function(t) {
  var e, r, n, i, a, o, f = this, u = f.constructor, s = +(t = new u(t));
  if (!f.d || !t.d || !f.d[0] || !t.d[0]) return new u(or(+f, s));
  if (f = new u(f), f.eq(1)) return f;
  if (n = u.precision, a = u.rounding, t.eq(1)) return je(f, n, a);
  if (e = Fr(t.e / Ke), e >= t.d.length - 1 && (r = s < 0 ? -s : s) <= wC)
    return i = F2(u, f, r, n), t.s < 0 ? new u(1).div(i) : je(i, n, a);
  if (o = f.s, o < 0) {
    if (e < t.d.length - 1) return new u(NaN);
    if (t.d[e] & 1 || (o = 1), f.e == 0 && f.d[0] == 1 && f.d.length == 1)
      return f.s = o, f;
  }
  return r = or(+f, s), e = r == 0 || !isFinite(r) ? Fr(s * (Math.log("0." + wr(f.d)) / Math.LN10 + f.e + 1)) : new u(r + "").e, e > u.maxE + 1 || e < u.minE - 1 ? new u(e > 0 ? o / 0 : 0) : (ut = !1, u.rounding = f.s = 1, r = Math.min(12, (e + "").length), i = Qh(t.times(di(f, n + r)), n), i.d && (i = je(i, n + 5, 1), Ds(i.d, n, a) && (e = n + 10, i = je(Qh(t.times(di(f, e + r)), e), e + 5, 1), +wr(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = je(i, n + 1, 0)))), i.s = o, ut = !0, u.rounding = a, je(i, n, a));
};
qe.toPrecision = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Rn(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (Zr(t, 1, Ni), e === void 0 ? e = i.rounding : Zr(e, 0, 8), n = je(new i(n), t, e), r = Rn(n, t <= n.e || n.e <= i.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
qe.toSignificantDigits = qe.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (Zr(t, 1, Ni), e === void 0 ? e = n.rounding : Zr(e, 0, 8)), je(new n(r), t, e);
};
qe.toString = function() {
  var t = this, e = t.constructor, r = Rn(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
qe.truncated = qe.trunc = function() {
  return je(new this.constructor(this), this.e + 1, 1);
};
qe.valueOf = qe.toJSON = function() {
  var t = this, e = t.constructor, r = Rn(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function wr(t) {
  var e, r, n, i = t.length - 1, a = "", o = t[0];
  if (i > 0) {
    for (a += o, e = 1; e < i; e++)
      n = t[e] + "", r = Ke - n.length, r && (a += pi(r)), a += n;
    o = t[e], n = o + "", r = Ke - n.length, r && (a += pi(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return a + o;
}
function Zr(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(gi + t);
}
function Ds(t, e, r, n) {
  var i, a, o, f;
  for (a = t[0]; a >= 10; a /= 10) --e;
  return --e < 0 ? (e += Ke, i = 0) : (i = Math.ceil((e + 1) / Ke), e %= Ke), a = or(10, Ke - e), f = t[i] % a | 0, n == null ? e < 3 ? (e == 0 ? f = f / 100 | 0 : e == 1 && (f = f / 10 | 0), o = r < 4 && f == 99999 || r > 3 && f == 49999 || f == 5e4 || f == 0) : o = (r < 4 && f + 1 == a || r > 3 && f + 1 == a / 2) && (t[i + 1] / a / 100 | 0) == or(10, e - 2) - 1 || (f == a / 2 || f == 0) && (t[i + 1] / a / 100 | 0) == 0 : e < 4 ? (e == 0 ? f = f / 1e3 | 0 : e == 1 ? f = f / 100 | 0 : e == 2 && (f = f / 10 | 0), o = (n || r < 4) && f == 9999 || !n && r > 3 && f == 4999) : o = ((n || r < 4) && f + 1 == a || !n && r > 3 && f + 1 == a / 2) && (t[i + 1] / a / 1e3 | 0) == or(10, e - 3) - 1, o;
}
function Ho(t, e, r) {
  for (var n, i = [0], a, o = 0, f = t.length; o < f; ) {
    for (a = i.length; a--; ) i[a] *= e;
    for (i[0] += Uh.indexOf(t.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function DC(t, e) {
  var r, n, i;
  if (e.isZero()) return e;
  n = e.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Su(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), t.precision += r, e = _a(t, 1, e.times(i), new t(1));
  for (var a = r; a--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var Ht = /* @__PURE__ */ function() {
  function t(n, i, a) {
    var o, f = 0, u = n.length;
    for (n = n.slice(); u--; )
      o = n[u] * i + f, n[u] = o % a | 0, f = o / a | 0;
    return f && n.unshift(f), n;
  }
  function e(n, i, a, o) {
    var f, u;
    if (a != o)
      u = a > o ? 1 : -1;
    else
      for (f = u = 0; f < a; f++)
        if (n[f] != i[f]) {
          u = n[f] > i[f] ? 1 : -1;
          break;
        }
    return u;
  }
  function r(n, i, a, o) {
    for (var f = 0; a--; )
      n[a] -= f, f = n[a] < i[a] ? 1 : 0, n[a] = f * o + n[a] - i[a];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, a, o, f, u) {
    var s, c, l, m, h, g, d, y, w, E, x, N, D, b, C, A, T, _, O, I, B = n.constructor, k = n.s == i.s ? 1 : -1, L = n.d, F = i.d;
    if (!L || !L[0] || !F || !F[0])
      return new B(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (L ? F && L[0] == F[0] : !F) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          L && L[0] == 0 || !F ? k * 0 : k / 0
        )
      );
    for (u ? (h = 1, c = n.e - i.e) : (u = An, h = Ke, c = Fr(n.e / h) - Fr(i.e / h)), O = F.length, T = L.length, w = new B(k), E = w.d = [], l = 0; F[l] == (L[l] || 0); l++) ;
    if (F[l] > (L[l] || 0) && c--, a == null ? (b = a = B.precision, o = B.rounding) : f ? b = a + (n.e - i.e) + 1 : b = a, b < 0)
      E.push(1), g = !0;
    else {
      if (b = b / h + 2 | 0, l = 0, O == 1) {
        for (m = 0, F = F[0], b++; (l < T || m) && b--; l++)
          C = m * u + (L[l] || 0), E[l] = C / F | 0, m = C % F | 0;
        g = m || l < T;
      } else {
        for (m = u / (F[0] + 1) | 0, m > 1 && (F = t(F, m, u), L = t(L, m, u), O = F.length, T = L.length), A = O, x = L.slice(0, O), N = x.length; N < O; ) x[N++] = 0;
        I = F.slice(), I.unshift(0), _ = F[0], F[1] >= u / 2 && ++_;
        do
          m = 0, s = e(F, x, O, N), s < 0 ? (D = x[0], O != N && (D = D * u + (x[1] || 0)), m = D / _ | 0, m > 1 ? (m >= u && (m = u - 1), d = t(F, m, u), y = d.length, N = x.length, s = e(d, x, y, N), s == 1 && (m--, r(d, O < y ? I : F, y, u))) : (m == 0 && (s = m = 1), d = F.slice()), y = d.length, y < N && d.unshift(0), r(x, d, N, u), s == -1 && (N = x.length, s = e(F, x, O, N), s < 1 && (m++, r(x, O < N ? I : F, N, u))), N = x.length) : s === 0 && (m++, x = [0]), E[l++] = m, s && x[0] ? x[N++] = L[A] || 0 : (x = [L[A]], N = 1);
        while ((A++ < T || x[0] !== void 0) && b--);
        g = x[0] !== void 0;
      }
      E[0] || E.shift();
    }
    if (h == 1)
      w.e = c, T2 = g;
    else {
      for (l = 1, m = E[0]; m >= 10; m /= 10) l++;
      w.e = l + c * h - 1, je(w, f ? a + w.e + 1 : a, o, g);
    }
    return w;
  };
}();
function je(t, e, r, n) {
  var i, a, o, f, u, s, c, l, m, h = t.constructor;
  e: if (e != null) {
    if (l = t.d, !l) return t;
    for (i = 1, f = l[0]; f >= 10; f /= 10) i++;
    if (a = e - i, a < 0)
      a += Ke, o = e, c = l[m = 0], u = c / or(10, i - o - 1) % 10 | 0;
    else if (m = Math.ceil((a + 1) / Ke), f = l.length, m >= f)
      if (n) {
        for (; f++ <= m; ) l.push(0);
        c = u = 0, i = 1, a %= Ke, o = a - Ke + 1;
      } else
        break e;
    else {
      for (c = f = l[m], i = 1; f >= 10; f /= 10) i++;
      a %= Ke, o = a - Ke + i, u = o < 0 ? 0 : c / or(10, i - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || l[m + 1] !== void 0 || (o < 0 ? c : c % or(10, i - o - 1)), s = r < 4 ? (u || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (a > 0 ? o > 0 ? c / or(10, i - o) : 0 : l[m - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !l[0])
      return l.length = 0, s ? (e -= t.e + 1, l[0] = or(10, (Ke - e % Ke) % Ke), t.e = -e || 0) : l[0] = t.e = 0, t;
    if (a == 0 ? (l.length = m, f = 1, m--) : (l.length = m + 1, f = or(10, Ke - a), l[m] = o > 0 ? (c / or(10, i - o) % or(10, o) | 0) * f : 0), s)
      for (; ; )
        if (m == 0) {
          for (a = 1, o = l[0]; o >= 10; o /= 10) a++;
          for (o = l[0] += f, f = 1; o >= 10; o /= 10) f++;
          a != f && (t.e++, l[0] == An && (l[0] = 1));
          break;
        } else {
          if (l[m] += f, l[m] != An) break;
          l[m--] = 0, f = 1;
        }
    for (a = l.length; l[--a] === 0; ) l.pop();
  }
  return ut && (t.e > h.maxE ? (t.d = null, t.e = NaN) : t.e < h.minE && (t.e = 0, t.d = [0])), t;
}
function Rn(t, e, r) {
  if (!t.isFinite()) return R2(t);
  var n, i = t.e, a = wr(t.d), o = a.length;
  return e ? (r && (n = r - o) > 0 ? a = a.charAt(0) + "." + a.slice(1) + pi(n) : o > 1 && (a = a.charAt(0) + "." + a.slice(1)), a = a + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (a = "0." + pi(-i - 1) + a, r && (n = r - o) > 0 && (a += pi(n))) : i >= o ? (a += pi(i + 1 - o), r && (n = r - i - 1) > 0 && (a = a + "." + pi(n))) : ((n = i + 1) < o && (a = a.slice(0, n) + "." + a.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (a += "."), a += pi(n))), a;
}
function Eu(t, e) {
  var r = t[0];
  for (e *= Ke; r >= 10; r /= 10) e++;
  return e;
}
function jo(t, e, r) {
  if (e > NC)
    throw ut = !0, r && (t.precision = r), Error(_2);
  return je(new t(Vo), e, 1, !0);
}
function Sn(t, e, r) {
  if (e > Hh) throw Error(_2);
  return je(new t(Wo), e, r, !0);
}
function I2(t) {
  var e = t.length - 1, r = e * Ke + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function pi(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function F2(t, e, r, n) {
  var i, a = new t(1), o = Math.ceil(n / Ke + 4);
  for (ut = !1; ; ) {
    if (r % 2 && (a = a.times(e), Wv(a.d, o) && (i = !0)), r = Fr(r / 2), r === 0) {
      r = a.d.length - 1, i && a.d[r] === 0 && ++a.d[r];
      break;
    }
    e = e.times(e), Wv(e.d, o);
  }
  return ut = !0, a;
}
function Vv(t) {
  return t.d[t.d.length - 1] & 1;
}
function B2(t, e, r) {
  for (var n, i = new t(e[0]), a = 0; ++a < e.length; )
    if (n = new t(e[a]), n.s)
      i[r](n) && (i = n);
    else {
      i = n;
      break;
    }
  return i;
}
function Qh(t, e) {
  var r, n, i, a, o, f, u, s = 0, c = 0, l = 0, m = t.constructor, h = m.rounding, g = m.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new m(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (ut = !1, u = g) : u = e, f = new m(0.03125); t.e > -2; )
    t = t.times(f), l += 5;
  for (n = Math.log(or(2, l)) / Math.LN10 * 2 + 5 | 0, u += n, r = a = o = new m(1), m.precision = u; ; ) {
    if (a = je(a.times(t), u, 1), r = r.times(++c), f = o.plus(Ht(a, r, u, 1)), wr(f.d).slice(0, u) === wr(o.d).slice(0, u)) {
      for (i = l; i--; ) o = je(o.times(o), u, 1);
      if (e == null)
        if (s < 3 && Ds(o.d, u - n, h, s))
          m.precision = u += 10, r = a = f = new m(1), c = 0, s++;
        else
          return je(o, m.precision = g, h, ut = !0);
      else
        return m.precision = g, o;
    }
    o = f;
  }
}
function di(t, e) {
  var r, n, i, a, o, f, u, s, c, l, m, h = 1, g = 10, d = t, y = d.d, w = d.constructor, E = w.rounding, x = w.precision;
  if (d.s < 0 || !y || !y[0] || !d.e && y[0] == 1 && y.length == 1)
    return new w(y && !y[0] ? -1 / 0 : d.s != 1 ? NaN : y ? 0 : d);
  if (e == null ? (ut = !1, c = x) : c = e, w.precision = c += g, r = wr(y), n = r.charAt(0), Math.abs(a = d.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      d = d.times(t), r = wr(d.d), n = r.charAt(0), h++;
    a = d.e, n > 1 ? (d = new w("0." + r), a++) : d = new w(n + "." + r.slice(1));
  } else
    return s = jo(w, c + 2, x).times(a + ""), d = di(new w(n + "." + r.slice(1)), c - g).plus(s), w.precision = x, e == null ? je(d, x, E, ut = !0) : d;
  for (l = d, u = o = d = Ht(d.minus(1), d.plus(1), c, 1), m = je(d.times(d), c, 1), i = 3; ; ) {
    if (o = je(o.times(m), c, 1), s = u.plus(Ht(o, new w(i), c, 1)), wr(s.d).slice(0, c) === wr(u.d).slice(0, c))
      if (u = u.times(2), a !== 0 && (u = u.plus(jo(w, c + 2, x).times(a + ""))), u = Ht(u, new w(h), c, 1), e == null)
        if (Ds(u.d, c - g, E, f))
          w.precision = c += g, s = o = d = Ht(l.minus(1), l.plus(1), c, 1), m = je(d.times(d), c, 1), i = f = 1;
        else
          return je(u, w.precision = x, E, ut = !0);
      else
        return w.precision = x, u;
    u = s, i += 2;
  }
}
function R2(t) {
  return String(t.s * t.s / 0);
}
function Vh(t, e) {
  var r, n, i;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i) ;
  if (e = e.slice(n, i), e) {
    if (i -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % Ke, r < 0 && (n += Ke), n < i) {
      for (n && t.d.push(+e.slice(0, n)), i -= Ke; n < i; ) t.d.push(+e.slice(n, n += Ke));
      e = e.slice(n), n = Ke - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    t.d.push(+e), ut && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function EC(t, e) {
  var r, n, i, a, o, f, u, s, c;
  if (e.indexOf("_") > -1) {
    if (e = e.replace(/(\d)_(?=\d)/g, "$1"), q2.test(e)) return Vh(t, e);
  } else if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (xC.test(e))
    r = 16, e = e.toLowerCase();
  else if (yC.test(e))
    r = 2;
  else if (bC.test(e))
    r = 8;
  else
    throw Error(gi + e);
  for (a = e.search(/p/i), a > 0 ? (u = +e.slice(a + 1), e = e.substring(2, a)) : e = e.slice(2), a = e.indexOf("."), o = a >= 0, n = t.constructor, o && (e = e.replace(".", ""), f = e.length, a = f - a, i = F2(n, new n(r), a, a * 2)), s = Ho(e, r, An), c = s.length - 1, a = c; s[a] === 0; --a) s.pop();
  return a < 0 ? new n(t.s * 0) : (t.e = Eu(s, c), t.d = s, ut = !1, o && (t = Ht(t, i, f * 4)), u && (t = t.times(Math.abs(u) < 54 ? or(2, u) : vi.pow(2, u))), ut = !0, t);
}
function SC(t, e) {
  var r, n = e.d.length;
  if (n < 3)
    return e.isZero() ? e : _a(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(1 / Su(5, r)), e = _a(t, 2, e, e);
  for (var i, a = new t(5), o = new t(16), f = new t(20); r--; )
    i = e.times(e), e = e.times(a.plus(i.times(o.times(i).minus(f))));
  return e;
}
function _a(t, e, r, n, i) {
  var a, o, f, u, s = t.precision, c = Math.ceil(s / Ke);
  for (ut = !1, u = r.times(r), f = new t(n); ; ) {
    if (o = Ht(f.times(u), new t(e++ * e++), s, 1), f = i ? n.plus(o) : n.minus(o), n = Ht(o.times(u), new t(e++ * e++), s, 1), o = f.plus(n), o.d[c] !== void 0) {
      for (a = c; o.d[a] === f.d[a] && a--; ) ;
      if (a == -1) break;
    }
    a = f, f = n, n = o, o = a;
  }
  return ut = !0, o.d.length = c + 1, o;
}
function Su(t, e) {
  for (var r = t; --e; ) r *= t;
  return r;
}
function P2(t, e) {
  var r, n = e.s < 0, i = Sn(t, t.precision, 1), a = i.times(0.5);
  if (e = e.abs(), e.lte(a))
    return Yn = n ? 4 : 1, e;
  if (r = e.divToInt(i), r.isZero())
    Yn = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(i)), e.lte(a))
      return Yn = Vv(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    Yn = Vv(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(i).abs();
}
function Nd(t, e, r, n) {
  var i, a, o, f, u, s, c, l, m, h = t.constructor, g = r !== void 0;
  if (g ? (Zr(r, 1, Ni), n === void 0 ? n = h.rounding : Zr(n, 0, 8)) : (r = h.precision, n = h.rounding), !t.isFinite())
    c = R2(t);
  else {
    for (c = Rn(t), o = c.indexOf("."), g ? (i = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : i = e, o >= 0 && (c = c.replace(".", ""), m = new h(1), m.e = c.length - o, m.d = Ho(Rn(m), 10, i), m.e = m.d.length), l = Ho(c, 10, i), a = u = l.length; l[--u] == 0; ) l.pop();
    if (!l[0])
      c = g ? "0p+0" : "0";
    else {
      if (o < 0 ? a-- : (t = new h(t), t.d = l, t.e = a, t = Ht(t, m, r, n, 0, i), l = t.d, a = t.e, s = T2), o = l[r], f = i / 2, s = s || l[r + 1] !== void 0, s = n < 4 ? (o !== void 0 || s) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > f || o === f && (n === 4 || s || n === 6 && l[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), l.length = r, s)
        for (; ++l[--r] > i - 1; )
          l[r] = 0, r || (++a, l.unshift(1));
      for (u = l.length; !l[u - 1]; --u) ;
      for (o = 0, c = ""; o < u; o++) c += Uh.charAt(l[o]);
      if (g) {
        if (u > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --u; u % o; u++) c += "0";
            for (l = Ho(c, i, e), u = l.length; !l[u - 1]; --u) ;
            for (o = 1, c = "1."; o < u; o++) c += Uh.charAt(l[o]);
          } else
            c = c.charAt(0) + "." + c.slice(1);
        c = c + (a < 0 ? "p" : "p+") + a;
      } else if (a < 0) {
        for (; ++a; ) c = "0" + c;
        c = "0." + c;
      } else if (++a > u) for (a -= u; a--; ) c += "0";
      else a < u && (c = c.slice(0, a) + "." + c.slice(a));
    }
    c = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + c;
  }
  return t.s < 0 ? "-" + c : c;
}
function Wv(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function AC(t) {
  return new this(t).abs();
}
function CC(t) {
  return new this(t).acos();
}
function TC(t) {
  return new this(t).acosh();
}
function _C(t, e) {
  return new this(t).plus(e);
}
function MC(t) {
  return new this(t).asin();
}
function OC(t) {
  return new this(t).asinh();
}
function qC(t) {
  return new this(t).atan();
}
function IC(t) {
  return new this(t).atanh();
}
function FC(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, i = this.rounding, a = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Sn(this, a, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Sn(this, n, i) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Sn(this, a, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = a, this.rounding = 1, r = this.atan(Ht(t, e, a, 1)), e = Sn(this, a, 1), this.precision = n, this.rounding = i, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(Ht(t, e, a, 1)), r;
}
function BC(t) {
  return new this(t).cbrt();
}
function RC(t) {
  return je(t = new this(t), t.e + 1, 2);
}
function PC(t, e, r) {
  return new this(t).clamp(e, r);
}
function LC(t) {
  if (!t || typeof t != "object") throw Error(Du + "Object expected");
  var e, r, n, i = t.defaults === !0, a = [
    "precision",
    1,
    Ni,
    "rounding",
    0,
    8,
    "toExpNeg",
    -wa,
    0,
    "toExpPos",
    0,
    wa,
    "maxE",
    0,
    wa,
    "minE",
    -wa,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < a.length; e += 3)
    if (r = a[e], i && (this[r] = Gh[r]), (n = t[r]) !== void 0)
      if (Fr(n) === n && n >= a[e + 1] && n <= a[e + 2]) this[r] = n;
      else throw Error(gi + r + ": " + n);
  if (r = "crypto", i && (this[r] = Gh[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(M2);
      else
        this[r] = !1;
    else
      throw Error(gi + r + ": " + n);
  return this;
}
function kC(t) {
  return new this(t).cos();
}
function zC(t) {
  return new this(t).cosh();
}
function L2(t) {
  var e, r, n;
  function i(a) {
    var o, f, u, s = this;
    if (!(s instanceof i)) return new i(a);
    if (s.constructor = i, jv(a)) {
      s.s = a.s, ut ? !a.d || a.e > i.maxE ? (s.e = NaN, s.d = null) : a.e < i.minE ? (s.e = 0, s.d = [0]) : (s.e = a.e, s.d = a.d.slice()) : (s.e = a.e, s.d = a.d ? a.d.slice() : a.d);
      return;
    }
    if (u = typeof a, u === "number") {
      if (a === 0) {
        s.s = 1 / a < 0 ? -1 : 1, s.e = 0, s.d = [0];
        return;
      }
      if (a < 0 ? (a = -a, s.s = -1) : s.s = 1, a === ~~a && a < 1e7) {
        for (o = 0, f = a; f >= 10; f /= 10) o++;
        ut ? o > i.maxE ? (s.e = NaN, s.d = null) : o < i.minE ? (s.e = 0, s.d = [0]) : (s.e = o, s.d = [a]) : (s.e = o, s.d = [a]);
        return;
      } else if (a * 0 !== 0) {
        a || (s.s = NaN), s.e = NaN, s.d = null;
        return;
      }
      return Vh(s, a.toString());
    } else if (u !== "string")
      throw Error(gi + a);
    return (f = a.charCodeAt(0)) === 45 ? (a = a.slice(1), s.s = -1) : (f === 43 && (a = a.slice(1)), s.s = 1), q2.test(a) ? Vh(s, a) : EC(s, a);
  }
  if (i.prototype = qe, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = LC, i.clone = L2, i.isDecimal = jv, i.abs = AC, i.acos = CC, i.acosh = TC, i.add = _C, i.asin = MC, i.asinh = OC, i.atan = qC, i.atanh = IC, i.atan2 = FC, i.cbrt = BC, i.ceil = RC, i.clamp = PC, i.cos = kC, i.cosh = zC, i.div = $C, i.exp = UC, i.floor = GC, i.hypot = HC, i.ln = QC, i.log = VC, i.log10 = jC, i.log2 = WC, i.max = YC, i.min = ZC, i.mod = JC, i.mul = XC, i.pow = KC, i.random = eT, i.round = tT, i.sign = rT, i.sin = nT, i.sinh = iT, i.sqrt = aT, i.sub = sT, i.sum = oT, i.tan = uT, i.tanh = lT, i.trunc = cT, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return i.config(t), i;
}
function $C(t, e) {
  return new this(t).div(e);
}
function UC(t) {
  return new this(t).exp();
}
function GC(t) {
  return je(t = new this(t), t.e + 1, 3);
}
function HC() {
  var t, e, r = new this(0);
  for (ut = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return ut = !0, new this(1 / 0);
      r = e;
    }
  return ut = !0, r.sqrt();
}
function jv(t) {
  return t instanceof vi || t && t.toStringTag === O2 || !1;
}
function QC(t) {
  return new this(t).ln();
}
function VC(t, e) {
  return new this(t).log(e);
}
function WC(t) {
  return new this(t).log(2);
}
function jC(t) {
  return new this(t).log(10);
}
function YC() {
  return B2(this, arguments, "lt");
}
function ZC() {
  return B2(this, arguments, "gt");
}
function JC(t, e) {
  return new this(t).mod(e);
}
function XC(t, e) {
  return new this(t).mul(e);
}
function KC(t, e) {
  return new this(t).pow(e);
}
function eT(t) {
  var e, r, n, i, a = 0, o = new this(1), f = [];
  if (t === void 0 ? t = this.precision : Zr(t, 1, Ni), n = Math.ceil(t / Ke), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); a < n; )
        i = e[a], i >= 429e7 ? e[a] = crypto.getRandomValues(new Uint32Array(1))[0] : f[a++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); a < n; )
        i = e[a] + (e[a + 1] << 8) + (e[a + 2] << 16) + ((e[a + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, a) : (f.push(i % 1e7), a += 4);
      a = n / 4;
    } else
      throw Error(M2);
  else for (; a < n; ) f[a++] = Math.random() * 1e7 | 0;
  for (n = f[--a], t %= Ke, n && t && (i = or(10, Ke - t), f[a] = (n / i | 0) * i); f[a] === 0; a--) f.pop();
  if (a < 0)
    r = 0, f = [0];
  else {
    for (r = -1; f[0] === 0; r -= Ke) f.shift();
    for (n = 1, i = f[0]; i >= 10; i /= 10) n++;
    n < Ke && (r -= Ke - n);
  }
  return o.e = r, o.d = f, o;
}
function tT(t) {
  return je(t = new this(t), t.e + 1, this.rounding);
}
function rT(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function nT(t) {
  return new this(t).sin();
}
function iT(t) {
  return new this(t).sinh();
}
function aT(t) {
  return new this(t).sqrt();
}
function sT(t, e) {
  return new this(t).sub(e);
}
function oT() {
  var t = 0, e = arguments, r = new this(e[t]);
  for (ut = !1; r.s && ++t < e.length; ) r = r.plus(e[t]);
  return ut = !0, je(r, this.precision, this.rounding);
}
function uT(t) {
  return new this(t).tan();
}
function lT(t) {
  return new this(t).tanh();
}
function cT(t) {
  return je(t = new this(t), t.e + 1, 1);
}
qe[Symbol.for("nodejs.util.inspect.custom")] = qe.toString;
qe[Symbol.toStringTag] = "Decimal";
var vi = qe.constructor = L2(Gh);
Vo = new vi(Vo);
Wo = new vi(Wo);
var fT = "BigNumber", pT = ["?on", "config"], Au = /* @__PURE__ */ H(fT, pT, (t) => {
  var {
    on: e,
    config: r
  } = t, n = vi.clone({
    precision: r.precision,
    modulo: vi.EUCLID
  });
  return n.prototype = Object.create(n.prototype), n.prototype.type = "BigNumber", n.prototype.isBigNumber = !0, n.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  }, n.fromJSON = function(i) {
    return new n(i.value);
  }, e && e("config", function(i, a) {
    i.precision !== a.precision && n.config({
      precision: i.precision
    });
  }), n;
}, {
  isClass: !0
}), Ki = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qs(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function mT(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var k2 = { exports: {} };
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(t, e) {
  (function(r) {
    var n = Math.cosh || function(l) {
      return Math.abs(l) < 1e-9 ? 1 - l : (Math.exp(l) + Math.exp(-l)) * 0.5;
    }, i = Math.sinh || function(l) {
      return Math.abs(l) < 1e-9 ? l : (Math.exp(l) - Math.exp(-l)) * 0.5;
    }, a = function(l) {
      var m = Math.PI / 4;
      if (-m > l || l > m)
        return Math.cos(l) - 1;
      var h = l * l;
      return h * (h * (h * (h * (h * (h * (h * (h / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
    }, o = function(l, m) {
      var h = Math.abs(l), g = Math.abs(m);
      return h < 3e3 && g < 3e3 ? Math.sqrt(h * h + g * g) : (h < g ? (h = g, g = l / m) : g = m / l, h * Math.sqrt(1 + g * g));
    }, f = function() {
      throw SyntaxError("Invalid Param");
    };
    function u(l, m) {
      var h = Math.abs(l), g = Math.abs(m);
      return l === 0 ? Math.log(g) : m === 0 ? Math.log(h) : h < 3e3 && g < 3e3 ? Math.log(l * l + m * m) * 0.5 : (l = l / 2, m = m / 2, 0.5 * Math.log(l * l + m * m) + Math.LN2);
    }
    var s = function(l, m) {
      var h = { re: 0, im: 0 };
      if (l == null)
        h.re = h.im = 0;
      else if (m !== void 0)
        h.re = l, h.im = m;
      else
        switch (typeof l) {
          case "object":
            if ("im" in l && "re" in l)
              h.re = l.re, h.im = l.im;
            else if ("abs" in l && "arg" in l) {
              if (!Number.isFinite(l.abs) && Number.isFinite(l.arg))
                return c.INFINITY;
              h.re = l.abs * Math.cos(l.arg), h.im = l.abs * Math.sin(l.arg);
            } else if ("r" in l && "phi" in l) {
              if (!Number.isFinite(l.r) && Number.isFinite(l.phi))
                return c.INFINITY;
              h.re = l.r * Math.cos(l.phi), h.im = l.r * Math.sin(l.phi);
            } else l.length === 2 ? (h.re = l[0], h.im = l[1]) : f();
            break;
          case "string":
            h.im = /* void */
            h.re = 0;
            var g = l.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), d = 1, y = 0;
            g === null && f();
            for (var w = 0; w < g.length; w++) {
              var E = g[w];
              E === " " || E === "	" || E === `
` || (E === "+" ? d++ : E === "-" ? y++ : E === "i" || E === "I" ? (d + y === 0 && f(), g[w + 1] !== " " && !isNaN(g[w + 1]) ? (h.im += parseFloat((y % 2 ? "-" : "") + g[w + 1]), w++) : h.im += parseFloat((y % 2 ? "-" : "") + "1"), d = y = 0) : ((d + y === 0 || isNaN(E)) && f(), g[w + 1] === "i" || g[w + 1] === "I" ? (h.im += parseFloat((y % 2 ? "-" : "") + E), w++) : h.re += parseFloat((y % 2 ? "-" : "") + E), d = y = 0));
            }
            d + y > 0 && f();
            break;
          case "number":
            h.im = 0, h.re = l;
            break;
          default:
            f();
        }
      return isNaN(h.re) || isNaN(h.im), h;
    };
    function c(l, m) {
      if (!(this instanceof c))
        return new c(l, m);
      var h = s(l, m);
      this.re = h.re, this.im = h.im;
    }
    c.prototype = {
      re: 0,
      im: 0,
      /**
       * Calculates the sign of a complex number, which is a normalized complex
       *
       * @returns {Complex}
       */
      sign: function() {
        var l = this.abs();
        return new c(
          this.re / l,
          this.im / l
        );
      },
      /**
       * Adds two complex numbers
       *
       * @returns {Complex}
       */
      add: function(l, m) {
        var h = new c(l, m);
        return this.isInfinite() && h.isInfinite() ? c.NAN : this.isInfinite() || h.isInfinite() ? c.INFINITY : new c(
          this.re + h.re,
          this.im + h.im
        );
      },
      /**
       * Subtracts two complex numbers
       *
       * @returns {Complex}
       */
      sub: function(l, m) {
        var h = new c(l, m);
        return this.isInfinite() && h.isInfinite() ? c.NAN : this.isInfinite() || h.isInfinite() ? c.INFINITY : new c(
          this.re - h.re,
          this.im - h.im
        );
      },
      /**
       * Multiplies two complex numbers
       *
       * @returns {Complex}
       */
      mul: function(l, m) {
        var h = new c(l, m);
        return this.isInfinite() && h.isZero() || this.isZero() && h.isInfinite() ? c.NAN : this.isInfinite() || h.isInfinite() ? c.INFINITY : h.im === 0 && this.im === 0 ? new c(this.re * h.re, 0) : new c(
          this.re * h.re - this.im * h.im,
          this.re * h.im + this.im * h.re
        );
      },
      /**
       * Divides two complex numbers
       *
       * @returns {Complex}
       */
      div: function(l, m) {
        var h = new c(l, m);
        if (this.isZero() && h.isZero() || this.isInfinite() && h.isInfinite())
          return c.NAN;
        if (this.isInfinite() || h.isZero())
          return c.INFINITY;
        if (this.isZero() || h.isInfinite())
          return c.ZERO;
        l = this.re, m = this.im;
        var g = h.re, d = h.im, y, w;
        return d === 0 ? new c(l / g, m / g) : Math.abs(g) < Math.abs(d) ? (w = g / d, y = g * w + d, new c(
          (l * w + m) / y,
          (m * w - l) / y
        )) : (w = d / g, y = d * w + g, new c(
          (l + m * w) / y,
          (m - l * w) / y
        ));
      },
      /**
       * Calculate the power of two complex numbers
       *
       * @returns {Complex}
       */
      pow: function(l, m) {
        var h = new c(l, m);
        if (l = this.re, m = this.im, h.isZero())
          return c.ONE;
        if (h.im === 0) {
          if (m === 0 && l > 0)
            return new c(Math.pow(l, h.re), 0);
          if (l === 0)
            switch ((h.re % 4 + 4) % 4) {
              case 0:
                return new c(Math.pow(m, h.re), 0);
              case 1:
                return new c(0, Math.pow(m, h.re));
              case 2:
                return new c(-Math.pow(m, h.re), 0);
              case 3:
                return new c(0, -Math.pow(m, h.re));
            }
        }
        if (l === 0 && m === 0 && h.re > 0 && h.im >= 0)
          return c.ZERO;
        var g = Math.atan2(m, l), d = u(l, m);
        return l = Math.exp(h.re * d - h.im * g), m = h.im * d + h.re * g, new c(
          l * Math.cos(m),
          l * Math.sin(m)
        );
      },
      /**
       * Calculate the complex square root
       *
       * @returns {Complex}
       */
      sqrt: function() {
        var l = this.re, m = this.im, h = this.abs(), g, d;
        if (l >= 0) {
          if (m === 0)
            return new c(Math.sqrt(l), 0);
          g = 0.5 * Math.sqrt(2 * (h + l));
        } else
          g = Math.abs(m) / Math.sqrt(2 * (h - l));
        return l <= 0 ? d = 0.5 * Math.sqrt(2 * (h - l)) : d = Math.abs(m) / Math.sqrt(2 * (h + l)), new c(g, m < 0 ? -d : d);
      },
      /**
       * Calculate the complex exponent
       *
       * @returns {Complex}
       */
      exp: function() {
        var l = Math.exp(this.re);
        return this.im, new c(
          l * Math.cos(this.im),
          l * Math.sin(this.im)
        );
      },
      /**
       * Calculate the complex exponent and subtracts one.
       *
       * This may be more accurate than `Complex(x).exp().sub(1)` if
       * `x` is small.
       *
       * @returns {Complex}
       */
      expm1: function() {
        var l = this.re, m = this.im;
        return new c(
          Math.expm1(l) * Math.cos(m) + a(m),
          Math.exp(l) * Math.sin(m)
        );
      },
      /**
       * Calculate the natural log
       *
       * @returns {Complex}
       */
      log: function() {
        var l = this.re, m = this.im;
        return new c(
          u(l, m),
          Math.atan2(m, l)
        );
      },
      /**
       * Calculate the magnitude of the complex number
       *
       * @returns {number}
       */
      abs: function() {
        return o(this.re, this.im);
      },
      /**
       * Calculate the angle of the complex number
       *
       * @returns {number}
       */
      arg: function() {
        return Math.atan2(this.im, this.re);
      },
      /**
       * Calculate the sine of the complex number
       *
       * @returns {Complex}
       */
      sin: function() {
        var l = this.re, m = this.im;
        return new c(
          Math.sin(l) * n(m),
          Math.cos(l) * i(m)
        );
      },
      /**
       * Calculate the cosine
       *
       * @returns {Complex}
       */
      cos: function() {
        var l = this.re, m = this.im;
        return new c(
          Math.cos(l) * n(m),
          -Math.sin(l) * i(m)
        );
      },
      /**
       * Calculate the tangent
       *
       * @returns {Complex}
       */
      tan: function() {
        var l = 2 * this.re, m = 2 * this.im, h = Math.cos(l) + n(m);
        return new c(
          Math.sin(l) / h,
          i(m) / h
        );
      },
      /**
       * Calculate the cotangent
       *
       * @returns {Complex}
       */
      cot: function() {
        var l = 2 * this.re, m = 2 * this.im, h = Math.cos(l) - n(m);
        return new c(
          -Math.sin(l) / h,
          i(m) / h
        );
      },
      /**
       * Calculate the secant
       *
       * @returns {Complex}
       */
      sec: function() {
        var l = this.re, m = this.im, h = 0.5 * n(2 * m) + 0.5 * Math.cos(2 * l);
        return new c(
          Math.cos(l) * n(m) / h,
          Math.sin(l) * i(m) / h
        );
      },
      /**
       * Calculate the cosecans
       *
       * @returns {Complex}
       */
      csc: function() {
        var l = this.re, m = this.im, h = 0.5 * n(2 * m) - 0.5 * Math.cos(2 * l);
        return new c(
          Math.sin(l) * n(m) / h,
          -Math.cos(l) * i(m) / h
        );
      },
      /**
       * Calculate the complex arcus sinus
       *
       * @returns {Complex}
       */
      asin: function() {
        var l = this.re, m = this.im, h = new c(
          m * m - l * l + 1,
          -2 * l * m
        ).sqrt(), g = new c(
          h.re - m,
          h.im + l
        ).log();
        return new c(g.im, -g.re);
      },
      /**
       * Calculate the complex arcus cosinus
       *
       * @returns {Complex}
       */
      acos: function() {
        var l = this.re, m = this.im, h = new c(
          m * m - l * l + 1,
          -2 * l * m
        ).sqrt(), g = new c(
          h.re - m,
          h.im + l
        ).log();
        return new c(Math.PI / 2 - g.im, g.re);
      },
      /**
       * Calculate the complex arcus tangent
       *
       * @returns {Complex}
       */
      atan: function() {
        var l = this.re, m = this.im;
        if (l === 0) {
          if (m === 1)
            return new c(0, 1 / 0);
          if (m === -1)
            return new c(0, -1 / 0);
        }
        var h = l * l + (1 - m) * (1 - m), g = new c(
          (1 - m * m - l * l) / h,
          -2 * l / h
        ).log();
        return new c(-0.5 * g.im, 0.5 * g.re);
      },
      /**
       * Calculate the complex arcus cotangent
       *
       * @returns {Complex}
       */
      acot: function() {
        var l = this.re, m = this.im;
        if (m === 0)
          return new c(Math.atan2(1, l), 0);
        var h = l * l + m * m;
        return h !== 0 ? new c(
          l / h,
          -m / h
        ).atan() : new c(
          l !== 0 ? l / 0 : 0,
          m !== 0 ? -m / 0 : 0
        ).atan();
      },
      /**
       * Calculate the complex arcus secant
       *
       * @returns {Complex}
       */
      asec: function() {
        var l = this.re, m = this.im;
        if (l === 0 && m === 0)
          return new c(0, 1 / 0);
        var h = l * l + m * m;
        return h !== 0 ? new c(
          l / h,
          -m / h
        ).acos() : new c(
          l !== 0 ? l / 0 : 0,
          m !== 0 ? -m / 0 : 0
        ).acos();
      },
      /**
       * Calculate the complex arcus cosecans
       *
       * @returns {Complex}
       */
      acsc: function() {
        var l = this.re, m = this.im;
        if (l === 0 && m === 0)
          return new c(Math.PI / 2, 1 / 0);
        var h = l * l + m * m;
        return h !== 0 ? new c(
          l / h,
          -m / h
        ).asin() : new c(
          l !== 0 ? l / 0 : 0,
          m !== 0 ? -m / 0 : 0
        ).asin();
      },
      /**
       * Calculate the complex sinh
       *
       * @returns {Complex}
       */
      sinh: function() {
        var l = this.re, m = this.im;
        return new c(
          i(l) * Math.cos(m),
          n(l) * Math.sin(m)
        );
      },
      /**
       * Calculate the complex cosh
       *
       * @returns {Complex}
       */
      cosh: function() {
        var l = this.re, m = this.im;
        return new c(
          n(l) * Math.cos(m),
          i(l) * Math.sin(m)
        );
      },
      /**
       * Calculate the complex tanh
       *
       * @returns {Complex}
       */
      tanh: function() {
        var l = 2 * this.re, m = 2 * this.im, h = n(l) + Math.cos(m);
        return new c(
          i(l) / h,
          Math.sin(m) / h
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      coth: function() {
        var l = 2 * this.re, m = 2 * this.im, h = n(l) - Math.cos(m);
        return new c(
          i(l) / h,
          -Math.sin(m) / h
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      csch: function() {
        var l = this.re, m = this.im, h = Math.cos(2 * m) - n(2 * l);
        return new c(
          -2 * i(l) * Math.cos(m) / h,
          2 * n(l) * Math.sin(m) / h
        );
      },
      /**
       * Calculate the complex sech
       *
       * @returns {Complex}
       */
      sech: function() {
        var l = this.re, m = this.im, h = Math.cos(2 * m) + n(2 * l);
        return new c(
          2 * n(l) * Math.cos(m) / h,
          -2 * i(l) * Math.sin(m) / h
        );
      },
      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      asinh: function() {
        var l = this.im;
        this.im = -this.re, this.re = l;
        var m = this.asin();
        return this.re = -this.im, this.im = l, l = m.re, m.re = -m.im, m.im = l, m;
      },
      /**
       * Calculate the complex acosh
       *
       * @returns {Complex}
       */
      acosh: function() {
        var l = this.acos();
        if (l.im <= 0) {
          var m = l.re;
          l.re = -l.im, l.im = m;
        } else {
          var m = l.im;
          l.im = -l.re, l.re = m;
        }
        return l;
      },
      /**
       * Calculate the complex atanh
       *
       * @returns {Complex}
       */
      atanh: function() {
        var l = this.re, m = this.im, h = l > 1 && m === 0, g = 1 - l, d = 1 + l, y = g * g + m * m, w = y !== 0 ? new c(
          (d * g - m * m) / y,
          (m * g + d * m) / y
        ) : new c(
          l !== -1 ? l / 0 : 0,
          m !== 0 ? m / 0 : 0
        ), E = w.re;
        return w.re = u(w.re, w.im) / 2, w.im = Math.atan2(w.im, E) / 2, h && (w.im = -w.im), w;
      },
      /**
       * Calculate the complex acoth
       *
       * @returns {Complex}
       */
      acoth: function() {
        var l = this.re, m = this.im;
        if (l === 0 && m === 0)
          return new c(0, Math.PI / 2);
        var h = l * l + m * m;
        return h !== 0 ? new c(
          l / h,
          -m / h
        ).atanh() : new c(
          l !== 0 ? l / 0 : 0,
          m !== 0 ? -m / 0 : 0
        ).atanh();
      },
      /**
       * Calculate the complex acsch
       *
       * @returns {Complex}
       */
      acsch: function() {
        var l = this.re, m = this.im;
        if (m === 0)
          return new c(
            l !== 0 ? Math.log(l + Math.sqrt(l * l + 1)) : 1 / 0,
            0
          );
        var h = l * l + m * m;
        return h !== 0 ? new c(
          l / h,
          -m / h
        ).asinh() : new c(
          l !== 0 ? l / 0 : 0,
          m !== 0 ? -m / 0 : 0
        ).asinh();
      },
      /**
       * Calculate the complex asech
       *
       * @returns {Complex}
       */
      asech: function() {
        var l = this.re, m = this.im;
        if (this.isZero())
          return c.INFINITY;
        var h = l * l + m * m;
        return h !== 0 ? new c(
          l / h,
          -m / h
        ).acosh() : new c(
          l !== 0 ? l / 0 : 0,
          m !== 0 ? -m / 0 : 0
        ).acosh();
      },
      /**
       * Calculate the complex inverse 1/z
       *
       * @returns {Complex}
       */
      inverse: function() {
        if (this.isZero())
          return c.INFINITY;
        if (this.isInfinite())
          return c.ZERO;
        var l = this.re, m = this.im, h = l * l + m * m;
        return new c(l / h, -m / h);
      },
      /**
       * Returns the complex conjugate
       *
       * @returns {Complex}
       */
      conjugate: function() {
        return new c(this.re, -this.im);
      },
      /**
       * Gets the negated complex number
       *
       * @returns {Complex}
       */
      neg: function() {
        return new c(-this.re, -this.im);
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      ceil: function(l) {
        return l = Math.pow(10, l || 0), new c(
          Math.ceil(this.re * l) / l,
          Math.ceil(this.im * l) / l
        );
      },
      /**
       * Floors the actual complex number
       *
       * @returns {Complex}
       */
      floor: function(l) {
        return l = Math.pow(10, l || 0), new c(
          Math.floor(this.re * l) / l,
          Math.floor(this.im * l) / l
        );
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      round: function(l) {
        return l = Math.pow(10, l || 0), new c(
          Math.round(this.re * l) / l,
          Math.round(this.im * l) / l
        );
      },
      /**
       * Compares two complex numbers
       *
       * **Note:** new Complex(Infinity).equals(Infinity) === false
       *
       * @returns {boolean}
       */
      equals: function(l, m) {
        var h = new c(l, m);
        return Math.abs(h.re - this.re) <= c.EPSILON && Math.abs(h.im - this.im) <= c.EPSILON;
      },
      /**
       * Clones the actual object
       *
       * @returns {Complex}
       */
      clone: function() {
        return new c(this.re, this.im);
      },
      /**
       * Gets a string of the actual complex number
       *
       * @returns {string}
       */
      toString: function() {
        var l = this.re, m = this.im, h = "";
        return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(l) < c.EPSILON && (l = 0), Math.abs(m) < c.EPSILON && (m = 0), m === 0 ? h + l : (l !== 0 ? (h += l, h += " ", m < 0 ? (m = -m, h += "-") : h += "+", h += " ") : m < 0 && (m = -m, h += "-"), m !== 1 && (h += m), h + "i"));
      },
      /**
       * Returns the actual number as a vector
       *
       * @returns {Array}
       */
      toVector: function() {
        return [this.re, this.im];
      },
      /**
       * Returns the actual real value of the current object
       *
       * @returns {number|null}
       */
      valueOf: function() {
        return this.im === 0 ? this.re : null;
      },
      /**
       * Determines whether a complex number is not on the Riemann sphere.
       *
       * @returns {boolean}
       */
      isNaN: function() {
        return isNaN(this.re) || isNaN(this.im);
      },
      /**
       * Determines whether or not a complex number is at the zero pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isZero: function() {
        return this.im === 0 && this.re === 0;
      },
      /**
       * Determines whether a complex number is not at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isFinite: function() {
        return isFinite(this.re) && isFinite(this.im);
      },
      /**
       * Determines whether or not a complex number is at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isInfinite: function() {
        return !(this.isNaN() || this.isFinite());
      }
    }, c.ZERO = new c(0, 0), c.ONE = new c(1, 0), c.I = new c(0, 1), c.PI = new c(Math.PI, 0), c.E = new c(Math.E, 0), c.INFINITY = new c(1 / 0, 1 / 0), c.NAN = new c(NaN, NaN), c.EPSILON = 1e-15, Object.defineProperty(c, "__esModule", { value: !0 }), c.default = c, c.Complex = c, t.exports = c;
  })();
})(k2);
var hT = k2.exports;
const br = /* @__PURE__ */ qs(hT);
var dT = "Complex", gT = [], Cu = /* @__PURE__ */ H(dT, gT, () => (Object.defineProperty(br, "name", {
  value: "Complex"
}), br.prototype.constructor = br, br.prototype.type = "Complex", br.prototype.isComplex = !0, br.prototype.toJSON = function() {
  return {
    mathjs: "Complex",
    re: this.re,
    im: this.im
  };
}, br.prototype.toPolar = function() {
  return {
    r: this.abs(),
    phi: this.arg()
  };
}, br.prototype.format = function(t) {
  var e = "", r = this.im, n = this.re, i = Vi(this.re, t), a = Vi(this.im, t), o = ot(t) ? t : t ? t.precision : null;
  if (o !== null) {
    var f = Math.pow(10, -o);
    Math.abs(n / r) < f && (n = 0), Math.abs(r / n) < f && (r = 0);
  }
  return r === 0 ? e = i : n === 0 ? r === 1 ? e = "i" : r === -1 ? e = "-i" : e = a + "i" : r < 0 ? r === -1 ? e = i + " - i" : e = i + " - " + a.substring(1) + "i" : r === 1 ? e = i + " + i" : e = i + " + " + a + "i", e;
}, br.fromPolar = function(t) {
  switch (arguments.length) {
    case 1: {
      var e = arguments[0];
      if (typeof e == "object")
        return br(e);
      throw new TypeError("Input has to be an object with r and phi keys.");
    }
    case 2: {
      var r = arguments[0], n = arguments[1];
      if (ot(r)) {
        if (Lr(n) && n.hasBase("ANGLE") && (n = n.toNumber("rad")), ot(n))
          return new br({
            r,
            phi: n
          });
        throw new TypeError("Phi is not a number nor an angle unit.");
      } else
        throw new TypeError("Radius r is not a number.");
    }
    default:
      throw new SyntaxError("Wrong number of arguments in function fromPolar");
  }
}, br.prototype.valueOf = br.prototype.toString, br.fromJSON = function(t) {
  return new br(t);
}, br.compare = function(t, e) {
  return t.re > e.re ? 1 : t.re < e.re ? -1 : t.im > e.im ? 1 : t.im < e.im ? -1 : 0;
}, br), {
  isClass: !0
});
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
var vT = 2e3, He = {
  s: 1,
  n: 0,
  d: 1
};
function Vn(t, e) {
  if (isNaN(t = parseInt(t, 10)))
    throw Qo();
  return t * e;
}
function Jt(t, e) {
  if (e === 0)
    throw Dd();
  var r = Object.create(Or.prototype);
  r.s = t < 0 ? -1 : 1, t = t < 0 ? -t : t;
  var n = Na(t, e);
  return r.n = t / n, r.d = e / n, r;
}
function Yv(t) {
  for (var e = {}, r = t, n = 2, i = 4; i <= r; ) {
    for (; r % n === 0; )
      r /= n, e[n] = (e[n] || 0) + 1;
    i += 1 + 2 * n++;
  }
  return r !== t ? r > 1 && (e[r] = (e[r] || 0) + 1) : e[t] = (e[t] || 0) + 1, e;
}
var tn = function(t, e) {
  var r = 0, n = 1, i = 1, a = 0, o = 0, f = 0, u = 1, s = 1, c = 0, l = 1, m = 1, h = 1, g = 1e7, d;
  if (t != null) if (e !== void 0) {
    if (r = t, n = e, i = r * n, r % 1 !== 0 || n % 1 !== 0)
      throw wT();
  } else
    switch (typeof t) {
      case "object": {
        if ("d" in t && "n" in t)
          r = t.n, n = t.d, "s" in t && (r *= t.s);
        else if (0 in t)
          r = t[0], 1 in t && (n = t[1]);
        else
          throw Qo();
        i = r * n;
        break;
      }
      case "number": {
        if (t < 0 && (i = t, t = -t), t % 1 === 0)
          r = t;
        else if (t > 0) {
          for (t >= 1 && (s = Math.pow(10, Math.floor(1 + Math.log(t) / Math.LN10)), t /= s); l <= g && h <= g; )
            if (d = (c + m) / (l + h), t === d) {
              l + h <= g ? (r = c + m, n = l + h) : h > l ? (r = m, n = h) : (r = c, n = l);
              break;
            } else
              t > d ? (c += m, l += h) : (m += c, h += l), l > g ? (r = m, n = h) : (r = c, n = l);
          r *= s;
        } else (isNaN(t) || isNaN(e)) && (n = r = NaN);
        break;
      }
      case "string": {
        if (l = t.match(/\d+|./g), l === null)
          throw Qo();
        if (l[c] === "-" ? (i = -1, c++) : l[c] === "+" && c++, l.length === c + 1 ? o = Vn(l[c++], i) : l[c + 1] === "." || l[c] === "." ? (l[c] !== "." && (a = Vn(l[c++], i)), c++, (c + 1 === l.length || l[c + 1] === "(" && l[c + 3] === ")" || l[c + 1] === "'" && l[c + 3] === "'") && (o = Vn(l[c], i), u = Math.pow(10, l[c].length), c++), (l[c] === "(" && l[c + 2] === ")" || l[c] === "'" && l[c + 2] === "'") && (f = Vn(l[c + 1], i), s = Math.pow(10, l[c + 1].length) - 1, c += 3)) : l[c + 1] === "/" || l[c + 1] === ":" ? (o = Vn(l[c], i), u = Vn(l[c + 2], 1), c += 3) : l[c + 3] === "/" && l[c + 1] === " " && (a = Vn(l[c], i), o = Vn(l[c + 2], i), u = Vn(l[c + 4], 1), c += 5), l.length <= c) {
          n = u * s, i = /* void */
          r = f + n * a + s * o;
          break;
        }
      }
      default:
        throw Qo();
    }
  if (n === 0)
    throw Dd();
  He.s = i < 0 ? -1 : 1, He.n = Math.abs(r), He.d = Math.abs(n);
};
function yT(t, e, r) {
  for (var n = 1; e > 0; t = t * t % r, e >>= 1)
    e & 1 && (n = n * t % r);
  return n;
}
function xT(t, e) {
  for (; e % 2 === 0; e /= 2)
    ;
  for (; e % 5 === 0; e /= 5)
    ;
  if (e === 1)
    return 0;
  for (var r = 10 % e, n = 1; r !== 1; n++)
    if (r = r * 10 % e, n > vT)
      return 0;
  return n;
}
function bT(t, e, r) {
  for (var n = 1, i = yT(10, r, e), a = 0; a < 300; a++) {
    if (n === i)
      return a;
    n = n * 10 % e, i = i * 10 % e;
  }
  return 0;
}
function Na(t, e) {
  if (!t)
    return e;
  if (!e)
    return t;
  for (; ; ) {
    if (t %= e, !t)
      return e;
    if (e %= t, !e)
      return t;
  }
}
function Or(t, e) {
  if (tn(t, e), this instanceof Or)
    t = Na(He.d, He.n), this.s = He.s, this.n = He.n / t, this.d = He.d / t;
  else
    return Jt(He.s * He.n, He.d);
}
var Dd = function() {
  return new Error("Division by Zero");
}, Qo = function() {
  return new Error("Invalid argument");
}, wT = function() {
  return new Error("Parameters must be integer");
};
Or.prototype = {
  s: 1,
  n: 0,
  d: 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return Jt(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return Jt(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(t, e) {
    return tn(t, e), Jt(
      this.s * this.n * He.d + He.s * this.d * He.n,
      this.d * He.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(t, e) {
    return tn(t, e), Jt(
      this.s * this.n * He.d - He.s * this.d * He.n,
      this.d * He.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(t, e) {
    return tn(t, e), Jt(
      this.s * He.s * this.n * He.n,
      this.d * He.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(t, e) {
    return tn(t, e), Jt(
      this.s * He.s * this.n * He.d,
      this.d * He.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return Jt(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  mod: function(t, e) {
    if (isNaN(this.n) || isNaN(this.d))
      return new Or(NaN);
    if (t === void 0)
      return Jt(this.s * this.n % this.d, 1);
    if (tn(t, e), He.n === 0 && this.d === 0)
      throw Dd();
    return Jt(
      this.s * (He.d * this.n) % (He.n * this.d),
      He.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(t, e) {
    return tn(t, e), Jt(Na(He.n, this.n) * Na(He.d, this.d), He.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(t, e) {
    return tn(t, e), He.n === 0 && this.n === 0 ? Jt(0, 1) : Jt(He.n * this.n, Na(He.n, this.n) * Na(He.d, this.d));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(t) {
    return t = Math.pow(10, t || 0), isNaN(this.n) || isNaN(this.d) ? new Or(NaN) : Jt(Math.ceil(t * this.s * this.n / this.d), t);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(t) {
    return t = Math.pow(10, t || 0), isNaN(this.n) || isNaN(this.d) ? new Or(NaN) : Jt(Math.floor(t * this.s * this.n / this.d), t);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(t) {
    return t = Math.pow(10, t || 0), isNaN(this.n) || isNaN(this.d) ? new Or(NaN) : Jt(Math.round(t * this.s * this.n / this.d), t);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  roundTo: function(t, e) {
    return tn(t, e), Jt(this.s * Math.round(this.n * He.d / (this.d * He.n)) * He.n, He.d);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return Jt(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(t, e) {
    if (tn(t, e), He.d === 1)
      return He.s < 0 ? Jt(Math.pow(this.s * this.d, He.n), Math.pow(this.n, He.n)) : Jt(Math.pow(this.s * this.n, He.n), Math.pow(this.d, He.n));
    if (this.s < 0) return null;
    var r = Yv(this.n), n = Yv(this.d), i = 1, a = 1;
    for (var o in r)
      if (o !== "1") {
        if (o === "0") {
          i = 0;
          break;
        }
        if (r[o] *= He.n, r[o] % He.d === 0)
          r[o] /= He.d;
        else return null;
        i *= Math.pow(o, r[o]);
      }
    for (var o in n)
      if (o !== "1") {
        if (n[o] *= He.n, n[o] % He.d === 0)
          n[o] /= He.d;
        else return null;
        a *= Math.pow(o, n[o]);
      }
    return He.s < 0 ? Jt(a, i) : Jt(i, a);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(t, e) {
    return tn(t, e), this.s * this.n * He.d === He.s * He.n * this.d;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  compare: function(t, e) {
    tn(t, e);
    var r = this.s * this.n * He.d - He.s * He.n * this.d;
    return (0 < r) - (r < 0);
  },
  simplify: function(t) {
    if (isNaN(this.n) || isNaN(this.d))
      return this;
    t = t || 1e-3;
    for (var e = this.abs(), r = e.toContinued(), n = 1; n < r.length; n++) {
      for (var i = Jt(r[n - 1], 1), a = n - 2; a >= 0; a--)
        i = i.inverse().add(r[a]);
      if (Math.abs(i.sub(e).valueOf()) < t)
        return i.mul(this.s);
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(t, e) {
    return tn(t, e), !(!(He.n * this.d) || this.n * He.d % (He.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return this.s * this.n / this.d;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  toFraction: function(t) {
    var e, r = "", n = this.n, i = this.d;
    return this.s < 0 && (r += "-"), i === 1 ? r += n : (t && (e = Math.floor(n / i)) > 0 && (r += e, r += " ", n %= i), r += n, r += "/", r += i), r;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(t) {
    var e, r = "", n = this.n, i = this.d;
    return this.s < 0 && (r += "-"), i === 1 ? r += n : (t && (e = Math.floor(n / i)) > 0 && (r += e, n %= i), r += "\\frac{", r += n, r += "}{", r += i, r += "}"), r;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    var t, e = this.n, r = this.d, n = [];
    if (isNaN(e) || isNaN(r))
      return n;
    do
      n.push(Math.floor(e / r)), t = e % r, e = r, r = t;
    while (e !== 1);
    return n;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(t) {
    var e = this.n, r = this.d;
    if (isNaN(e) || isNaN(r))
      return "NaN";
    t = t || 15;
    var n = xT(e, r), i = bT(e, r, n), a = this.s < 0 ? "-" : "";
    if (a += e / r | 0, e %= r, e *= 10, e && (a += "."), n) {
      for (var o = i; o--; )
        a += e / r | 0, e %= r, e *= 10;
      a += "(";
      for (var o = n; o--; )
        a += e / r | 0, e %= r, e *= 10;
      a += ")";
    } else
      for (var o = t; e && o--; )
        a += e / r | 0, e %= r, e *= 10;
    return a;
  }
};
var NT = "Fraction", DT = [], Tu = /* @__PURE__ */ H(NT, DT, () => (Object.defineProperty(Or, "name", {
  value: "Fraction"
}), Or.prototype.constructor = Or, Or.prototype.type = "Fraction", Or.prototype.isFraction = !0, Or.prototype.toJSON = function() {
  return {
    mathjs: "Fraction",
    n: this.s * this.n,
    d: this.d
  };
}, Or.fromJSON = function(t) {
  return new Or(t);
}, Or), {
  isClass: !0
}), ET = "Range", ST = [], _u = /* @__PURE__ */ H(ET, ST, () => {
  function t(e, r, n) {
    if (!(this instanceof t))
      throw new SyntaxError("Constructor must be called with the new operator");
    var i = e != null, a = r != null, o = n != null;
    if (i) {
      if (at(e))
        e = e.toNumber();
      else if (typeof e != "number")
        throw new TypeError("Parameter start must be a number");
    }
    if (a) {
      if (at(r))
        r = r.toNumber();
      else if (typeof r != "number")
        throw new TypeError("Parameter end must be a number");
    }
    if (o) {
      if (at(n))
        n = n.toNumber();
      else if (typeof n != "number")
        throw new TypeError("Parameter step must be a number");
    }
    this.start = i ? parseFloat(e) : 0, this.end = a ? parseFloat(r) : 0, this.step = o ? parseFloat(n) : 1;
  }
  return t.prototype.type = "Range", t.prototype.isRange = !0, t.parse = function(e) {
    if (typeof e != "string")
      return null;
    var r = e.split(":"), n = r.map(function(a) {
      return parseFloat(a);
    }), i = n.some(function(a) {
      return isNaN(a);
    });
    if (i)
      return null;
    switch (n.length) {
      case 2:
        return new t(n[0], n[1]);
      case 3:
        return new t(n[0], n[2], n[1]);
      default:
        return null;
    }
  }, t.prototype.clone = function() {
    return new t(this.start, this.end, this.step);
  }, t.prototype.size = function() {
    var e = 0, r = this.start, n = this.step, i = this.end, a = i - r;
    return hi(n) === hi(a) ? e = Math.ceil(a / n) : a === 0 && (e = 0), isNaN(e) && (e = 0), [e];
  }, t.prototype.min = function() {
    var e = this.size()[0];
    if (e > 0)
      return this.step > 0 ? this.start : this.start + (e - 1) * this.step;
  }, t.prototype.max = function() {
    var e = this.size()[0];
    if (e > 0)
      return this.step > 0 ? this.start + (e - 1) * this.step : this.start;
  }, t.prototype.forEach = function(e) {
    var r = this.start, n = this.step, i = this.end, a = 0;
    if (n > 0)
      for (; r < i; )
        e(r, [a], this), r += n, a++;
    else if (n < 0)
      for (; r > i; )
        e(r, [a], this), r += n, a++;
  }, t.prototype.map = function(e) {
    var r = [];
    return this.forEach(function(n, i, a) {
      r[i[0]] = e(n, i, a);
    }), r;
  }, t.prototype.toArray = function() {
    var e = [];
    return this.forEach(function(r, n) {
      e[n[0]] = r;
    }), e;
  }, t.prototype.valueOf = function() {
    return this.toArray();
  }, t.prototype.format = function(e) {
    var r = Vi(this.start, e);
    return this.step !== 1 && (r += ":" + Vi(this.step, e)), r += ":" + Vi(this.end, e), r;
  }, t.prototype.toString = function() {
    return this.format();
  }, t.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  }, t.fromJSON = function(e) {
    return new t(e.start, e.end, e.step);
  }, t;
}, {
  isClass: !0
}), AT = "Matrix", CT = [], Mu = /* @__PURE__ */ H(AT, CT, () => {
  function t() {
    if (!(this instanceof t))
      throw new SyntaxError("Constructor must be called with the new operator");
  }
  return t.prototype.type = "Matrix", t.prototype.isMatrix = !0, t.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  }, t.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  }, t.prototype.create = function(e, r) {
    throw new Error("Cannot invoke create on a Matrix interface");
  }, t.prototype.subset = function(e, r, n) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  }, t.prototype.get = function(e) {
    throw new Error("Cannot invoke get on a Matrix interface");
  }, t.prototype.set = function(e, r, n) {
    throw new Error("Cannot invoke set on a Matrix interface");
  }, t.prototype.resize = function(e, r) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  }, t.prototype.reshape = function(e, r) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  }, t.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  }, t.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  }, t.prototype.map = function(e, r) {
    throw new Error("Cannot invoke map on a Matrix interface");
  }, t.prototype.forEach = function(e) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  }, t.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  }, t.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  }, t.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  }, t.prototype.format = function(e) {
    throw new Error("Cannot invoke format on a Matrix interface");
  }, t.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  }, t;
}, {
  isClass: !0
});
function qh(t, e, r) {
  var n = t.constructor, i = new n(2), a = "";
  if (r) {
    if (r < 1)
      throw new Error("size must be in greater than 0");
    if (!Ve(r))
      throw new Error("size must be an integer");
    if (t.greaterThan(i.pow(r - 1).sub(1)) || t.lessThan(i.pow(r - 1).mul(-1)))
      throw new Error("Value must be in range [-2^".concat(r - 1, ", 2^").concat(r - 1, "-1]"));
    if (!t.isInteger())
      throw new Error("Value must be an integer");
    t.lessThan(0) && (t = t.add(i.pow(r))), a = "i".concat(r);
  }
  switch (e) {
    case 2:
      return "".concat(t.toBinary()).concat(a);
    case 8:
      return "".concat(t.toOctal()).concat(a);
    case 16:
      return "".concat(t.toHexadecimal()).concat(a);
    default:
      throw new Error("Base ".concat(e, " not supported "));
  }
}
function TT(t, e) {
  if (typeof e == "function")
    return e(t);
  if (!t.isFinite())
    return t.isNaN() ? "NaN" : t.gt(0) ? "Infinity" : "-Infinity";
  var {
    notation: r,
    precision: n,
    wordSize: i
  } = y2(e);
  switch (r) {
    case "fixed":
      return MT(t, n);
    case "exponential":
      return Zv(t, n);
    case "engineering":
      return _T(t, n);
    case "bin":
      return qh(t, 2, i);
    case "oct":
      return qh(t, 8, i);
    case "hex":
      return qh(t, 16, i);
    case "auto": {
      var a = Jv(e?.lowerExp, -3), o = Jv(e?.upperExp, 5);
      if (t.isZero()) return "0";
      var f, u = t.toSignificantDigits(n), s = u.e;
      return s >= a && s < o ? f = u.toFixed() : f = Zv(t, n), f.replace(/((\.\d*?)(0+))($|e)/, function() {
        var c = arguments[2], l = arguments[4];
        return c !== "." ? c + l : l;
      });
    }
    default:
      throw new Error('Unknown notation "' + r + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function _T(t, e) {
  var r = t.e, n = r % 3 === 0 ? r : r < 0 ? r - 3 - r % 3 : r - r % 3, i = t.mul(Math.pow(10, -n)), a = i.toPrecision(e);
  if (a.includes("e")) {
    var o = t.constructor;
    a = new o(a).toFixed();
  }
  return a + "e" + (r >= 0 ? "+" : "") + n.toString();
}
function Zv(t, e) {
  return e !== void 0 ? t.toExponential(e - 1) : t.toExponential();
}
function MT(t, e) {
  return t.toFixed(e);
}
function Jv(t, e) {
  return ot(t) ? t : at(t) ? t.toNumber() : e;
}
function OT(t, e) {
  var r = t.length - e.length, n = t.length;
  return t.substring(r, n) === e;
}
function vt(t, e) {
  var r = qT(t, e);
  return e && typeof e == "object" && "truncate" in e && r.length > e.truncate ? r.substring(0, e.truncate - 3) + "..." : r;
}
function qT(t, e) {
  if (typeof t == "number")
    return Vi(t, e);
  if (at(t))
    return TT(t, e);
  if (IT(t))
    return !e || e.fraction !== "decimal" ? t.s * t.n + "/" + t.d : t.toString();
  if (Array.isArray(t))
    return z2(t, e);
  if (hr(t))
    return Da(t);
  if (typeof t == "function")
    return t.syntax ? String(t.syntax) : "function";
  if (t && typeof t == "object") {
    if (typeof t.format == "function")
      return t.format(e);
    if (t && t.toString(e) !== {}.toString())
      return t.toString(e);
    var r = Object.keys(t).map((n) => Da(n) + ": " + vt(t[n], e));
    return "{" + r.join(", ") + "}";
  }
  return String(t);
}
function Da(t) {
  for (var e = String(t), r = "", n = 0; n < e.length; ) {
    var i = e.charAt(n);
    r += i in Xv ? Xv[i] : i, n++;
  }
  return '"' + r + '"';
}
var Xv = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
function hn(t) {
  var e = String(t);
  return e = e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), e;
}
function z2(t, e) {
  if (Array.isArray(t)) {
    for (var r = "[", n = t.length, i = 0; i < n; i++)
      i !== 0 && (r += ", "), r += z2(t[i], e);
    return r += "]", r;
  } else
    return vt(t, e);
}
function IT(t) {
  return t && typeof t == "object" && typeof t.s == "number" && typeof t.n == "number" && typeof t.d == "number" || !1;
}
function Wh(t, e) {
  if (!hr(t))
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + kt(t) + ", index: 0)");
  if (!hr(e))
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + kt(e) + ", index: 1)");
  return t === e ? 0 : t > e ? 1 : -1;
}
function mt(t, e, r) {
  if (!(this instanceof mt))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.actual = t, this.expected = e, this.relation = r, this.message = "Dimension mismatch (" + (Array.isArray(t) ? "[" + t.join(", ") + "]" : t) + " " + (this.relation || "!=") + " " + (Array.isArray(e) ? "[" + e.join(", ") + "]" : e) + ")", this.stack = new Error().stack;
}
mt.prototype = new RangeError();
mt.prototype.constructor = RangeError;
mt.prototype.name = "DimensionError";
mt.prototype.isDimensionError = !0;
function nn(t, e, r) {
  if (!(this instanceof nn))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.index = t, arguments.length < 3 ? (this.min = 0, this.max = e) : (this.min = e, this.max = r), this.min !== void 0 && this.index < this.min ? this.message = "Index out of range (" + this.index + " < " + this.min + ")" : this.max !== void 0 && this.index >= this.max ? this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")" : this.message = "Index out of range (" + this.index + ")", this.stack = new Error().stack;
}
nn.prototype = new RangeError();
nn.prototype.constructor = RangeError;
nn.prototype.name = "IndexError";
nn.prototype.isIndexError = !0;
function ft(t) {
  for (var e = []; Array.isArray(t); )
    e.push(t.length), t = t[0];
  return e;
}
function $2(t, e, r) {
  var n, i = t.length;
  if (i !== e[r])
    throw new mt(i, e[r]);
  if (r < e.length - 1) {
    var a = r + 1;
    for (n = 0; n < i; n++) {
      var o = t[n];
      if (!Array.isArray(o))
        throw new mt(e.length - 1, e.length, "<");
      $2(t[n], e, a);
    }
  } else
    for (n = 0; n < i; n++)
      if (Array.isArray(t[n]))
        throw new mt(e.length + 1, e.length, ">");
}
function Kv(t, e) {
  var r = e.length === 0;
  if (r) {
    if (Array.isArray(t))
      throw new mt(t.length, 0);
  } else
    $2(t, e, 0);
}
function Yo(t, e) {
  var r = t.isMatrix ? t._size : ft(t), n = e._sourceSize;
  n.forEach((i, a) => {
    if (i !== null && i !== r[a])
      throw new mt(i, r[a]);
  });
}
function Pt(t, e) {
  if (t !== void 0) {
    if (!ot(t) || !Ve(t))
      throw new TypeError("Index must be an integer (value: " + t + ")");
    if (t < 0 || typeof e == "number" && t >= e)
      throw new nn(t, e);
  }
}
function Ma(t) {
  for (var e = 0; e < t._dimensions.length; ++e) {
    var r = t._dimensions[e];
    if (r._data && _t(r._data)) {
      if (r._size[0] === 0)
        return !0;
    } else if (r.isRange) {
      if (r.start === r.end)
        return !0;
    } else if (hr(r) && r.length === 0)
      return !0;
  }
  return !1;
}
function Oa(t, e, r) {
  if (!Array.isArray(e))
    throw new TypeError("Array expected");
  if (e.length === 0)
    throw new Error("Resizing to scalar is not supported");
  e.forEach(function(i) {
    if (!ot(i) || !Ve(i) || i < 0)
      throw new TypeError("Invalid size, must contain positive integers (size: " + vt(e) + ")");
  }), (ot(t) || at(t)) && (t = [t]);
  var n = r !== void 0 ? r : 0;
  return jh(t, e, 0, n), t;
}
function jh(t, e, r, n) {
  var i, a, o = t.length, f = e[r], u = Math.min(o, f);
  if (t.length = f, r < e.length - 1) {
    var s = r + 1;
    for (i = 0; i < u; i++)
      a = t[i], Array.isArray(a) || (a = [a], t[i] = a), jh(a, e, s, n);
    for (i = u; i < f; i++)
      a = [], t[i] = a, jh(a, e, s, n);
  } else {
    for (i = 0; i < u; i++)
      for (; Array.isArray(t[i]); )
        t[i] = t[i][0];
    for (i = u; i < f; i++)
      t[i] = n;
  }
}
function Ed(t, e) {
  var r = Mt(t), n = r.length;
  if (!Array.isArray(t) || !Array.isArray(e))
    throw new TypeError("Array expected");
  if (e.length === 0)
    throw new mt(0, n, "!=");
  e = Sd(e, n);
  var i = U2(e);
  if (n !== i)
    throw new mt(i, n, "!=");
  try {
    return FT(r, e);
  } catch (a) {
    throw a instanceof mt ? new mt(i, n, "!=") : a;
  }
}
function Sd(t, e) {
  var r = U2(t), n = t.slice(), i = -1, a = t.indexOf(i), o = t.indexOf(i, a + 1) >= 0;
  if (o)
    throw new Error("More than one wildcard in sizes");
  var f = a >= 0, u = e % r === 0;
  if (f)
    if (u)
      n[a] = -e / r;
    else
      throw new Error("Could not replace wildcard, since " + e + " is no multiple of " + -r);
  return n;
}
function U2(t) {
  return t.reduce((e, r) => e * r, 1);
}
function FT(t, e) {
  for (var r = t, n, i = e.length - 1; i > 0; i--) {
    var a = e[i];
    n = [];
    for (var o = r.length / a, f = 0; f < o; f++)
      n.push(r.slice(f * a, (f + 1) * a));
    r = n;
  }
  return r;
}
function Zo(t, e) {
  for (var r = ft(t); Array.isArray(t) && t.length === 1; )
    t = t[0], r.shift();
  for (var n = r.length; r[n - 1] === 1; )
    n--;
  return n < r.length && (t = G2(t, n, 0), r.length = n), t;
}
function G2(t, e, r) {
  var n, i;
  if (r < e) {
    var a = r + 1;
    for (n = 0, i = t.length; n < i; n++)
      t[n] = G2(t[n], e, a);
  } else
    for (; Array.isArray(t); )
      t = t[0];
  return t;
}
function H2(t, e, r, n) {
  var i = n || ft(t);
  if (r)
    for (var a = 0; a < r; a++)
      t = [t], i.unshift(1);
  for (t = Q2(t, e, 0); i.length < e; )
    i.push(1);
  return t;
}
function Q2(t, e, r) {
  var n, i;
  if (Array.isArray(t)) {
    var a = r + 1;
    for (n = 0, i = t.length; n < i; n++)
      t[n] = Q2(t[n], e, a);
  } else
    for (var o = r; o < e; o++)
      t = [t];
  return t;
}
function Mt(t) {
  if (!Array.isArray(t))
    return t;
  var e = [];
  return t.forEach(function r(n) {
    Array.isArray(n) ? n.forEach(r) : e.push(n);
  }), e;
}
function Xn(t, e) {
  return Array.prototype.map.call(t, e);
}
function Ou(t, e) {
  Array.prototype.forEach.call(t, e);
}
function V2(t, e) {
  if (ft(t).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(t, e);
}
function Jo(t, e) {
  if (ft(t).length !== 1)
    throw new Error("Only one dimensional matrices supported");
  return Array.prototype.filter.call(t, (r) => e.test(r));
}
function e1(t, e) {
  return Array.prototype.join.call(t, e);
}
function qa(t) {
  if (!Array.isArray(t))
    throw new TypeError("Array input expected");
  if (t.length === 0)
    return t;
  var e = [], r = 0;
  e[0] = {
    value: t[0],
    identifier: 0
  };
  for (var n = 1; n < t.length; n++)
    t[n] === t[n - 1] ? r++ : r = 0, e.push({
      value: t[n],
      identifier: r
    });
  return e;
}
function Xo(t) {
  if (!Array.isArray(t))
    throw new TypeError("Array input expected");
  if (t.length === 0)
    return t;
  for (var e = [], r = 0; r < t.length; r++)
    e.push(t[r].value);
  return e;
}
function Es(t, e) {
  for (var r, n = 0, i = 0; i < t.length; i++) {
    var a = t[i], o = Array.isArray(a);
    if (i === 0 && o && (n = a.length), o && a.length !== n)
      return;
    var f = o ? Es(a, e) : e(a);
    if (r === void 0)
      r = f;
    else if (r !== f)
      return "mixed";
  }
  return r;
}
function W2(t, e, r, n) {
  if (n < r) {
    if (t.length !== e.length)
      throw new mt(t.length, e.length);
    for (var i = [], a = 0; a < t.length; a++)
      i[a] = W2(t[a], e[a], r, n + 1);
    return i;
  } else
    return t.concat(e);
}
function j2() {
  var t = Array.prototype.slice.call(arguments, 0, -1), e = Array.prototype.slice.call(arguments, -1);
  if (t.length === 1)
    return t[0];
  if (t.length > 1)
    return t.slice(1).reduce(function(r, n) {
      return W2(r, n, e, 0);
    }, t[0]);
  throw new Error("Wrong number of arguments in function concat");
}
function BT() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  for (var n = e.map((m) => m.length), i = Math.max(...n), a = new Array(i).fill(null), o = 0; o < e.length; o++)
    for (var f = e[o], u = n[o], s = 0; s < u; s++) {
      var c = i - u + s;
      f[s] > a[c] && (a[c] = f[s]);
    }
  for (var l = 0; l < e.length; l++)
    Ko(e[l], a);
  return a;
}
function Ko(t, e) {
  for (var r = e.length, n = t.length, i = 0; i < n; i++) {
    var a = r - n + i;
    if (t[i] < e[a] && t[i] > 1 || t[i] > e[a])
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(t, ") not possible to broadcast dimension ").concat(n, " with size ").concat(t[i], " to size ").concat(e[a]));
  }
}
function t1(t, e) {
  var r = ft(t);
  if (Wi(r, e))
    return t;
  Ko(r, e);
  var n = BT(r, e), i = n.length, a = [...Array(i - r.length).fill(1), ...r], o = PT(t);
  r.length < i && (o = Ed(o, a), r = ft(o));
  for (var f = 0; f < i; f++)
    r[f] < n[f] && (o = RT(o, n[f], f), r = ft(o));
  return o;
}
function RT(t, e, r) {
  return j2(...Array(e).fill(t), r);
}
function PT(t) {
  return nr([], t);
}
function LT(t) {
  var e = 0, r = 1, n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), a = 0, o = function(u) {
    var s = i[u];
    if (s && (delete n[s], delete i[u], --e, r === s)) {
      if (!e) {
        a = 0, r = 1;
        return;
      }
      for (; !Object.prototype.hasOwnProperty.call(n, ++r); )
        ;
    }
  };
  return t = Math.abs(t), {
    hit: function(u) {
      var s = i[u], c = ++a;
      if (n[c] = u, i[u] = c, !s)
        return ++e, e <= t ? void 0 : (u = n[r], o(u), u);
      if (delete n[s], r === s)
        for (; !Object.prototype.hasOwnProperty.call(n, ++r); )
          ;
    },
    delete: o,
    clear: function() {
      e = a = 0, r = 1, n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
    }
  };
}
function Is(t) {
  var {
    hasher: e,
    limit: r
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return r = r ?? Number.POSITIVE_INFINITY, e = e ?? JSON.stringify, function n() {
    typeof n.cache != "object" && (n.cache = {
      values: /* @__PURE__ */ new Map(),
      lru: LT(r || Number.POSITIVE_INFINITY)
    });
    for (var i = [], a = 0; a < arguments.length; a++)
      i[a] = arguments[a];
    var o = e(i);
    if (n.cache.values.has(o))
      return n.cache.lru.hit(o), n.cache.values.get(o);
    var f = t.apply(t, i);
    return n.cache.values.set(o, f), n.cache.values.delete(n.cache.lru.hit(o)), f;
  };
}
function Y2(t) {
  return Object.keys(t.signatures || {}).reduce(function(e, r) {
    var n = (r.match(/,/g) || []).length + 1;
    return Math.max(e, n);
  }, -1);
}
var kT = "DenseMatrix", zT = ["Matrix"], qu = /* @__PURE__ */ H(kT, zT, (t) => {
  var {
    Matrix: e
  } = t;
  function r(c, l) {
    if (!(this instanceof r))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (l && !hr(l))
      throw new Error("Invalid datatype: " + l);
    if (Ye(c))
      c.type === "DenseMatrix" ? (this._data = Je(c._data), this._size = Je(c._size), this._datatype = l || c._datatype) : (this._data = c.toArray(), this._size = c.size(), this._datatype = l || c._datatype);
    else if (c && _t(c.data) && _t(c.size))
      this._data = c.data, this._size = c.size, Kv(this._data, this._size), this._datatype = l || c.datatype;
    else if (_t(c))
      this._data = s(c), this._size = ft(this._data), Kv(this._data, this._size), this._datatype = l;
    else {
      if (c)
        throw new TypeError("Unsupported type of data (" + kt(c) + ")");
      this._data = [], this._size = [0], this._datatype = l;
    }
  }
  r.prototype = new e(), r.prototype.createDenseMatrix = function(c, l) {
    return new r(c, l);
  }, Object.defineProperty(r, "name", {
    value: "DenseMatrix"
  }), r.prototype.constructor = r, r.prototype.type = "DenseMatrix", r.prototype.isDenseMatrix = !0, r.prototype.getDataType = function() {
    return Es(this._data, kt);
  }, r.prototype.storage = function() {
    return "dense";
  }, r.prototype.datatype = function() {
    return this._datatype;
  }, r.prototype.create = function(c, l) {
    return new r(c, l);
  }, r.prototype.subset = function(c, l, m) {
    switch (arguments.length) {
      case 1:
        return n(this, c);
      case 2:
      case 3:
        return a(this, c, l, m);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  }, r.prototype.get = function(c) {
    if (!_t(c))
      throw new TypeError("Array expected");
    if (c.length !== this._size.length)
      throw new mt(c.length, this._size.length);
    for (var l = 0; l < c.length; l++)
      Pt(c[l], this._size[l]);
    for (var m = this._data, h = 0, g = c.length; h < g; h++) {
      var d = c[h];
      Pt(d, m.length), m = m[d];
    }
    return m;
  }, r.prototype.set = function(c, l, m) {
    if (!_t(c))
      throw new TypeError("Array expected");
    if (c.length < this._size.length)
      throw new mt(c.length, this._size.length, "<");
    var h, g, d, y = c.map(function(E) {
      return E + 1;
    });
    u(this, y, m);
    var w = this._data;
    for (h = 0, g = c.length - 1; h < g; h++)
      d = c[h], Pt(d, w.length), w = w[d];
    return d = c[c.length - 1], Pt(d, w.length), w[d] = l, this;
  };
  function n(c, l) {
    if (!Ba(l))
      throw new TypeError("Invalid index");
    var m = l.isScalar();
    if (m)
      return c.get(l.min());
    var h = l.size();
    if (h.length !== c._size.length)
      throw new mt(h.length, c._size.length);
    for (var g = l.min(), d = l.max(), y = 0, w = c._size.length; y < w; y++)
      Pt(g[y], c._size[y]), Pt(d[y], c._size[y]);
    return new r(i(c._data, l, h.length, 0), c._datatype);
  }
  function i(c, l, m, h) {
    var g = h === m - 1, d = l.dimension(h);
    return g ? d.map(function(y) {
      return Pt(y, c.length), c[y];
    }).valueOf() : d.map(function(y) {
      Pt(y, c.length);
      var w = c[y];
      return i(w, l, m, h + 1);
    }).valueOf();
  }
  function a(c, l, m, h) {
    if (!l || l.isIndex !== !0)
      throw new TypeError("Invalid index");
    var g = l.size(), d = l.isScalar(), y;
    if (Ye(m) ? (y = m.size(), m = m.valueOf()) : y = ft(m), d) {
      if (y.length !== 0)
        throw new TypeError("Scalar expected");
      c.set(l.min(), m, h);
    } else {
      if (!Wi(y, g))
        try {
          y.length === 0 ? m = t1([m], g) : m = t1(m, g), y = ft(m);
        } catch {
        }
      if (g.length < c._size.length)
        throw new mt(g.length, c._size.length, "<");
      if (y.length < g.length) {
        for (var w = 0, E = 0; g[w] === 1 && y[w] === 1; )
          w++;
        for (; g[w] === 1; )
          E++, w++;
        m = H2(m, g.length, E, y);
      }
      if (!Wi(g, y))
        throw new mt(g, y, ">");
      var x = l.max().map(function(b) {
        return b + 1;
      });
      u(c, x, h);
      var N = g.length, D = 0;
      o(c._data, l, m, N, D);
    }
    return c;
  }
  function o(c, l, m, h, g) {
    var d = g === h - 1, y = l.dimension(g);
    d ? y.forEach(function(w, E) {
      Pt(w), c[w] = m[E[0]];
    }) : y.forEach(function(w, E) {
      Pt(w), o(c[w], l, m[E[0]], h, g + 1);
    });
  }
  r.prototype.resize = function(c, l, m) {
    if (!Yr(c))
      throw new TypeError("Array or Matrix expected");
    var h = c.valueOf().map((d) => Array.isArray(d) && d.length === 1 ? d[0] : d), g = m ? this.clone() : this;
    return f(g, h, l);
  };
  function f(c, l, m) {
    if (l.length === 0) {
      for (var h = c._data; _t(h); )
        h = h[0];
      return h;
    }
    return c._size = l.slice(0), c._data = Oa(c._data, c._size, m), c;
  }
  r.prototype.reshape = function(c, l) {
    var m = l ? this.clone() : this;
    m._data = Ed(m._data, c);
    var h = m._size.reduce((g, d) => g * d);
    return m._size = Sd(c, h), m;
  };
  function u(c, l, m) {
    for (var h = c._size.slice(0), g = !1; h.length < l.length; )
      h.push(0), g = !0;
    for (var d = 0, y = l.length; d < y; d++)
      l[d] > h[d] && (h[d] = l[d], g = !0);
    g && f(c, h, m);
  }
  r.prototype.clone = function() {
    var c = new r({
      data: Je(this._data),
      size: Je(this._size),
      datatype: this._datatype
    });
    return c;
  }, r.prototype.size = function() {
    return this._size.slice(0);
  }, r.prototype.map = function(c) {
    var l = this, m = Y2(c), h = function y(w, E) {
      return _t(w) ? w.map(function(x, N) {
        return y(x, E.concat(N));
      }) : m === 1 ? c(w) : m === 2 ? c(w, E) : c(w, E, l);
    }, g = h(this._data, []), d = this._datatype !== void 0 ? Es(g, kt) : void 0;
    return new r(g, d);
  }, r.prototype.forEach = function(c) {
    var l = this, m = function h(g, d) {
      _t(g) ? g.forEach(function(y, w) {
        h(y, d.concat(w));
      }) : c(g, d, l);
    };
    m(this._data, []);
  }, r.prototype[Symbol.iterator] = function* () {
    var c = function* l(m, h) {
      if (_t(m))
        for (var g = 0; g < m.length; g++)
          yield* l(m[g], h.concat(g));
      else
        yield {
          value: m,
          index: h
        };
    };
    yield* c(this._data, []);
  }, r.prototype.rows = function() {
    var c = [], l = this.size();
    if (l.length !== 2)
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    var m = this._data;
    for (var h of m)
      c.push(new r([h], this._datatype));
    return c;
  }, r.prototype.columns = function() {
    var c = this, l = [], m = this.size();
    if (m.length !== 2)
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    for (var h = this._data, g = function(w) {
      var E = h.map((x) => [x[w]]);
      l.push(new r(E, c._datatype));
    }, d = 0; d < m[1]; d++)
      g(d);
    return l;
  }, r.prototype.toArray = function() {
    return Je(this._data);
  }, r.prototype.valueOf = function() {
    return this._data;
  }, r.prototype.format = function(c) {
    return vt(this._data, c);
  }, r.prototype.toString = function() {
    return vt(this._data);
  }, r.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  }, r.prototype.diagonal = function(c) {
    if (c) {
      if (at(c) && (c = c.toNumber()), !ot(c) || !Ve(c))
        throw new TypeError("The parameter k must be an integer number");
    } else
      c = 0;
    for (var l = c > 0 ? c : 0, m = c < 0 ? -c : 0, h = this._size[0], g = this._size[1], d = Math.min(h - m, g - l), y = [], w = 0; w < d; w++)
      y[w] = this._data[w + m][w + l];
    return new r({
      data: y,
      size: [d],
      datatype: this._datatype
    });
  }, r.diagonal = function(c, l, m, h) {
    if (!_t(c))
      throw new TypeError("Array expected, size parameter");
    if (c.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    if (c = c.map(function(C) {
      if (at(C) && (C = C.toNumber()), !ot(C) || !Ve(C) || C < 1)
        throw new Error("Size values must be positive integers");
      return C;
    }), m) {
      if (at(m) && (m = m.toNumber()), !ot(m) || !Ve(m))
        throw new TypeError("The parameter k must be an integer number");
    } else
      m = 0;
    var g = m > 0 ? m : 0, d = m < 0 ? -m : 0, y = c[0], w = c[1], E = Math.min(y - d, w - g), x;
    if (_t(l)) {
      if (l.length !== E)
        throw new Error("Invalid value array length");
      x = function(A) {
        return l[A];
      };
    } else if (Ye(l)) {
      var N = l.size();
      if (N.length !== 1 || N[0] !== E)
        throw new Error("Invalid matrix length");
      x = function(A) {
        return l.get([A]);
      };
    } else
      x = function() {
        return l;
      };
    h || (h = at(x(0)) ? x(0).mul(0) : 0);
    var D = [];
    if (c.length > 0) {
      D = Oa(D, c, h);
      for (var b = 0; b < E; b++)
        D[b + d][b + g] = x(b);
    }
    return new r({
      data: D,
      size: [y, w]
    });
  }, r.fromJSON = function(c) {
    return new r(c);
  }, r.prototype.swapRows = function(c, l) {
    if (!ot(c) || !Ve(c) || !ot(l) || !Ve(l))
      throw new Error("Row index must be positive integers");
    if (this._size.length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    return Pt(c, this._size[0]), Pt(l, this._size[0]), r._swapRows(c, l, this._data), this;
  }, r._swapRows = function(c, l, m) {
    var h = m[c];
    m[c] = m[l], m[l] = h;
  };
  function s(c) {
    return Ye(c) ? s(c.valueOf()) : _t(c) ? c.map(s) : c;
  }
  return r;
}, {
  isClass: !0
}), r1 = "clone", $T = ["typed"], Iu = /* @__PURE__ */ H(r1, $T, (t) => {
  var {
    typed: e
  } = t;
  return e(r1, {
    any: Je
  });
});
function Z2(t) {
  var e = t.length, r = t[0].length, n, i, a = [];
  for (i = 0; i < r; i++) {
    var o = [];
    for (n = 0; n < e; n++)
      o.push(t[n][i]);
    a.push(o);
  }
  return a;
}
function La(t) {
  for (var e = 0; e < t.length; e++)
    if (Yr(t[e]))
      return !0;
  return !1;
}
function ei(t, e) {
  Ye(t) && (t = t.valueOf());
  for (var r = 0, n = t.length; r < n; r++) {
    var i = t[r];
    Array.isArray(i) ? ei(i, e) : e(i);
  }
}
function gt(t, e, r) {
  return t && typeof t.map == "function" ? t.map(function(n) {
    return gt(n, e);
  }) : e(t);
}
function Fu(t, e, r) {
  var n = Array.isArray(t) ? ft(t) : t.size();
  if (e < 0 || e >= n.length)
    throw new nn(e, n.length);
  return Ye(t) ? t.create(eu(t.valueOf(), e, r)) : eu(t, e, r);
}
function eu(t, e, r) {
  var n, i, a, o;
  if (e <= 0)
    if (Array.isArray(t[0])) {
      for (o = Z2(t), i = [], n = 0; n < o.length; n++)
        i[n] = eu(o[n], e - 1, r);
      return i;
    } else {
      for (a = t[0], n = 1; n < t.length; n++)
        a = r(a, t[n]);
      return a;
    }
  else {
    for (i = [], n = 0; n < t.length; n++)
      i[n] = eu(t[n], e - 1, r);
    return i;
  }
}
function n1(t, e, r, n, i, a, o, f, u, s, c) {
  var l = t._values, m = t._index, h = t._ptr, g, d, y, w;
  if (n)
    for (d = h[e], y = h[e + 1], g = d; g < y; g++)
      w = m[g], r[w] !== a ? (r[w] = a, o.push(w), n[w] = l[g]) : (n[w] = f(n[w], l[g]), i[w] = a);
  else
    for (d = h[e], y = h[e + 1], g = d; g < y; g++)
      w = m[g], r[w] !== a ? (r[w] = a, o.push(w)) : i[w] = a;
}
var i1 = "isInteger", UT = ["typed"], Bu = /* @__PURE__ */ H(i1, UT, (t) => {
  var {
    typed: e
  } = t;
  return e(i1, {
    number: Ve,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function(n) {
      return n.isInt();
    },
    bigint: function(n) {
      return !0;
    },
    Fraction: function(n) {
      return n.d === 1 && isFinite(n.n);
    },
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), Tn = "number", ka = "number, number";
function J2(t) {
  return Math.abs(t);
}
J2.signature = Tn;
function X2(t, e) {
  return t + e;
}
X2.signature = ka;
function K2(t, e) {
  return t - e;
}
K2.signature = ka;
function ew(t, e) {
  return t * e;
}
ew.signature = ka;
function tw(t) {
  return -t;
}
tw.signature = Tn;
function rw(t) {
  return t;
}
rw.signature = Tn;
function ys(t) {
  return YA(t);
}
ys.signature = Tn;
function nw(t) {
  return t * t * t;
}
nw.signature = Tn;
function iw(t) {
  return Math.exp(t);
}
iw.signature = Tn;
function aw(t) {
  return ZA(t);
}
aw.signature = Tn;
function sw(t, e) {
  if (!Ve(t) || !Ve(e))
    throw new Error("Parameters in function lcm must be integer numbers");
  if (t === 0 || e === 0)
    return 0;
  for (var r, n = t * e; e !== 0; )
    r = e, e = t % r, t = r;
  return Math.abs(n / t);
}
sw.signature = ka;
function GT(t, e) {
  return Math.log(t);
}
function ow(t) {
  return WA(t);
}
ow.signature = Tn;
function uw(t) {
  return VA(t);
}
uw.signature = Tn;
function a1(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, r = e < 0;
  if (r && (e = -e), e === 0)
    throw new Error("Root must be non-zero");
  if (t < 0 && Math.abs(e) % 2 !== 1)
    throw new Error("Root must be odd when a is negative.");
  if (t === 0)
    return r ? 1 / 0 : 0;
  if (!isFinite(t))
    return r ? 0 : t;
  var n = Math.pow(Math.abs(t), 1 / e);
  return n = t < 0 ? -n : n, r ? 1 / n : n;
}
function Yh(t) {
  return hi(t);
}
Yh.signature = Tn;
function lw(t) {
  return t * t;
}
lw.signature = Tn;
function cw(t, e) {
  var r, n, i, a = 0, o = 1, f = 1, u = 0;
  if (!Ve(t) || !Ve(e))
    throw new Error("Parameters in function xgcd must be integer numbers");
  for (; e; )
    n = Math.floor(t / e), i = t - n * e, r = a, a = o - n * a, o = r, r = f, f = u - n * f, u = r, t = e, e = i;
  var s;
  return t < 0 ? s = [-t, -o, -u] : s = [t, t ? o : 0, u], s;
}
cw.signature = ka;
function fw(t, e) {
  return t * t < 1 && e === 1 / 0 || t * t > 1 && e === -1 / 0 ? 0 : Math.pow(t, e);
}
fw.signature = ka;
function gs(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!Ve(e) || e < 0 || e > 15)
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  return parseFloat(x2(t, e));
}
var HT = "number", za = "number, number";
function pw(t, e) {
  if (!Ve(t) || !Ve(e))
    throw new Error("Integers expected in function bitAnd");
  return t & e;
}
pw.signature = za;
function mw(t) {
  if (!Ve(t))
    throw new Error("Integer expected in function bitNot");
  return ~t;
}
mw.signature = HT;
function hw(t, e) {
  if (!Ve(t) || !Ve(e))
    throw new Error("Integers expected in function bitOr");
  return t | e;
}
hw.signature = za;
function dw(t, e) {
  if (!Ve(t) || !Ve(e))
    throw new Error("Integers expected in function bitXor");
  return t ^ e;
}
dw.signature = za;
function gw(t, e) {
  if (!Ve(t) || !Ve(e))
    throw new Error("Integers expected in function leftShift");
  return t << e;
}
gw.signature = za;
function vw(t, e) {
  if (!Ve(t) || !Ve(e))
    throw new Error("Integers expected in function rightArithShift");
  return t >> e;
}
vw.signature = za;
function yw(t, e) {
  if (!Ve(t) || !Ve(e))
    throw new Error("Integers expected in function rightLogShift");
  return t >>> e;
}
yw.signature = za;
function Zn(t, e) {
  if (e < t)
    return 1;
  if (e === t)
    return e;
  var r = e + t >> 1;
  return Zn(t, r) * Zn(r + 1, e);
}
function xw(t, e) {
  if (!Ve(t) || t < 0)
    throw new TypeError("Positive integer value expected in function combinations");
  if (!Ve(e) || e < 0)
    throw new TypeError("Positive integer value expected in function combinations");
  if (e > t)
    throw new TypeError("k must be less than or equal to n");
  for (var r = t - e, n = 1, i = e < r ? r + 1 : e + 1, a = 2, o = e < r ? e : r, f = i; f <= t; ++f)
    for (n *= f; a <= o && n % a === 0; )
      n /= a, ++a;
  return a <= o && (n /= Zn(a, o)), n;
}
xw.signature = "number, number";
var QT = Math.PI, VT = 2 * Math.PI, WT = Math.E, jT = 1.618033988749895, YT = "number", Ad = "number, number";
function bw(t) {
  return !t;
}
bw.signature = YT;
function Zh(t, e) {
  return !!(t || e);
}
Zh.signature = Ad;
function Jh(t, e) {
  return !!t != !!e;
}
Jh.signature = Ad;
function Xh(t, e) {
  return !!(t && e);
}
Xh.signature = Ad;
function tu(t) {
  var e;
  if (Ve(t))
    return t <= 0 ? isFinite(t) ? 1 / 0 : NaN : t > 171 ? 1 / 0 : Zn(1, t - 1);
  if (t < 0.5)
    return Math.PI / (Math.sin(Math.PI * t) * tu(1 - t));
  if (t >= 171.35)
    return 1 / 0;
  if (t > 85) {
    var r = t * t, n = r * t, i = n * t, a = i * t;
    return Math.sqrt(2 * Math.PI / t) * Math.pow(t / Math.E, t) * (1 + 1 / (12 * t) + 1 / (288 * r) - 139 / (51840 * n) - 571 / (2488320 * i) + 163879 / (209018880 * a) + 5246819 / (75246796800 * a * t));
  }
  --t, e = Aa[0];
  for (var o = 1; o < Aa.length; ++o)
    e += Aa[o] / (t + o);
  var f = t + ww + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(f, t + 0.5) * Math.exp(-f) * e;
}
tu.signature = "number";
var ww = 4.7421875, Aa = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22], Nw = 0.9189385332046728, ZT = 5, JT = 7, s1 = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
function ru(t) {
  if (t < 0) return NaN;
  if (t === 0) return 1 / 0;
  if (!isFinite(t)) return t;
  if (t < 0.5)
    return Math.log(Math.PI / Math.sin(Math.PI * t)) - ru(1 - t);
  t = t - 1;
  for (var e = t + ZT + 0.5, r = s1[0], n = JT - 1; n >= 1; n--)
    r += s1[n] / (t + n);
  return Nw + (t + 0.5) * Math.log(e) - e + Math.log(r);
}
ru.signature = "number";
var Br = "number";
function Dw(t) {
  return eC(t);
}
Dw.signature = Br;
function Ew(t) {
  return Math.atan(1 / t);
}
Ew.signature = Br;
function Sw(t) {
  return isFinite(t) ? (Math.log((t + 1) / t) + Math.log(t / (t - 1))) / 2 : 0;
}
Sw.signature = Br;
function Aw(t) {
  return Math.asin(1 / t);
}
Aw.signature = Br;
function Cw(t) {
  var e = 1 / t;
  return Math.log(e + Math.sqrt(e * e + 1));
}
Cw.signature = Br;
function Tw(t) {
  return Math.acos(1 / t);
}
Tw.signature = Br;
function _w(t) {
  var e = 1 / t, r = Math.sqrt(e * e - 1);
  return Math.log(r + e);
}
_w.signature = Br;
function Mw(t) {
  return tC(t);
}
Mw.signature = Br;
function Ow(t) {
  return rC(t);
}
Ow.signature = Br;
function qw(t) {
  return 1 / Math.tan(t);
}
qw.signature = Br;
function Iw(t) {
  var e = Math.exp(2 * t);
  return (e + 1) / (e - 1);
}
Iw.signature = Br;
function Fw(t) {
  return 1 / Math.sin(t);
}
Fw.signature = Br;
function Bw(t) {
  return t === 0 ? Number.POSITIVE_INFINITY : Math.abs(2 / (Math.exp(t) - Math.exp(-t))) * hi(t);
}
Bw.signature = Br;
function Rw(t) {
  return 1 / Math.cos(t);
}
Rw.signature = Br;
function Pw(t) {
  return 2 / (Math.exp(t) + Math.exp(-t));
}
Pw.signature = Br;
function Lw(t) {
  return iC(t);
}
Lw.signature = Br;
var Cd = "number";
function kw(t) {
  return t < 0;
}
kw.signature = Cd;
function zw(t) {
  return t > 0;
}
zw.signature = Cd;
function $w(t) {
  return Number.isNaN(t);
}
$w.signature = Cd;
function Jr(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-9, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  if (r <= 0)
    throw new Error("Relative tolerance must be greater than 0");
  if (n < 0)
    throw new Error("Absolute tolerance must be at least 0");
  return t.isNaN() || e.isNaN() ? !1 : !t.isFinite() || !e.isFinite() ? t.eq(e) : t.eq(e) ? !0 : t.minus(e).abs().lte(t.constructor.max(t.constructor.max(t.abs(), e.abs()).mul(r), n));
}
var o1 = "isNegative", XT = ["typed", "config"], Ru = /* @__PURE__ */ H(o1, XT, (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(o1, {
    number: (n) => Er(n, 0, r.relTol, r.absTol) ? !1 : kw(n),
    BigNumber: (n) => Jr(n, new n.constructor(0), r.relTol, r.absTol) ? !1 : n.isNeg() && !n.isZero() && !n.isNaN(),
    bigint: (n) => n < 0n,
    Fraction: (n) => n.s < 0,
    // It's enough to decide on the sign
    Unit: e.referToSelf((n) => (i) => e.find(n, i.valueType())(i.value)),
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), u1 = "isNumeric", KT = ["typed"], Pu = /* @__PURE__ */ H(u1, KT, (t) => {
  var {
    typed: e
  } = t;
  return e(u1, {
    "number | BigNumber | bigint | Fraction | boolean": () => !0,
    "Complex | Unit | string | null | undefined | Node": () => !1,
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), l1 = "hasNumericValue", e3 = ["typed", "isNumeric"], Lu = /* @__PURE__ */ H(l1, e3, (t) => {
  var {
    typed: e,
    isNumeric: r
  } = t;
  return e(l1, {
    boolean: () => !0,
    string: function(i) {
      return i.trim().length > 0 && !isNaN(Number(i));
    },
    any: function(i) {
      return r(i);
    }
  });
}), c1 = "isPositive", t3 = ["typed", "config"], ku = /* @__PURE__ */ H(c1, t3, (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(c1, {
    number: (n) => Er(n, 0, r.relTol, r.absTol) ? !1 : zw(n),
    BigNumber: (n) => Jr(n, new n.constructor(0), r.relTol, r.absTol) ? !1 : !n.isNeg() && !n.isZero() && !n.isNaN(),
    bigint: (n) => n > 0n,
    Fraction: (n) => n.s > 0 && n.n > 0,
    Unit: e.referToSelf((n) => (i) => e.find(n, i.valueType())(i.value)),
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), f1 = "isZero", r3 = ["typed", "equalScalar"], zu = /* @__PURE__ */ H(f1, r3, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return e(f1, {
    "number | BigNumber | Complex | Fraction": (n) => r(n, 0),
    bigint: (n) => n === 0n,
    Unit: e.referToSelf((n) => (i) => e.find(n, i.valueType())(i.value)),
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), p1 = "isNaN", n3 = ["typed"], $u = /* @__PURE__ */ H(p1, n3, (t) => {
  var {
    typed: e
  } = t;
  return e(p1, {
    number: $w,
    BigNumber: function(n) {
      return n.isNaN();
    },
    bigint: function(n) {
      return !1;
    },
    Fraction: function(n) {
      return !1;
    },
    Complex: function(n) {
      return n.isNaN();
    },
    Unit: function(n) {
      return Number.isNaN(n.value);
    },
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), m1 = "typeOf", i3 = ["typed"], Uu = /* @__PURE__ */ H(m1, i3, (t) => {
  var {
    typed: e
  } = t;
  return e(m1, {
    any: kt
  });
});
function a3(t, e, r, n) {
  return Er(t.re, e.re, r, n) && Er(t.im, e.im, r, n);
}
var $a = /* @__PURE__ */ H("compareUnits", ["typed"], (t) => {
  var {
    typed: e
  } = t;
  return {
    "Unit, Unit": e.referToSelf((r) => (n, i) => {
      if (!n.equalBase(i))
        throw new Error("Cannot compare units with different base");
      return e.find(r, [n.valueType(), i.valueType()])(n.value, i.value);
    })
  };
}), nu = "equalScalar", s3 = ["typed", "config"], Gu = /* @__PURE__ */ H(nu, s3, (t) => {
  var {
    typed: e,
    config: r
  } = t, n = $a({
    typed: e
  });
  return e(nu, {
    "boolean, boolean": function(a, o) {
      return a === o;
    },
    "number, number": function(a, o) {
      return Er(a, o, r.relTol, r.absTol);
    },
    "BigNumber, BigNumber": function(a, o) {
      return a.eq(o) || Jr(a, o, r.relTol, r.absTol);
    },
    "bigint, bigint": function(a, o) {
      return a === o;
    },
    "Fraction, Fraction": function(a, o) {
      return a.equals(o);
    },
    "Complex, Complex": function(a, o) {
      return a3(a, o, r.relTol, r.absTol);
    }
  }, n);
});
H(nu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(nu, {
    "number, number": function(i, a) {
      return Er(i, a, r.relTol, r.absTol);
    }
  });
});
var o3 = "SparseMatrix", u3 = ["typed", "equalScalar", "Matrix"], Hu = /* @__PURE__ */ H(o3, u3, (t) => {
  var {
    typed: e,
    equalScalar: r,
    Matrix: n
  } = t;
  function i(d, y) {
    if (!(this instanceof i))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (y && !hr(y))
      throw new Error("Invalid datatype: " + y);
    if (Ye(d))
      a(this, d, y);
    else if (d && _t(d.index) && _t(d.ptr) && _t(d.size))
      this._values = d.values, this._index = d.index, this._ptr = d.ptr, this._size = d.size, this._datatype = y || d.datatype;
    else if (_t(d))
      o(this, d, y);
    else {
      if (d)
        throw new TypeError("Unsupported type of data (" + kt(d) + ")");
      this._values = [], this._index = [], this._ptr = [0], this._size = [0, 0], this._datatype = y;
    }
  }
  function a(d, y, w) {
    y.type === "SparseMatrix" ? (d._values = y._values ? Je(y._values) : void 0, d._index = Je(y._index), d._ptr = Je(y._ptr), d._size = Je(y._size), d._datatype = w || y._datatype) : o(d, y.valueOf(), w || y._datatype);
  }
  function o(d, y, w) {
    d._values = [], d._index = [], d._ptr = [], d._datatype = w;
    var E = y.length, x = 0, N = r, D = 0;
    if (hr(w) && (N = e.find(r, [w, w]) || r, D = e.convert(0, w)), E > 0) {
      var b = 0;
      do {
        d._ptr.push(d._index.length);
        for (var C = 0; C < E; C++) {
          var A = y[C];
          if (_t(A)) {
            if (b === 0 && x < A.length && (x = A.length), b < A.length) {
              var T = A[b];
              N(T, D) || (d._values.push(T), d._index.push(C));
            }
          } else
            b === 0 && x < 1 && (x = 1), N(A, D) || (d._values.push(A), d._index.push(C));
        }
        b++;
      } while (b < x);
    }
    d._ptr.push(d._index.length), d._size = [E, x];
  }
  i.prototype = new n(), i.prototype.createSparseMatrix = function(d, y) {
    return new i(d, y);
  }, Object.defineProperty(i, "name", {
    value: "SparseMatrix"
  }), i.prototype.constructor = i, i.prototype.type = "SparseMatrix", i.prototype.isSparseMatrix = !0, i.prototype.getDataType = function() {
    return Es(this._values, kt);
  }, i.prototype.storage = function() {
    return "sparse";
  }, i.prototype.datatype = function() {
    return this._datatype;
  }, i.prototype.create = function(d, y) {
    return new i(d, y);
  }, i.prototype.density = function() {
    var d = this._size[0], y = this._size[1];
    return d !== 0 && y !== 0 ? this._index.length / (d * y) : 0;
  }, i.prototype.subset = function(d, y, w) {
    if (!this._values)
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    switch (arguments.length) {
      case 1:
        return f(this, d);
      case 2:
      case 3:
        return u(this, d, y, w);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function f(d, y) {
    if (!Ba(y))
      throw new TypeError("Invalid index");
    var w = y.isScalar();
    if (w)
      return d.get(y.min());
    var E = y.size();
    if (E.length !== d._size.length)
      throw new mt(E.length, d._size.length);
    var x, N, D, b, C = y.min(), A = y.max();
    for (x = 0, N = d._size.length; x < N; x++)
      Pt(C[x], d._size[x]), Pt(A[x], d._size[x]);
    var T = d._values, _ = d._index, O = d._ptr, I = y.dimension(0), B = y.dimension(1), k = [], L = [];
    I.forEach(function(R, Q) {
      L[R] = Q[0], k[R] = !0;
    });
    var F = T ? [] : void 0, M = [], $ = [];
    return B.forEach(function(R) {
      for ($.push(M.length), D = O[R], b = O[R + 1]; D < b; D++)
        x = _[D], k[x] === !0 && (M.push(L[x]), F && F.push(T[D]));
    }), $.push(M.length), new i({
      values: F,
      index: M,
      ptr: $,
      size: E,
      datatype: d._datatype
    });
  }
  function u(d, y, w, E) {
    if (!y || y.isIndex !== !0)
      throw new TypeError("Invalid index");
    var x = y.size(), N = y.isScalar(), D;
    if (Ye(w) ? (D = w.size(), w = w.toArray()) : D = ft(w), N) {
      if (D.length !== 0)
        throw new TypeError("Scalar expected");
      d.set(y.min(), w, E);
    } else {
      if (x.length !== 1 && x.length !== 2)
        throw new mt(x.length, d._size.length, "<");
      if (D.length < x.length) {
        for (var b = 0, C = 0; x[b] === 1 && D[b] === 1; )
          b++;
        for (; x[b] === 1; )
          C++, b++;
        w = H2(w, x.length, C, D);
      }
      if (!Wi(x, D))
        throw new mt(x, D, ">");
      if (x.length === 1) {
        var A = y.dimension(0);
        A.forEach(function(O, I) {
          Pt(O), d.set([O, 0], w[I[0]], E);
        });
      } else {
        var T = y.dimension(0), _ = y.dimension(1);
        T.forEach(function(O, I) {
          Pt(O), _.forEach(function(B, k) {
            Pt(B), d.set([O, B], w[I[0]][k[0]], E);
          });
        });
      }
    }
    return d;
  }
  i.prototype.get = function(d) {
    if (!_t(d))
      throw new TypeError("Array expected");
    if (d.length !== this._size.length)
      throw new mt(d.length, this._size.length);
    if (!this._values)
      throw new Error("Cannot invoke get on a Pattern only matrix");
    var y = d[0], w = d[1];
    Pt(y, this._size[0]), Pt(w, this._size[1]);
    var E = s(y, this._ptr[w], this._ptr[w + 1], this._index);
    return E < this._ptr[w + 1] && this._index[E] === y ? this._values[E] : 0;
  }, i.prototype.set = function(d, y, w) {
    if (!_t(d))
      throw new TypeError("Array expected");
    if (d.length !== this._size.length)
      throw new mt(d.length, this._size.length);
    if (!this._values)
      throw new Error("Cannot invoke set on a Pattern only matrix");
    var E = d[0], x = d[1], N = this._size[0], D = this._size[1], b = r, C = 0;
    hr(this._datatype) && (b = e.find(r, [this._datatype, this._datatype]) || r, C = e.convert(0, this._datatype)), (E > N - 1 || x > D - 1) && (m(this, Math.max(E + 1, N), Math.max(x + 1, D), w), N = this._size[0], D = this._size[1]), Pt(E, N), Pt(x, D);
    var A = s(E, this._ptr[x], this._ptr[x + 1], this._index);
    return A < this._ptr[x + 1] && this._index[A] === E ? b(y, C) ? c(A, x, this._values, this._index, this._ptr) : this._values[A] = y : b(y, C) || l(A, E, x, y, this._values, this._index, this._ptr), this;
  };
  function s(d, y, w, E) {
    if (w - y === 0)
      return w;
    for (var x = y; x < w; x++)
      if (E[x] === d)
        return x;
    return y;
  }
  function c(d, y, w, E, x) {
    w.splice(d, 1), E.splice(d, 1);
    for (var N = y + 1; N < x.length; N++)
      x[N]--;
  }
  function l(d, y, w, E, x, N, D) {
    x.splice(d, 0, E), N.splice(d, 0, y);
    for (var b = w + 1; b < D.length; b++)
      D[b]++;
  }
  i.prototype.resize = function(d, y, w) {
    if (!Yr(d))
      throw new TypeError("Array or Matrix expected");
    var E = d.valueOf().map((N) => Array.isArray(N) && N.length === 1 ? N[0] : N);
    if (E.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    E.forEach(function(N) {
      if (!ot(N) || !Ve(N) || N < 0)
        throw new TypeError("Invalid size, must contain positive integers (size: " + vt(E) + ")");
    });
    var x = w ? this.clone() : this;
    return m(x, E[0], E[1], y);
  };
  function m(d, y, w, E) {
    var x = E || 0, N = r, D = 0;
    hr(d._datatype) && (N = e.find(r, [d._datatype, d._datatype]) || r, D = e.convert(0, d._datatype), x = e.convert(x, d._datatype));
    var b = !N(x, D), C = d._size[0], A = d._size[1], T, _, O;
    if (w > A) {
      for (_ = A; _ < w; _++)
        if (d._ptr[_] = d._values.length, b)
          for (T = 0; T < C; T++)
            d._values.push(x), d._index.push(T);
      d._ptr[w] = d._values.length;
    } else w < A && (d._ptr.splice(w + 1, A - w), d._values.splice(d._ptr[w], d._values.length), d._index.splice(d._ptr[w], d._index.length));
    if (A = w, y > C) {
      if (b) {
        var I = 0;
        for (_ = 0; _ < A; _++) {
          d._ptr[_] = d._ptr[_] + I, O = d._ptr[_ + 1] + I;
          var B = 0;
          for (T = C; T < y; T++, B++)
            d._values.splice(O + B, 0, x), d._index.splice(O + B, 0, T), I++;
        }
        d._ptr[A] = d._values.length;
      }
    } else if (y < C) {
      var k = 0;
      for (_ = 0; _ < A; _++) {
        d._ptr[_] = d._ptr[_] - k;
        var L = d._ptr[_], F = d._ptr[_ + 1] - k;
        for (O = L; O < F; O++)
          T = d._index[O], T > y - 1 && (d._values.splice(O, 1), d._index.splice(O, 1), k++);
      }
      d._ptr[_] = d._values.length;
    }
    return d._size[0] = y, d._size[1] = w, d;
  }
  i.prototype.reshape = function(d, y) {
    if (!_t(d))
      throw new TypeError("Array expected");
    if (d.length !== 2)
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    d.forEach(function(R) {
      if (!ot(R) || !Ve(R) || R <= -2 || R === 0)
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + vt(d) + ")");
    });
    var w = this._size[0] * this._size[1];
    d = Sd(d, w);
    var E = d[0] * d[1];
    if (w !== E)
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    var x = y ? this.clone() : this;
    if (this._size[0] === d[0] && this._size[1] === d[1])
      return x;
    for (var N = [], D = 0; D < x._ptr.length; D++)
      for (var b = 0; b < x._ptr[D + 1] - x._ptr[D]; b++)
        N.push(D);
    for (var C = x._values.slice(), A = x._index.slice(), T = 0; T < x._index.length; T++) {
      var _ = A[T], O = N[T], I = _ * x._size[1] + O;
      N[T] = I % d[1], A[T] = Math.floor(I / d[1]);
    }
    x._values.length = 0, x._index.length = 0, x._ptr.length = d[1] + 1, x._size = d.slice();
    for (var B = 0; B < x._ptr.length; B++)
      x._ptr[B] = 0;
    for (var k = 0; k < C.length; k++) {
      var L = A[k], F = N[k], M = C[k], $ = s(L, x._ptr[F], x._ptr[F + 1], x._index);
      l($, L, F, M, x._values, x._index, x._ptr);
    }
    return x;
  }, i.prototype.clone = function() {
    var d = new i({
      values: this._values ? Je(this._values) : void 0,
      index: Je(this._index),
      ptr: Je(this._ptr),
      size: Je(this._size),
      datatype: this._datatype
    });
    return d;
  }, i.prototype.size = function() {
    return this._size.slice(0);
  }, i.prototype.map = function(d, y) {
    if (!this._values)
      throw new Error("Cannot invoke map on a Pattern only matrix");
    var w = this, E = this._size[0], x = this._size[1], N = Y2(d), D = function(C, A, T) {
      return N === 1 ? d(C) : N === 2 ? d(C, [A, T]) : d(C, [A, T], w);
    };
    return h(this, 0, E - 1, 0, x - 1, D, y);
  };
  function h(d, y, w, E, x, N, D) {
    var b = [], C = [], A = [], T = r, _ = 0;
    hr(d._datatype) && (T = e.find(r, [d._datatype, d._datatype]) || r, _ = e.convert(0, d._datatype));
    for (var O = function(U, pe, X) {
      U = N(U, pe, X), T(U, _) || (b.push(U), C.push(pe));
    }, I = E; I <= x; I++) {
      A.push(b.length);
      var B = d._ptr[I], k = d._ptr[I + 1];
      if (D)
        for (var L = B; L < k; L++) {
          var F = d._index[L];
          F >= y && F <= w && O(d._values[L], F - y, I - E);
        }
      else {
        for (var M = {}, $ = B; $ < k; $++) {
          var R = d._index[$];
          M[R] = d._values[$];
        }
        for (var Q = y; Q <= w; Q++) {
          var ee = Q in M ? M[Q] : 0;
          O(ee, Q - y, I - E);
        }
      }
    }
    return A.push(b.length), new i({
      values: b,
      index: C,
      ptr: A,
      size: [w - y + 1, x - E + 1]
    });
  }
  i.prototype.forEach = function(d, y) {
    if (!this._values)
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    for (var w = this, E = this._size[0], x = this._size[1], N = 0; N < x; N++) {
      var D = this._ptr[N], b = this._ptr[N + 1];
      if (y)
        for (var C = D; C < b; C++) {
          var A = this._index[C];
          d(this._values[C], [A, N], w);
        }
      else {
        for (var T = {}, _ = D; _ < b; _++) {
          var O = this._index[_];
          T[O] = this._values[_];
        }
        for (var I = 0; I < E; I++) {
          var B = I in T ? T[I] : 0;
          d(B, [I, N], w);
        }
      }
    }
  }, i.prototype[Symbol.iterator] = function* () {
    if (!this._values)
      throw new Error("Cannot iterate a Pattern only matrix");
    for (var d = this._size[1], y = 0; y < d; y++)
      for (var w = this._ptr[y], E = this._ptr[y + 1], x = w; x < E; x++) {
        var N = this._index[x];
        yield {
          value: this._values[x],
          index: [N, y]
        };
      }
  }, i.prototype.toArray = function() {
    return g(this._values, this._index, this._ptr, this._size, !0);
  }, i.prototype.valueOf = function() {
    return g(this._values, this._index, this._ptr, this._size, !1);
  };
  function g(d, y, w, E, x) {
    var N = E[0], D = E[1], b = [], C, A;
    for (C = 0; C < N; C++)
      for (b[C] = [], A = 0; A < D; A++)
        b[C][A] = 0;
    for (A = 0; A < D; A++)
      for (var T = w[A], _ = w[A + 1], O = T; O < _; O++)
        C = y[O], b[C][A] = d ? x ? Je(d[O]) : d[O] : 1;
    return b;
  }
  return i.prototype.format = function(d) {
    for (var y = this._size[0], w = this._size[1], E = this.density(), x = "Sparse Matrix [" + vt(y, d) + " x " + vt(w, d) + "] density: " + vt(E, d) + `
`, N = 0; N < w; N++)
      for (var D = this._ptr[N], b = this._ptr[N + 1], C = D; C < b; C++) {
        var A = this._index[C];
        x += `
    (` + vt(A, d) + ", " + vt(N, d) + ") ==> " + (this._values ? vt(this._values[C], d) : "X");
      }
    return x;
  }, i.prototype.toString = function() {
    return vt(this.toArray());
  }, i.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  }, i.prototype.diagonal = function(d) {
    if (d) {
      if (at(d) && (d = d.toNumber()), !ot(d) || !Ve(d))
        throw new TypeError("The parameter k must be an integer number");
    } else
      d = 0;
    var y = d > 0 ? d : 0, w = d < 0 ? -d : 0, E = this._size[0], x = this._size[1], N = Math.min(E - w, x - y), D = [], b = [], C = [];
    C[0] = 0;
    for (var A = y; A < x && D.length < N; A++)
      for (var T = this._ptr[A], _ = this._ptr[A + 1], O = T; O < _; O++) {
        var I = this._index[O];
        if (I === A - y + w) {
          D.push(this._values[O]), b[D.length - 1] = I - w;
          break;
        }
      }
    return C.push(D.length), new i({
      values: D,
      index: b,
      ptr: C,
      size: [N, 1]
    });
  }, i.fromJSON = function(d) {
    return new i(d);
  }, i.diagonal = function(d, y, w, E, x) {
    if (!_t(d))
      throw new TypeError("Array expected, size parameter");
    if (d.length !== 2)
      throw new Error("Only two dimensions matrix are supported");
    if (d = d.map(function(R) {
      if (at(R) && (R = R.toNumber()), !ot(R) || !Ve(R) || R < 1)
        throw new Error("Size values must be positive integers");
      return R;
    }), w) {
      if (at(w) && (w = w.toNumber()), !ot(w) || !Ve(w))
        throw new TypeError("The parameter k must be an integer number");
    } else
      w = 0;
    var N = r, D = 0;
    hr(x) && (N = e.find(r, [x, x]) || r, D = e.convert(0, x));
    var b = w > 0 ? w : 0, C = w < 0 ? -w : 0, A = d[0], T = d[1], _ = Math.min(A - C, T - b), O;
    if (_t(y)) {
      if (y.length !== _)
        throw new Error("Invalid value array length");
      O = function(Q) {
        return y[Q];
      };
    } else if (Ye(y)) {
      var I = y.size();
      if (I.length !== 1 || I[0] !== _)
        throw new Error("Invalid matrix length");
      O = function(Q) {
        return y.get([Q]);
      };
    } else
      O = function() {
        return y;
      };
    for (var B = [], k = [], L = [], F = 0; F < T; F++) {
      L.push(B.length);
      var M = F - b;
      if (M >= 0 && M < _) {
        var $ = O(M);
        N($, D) || (k.push(M + C), B.push($));
      }
    }
    return L.push(B.length), new i({
      values: B,
      index: k,
      ptr: L,
      size: [A, T]
    });
  }, i.prototype.swapRows = function(d, y) {
    if (!ot(d) || !Ve(d) || !ot(y) || !Ve(y))
      throw new Error("Row index must be positive integers");
    if (this._size.length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    return Pt(d, this._size[0]), Pt(y, this._size[0]), i._swapRows(d, y, this._size[1], this._values, this._index, this._ptr), this;
  }, i._forEachRow = function(d, y, w, E, x) {
    for (var N = E[d], D = E[d + 1], b = N; b < D; b++)
      x(w[b], y[b]);
  }, i._swapRows = function(d, y, w, E, x, N) {
    for (var D = 0; D < w; D++) {
      var b = N[D], C = N[D + 1], A = s(d, b, C, x), T = s(y, b, C, x);
      if (A < C && T < C && x[A] === d && x[T] === y) {
        if (E) {
          var _ = E[A];
          E[A] = E[T], E[T] = _;
        }
        continue;
      }
      if (A < C && x[A] === d && (T >= C || x[T] !== y)) {
        var O = E ? E[A] : void 0;
        x.splice(T, 0, y), E && E.splice(T, 0, O), x.splice(T <= A ? A + 1 : A, 1), E && E.splice(T <= A ? A + 1 : A, 1);
        continue;
      }
      if (T < C && x[T] === y && (A >= C || x[A] !== d)) {
        var I = E ? E[T] : void 0;
        x.splice(A, 0, d), E && E.splice(A, 0, I), x.splice(A <= T ? T + 1 : T, 1), E && E.splice(A <= T ? T + 1 : T, 1);
      }
    }
  }, i;
}, {
  isClass: !0
}), l3 = "number", c3 = ["typed"];
function f3(t) {
  var e = t.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (e) {
    var r = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[e[1]], n = e[2], i = e[3];
    return {
      input: t,
      radix: r,
      integerPart: n,
      fractionalPart: i
    };
  } else
    return null;
}
function p3(t) {
  for (var e = parseInt(t.integerPart, t.radix), r = 0, n = 0; n < t.fractionalPart.length; n++) {
    var i = parseInt(t.fractionalPart[n], t.radix);
    r += i / Math.pow(t.radix, n + 1);
  }
  var a = e + r;
  if (isNaN(a))
    throw new SyntaxError('String "' + t.input + '" is not a valid number');
  return a;
}
var Qu = /* @__PURE__ */ H(l3, c3, (t) => {
  var {
    typed: e
  } = t, r = e("number", {
    "": function() {
      return 0;
    },
    number: function(i) {
      return i;
    },
    string: function(i) {
      if (i === "NaN") return NaN;
      var a = f3(i);
      if (a)
        return p3(a);
      var o = 0, f = i.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      f && (o = Number(f[2]), i = f[1]);
      var u = Number(i);
      if (isNaN(u))
        throw new SyntaxError('String "' + i + '" is not a valid number');
      if (f) {
        if (u > 2 ** o - 1)
          throw new SyntaxError('String "'.concat(i, '" is out of range'));
        u >= 2 ** (o - 1) && (u = u - 2 ** o);
      }
      return u;
    },
    BigNumber: function(i) {
      return i.toNumber();
    },
    bigint: function(i) {
      return Number(i);
    },
    Fraction: function(i) {
      return i.valueOf();
    },
    Unit: e.referToSelf((n) => (i) => {
      var a = i.clone();
      return a.value = n(i.value), a;
    }),
    null: function(i) {
      return 0;
    },
    "Unit, string | Unit": function(i, a) {
      return i.toNumber(a);
    },
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
  return r.fromJSON = function(n) {
    return parseFloat(n.value);
  }, r;
}), m3 = "bigint", h3 = ["typed"], Vu = /* @__PURE__ */ H(m3, h3, (t) => {
  var {
    typed: e
  } = t, r = e("bigint", {
    "": function() {
      return 0n;
    },
    bigint: function(i) {
      return i;
    },
    number: function(i) {
      return BigInt(i.toFixed());
    },
    BigNumber: function(i) {
      return BigInt(i.round().toString());
    },
    Fraction: function(i) {
      return BigInt(i.valueOf().toFixed());
    },
    "string | boolean": function(i) {
      return BigInt(i);
    },
    null: function(i) {
      return 0n;
    },
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
  return r.fromJSON = function(n) {
    return BigInt(n.value);
  }, r;
}), h1 = "string", d3 = ["typed"], Wu = /* @__PURE__ */ H(h1, d3, (t) => {
  var {
    typed: e
  } = t;
  return e(h1, {
    "": function() {
      return "";
    },
    number: Vi,
    null: function(n) {
      return "null";
    },
    boolean: function(n) {
      return n + "";
    },
    string: function(n) {
      return n;
    },
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r)),
    any: function(n) {
      return String(n);
    }
  });
}), d1 = "boolean", g3 = ["typed"], ju = /* @__PURE__ */ H(d1, g3, (t) => {
  var {
    typed: e
  } = t;
  return e(d1, {
    "": function() {
      return !1;
    },
    boolean: function(n) {
      return n;
    },
    number: function(n) {
      return !!n;
    },
    null: function(n) {
      return !1;
    },
    BigNumber: function(n) {
      return !n.isZero();
    },
    string: function(n) {
      var i = n.toLowerCase();
      if (i === "true")
        return !0;
      if (i === "false")
        return !1;
      var a = Number(n);
      if (n !== "" && !isNaN(a))
        return !!a;
      throw new Error('Cannot convert "' + n + '" to a boolean');
    },
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), v3 = "bignumber", y3 = ["typed", "BigNumber"], Yu = /* @__PURE__ */ H(v3, y3, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e("bignumber", {
    "": function() {
      return new r(0);
    },
    number: function(i) {
      return new r(i + "");
    },
    string: function(i) {
      var a = i.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (a) {
        var o = a[2], f = r(a[1]), u = new r(2).pow(Number(o));
        if (f.gt(u.sub(1)))
          throw new SyntaxError('String "'.concat(i, '" is out of range'));
        var s = new r(2).pow(Number(o) - 1);
        return f.gte(s) ? f.sub(u) : f;
      }
      return new r(i);
    },
    BigNumber: function(i) {
      return i;
    },
    bigint: function(i) {
      return new r(i.toString());
    },
    Unit: e.referToSelf((n) => (i) => {
      var a = i.clone();
      return a.value = n(i.value), a;
    }),
    Fraction: function(i) {
      return new r(i.n).div(i.d).times(i.s);
    },
    null: function(i) {
      return new r(0);
    },
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), x3 = "complex", b3 = ["typed", "Complex"], Zu = /* @__PURE__ */ H(x3, b3, (t) => {
  var {
    typed: e,
    Complex: r
  } = t;
  return e("complex", {
    "": function() {
      return r.ZERO;
    },
    number: function(i) {
      return new r(i, 0);
    },
    "number, number": function(i, a) {
      return new r(i, a);
    },
    // TODO: this signature should be redundant
    "BigNumber, BigNumber": function(i, a) {
      return new r(i.toNumber(), a.toNumber());
    },
    Fraction: function(i) {
      return new r(i.valueOf(), 0);
    },
    Complex: function(i) {
      return i.clone();
    },
    string: function(i) {
      return r(i);
    },
    null: function(i) {
      return r(0);
    },
    Object: function(i) {
      if ("re" in i && "im" in i)
        return new r(i.re, i.im);
      if ("r" in i && "phi" in i || "abs" in i && "arg" in i)
        return new r(i);
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), w3 = "fraction", N3 = ["typed", "Fraction"], Ju = /* @__PURE__ */ H(w3, N3, (t) => {
  var {
    typed: e,
    Fraction: r
  } = t;
  return e("fraction", {
    number: function(i) {
      if (!isFinite(i) || isNaN(i))
        throw new Error(i + " cannot be represented as a fraction");
      return new r(i);
    },
    string: function(i) {
      return new r(i);
    },
    "number, number": function(i, a) {
      return new r(i, a);
    },
    null: function(i) {
      return new r(0);
    },
    BigNumber: function(i) {
      return new r(i.toString());
    },
    bigint: function(i) {
      return new r(i.toString());
    },
    Fraction: function(i) {
      return i;
    },
    Unit: e.referToSelf((n) => (i) => {
      var a = i.clone();
      return a.value = n(i.value), a;
    }),
    Object: function(i) {
      return new r(i);
    },
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), g1 = "matrix", D3 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"], Xu = /* @__PURE__ */ H(g1, D3, (t) => {
  var {
    typed: e,
    Matrix: r,
    DenseMatrix: n,
    SparseMatrix: i
  } = t;
  return e(g1, {
    "": function() {
      return a([]);
    },
    string: function(f) {
      return a([], f);
    },
    "string, string": function(f, u) {
      return a([], f, u);
    },
    Array: function(f) {
      return a(f);
    },
    Matrix: function(f) {
      return a(f, f.storage());
    },
    "Array | Matrix, string": a,
    "Array | Matrix, string, string": a
  });
  function a(o, f, u) {
    if (f === "dense" || f === "default" || f === void 0)
      return new n(o, u);
    if (f === "sparse")
      return new i(o, u);
    throw new TypeError("Unknown matrix type " + JSON.stringify(f) + ".");
  }
}), v1 = "matrixFromFunction", E3 = ["typed", "matrix", "isZero"], Ku = /* @__PURE__ */ H(v1, E3, (t) => {
  var {
    typed: e,
    matrix: r,
    isZero: n
  } = t;
  return e(v1, {
    "Array | Matrix, function, string, string": function(o, f, u, s) {
      return i(o, f, u, s);
    },
    "Array | Matrix, function, string": function(o, f, u) {
      return i(o, f, u);
    },
    "Matrix, function": function(o, f) {
      return i(o, f, "dense");
    },
    "Array, function": function(o, f) {
      return i(o, f, "dense").toArray();
    },
    "Array | Matrix, string, function": function(o, f, u) {
      return i(o, u, f);
    },
    "Array | Matrix, string, string, function": function(o, f, u, s) {
      return i(o, s, f, u);
    }
  });
  function i(a, o, f, u) {
    var s;
    return u !== void 0 ? s = r(f, u) : s = r(f), s.resize(a), s.forEach(function(c, l) {
      var m = o(l);
      n(m) || s.set(l, m);
    }), s;
  }
}), y1 = "matrixFromRows", S3 = ["typed", "matrix", "flatten", "size"], e0 = /* @__PURE__ */ H(y1, S3, (t) => {
  var {
    typed: e,
    matrix: r,
    flatten: n,
    size: i
  } = t;
  return e(y1, {
    "...Array": function(u) {
      return a(u);
    },
    "...Matrix": function(u) {
      return r(a(u.map((s) => s.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function a(f) {
    if (f.length === 0) throw new TypeError("At least one row is needed to construct a matrix.");
    var u = o(f[0]), s = [];
    for (var c of f) {
      var l = o(c);
      if (l !== u)
        throw new TypeError("The vectors had different length: " + (u | 0) + " ≠ " + (l | 0));
      s.push(n(c));
    }
    return s;
  }
  function o(f) {
    var u = i(f);
    if (u.length === 1)
      return u[0];
    if (u.length === 2) {
      if (u[0] === 1)
        return u[1];
      if (u[1] === 1)
        return u[0];
      throw new TypeError("At least one of the arguments is not a vector.");
    } else
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
  }
}), x1 = "matrixFromColumns", A3 = ["typed", "matrix", "flatten", "size"], t0 = /* @__PURE__ */ H(x1, A3, (t) => {
  var {
    typed: e,
    matrix: r,
    flatten: n,
    size: i
  } = t;
  return e(x1, {
    "...Array": function(u) {
      return a(u);
    },
    "...Matrix": function(u) {
      return r(a(u.map((s) => s.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function a(f) {
    if (f.length === 0) throw new TypeError("At least one column is needed to construct a matrix.");
    for (var u = o(f[0]), s = [], c = 0; c < u; c++)
      s[c] = [];
    for (var l of f) {
      var m = o(l);
      if (m !== u)
        throw new TypeError("The vectors had different length: " + (u | 0) + " ≠ " + (m | 0));
      for (var h = n(l), g = 0; g < u; g++)
        s[g].push(h[g]);
    }
    return s;
  }
  function o(f) {
    var u = i(f);
    if (u.length === 1)
      return u[0];
    if (u.length === 2) {
      if (u[0] === 1)
        return u[1];
      if (u[1] === 1)
        return u[0];
      throw new TypeError("At least one of the arguments is not a vector.");
    } else
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
  }
}), b1 = "splitUnit", C3 = ["typed"], r0 = /* @__PURE__ */ H(b1, C3, (t) => {
  var {
    typed: e
  } = t;
  return e(b1, {
    "Unit, Array": function(n, i) {
      return n.splitUnit(i);
    }
  });
}), w1 = "unaryMinus", T3 = ["typed"], n0 = /* @__PURE__ */ H(w1, T3, (t) => {
  var {
    typed: e
  } = t;
  return e(w1, {
    number: tw,
    "Complex | BigNumber | Fraction": (r) => r.neg(),
    bigint: (r) => -r,
    Unit: e.referToSelf((r) => (n) => {
      var i = n.clone();
      return i.value = e.find(r, i.valueType())(n.value), i;
    }),
    // deep map collection, skip zeros since unaryMinus(0) = 0
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
    // TODO: add support for string
  });
}), N1 = "unaryPlus", _3 = ["typed", "config", "numeric"], i0 = /* @__PURE__ */ H(N1, _3, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n
  } = t;
  return e(N1, {
    number: rw,
    Complex: function(a) {
      return a;
    },
    BigNumber: function(a) {
      return a;
    },
    bigint: function(a) {
      return a;
    },
    Fraction: function(a) {
      return a;
    },
    Unit: function(a) {
      return a.clone();
    },
    // deep map collection, skip zeros since unaryPlus(0) = 0
    "Array | Matrix": e.referToSelf((i) => (a) => gt(a, i)),
    boolean: function(a) {
      return n(a ? 1 : 0, r.number);
    },
    string: function(a) {
      return n(a, wi(a, r));
    }
  });
}), D1 = "abs", M3 = ["typed"], a0 = /* @__PURE__ */ H(D1, M3, (t) => {
  var {
    typed: e
  } = t;
  return e(D1, {
    number: J2,
    "Complex | BigNumber | Fraction | Unit": (r) => r.abs(),
    bigint: (r) => r < 0n ? -r : r,
    // deep map collection, skip zeros since abs(0) = 0
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), E1 = "apply", O3 = ["typed", "isInteger"], Ua = /* @__PURE__ */ H(E1, O3, (t) => {
  var {
    typed: e,
    isInteger: r
  } = t;
  return e(E1, {
    "Array | Matrix, number | BigNumber, function": function(i, a, o) {
      if (!r(a))
        throw new TypeError("Integer number expected for dimension");
      var f = Array.isArray(i) ? ft(i) : i.size();
      if (a < 0 || a >= f.length)
        throw new nn(a, f.length);
      return Ye(i) ? i.create(iu(i.valueOf(), a, o)) : iu(i, a, o);
    }
  });
});
function iu(t, e, r) {
  var n, i, a;
  if (e <= 0)
    if (Array.isArray(t[0])) {
      for (a = q3(t), i = [], n = 0; n < a.length; n++)
        i[n] = iu(a[n], e - 1, r);
      return i;
    } else
      return r(t);
  else {
    for (i = [], n = 0; n < t.length; n++)
      i[n] = iu(t[n], e - 1, r);
    return i;
  }
}
function q3(t) {
  var e = t.length, r = t[0].length, n, i, a = [];
  for (i = 0; i < r; i++) {
    var o = [];
    for (n = 0; n < e; n++)
      o.push(t[n][i]);
    a.push(o);
  }
  return a;
}
var S1 = "addScalar", I3 = ["typed"], s0 = /* @__PURE__ */ H(S1, I3, (t) => {
  var {
    typed: e
  } = t;
  return e(S1, {
    "number, number": X2,
    "Complex, Complex": function(n, i) {
      return n.add(i);
    },
    "BigNumber, BigNumber": function(n, i) {
      return n.plus(i);
    },
    "bigint, bigint": function(n, i) {
      return n + i;
    },
    "Fraction, Fraction": function(n, i) {
      return n.add(i);
    },
    "Unit, Unit": e.referToSelf((r) => (n, i) => {
      if (n.value === null || n.value === void 0)
        throw new Error("Parameter x contains a unit with undefined value");
      if (i.value === null || i.value === void 0)
        throw new Error("Parameter y contains a unit with undefined value");
      if (!n.equalBase(i)) throw new Error("Units do not match");
      var a = n.clone();
      return a.value = e.find(r, [a.valueType(), i.valueType()])(a.value, i.value), a.fixPrefix = !1, a;
    })
  });
}), A1 = "subtractScalar", F3 = ["typed"], o0 = /* @__PURE__ */ H(A1, F3, (t) => {
  var {
    typed: e
  } = t;
  return e(A1, {
    "number, number": K2,
    "Complex, Complex": function(n, i) {
      return n.sub(i);
    },
    "BigNumber, BigNumber": function(n, i) {
      return n.minus(i);
    },
    "bigint, bigint": function(n, i) {
      return n - i;
    },
    "Fraction, Fraction": function(n, i) {
      return n.sub(i);
    },
    "Unit, Unit": e.referToSelf((r) => (n, i) => {
      if (n.value === null || n.value === void 0)
        throw new Error("Parameter x contains a unit with undefined value");
      if (i.value === null || i.value === void 0)
        throw new Error("Parameter y contains a unit with undefined value");
      if (!n.equalBase(i)) throw new Error("Units do not match");
      var a = n.clone();
      return a.value = e.find(r, [a.valueType(), i.valueType()])(a.value, i.value), a.fixPrefix = !1, a;
    })
  });
}), C1 = "cbrt", B3 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"], u0 = /* @__PURE__ */ H(C1, B3, (t) => {
  var {
    config: e,
    typed: r,
    isNegative: n,
    unaryMinus: i,
    matrix: a,
    Complex: o,
    BigNumber: f,
    Fraction: u
  } = t;
  return r(C1, {
    number: ys,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex
    Complex: s,
    "Complex, boolean": s,
    BigNumber: function(m) {
      return m.cbrt();
    },
    Unit: c
  });
  function s(l, m) {
    var h = l.arg() / 3, g = l.abs(), d = new o(ys(g), 0).mul(new o(0, h).exp());
    if (m) {
      var y = [d, new o(ys(g), 0).mul(new o(0, h + Math.PI * 2 / 3).exp()), new o(ys(g), 0).mul(new o(0, h - Math.PI * 2 / 3).exp())];
      return e.matrix === "Array" ? y : a(y);
    } else
      return d;
  }
  function c(l) {
    if (l.value && dn(l.value)) {
      var m = l.clone();
      return m.value = 1, m = m.pow(1 / 3), m.value = s(l.value), m;
    } else {
      var h = n(l.value);
      h && (l.value = i(l.value));
      var g;
      at(l.value) ? g = new f(1).div(3) : xi(l.value) ? g = new u(1, 3) : g = 1 / 3;
      var d = l.pow(g);
      return h && (d.value = i(d.value)), d;
    }
  }
}), R3 = "matAlgo11xS0s", P3 = ["typed", "equalScalar"], Sr = /* @__PURE__ */ H(R3, P3, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(i, a, o, f) {
    var u = i._values, s = i._index, c = i._ptr, l = i._size, m = i._datatype;
    if (!u)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var h = l[0], g = l[1], d, y = r, w = 0, E = o;
    typeof m == "string" && (d = m, y = e.find(r, [d, d]), w = e.convert(0, d), a = e.convert(a, d), E = e.find(o, [d, d]));
    for (var x = [], N = [], D = [], b = 0; b < g; b++) {
      D[b] = N.length;
      for (var C = c[b], A = c[b + 1], T = C; T < A; T++) {
        var _ = s[T], O = f ? E(a, u[T]) : E(u[T], a);
        y(O, w) || (N.push(_), x.push(O));
      }
    }
    return D[g] = N.length, i.createSparseMatrix({
      values: x,
      index: N,
      ptr: D,
      size: [h, g],
      datatype: d
    });
  };
}), L3 = "matAlgo12xSfs", k3 = ["typed", "DenseMatrix"], cr = /* @__PURE__ */ H(L3, k3, (t) => {
  var {
    typed: e,
    DenseMatrix: r
  } = t;
  return function(i, a, o, f) {
    var u = i._values, s = i._index, c = i._ptr, l = i._size, m = i._datatype;
    if (!u)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var h = l[0], g = l[1], d, y = o;
    typeof m == "string" && (d = m, a = e.convert(a, d), y = e.find(o, [d, d]));
    for (var w = [], E = [], x = [], N = 0; N < g; N++) {
      for (var D = N + 1, b = c[N], C = c[N + 1], A = b; A < C; A++) {
        var T = s[A];
        E[T] = u[A], x[T] = D;
      }
      for (var _ = 0; _ < h; _++)
        N === 0 && (w[_] = []), x[_] === D ? w[_][N] = f ? y(a, E[_]) : y(E[_], a) : w[_][N] = f ? y(a, 0) : y(0, a);
    }
    return new r({
      data: w,
      size: [h, g],
      datatype: d
    });
  };
}), z3 = "matAlgo14xDs", $3 = ["typed"], _n = /* @__PURE__ */ H(z3, $3, (t) => {
  var {
    typed: e
  } = t;
  return function(i, a, o, f) {
    var u = i._data, s = i._size, c = i._datatype, l, m = o;
    typeof c == "string" && (l = c, a = e.convert(a, l), m = e.find(o, [l, l]));
    var h = s.length > 0 ? r(m, 0, s, s[0], u, a, f) : [];
    return i.createDenseMatrix({
      data: h,
      size: Je(s),
      datatype: l
    });
  };
  function r(n, i, a, o, f, u, s) {
    var c = [];
    if (i === a.length - 1)
      for (var l = 0; l < o; l++)
        c[l] = s ? n(u, f[l]) : n(f[l], u);
    else
      for (var m = 0; m < o; m++)
        c[m] = r(n, i + 1, a, a[i + 1], f[m], u, s);
    return c;
  }
}), Kh = "ceil", U3 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"], G3 = /* @__PURE__ */ H(Kh, ["typed", "config", "round"], (t) => {
  var {
    typed: e,
    config: r,
    round: n
  } = t;
  return e(Kh, {
    number: function(a) {
      return Er(a, n(a), r.relTol, r.absTol) ? n(a) : Math.ceil(a);
    },
    "number, number": function(a, o) {
      if (Er(a, n(a, o), r.relTol, r.absTol))
        return n(a, o);
      var [f, u] = "".concat(a, "e").split("e"), s = Math.ceil(Number("".concat(f, "e").concat(Number(u) + o)));
      return [f, u] = "".concat(s, "e").split("e"), Number("".concat(f, "e").concat(Number(u) - o));
    }
  });
}), l0 = /* @__PURE__ */ H(Kh, U3, (t) => {
  var {
    typed: e,
    config: r,
    round: n,
    matrix: i,
    equalScalar: a,
    zeros: o,
    DenseMatrix: f
  } = t, u = Sr({
    typed: e,
    equalScalar: a
  }), s = cr({
    typed: e,
    DenseMatrix: f
  }), c = _n({
    typed: e
  }), l = G3({
    typed: e,
    config: r,
    round: n
  });
  return e("ceil", {
    number: l.signatures.number,
    "number,number": l.signatures["number,number"],
    Complex: function(h) {
      return h.ceil();
    },
    "Complex, number": function(h, g) {
      return h.ceil(g);
    },
    "Complex, BigNumber": function(h, g) {
      return h.ceil(g.toNumber());
    },
    BigNumber: function(h) {
      return Jr(h, n(h), r.relTol, r.absTol) ? n(h) : h.ceil();
    },
    "BigNumber, BigNumber": function(h, g) {
      return Jr(h, n(h, g), r.relTol, r.absTol) ? n(h, g) : h.toDecimalPlaces(g.toNumber(), vi.ROUND_CEIL);
    },
    Fraction: function(h) {
      return h.ceil();
    },
    "Fraction, number": function(h, g) {
      return h.ceil(g);
    },
    "Fraction, BigNumber": function(h, g) {
      return h.ceil(g.toNumber());
    },
    "Array | Matrix": e.referToSelf((m) => (h) => gt(h, m)),
    "Array, number | BigNumber": e.referToSelf((m) => (h, g) => gt(h, (d) => m(d, g))),
    "SparseMatrix, number | BigNumber": e.referToSelf((m) => (h, g) => u(h, g, m, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((m) => (h, g) => c(h, g, m, !1)),
    "number | Complex | Fraction | BigNumber, Array": e.referToSelf((m) => (h, g) => c(i(g), h, m, !0).valueOf()),
    "number | Complex | Fraction | BigNumber, Matrix": e.referToSelf((m) => (h, g) => a(h, 0) ? o(g.size(), g.storage()) : g.storage() === "dense" ? c(g, h, m, !0) : s(g, h, m, !0))
  });
}), T1 = "cube", H3 = ["typed"], c0 = /* @__PURE__ */ H(T1, H3, (t) => {
  var {
    typed: e
  } = t;
  return e(T1, {
    number: nw,
    Complex: function(n) {
      return n.mul(n).mul(n);
    },
    BigNumber: function(n) {
      return n.times(n).times(n);
    },
    bigint: function(n) {
      return n * n * n;
    },
    Fraction: function(n) {
      return n.pow(3);
    },
    Unit: function(n) {
      return n.pow(3);
    }
  });
}), _1 = "exp", Q3 = ["typed"], f0 = /* @__PURE__ */ H(_1, Q3, (t) => {
  var {
    typed: e
  } = t;
  return e(_1, {
    number: iw,
    Complex: function(n) {
      return n.exp();
    },
    BigNumber: function(n) {
      return n.exp();
    }
  });
}), M1 = "expm1", V3 = ["typed", "Complex"], p0 = /* @__PURE__ */ H(M1, V3, (t) => {
  var {
    typed: e,
    Complex: r
  } = t;
  return e(M1, {
    number: aw,
    Complex: function(i) {
      var a = Math.exp(i.re);
      return new r(a * Math.cos(i.im) - 1, a * Math.sin(i.im));
    },
    BigNumber: function(i) {
      return i.exp().minus(1);
    }
  });
}), ed = "fix", W3 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"], j3 = /* @__PURE__ */ H(ed, ["typed", "ceil", "floor"], (t) => {
  var {
    typed: e,
    ceil: r,
    floor: n
  } = t;
  return e(ed, {
    number: function(a) {
      return a > 0 ? n(a) : r(a);
    },
    "number, number": function(a, o) {
      return a > 0 ? n(a, o) : r(a, o);
    }
  });
}), m0 = /* @__PURE__ */ H(ed, W3, (t) => {
  var {
    typed: e,
    Complex: r,
    matrix: n,
    ceil: i,
    floor: a,
    equalScalar: o,
    zeros: f,
    DenseMatrix: u
  } = t, s = cr({
    typed: e,
    DenseMatrix: u
  }), c = _n({
    typed: e
  }), l = j3({
    typed: e,
    ceil: i,
    floor: a
  });
  return e("fix", {
    number: l.signatures.number,
    "number, number | BigNumber": l.signatures["number,number"],
    Complex: function(h) {
      return new r(h.re > 0 ? Math.floor(h.re) : Math.ceil(h.re), h.im > 0 ? Math.floor(h.im) : Math.ceil(h.im));
    },
    "Complex, number": function(h, g) {
      return new r(h.re > 0 ? a(h.re, g) : i(h.re, g), h.im > 0 ? a(h.im, g) : i(h.im, g));
    },
    "Complex, BigNumber": function(h, g) {
      var d = g.toNumber();
      return new r(h.re > 0 ? a(h.re, d) : i(h.re, d), h.im > 0 ? a(h.im, d) : i(h.im, d));
    },
    BigNumber: function(h) {
      return h.isNegative() ? i(h) : a(h);
    },
    "BigNumber, number | BigNumber": function(h, g) {
      return h.isNegative() ? i(h, g) : a(h, g);
    },
    Fraction: function(h) {
      return h.s < 0 ? h.ceil() : h.floor();
    },
    "Fraction, number | BigNumber": function(h, g) {
      return h.s < 0 ? i(h, g) : a(h, g);
    },
    "Array | Matrix": e.referToSelf((m) => (h) => gt(h, m)),
    "Array | Matrix, number | BigNumber": e.referToSelf((m) => (h, g) => gt(h, (d) => m(d, g))),
    "number | Complex | Fraction | BigNumber, Array": e.referToSelf((m) => (h, g) => c(n(g), h, m, !0).valueOf()),
    "number | Complex | Fraction | BigNumber, Matrix": e.referToSelf((m) => (h, g) => o(h, 0) ? f(g.size(), g.storage()) : g.storage() === "dense" ? c(g, h, m, !0) : s(g, h, m, !0))
  });
}), td = "floor", Y3 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"], Z3 = /* @__PURE__ */ H(td, ["typed", "config", "round"], (t) => {
  var {
    typed: e,
    config: r,
    round: n
  } = t;
  return e(td, {
    number: function(a) {
      return Er(a, n(a), r.relTol, r.absTol) ? n(a) : Math.floor(a);
    },
    "number, number": function(a, o) {
      if (Er(a, n(a, o), r.relTol, r.absTol))
        return n(a, o);
      var [f, u] = "".concat(a, "e").split("e"), s = Math.floor(Number("".concat(f, "e").concat(Number(u) + o)));
      return [f, u] = "".concat(s, "e").split("e"), Number("".concat(f, "e").concat(Number(u) - o));
    }
  });
}), Fs = /* @__PURE__ */ H(td, Y3, (t) => {
  var {
    typed: e,
    config: r,
    round: n,
    matrix: i,
    equalScalar: a,
    zeros: o,
    DenseMatrix: f
  } = t, u = Sr({
    typed: e,
    equalScalar: a
  }), s = cr({
    typed: e,
    DenseMatrix: f
  }), c = _n({
    typed: e
  }), l = Z3({
    typed: e,
    config: r,
    round: n
  });
  return e("floor", {
    number: l.signatures.number,
    "number,number": l.signatures["number,number"],
    Complex: function(h) {
      return h.floor();
    },
    "Complex, number": function(h, g) {
      return h.floor(g);
    },
    "Complex, BigNumber": function(h, g) {
      return h.floor(g.toNumber());
    },
    BigNumber: function(h) {
      return Jr(h, n(h), r.relTol, r.absTol) ? n(h) : h.floor();
    },
    "BigNumber, BigNumber": function(h, g) {
      return Jr(h, n(h, g), r.relTol, r.absTol) ? n(h, g) : h.toDecimalPlaces(g.toNumber(), vi.ROUND_FLOOR);
    },
    Fraction: function(h) {
      return h.floor();
    },
    "Fraction, number": function(h, g) {
      return h.floor(g);
    },
    "Fraction, BigNumber": function(h, g) {
      return h.floor(g.toNumber());
    },
    "Array | Matrix": e.referToSelf((m) => (h) => gt(h, m)),
    "Array, number | BigNumber": e.referToSelf((m) => (h, g) => gt(h, (d) => m(d, g))),
    "SparseMatrix, number | BigNumber": e.referToSelf((m) => (h, g) => u(h, g, m, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((m) => (h, g) => c(h, g, m, !1)),
    "number | Complex | Fraction | BigNumber, Array": e.referToSelf((m) => (h, g) => c(i(g), h, m, !0).valueOf()),
    "number | Complex | Fraction | BigNumber, Matrix": e.referToSelf((m) => (h, g) => a(h, 0) ? o(g.size(), g.storage()) : g.storage() === "dense" ? c(g, h, m, !0) : s(g, h, m, !0))
  });
}), J3 = "matAlgo02xDS0", X3 = ["typed", "equalScalar"], Mn = /* @__PURE__ */ H(J3, X3, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(i, a, o, f) {
    var u = i._data, s = i._size, c = i._datatype || i.getDataType(), l = a._values, m = a._index, h = a._ptr, g = a._size, d = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (s.length !== g.length)
      throw new mt(s.length, g.length);
    if (s[0] !== g[0] || s[1] !== g[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + s + ") must match Matrix B (" + g + ")");
    if (!l)
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    var y = s[0], w = s[1], E, x = r, N = 0, D = o;
    typeof c == "string" && c === d && c !== "mixed" && (E = c, x = e.find(r, [E, E]), N = e.convert(0, E), D = e.find(o, [E, E]));
    for (var b = [], C = [], A = [], T = 0; T < w; T++) {
      A[T] = C.length;
      for (var _ = h[T], O = h[T + 1], I = _; I < O; I++) {
        var B = m[I], k = f ? D(l[I], u[B][T]) : D(u[B][T], l[I]);
        x(k, N) || (C.push(B), b.push(k));
      }
    }
    return A[w] = C.length, a.createSparseMatrix({
      values: b,
      index: C,
      ptr: A,
      size: [y, w],
      datatype: c === i._datatype && d === a._datatype ? E : void 0
    });
  };
}), K3 = "matAlgo03xDSf", e_ = ["typed"], Ur = /* @__PURE__ */ H(K3, e_, (t) => {
  var {
    typed: e
  } = t;
  return function(n, i, a, o) {
    var f = n._data, u = n._size, s = n._datatype || n.getDataType(), c = i._values, l = i._index, m = i._ptr, h = i._size, g = i._datatype || i._data === void 0 ? i._datatype : i.getDataType();
    if (u.length !== h.length)
      throw new mt(u.length, h.length);
    if (u[0] !== h[0] || u[1] !== h[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + h + ")");
    if (!c)
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    var d = u[0], y = u[1], w, E = 0, x = a;
    typeof s == "string" && s === g && s !== "mixed" && (w = s, E = e.convert(0, w), x = e.find(a, [w, w]));
    for (var N = [], D = 0; D < d; D++)
      N[D] = [];
    for (var b = [], C = [], A = 0; A < y; A++) {
      for (var T = A + 1, _ = m[A], O = m[A + 1], I = _; I < O; I++) {
        var B = l[I];
        b[B] = o ? x(c[I], f[B][A]) : x(f[B][A], c[I]), C[B] = T;
      }
      for (var k = 0; k < d; k++)
        C[k] === T ? N[k][A] = b[k] : N[k][A] = o ? x(E, f[k][A]) : x(f[k][A], E);
    }
    return n.createDenseMatrix({
      data: N,
      size: [d, y],
      datatype: s === n._datatype && g === i._datatype ? w : void 0
    });
  };
}), t_ = "matAlgo05xSfSf", r_ = ["typed", "equalScalar"], h0 = /* @__PURE__ */ H(t_, r_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(i, a, o) {
    var f = i._values, u = i._index, s = i._ptr, c = i._size, l = i._datatype || i._data === void 0 ? i._datatype : i.getDataType(), m = a._values, h = a._index, g = a._ptr, d = a._size, y = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (c.length !== d.length)
      throw new mt(c.length, d.length);
    if (c[0] !== d[0] || c[1] !== d[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + c + ") must match Matrix B (" + d + ")");
    var w = c[0], E = c[1], x, N = r, D = 0, b = o;
    typeof l == "string" && l === y && l !== "mixed" && (x = l, N = e.find(r, [x, x]), D = e.convert(0, x), b = e.find(o, [x, x]));
    var C = f && m ? [] : void 0, A = [], T = [], _ = C ? [] : void 0, O = C ? [] : void 0, I = [], B = [], k, L, F, M;
    for (L = 0; L < E; L++) {
      T[L] = A.length;
      var $ = L + 1;
      for (F = s[L], M = s[L + 1]; F < M; F++)
        k = u[F], A.push(k), I[k] = $, _ && (_[k] = f[F]);
      for (F = g[L], M = g[L + 1]; F < M; F++)
        k = h[F], I[k] !== $ && A.push(k), B[k] = $, O && (O[k] = m[F]);
      if (C)
        for (F = T[L]; F < A.length; ) {
          k = A[F];
          var R = I[k], Q = B[k];
          if (R === $ || Q === $) {
            var ee = R === $ ? _[k] : D, j = Q === $ ? O[k] : D, U = b(ee, j);
            N(U, D) ? A.splice(F, 1) : (C.push(U), F++);
          }
        }
    }
    return T[E] = A.length, i.createSparseMatrix({
      values: C,
      index: A,
      ptr: T,
      size: [w, E],
      datatype: l === i._datatype && y === a._datatype ? x : void 0
    });
  };
}), n_ = "matAlgo13xDD", i_ = ["typed"], a_ = /* @__PURE__ */ H(n_, i_, (t) => {
  var {
    typed: e
  } = t;
  return function(i, a, o) {
    var f = i._data, u = i._size, s = i._datatype, c = a._data, l = a._size, m = a._datatype, h = [];
    if (u.length !== l.length)
      throw new mt(u.length, l.length);
    for (var g = 0; g < u.length; g++) {
      if (u[g] !== l[g])
        throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + l + ")");
      h[g] = u[g];
    }
    var d, y = o;
    typeof s == "string" && s === m && (d = s, y = e.find(o, [d, d]));
    var w = h.length > 0 ? r(y, 0, h, h[0], f, c) : [];
    return i.createDenseMatrix({
      data: w,
      size: h,
      datatype: d
    });
  };
  function r(n, i, a, o, f, u) {
    var s = [];
    if (i === a.length - 1)
      for (var c = 0; c < o; c++)
        s[c] = n(f[c], u[c]);
    else
      for (var l = 0; l < o; l++)
        s[l] = r(n, i + 1, a, a[i + 1], f[l], u[l]);
    return s;
  }
}), s_ = "broadcast", o_ = ["concat"], u_ = /* @__PURE__ */ H(s_, o_, (t) => {
  var {
    concat: e
  } = t;
  return function(i, a) {
    var o = Math.max(i._size.length, a._size.length);
    if (i._size.length === a._size.length && i._size.every((g, d) => g === a._size[d]))
      return [i, a];
    for (var f = r(i._size, o, 0), u = r(a._size, o, 0), s = [], c = 0; c < o; c++)
      s[c] = Math.max(f[c], u[c]);
    Ko(f, s), Ko(u, s);
    var l = i.clone(), m = a.clone();
    l._size.length < o ? l.reshape(r(l._size, o, 1)) : m._size.length < o && m.reshape(r(m._size, o, 1));
    for (var h = 0; h < o; h++)
      l._size[h] < s[h] && (l = n(l, s[h], h)), m._size[h] < s[h] && (m = n(m, s[h], h));
    return [l, m];
  };
  function r(i, a, o) {
    return [...Array(a - i.length).fill(o), ...i];
  }
  function n(i, a, o) {
    return e(...Array(a).fill(i), o);
  }
}), l_ = "matrixAlgorithmSuite", c_ = ["typed", "matrix", "concat"], Ut = /* @__PURE__ */ H(l_, c_, (t) => {
  var {
    typed: e,
    matrix: r,
    concat: n
  } = t, i = a_({
    typed: e
  }), a = _n({
    typed: e
  }), o = u_({
    concat: n
  });
  return function(u) {
    var s = u.elop, c = u.SD || u.DS, l;
    s ? (l = {
      "DenseMatrix, DenseMatrix": (d, y) => i(...o(d, y), s),
      "Array, Array": (d, y) => i(...o(r(d), r(y)), s).valueOf(),
      "Array, DenseMatrix": (d, y) => i(...o(r(d), y), s),
      "DenseMatrix, Array": (d, y) => i(...o(d, r(y)), s)
    }, u.SS && (l["SparseMatrix, SparseMatrix"] = (d, y) => u.SS(...o(d, y), s, !1)), u.DS && (l["DenseMatrix, SparseMatrix"] = (d, y) => u.DS(...o(d, y), s, !1), l["Array, SparseMatrix"] = (d, y) => u.DS(...o(r(d), y), s, !1)), c && (l["SparseMatrix, DenseMatrix"] = (d, y) => c(...o(y, d), s, !0), l["SparseMatrix, Array"] = (d, y) => c(...o(r(y), d), s, !0))) : (l = {
      "DenseMatrix, DenseMatrix": e.referToSelf((d) => (y, w) => i(...o(y, w), d)),
      "Array, Array": e.referToSelf((d) => (y, w) => i(...o(r(y), r(w)), d).valueOf()),
      "Array, DenseMatrix": e.referToSelf((d) => (y, w) => i(...o(r(y), w), d)),
      "DenseMatrix, Array": e.referToSelf((d) => (y, w) => i(...o(y, r(w)), d))
    }, u.SS && (l["SparseMatrix, SparseMatrix"] = e.referToSelf((d) => (y, w) => u.SS(...o(y, w), d, !1))), u.DS && (l["DenseMatrix, SparseMatrix"] = e.referToSelf((d) => (y, w) => u.DS(...o(y, w), d, !1)), l["Array, SparseMatrix"] = e.referToSelf((d) => (y, w) => u.DS(...o(r(y), w), d, !1))), c && (l["SparseMatrix, DenseMatrix"] = e.referToSelf((d) => (y, w) => c(...o(w, y), d, !0)), l["SparseMatrix, Array"] = e.referToSelf((d) => (y, w) => c(...o(r(w), y), d, !0))));
    var m = u.scalar || "any", h = u.Ds || u.Ss;
    h && (s ? (l["DenseMatrix," + m] = (d, y) => a(d, y, s, !1), l[m + ", DenseMatrix"] = (d, y) => a(y, d, s, !0), l["Array," + m] = (d, y) => a(r(d), y, s, !1).valueOf(), l[m + ", Array"] = (d, y) => a(r(y), d, s, !0).valueOf()) : (l["DenseMatrix," + m] = e.referToSelf((d) => (y, w) => a(y, w, d, !1)), l[m + ", DenseMatrix"] = e.referToSelf((d) => (y, w) => a(w, y, d, !0)), l["Array," + m] = e.referToSelf((d) => (y, w) => a(r(y), w, d, !1).valueOf()), l[m + ", Array"] = e.referToSelf((d) => (y, w) => a(r(w), y, d, !0).valueOf())));
    var g = u.sS !== void 0 ? u.sS : u.Ss;
    return s ? (u.Ss && (l["SparseMatrix," + m] = (d, y) => u.Ss(d, y, s, !1)), g && (l[m + ", SparseMatrix"] = (d, y) => g(y, d, s, !0))) : (u.Ss && (l["SparseMatrix," + m] = e.referToSelf((d) => (y, w) => u.Ss(y, w, d, !1))), g && (l[m + ", SparseMatrix"] = e.referToSelf((d) => (y, w) => g(w, y, d, !0)))), s && s.signatures && h2(l, s.signatures), l;
  };
}), O1 = "mod", f_ = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], Bs = /* @__PURE__ */ H(O1, f_, (t) => {
  var {
    typed: e,
    config: r,
    round: n,
    matrix: i,
    equalScalar: a,
    zeros: o,
    DenseMatrix: f,
    concat: u
  } = t, s = Fs({
    typed: e,
    config: r,
    round: n,
    matrix: i,
    equalScalar: a,
    zeros: o,
    DenseMatrix: f
  }), c = Mn({
    typed: e,
    equalScalar: a
  }), l = Ur({
    typed: e
  }), m = h0({
    typed: e,
    equalScalar: a
  }), h = Sr({
    typed: e,
    equalScalar: a
  }), g = cr({
    typed: e,
    DenseMatrix: f
  }), d = Ut({
    typed: e,
    matrix: i,
    concat: u
  });
  return e(O1, {
    "number, number": y,
    "BigNumber, BigNumber": function(E, x) {
      return x.isZero() ? E : E.sub(x.mul(s(E.div(x))));
    },
    "bigint, bigint": function(E, x) {
      if (x === 0n)
        return E;
      if (E < 0) {
        var N = E % x;
        return N === 0n ? N : N + x;
      }
      return E % x;
    },
    "Fraction, Fraction": function(E, x) {
      return x.equals(0) ? E : E.sub(x.mul(s(E.div(x))));
    }
  }, d({
    SS: m,
    DS: l,
    SD: c,
    Ss: h,
    sS: g
  }));
  function y(w, E) {
    return E === 0 ? w : w - E * s(w / E);
  }
}), p_ = "matAlgo01xDSid", m_ = ["typed"], Di = /* @__PURE__ */ H(p_, m_, (t) => {
  var {
    typed: e
  } = t;
  return function(n, i, a, o) {
    var f = n._data, u = n._size, s = n._datatype || n.getDataType(), c = i._values, l = i._index, m = i._ptr, h = i._size, g = i._datatype || i._data === void 0 ? i._datatype : i.getDataType();
    if (u.length !== h.length)
      throw new mt(u.length, h.length);
    if (u[0] !== h[0] || u[1] !== h[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + h + ")");
    if (!c)
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    var d = u[0], y = u[1], w = typeof s == "string" && s !== "mixed" && s === g ? s : void 0, E = w ? e.find(a, [w, w]) : a, x, N, D = [];
    for (x = 0; x < d; x++)
      D[x] = [];
    var b = [], C = [];
    for (N = 0; N < y; N++) {
      for (var A = N + 1, T = m[N], _ = m[N + 1], O = T; O < _; O++)
        x = l[O], b[x] = o ? E(c[O], f[x][N]) : E(f[x][N], c[O]), C[x] = A;
      for (x = 0; x < d; x++)
        C[x] === A ? D[x][N] = b[x] : D[x][N] = f[x][N];
    }
    return n.createDenseMatrix({
      data: D,
      size: [d, y],
      datatype: s === n._datatype && g === i._datatype ? w : void 0
    });
  };
}), h_ = "matAlgo04xSidSid", d_ = ["typed", "equalScalar"], Td = /* @__PURE__ */ H(h_, d_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(i, a, o) {
    var f = i._values, u = i._index, s = i._ptr, c = i._size, l = i._datatype || i._data === void 0 ? i._datatype : i.getDataType(), m = a._values, h = a._index, g = a._ptr, d = a._size, y = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (c.length !== d.length)
      throw new mt(c.length, d.length);
    if (c[0] !== d[0] || c[1] !== d[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + c + ") must match Matrix B (" + d + ")");
    var w = c[0], E = c[1], x, N = r, D = 0, b = o;
    typeof l == "string" && l === y && l !== "mixed" && (x = l, N = e.find(r, [x, x]), D = e.convert(0, x), b = e.find(o, [x, x]));
    var C = f && m ? [] : void 0, A = [], T = [], _ = f && m ? [] : void 0, O = f && m ? [] : void 0, I = [], B = [], k, L, F, M, $;
    for (L = 0; L < E; L++) {
      T[L] = A.length;
      var R = L + 1;
      for (M = s[L], $ = s[L + 1], F = M; F < $; F++)
        k = u[F], A.push(k), I[k] = R, _ && (_[k] = f[F]);
      for (M = g[L], $ = g[L + 1], F = M; F < $; F++)
        if (k = h[F], I[k] === R) {
          if (_) {
            var Q = b(_[k], m[F]);
            N(Q, D) ? I[k] = null : _[k] = Q;
          }
        } else
          A.push(k), B[k] = R, O && (O[k] = m[F]);
      if (_ && O)
        for (F = T[L]; F < A.length; )
          k = A[F], I[k] === R ? (C[F] = _[k], F++) : B[k] === R ? (C[F] = O[k], F++) : A.splice(F, 1);
    }
    return T[E] = A.length, i.createSparseMatrix({
      values: C,
      index: A,
      ptr: T,
      size: [w, E],
      datatype: l === i._datatype && y === a._datatype ? x : void 0
    });
  };
}), g_ = "matAlgo10xSids", v_ = ["typed", "DenseMatrix"], ea = /* @__PURE__ */ H(g_, v_, (t) => {
  var {
    typed: e,
    DenseMatrix: r
  } = t;
  return function(i, a, o, f) {
    var u = i._values, s = i._index, c = i._ptr, l = i._size, m = i._datatype;
    if (!u)
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    var h = l[0], g = l[1], d, y = o;
    typeof m == "string" && (d = m, a = e.convert(a, d), y = e.find(o, [d, d]));
    for (var w = [], E = [], x = [], N = 0; N < g; N++) {
      for (var D = N + 1, b = c[N], C = c[N + 1], A = b; A < C; A++) {
        var T = s[A];
        E[T] = u[A], x[T] = D;
      }
      for (var _ = 0; _ < h; _++)
        N === 0 && (w[_] = []), x[_] === D ? w[_][N] = f ? y(a, E[_]) : y(E[_], a) : w[_][N] = a;
    }
    return new r({
      data: w,
      size: [h, g],
      datatype: d
    });
  };
});
function Pn(t, e, r, n) {
  if (!(this instanceof Pn))
    throw new SyntaxError("Constructor must be called with the new operator");
  this.fn = t, this.count = e, this.min = r, this.max = n, this.message = "Wrong number of arguments in function " + t + " (" + e + " provided, " + r + (n != null ? "-" + n : "") + " expected)", this.stack = new Error().stack;
}
Pn.prototype = new Error();
Pn.prototype.constructor = Error;
Pn.prototype.name = "ArgumentsError";
Pn.prototype.isArgumentsError = !0;
var q1 = "gcd", y_ = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"], Ih = "number | BigNumber | Fraction | Matrix | Array", x_ = "".concat(Ih, ", ").concat(Ih, ", ...").concat(Ih);
function I1(t) {
  return !t.some((e) => Array.isArray(e));
}
var d0 = /* @__PURE__ */ H(q1, y_, (t) => {
  var {
    typed: e,
    matrix: r,
    config: n,
    round: i,
    equalScalar: a,
    zeros: o,
    BigNumber: f,
    DenseMatrix: u,
    concat: s
  } = t, c = Bs({
    typed: e,
    config: n,
    round: i,
    matrix: r,
    equalScalar: a,
    zeros: o,
    DenseMatrix: u,
    concat: s
  }), l = Di({
    typed: e
  }), m = Td({
    typed: e,
    equalScalar: a
  }), h = ea({
    typed: e,
    DenseMatrix: u
  }), g = Ut({
    typed: e,
    matrix: r,
    concat: s
  });
  return e(q1, {
    "number, number": d,
    "BigNumber, BigNumber": y,
    "Fraction, Fraction": (w, E) => w.gcd(E)
  }, g({
    SS: m,
    DS: l,
    Ss: h
  }), {
    [x_]: e.referToSelf((w) => (E, x, N) => {
      for (var D = w(E, x), b = 0; b < N.length; b++)
        D = w(D, N[b]);
      return D;
    }),
    Array: e.referToSelf((w) => (E) => {
      if (E.length === 1 && Array.isArray(E[0]) && I1(E[0]))
        return w(...E[0]);
      if (I1(E))
        return w(...E);
      throw new Pn("gcd() supports only 1d matrices!");
    }),
    Matrix: e.referToSelf((w) => (E) => w(E.toArray()))
  });
  function d(w, E) {
    if (!Ve(w) || !Ve(E))
      throw new Error("Parameters in function gcd must be integer numbers");
    for (var x; E !== 0; )
      x = c(w, E), w = E, E = x;
    return w < 0 ? -w : w;
  }
  function y(w, E) {
    if (!w.isInt() || !E.isInt())
      throw new Error("Parameters in function gcd must be integer numbers");
    for (var x = new f(0); !E.isZero(); ) {
      var N = c(w, E);
      w = E, E = N;
    }
    return w.lt(x) ? w.neg() : w;
  }
}), b_ = "matAlgo06xS0S0", w_ = ["typed", "equalScalar"], g0 = /* @__PURE__ */ H(b_, w_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(i, a, o) {
    var f = i._values, u = i._size, s = i._datatype || i._data === void 0 ? i._datatype : i.getDataType(), c = a._values, l = a._size, m = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (u.length !== l.length)
      throw new mt(u.length, l.length);
    if (u[0] !== l[0] || u[1] !== l[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + l + ")");
    var h = u[0], g = u[1], d, y = r, w = 0, E = o;
    typeof s == "string" && s === m && s !== "mixed" && (d = s, y = e.find(r, [d, d]), w = e.convert(0, d), E = e.find(o, [d, d]));
    for (var x = f && c ? [] : void 0, N = [], D = [], b = x ? [] : void 0, C = [], A = [], T = 0; T < g; T++) {
      D[T] = N.length;
      var _ = T + 1;
      if (n1(i, T, C, b, A, _, N, E), n1(a, T, C, b, A, _, N, E), b)
        for (var O = D[T]; O < N.length; ) {
          var I = N[O];
          if (A[I] === _) {
            var B = b[I];
            y(B, w) ? N.splice(O, 1) : (x.push(B), O++);
          } else
            N.splice(O, 1);
        }
      else
        for (var k = D[T]; k < N.length; ) {
          var L = N[k];
          A[L] !== _ ? N.splice(k, 1) : k++;
        }
    }
    return D[g] = N.length, i.createSparseMatrix({
      values: x,
      index: N,
      ptr: D,
      size: [h, g],
      datatype: s === i._datatype && m === a._datatype ? d : void 0
    });
  };
}), F1 = "lcm", N_ = ["typed", "matrix", "equalScalar", "concat"], v0 = /* @__PURE__ */ H(F1, N_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    concat: i
  } = t, a = Mn({
    typed: e,
    equalScalar: n
  }), o = g0({
    typed: e,
    equalScalar: n
  }), f = Sr({
    typed: e,
    equalScalar: n
  }), u = Ut({
    typed: e,
    matrix: r,
    concat: i
  }), s = "number | BigNumber | Fraction | Matrix | Array", c = {};
  return c["".concat(s, ", ").concat(s, ", ...").concat(s)] = e.referToSelf((m) => (h, g, d) => {
    for (var y = m(h, g), w = 0; w < d.length; w++)
      y = m(y, d[w]);
    return y;
  }), e(F1, {
    "number, number": sw,
    "BigNumber, BigNumber": l,
    "Fraction, Fraction": (m, h) => m.lcm(h)
  }, u({
    SS: o,
    DS: a,
    Ss: f
  }), c);
  function l(m, h) {
    if (!m.isInt() || !h.isInt())
      throw new Error("Parameters in function lcm must be integer numbers");
    if (m.isZero())
      return m;
    if (h.isZero())
      return h;
    for (var g = m.times(h); !h.isZero(); ) {
      var d = h;
      h = m.mod(d), m = d;
    }
    return g.div(m).abs();
  }
}), B1 = "log10", D_ = ["typed", "config", "Complex"], y0 = /* @__PURE__ */ H(B1, D_, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(B1, {
    number: function(a) {
      return a >= 0 || r.predictable ? ow(a) : new n(a, 0).log().div(Math.LN10);
    },
    Complex: function(a) {
      return new n(a).log().div(Math.LN10);
    },
    BigNumber: function(a) {
      return !a.isNegative() || r.predictable ? a.log() : new n(a.toNumber(), 0).log().div(Math.LN10);
    },
    "Array | Matrix": e.referToSelf((i) => (a) => gt(a, i))
  });
}), R1 = "log2", E_ = ["typed", "config", "Complex"], x0 = /* @__PURE__ */ H(R1, E_, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(R1, {
    number: function(o) {
      return o >= 0 || r.predictable ? uw(o) : i(new n(o, 0));
    },
    Complex: i,
    BigNumber: function(o) {
      return !o.isNegative() || r.predictable ? o.log(2) : i(new n(o.toNumber(), 0));
    },
    "Array | Matrix": e.referToSelf((a) => (o) => gt(o, a))
  });
  function i(a) {
    var o = Math.sqrt(a.re * a.re + a.im * a.im);
    return new n(Math.log2 ? Math.log2(o) : Math.log(o) / Math.LN2, Math.atan2(a.im, a.re) / Math.LN2);
  }
}), S_ = "multiplyScalar", A_ = ["typed"], b0 = /* @__PURE__ */ H(S_, A_, (t) => {
  var {
    typed: e
  } = t;
  return e("multiplyScalar", {
    "number, number": ew,
    "Complex, Complex": function(n, i) {
      return n.mul(i);
    },
    "BigNumber, BigNumber": function(n, i) {
      return n.times(i);
    },
    "bigint, bigint": function(n, i) {
      return n * i;
    },
    "Fraction, Fraction": function(n, i) {
      return n.mul(i);
    },
    "number | Fraction | BigNumber | Complex, Unit": (r, n) => n.multiply(r),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (r, n) => r.multiply(n)
  });
}), P1 = "multiply", C_ = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"], w0 = /* @__PURE__ */ H(P1, C_, (t) => {
  var {
    typed: e,
    matrix: r,
    addScalar: n,
    multiplyScalar: i,
    equalScalar: a,
    dot: o
  } = t, f = Sr({
    typed: e,
    equalScalar: a
  }), u = _n({
    typed: e
  });
  function s(D, b) {
    switch (D.length) {
      case 1:
        switch (b.length) {
          case 1:
            if (D[0] !== b[0])
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            break;
          case 2:
            if (D[0] !== b[0])
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + D[0] + ") must match Matrix rows (" + b[0] + ")");
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + b.length + " dimensions)");
        }
        break;
      case 2:
        switch (b.length) {
          case 1:
            if (D[1] !== b[0])
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + D[1] + ") must match Vector length (" + b[0] + ")");
            break;
          case 2:
            if (D[1] !== b[0])
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + D[1] + ") must match Matrix B rows (" + b[0] + ")");
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + b.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + D.length + " dimensions)");
    }
  }
  function c(D, b, C) {
    if (C === 0)
      throw new Error("Cannot multiply two empty vectors");
    return o(D, b);
  }
  function l(D, b) {
    if (b.storage() !== "dense")
      throw new Error("Support for SparseMatrix not implemented");
    return m(D, b);
  }
  function m(D, b) {
    var C = D._data, A = D._size, T = D._datatype || D.getDataType(), _ = b._data, O = b._size, I = b._datatype || b.getDataType(), B = A[0], k = O[1], L, F = n, M = i;
    T && I && T === I && typeof T == "string" && T !== "mixed" && (L = T, F = e.find(n, [L, L]), M = e.find(i, [L, L]));
    for (var $ = [], R = 0; R < k; R++) {
      for (var Q = M(C[0], _[0][R]), ee = 1; ee < B; ee++)
        Q = F(Q, M(C[ee], _[ee][R]));
      $[R] = Q;
    }
    return D.createDenseMatrix({
      data: $,
      size: [k],
      datatype: T === D._datatype && I === b._datatype ? L : void 0
    });
  }
  var h = e("_multiplyMatrixVector", {
    "DenseMatrix, any": d,
    "SparseMatrix, any": E
  }), g = e("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": y,
    "DenseMatrix, SparseMatrix": w,
    "SparseMatrix, DenseMatrix": x,
    "SparseMatrix, SparseMatrix": N
  });
  function d(D, b) {
    var C = D._data, A = D._size, T = D._datatype || D.getDataType(), _ = b._data, O = b._datatype || b.getDataType(), I = A[0], B = A[1], k, L = n, F = i;
    T && O && T === O && typeof T == "string" && T !== "mixed" && (k = T, L = e.find(n, [k, k]), F = e.find(i, [k, k]));
    for (var M = [], $ = 0; $ < I; $++) {
      for (var R = C[$], Q = F(R[0], _[0]), ee = 1; ee < B; ee++)
        Q = L(Q, F(R[ee], _[ee]));
      M[$] = Q;
    }
    return D.createDenseMatrix({
      data: M,
      size: [I],
      datatype: T === D._datatype && O === b._datatype ? k : void 0
    });
  }
  function y(D, b) {
    var C = D._data, A = D._size, T = D._datatype || D.getDataType(), _ = b._data, O = b._size, I = b._datatype || b.getDataType(), B = A[0], k = A[1], L = O[1], F, M = n, $ = i;
    T && I && T === I && typeof T == "string" && T !== "mixed" && T !== "mixed" && (F = T, M = e.find(n, [F, F]), $ = e.find(i, [F, F]));
    for (var R = [], Q = 0; Q < B; Q++) {
      var ee = C[Q];
      R[Q] = [];
      for (var j = 0; j < L; j++) {
        for (var U = $(ee[0], _[0][j]), pe = 1; pe < k; pe++)
          U = M(U, $(ee[pe], _[pe][j]));
        R[Q][j] = U;
      }
    }
    return D.createDenseMatrix({
      data: R,
      size: [B, L],
      datatype: T === D._datatype && I === b._datatype ? F : void 0
    });
  }
  function w(D, b) {
    var C = D._data, A = D._size, T = D._datatype || D.getDataType(), _ = b._values, O = b._index, I = b._ptr, B = b._size, k = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (!_)
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    var L = A[0], F = B[1], M, $ = n, R = i, Q = a, ee = 0;
    T && k && T === k && typeof T == "string" && T !== "mixed" && (M = T, $ = e.find(n, [M, M]), R = e.find(i, [M, M]), Q = e.find(a, [M, M]), ee = e.convert(0, M));
    for (var j = [], U = [], pe = [], X = b.createSparseMatrix({
      values: j,
      index: U,
      ptr: pe,
      size: [L, F],
      datatype: T === D._datatype && k === b._datatype ? M : void 0
    }), te = 0; te < F; te++) {
      pe[te] = U.length;
      var ue = I[te], ce = I[te + 1];
      if (ce > ue)
        for (var se = 0, he = 0; he < L; he++) {
          for (var le = he + 1, ve = void 0, Ee = ue; Ee < ce; Ee++) {
            var _e = O[Ee];
            se !== le ? (ve = R(C[he][_e], _[Ee]), se = le) : ve = $(ve, R(C[he][_e], _[Ee]));
          }
          se === le && !Q(ve, ee) && (U.push(he), j.push(ve));
        }
    }
    return pe[F] = U.length, X;
  }
  function E(D, b) {
    var C = D._values, A = D._index, T = D._ptr, _ = D._datatype || D._data === void 0 ? D._datatype : D.getDataType();
    if (!C)
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    var O = b._data, I = b._datatype || b.getDataType(), B = D._size[0], k = b._size[0], L = [], F = [], M = [], $, R = n, Q = i, ee = a, j = 0;
    _ && I && _ === I && typeof _ == "string" && _ !== "mixed" && ($ = _, R = e.find(n, [$, $]), Q = e.find(i, [$, $]), ee = e.find(a, [$, $]), j = e.convert(0, $));
    var U = [], pe = [];
    M[0] = 0;
    for (var X = 0; X < k; X++) {
      var te = O[X];
      if (!ee(te, j))
        for (var ue = T[X], ce = T[X + 1], se = ue; se < ce; se++) {
          var he = A[se];
          pe[he] ? U[he] = R(U[he], Q(te, C[se])) : (pe[he] = !0, F.push(he), U[he] = Q(te, C[se]));
        }
    }
    for (var le = F.length, ve = 0; ve < le; ve++) {
      var Ee = F[ve];
      L[ve] = U[Ee];
    }
    return M[1] = F.length, D.createSparseMatrix({
      values: L,
      index: F,
      ptr: M,
      size: [B, 1],
      datatype: _ === D._datatype && I === b._datatype ? $ : void 0
    });
  }
  function x(D, b) {
    var C = D._values, A = D._index, T = D._ptr, _ = D._datatype || D._data === void 0 ? D._datatype : D.getDataType();
    if (!C)
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    var O = b._data, I = b._datatype || b.getDataType(), B = D._size[0], k = b._size[0], L = b._size[1], F, M = n, $ = i, R = a, Q = 0;
    _ && I && _ === I && typeof _ == "string" && _ !== "mixed" && (F = _, M = e.find(n, [F, F]), $ = e.find(i, [F, F]), R = e.find(a, [F, F]), Q = e.convert(0, F));
    for (var ee = [], j = [], U = [], pe = D.createSparseMatrix({
      values: ee,
      index: j,
      ptr: U,
      size: [B, L],
      datatype: _ === D._datatype && I === b._datatype ? F : void 0
    }), X = [], te = [], ue = 0; ue < L; ue++) {
      U[ue] = j.length;
      for (var ce = ue + 1, se = 0; se < k; se++) {
        var he = O[se][ue];
        if (!R(he, Q))
          for (var le = T[se], ve = T[se + 1], Ee = le; Ee < ve; Ee++) {
            var _e = A[Ee];
            te[_e] !== ce ? (te[_e] = ce, j.push(_e), X[_e] = $(he, C[Ee])) : X[_e] = M(X[_e], $(he, C[Ee]));
          }
      }
      for (var V = U[ue], J = j.length, ye = V; ye < J; ye++) {
        var K = j[ye];
        ee[ye] = X[K];
      }
    }
    return U[L] = j.length, pe;
  }
  function N(D, b) {
    var C = D._values, A = D._index, T = D._ptr, _ = D._datatype || D._data === void 0 ? D._datatype : D.getDataType(), O = b._values, I = b._index, B = b._ptr, k = b._datatype || b._data === void 0 ? b._datatype : b.getDataType(), L = D._size[0], F = b._size[1], M = C && O, $, R = n, Q = i;
    _ && k && _ === k && typeof _ == "string" && _ !== "mixed" && ($ = _, R = e.find(n, [$, $]), Q = e.find(i, [$, $]));
    for (var ee = M ? [] : void 0, j = [], U = [], pe = D.createSparseMatrix({
      values: ee,
      index: j,
      ptr: U,
      size: [L, F],
      datatype: _ === D._datatype && k === b._datatype ? $ : void 0
    }), X = M ? [] : void 0, te = [], ue, ce, se, he, le, ve, Ee, _e, V = 0; V < F; V++) {
      U[V] = j.length;
      var J = V + 1;
      for (le = B[V], ve = B[V + 1], he = le; he < ve; he++)
        if (_e = I[he], M)
          for (ce = T[_e], se = T[_e + 1], ue = ce; ue < se; ue++)
            Ee = A[ue], te[Ee] !== J ? (te[Ee] = J, j.push(Ee), X[Ee] = Q(O[he], C[ue])) : X[Ee] = R(X[Ee], Q(O[he], C[ue]));
        else
          for (ce = T[_e], se = T[_e + 1], ue = ce; ue < se; ue++)
            Ee = A[ue], te[Ee] !== J && (te[Ee] = J, j.push(Ee));
      if (M)
        for (var ye = U[V], K = j.length, ae = ye; ae < K; ae++) {
          var de = j[ae];
          ee[ae] = X[de];
        }
    }
    return U[F] = j.length, pe;
  }
  return e(P1, i, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": e.referTo("Matrix, Matrix", (D) => (b, C) => {
      s(ft(b), ft(C));
      var A = D(r(b), r(C));
      return Ye(A) ? A.valueOf() : A;
    }),
    "Matrix, Matrix": function(b, C) {
      var A = b.size(), T = C.size();
      return s(A, T), A.length === 1 ? T.length === 1 ? c(b, C, A[0]) : l(b, C) : T.length === 1 ? h(b, C) : g(b, C);
    },
    "Matrix, Array": e.referTo("Matrix,Matrix", (D) => (b, C) => D(b, r(C))),
    "Array, Matrix": e.referToSelf((D) => (b, C) => D(r(b, C.storage()), C)),
    "SparseMatrix, any": function(b, C) {
      return f(b, C, i, !1);
    },
    "DenseMatrix, any": function(b, C) {
      return u(b, C, i, !1);
    },
    "any, SparseMatrix": function(b, C) {
      return f(C, b, i, !0);
    },
    "any, DenseMatrix": function(b, C) {
      return u(C, b, i, !0);
    },
    "Array, any": function(b, C) {
      return u(r(b), C, i, !1).valueOf();
    },
    "any, Array": function(b, C) {
      return u(r(C), b, i, !0).valueOf();
    },
    "any, any": i,
    "any, any, ...any": e.referToSelf((D) => (b, C, A) => {
      for (var T = D(b, C), _ = 0; _ < A.length; _++)
        T = D(T, A[_]);
      return T;
    })
  });
}), L1 = "nthRoot", T_ = ["typed", "matrix", "equalScalar", "BigNumber", "concat"], N0 = /* @__PURE__ */ H(L1, T_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    BigNumber: i,
    concat: a
  } = t, o = Di({
    typed: e
  }), f = Mn({
    typed: e,
    equalScalar: n
  }), u = g0({
    typed: e,
    equalScalar: n
  }), s = Sr({
    typed: e,
    equalScalar: n
  }), c = Ut({
    typed: e,
    matrix: r,
    concat: a
  });
  function l() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return e(L1, {
    number: a1,
    "number, number": a1,
    BigNumber: (h) => m(h, new i(2)),
    "BigNumber, BigNumber": m,
    Complex: l,
    "Complex, number": l,
    Array: e.referTo("DenseMatrix,number", (h) => (g) => h(r(g), 2).valueOf()),
    DenseMatrix: e.referTo("DenseMatrix,number", (h) => (g) => h(g, 2)),
    SparseMatrix: e.referTo("SparseMatrix,number", (h) => (g) => h(g, 2)),
    "SparseMatrix, SparseMatrix": e.referToSelf((h) => (g, d) => {
      if (d.density() === 1)
        return u(g, d, h);
      throw new Error("Root must be non-zero");
    }),
    "DenseMatrix, SparseMatrix": e.referToSelf((h) => (g, d) => {
      if (d.density() === 1)
        return o(g, d, h, !1);
      throw new Error("Root must be non-zero");
    }),
    "Array, SparseMatrix": e.referTo("DenseMatrix,SparseMatrix", (h) => (g, d) => h(r(g), d)),
    "number | BigNumber, SparseMatrix": e.referToSelf((h) => (g, d) => {
      if (d.density() === 1)
        return s(d, g, h, !0);
      throw new Error("Root must be non-zero");
    })
  }, c({
    scalar: "number | BigNumber",
    SD: f,
    Ss: s,
    sS: !1
  }));
  function m(h, g) {
    var d = i.precision, y = i.clone({
      precision: d + 2
    }), w = new i(0), E = new y(1), x = g.isNegative();
    if (x && (g = g.neg()), g.isZero())
      throw new Error("Root must be non-zero");
    if (h.isNegative() && !g.abs().mod(2).equals(1))
      throw new Error("Root must be odd when a is negative.");
    if (h.isZero())
      return x ? new y(1 / 0) : 0;
    if (!h.isFinite())
      return x ? w : h;
    var N = h.abs().pow(E.div(g));
    return N = h.isNeg() ? N.neg() : N, new i((x ? E.div(N) : N).toPrecision(d));
  }
}), k1 = "sign", __ = ["typed", "BigNumber", "Fraction", "complex"], D0 = /* @__PURE__ */ H(k1, __, (t) => {
  var {
    typed: e,
    BigNumber: r,
    complex: n,
    Fraction: i
  } = t;
  return e(k1, {
    number: Yh,
    Complex: function(o) {
      return o.im === 0 ? n(Yh(o.re)) : o.sign();
    },
    BigNumber: function(o) {
      return new r(o.cmp(0));
    },
    bigint: function(o) {
      return o > 0n ? 1n : o < 0n ? -1n : 0n;
    },
    Fraction: function(o) {
      return new i(o.s, 1);
    },
    // deep map collection, skip zeros since sign(0) = 0
    "Array | Matrix": e.referToSelf((a) => (o) => gt(o, a)),
    Unit: e.referToSelf((a) => (o) => {
      if (!o._isDerived() && o.units[0].unit.offset !== 0)
        throw new TypeError("sign is ambiguous for units with offset");
      return e.find(a, o.valueType())(o.value);
    })
  });
}), M_ = "sqrt", O_ = ["config", "typed", "Complex"], E0 = /* @__PURE__ */ H(M_, O_, (t) => {
  var {
    config: e,
    typed: r,
    Complex: n
  } = t;
  return r("sqrt", {
    number: i,
    Complex: function(o) {
      return o.sqrt();
    },
    BigNumber: function(o) {
      return !o.isNegative() || e.predictable ? o.sqrt() : i(o.toNumber());
    },
    Unit: function(o) {
      return o.pow(0.5);
    }
  });
  function i(a) {
    return isNaN(a) ? NaN : a >= 0 || e.predictable ? Math.sqrt(a) : new n(a, 0).sqrt();
  }
}), z1 = "square", q_ = ["typed"], S0 = /* @__PURE__ */ H(z1, q_, (t) => {
  var {
    typed: e
  } = t;
  return e(z1, {
    number: lw,
    Complex: function(n) {
      return n.mul(n);
    },
    BigNumber: function(n) {
      return n.times(n);
    },
    bigint: function(n) {
      return n * n;
    },
    Fraction: function(n) {
      return n.mul(n);
    },
    Unit: function(n) {
      return n.pow(2);
    }
  });
}), $1 = "subtract", I_ = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"], A0 = /* @__PURE__ */ H($1, I_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    subtractScalar: i,
    unaryMinus: a,
    DenseMatrix: o,
    concat: f
  } = t, u = Di({
    typed: e
  }), s = Ur({
    typed: e
  }), c = h0({
    typed: e,
    equalScalar: n
  }), l = ea({
    typed: e,
    DenseMatrix: o
  }), m = cr({
    typed: e,
    DenseMatrix: o
  }), h = Ut({
    typed: e,
    matrix: r,
    concat: f
  });
  return e($1, {
    "any, any": i
  }, h({
    elop: i,
    SS: c,
    DS: u,
    SD: s,
    Ss: m,
    sS: l
  }));
}), U1 = "xgcd", F_ = ["typed", "config", "matrix", "BigNumber"], C0 = /* @__PURE__ */ H(U1, F_, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: i
  } = t;
  return e(U1, {
    "number, number": function(f, u) {
      var s = cw(f, u);
      return r.matrix === "Array" ? s : n(s);
    },
    "BigNumber, BigNumber": a
    // TODO: implement support for Fraction
  });
  function a(o, f) {
    var u, s, c, l = new i(0), m = new i(1), h = l, g = m, d = m, y = l;
    if (!o.isInt() || !f.isInt())
      throw new Error("Parameters in function xgcd must be integer numbers");
    for (; !f.isZero(); )
      s = o.div(f).floor(), c = o.mod(f), u = h, h = g.minus(s.times(h)), g = u, u = d, d = y.minus(s.times(d)), y = u, o = f, f = c;
    var w;
    return o.lt(l) ? w = [o.neg(), g.neg(), y.neg()] : w = [o, o.isZero() ? 0 : g, y], r.matrix === "Array" ? w : n(w);
  }
}), G1 = "invmod", B_ = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"], T0 = /* @__PURE__ */ H(G1, B_, (t) => {
  var {
    typed: e,
    config: r,
    BigNumber: n,
    xgcd: i,
    equal: a,
    smaller: o,
    mod: f,
    add: u,
    isInteger: s
  } = t;
  return e(G1, {
    "number, number": c,
    "BigNumber, BigNumber": c
  });
  function c(l, m) {
    if (!s(l) || !s(m)) throw new Error("Parameters in function invmod must be integer numbers");
    if (l = f(l, m), a(m, 0)) throw new Error("Divisor must be non zero");
    var h = i(l, m);
    h = h.valueOf();
    var [g, d] = h;
    return a(g, n(1)) ? (d = f(d, m), o(d, n(0)) && (d = u(d, m)), d) : NaN;
  }
}), R_ = "matAlgo09xS0Sf", P_ = ["typed", "equalScalar"], Uw = /* @__PURE__ */ H(R_, P_, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(i, a, o) {
    var f = i._values, u = i._index, s = i._ptr, c = i._size, l = i._datatype || i._data === void 0 ? i._datatype : i.getDataType(), m = a._values, h = a._index, g = a._ptr, d = a._size, y = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (c.length !== d.length)
      throw new mt(c.length, d.length);
    if (c[0] !== d[0] || c[1] !== d[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + c + ") must match Matrix B (" + d + ")");
    var w = c[0], E = c[1], x, N = r, D = 0, b = o;
    typeof l == "string" && l === y && l !== "mixed" && (x = l, N = e.find(r, [x, x]), D = e.convert(0, x), b = e.find(o, [x, x]));
    var C = f && m ? [] : void 0, A = [], T = [], _ = C ? [] : void 0, O = [], I, B, k, L, F;
    for (B = 0; B < E; B++) {
      T[B] = A.length;
      var M = B + 1;
      if (_)
        for (L = g[B], F = g[B + 1], k = L; k < F; k++)
          I = h[k], O[I] = M, _[I] = m[k];
      for (L = s[B], F = s[B + 1], k = L; k < F; k++)
        if (I = u[k], _) {
          var $ = O[I] === M ? _[I] : D, R = b(f[k], $);
          N(R, D) || (A.push(I), C.push(R));
        } else
          A.push(I);
    }
    return T[E] = A.length, i.createSparseMatrix({
      values: C,
      index: A,
      ptr: T,
      size: [w, E],
      datatype: l === i._datatype && y === a._datatype ? x : void 0
    });
  };
}), H1 = "dotMultiply", L_ = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"], _0 = /* @__PURE__ */ H(H1, L_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    multiplyScalar: i,
    concat: a
  } = t, o = Mn({
    typed: e,
    equalScalar: n
  }), f = Uw({
    typed: e,
    equalScalar: n
  }), u = Sr({
    typed: e,
    equalScalar: n
  }), s = Ut({
    typed: e,
    matrix: r,
    concat: a
  });
  return e(H1, s({
    elop: i,
    SS: f,
    DS: o,
    Ss: u
  }));
});
function k_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function bitAnd");
  var r = t.constructor;
  if (t.isNaN() || e.isNaN())
    return new r(NaN);
  if (t.isZero() || e.eq(-1) || t.eq(e))
    return t;
  if (e.isZero() || t.eq(-1))
    return e;
  if (!t.isFinite() || !e.isFinite()) {
    if (!t.isFinite() && !e.isFinite())
      return t.isNegative() === e.isNegative() ? t : new r(0);
    if (!t.isFinite())
      return e.isNegative() ? t : t.isNegative() ? new r(0) : e;
    if (!e.isFinite())
      return t.isNegative() ? e : e.isNegative() ? new r(0) : t;
  }
  return _d(t, e, function(n, i) {
    return n & i;
  });
}
function Ss(t) {
  if (t.isFinite() && !t.isInteger())
    throw new Error("Integer expected in function bitNot");
  var e = t.constructor, r = e.precision;
  e.config({
    precision: 1e9
  });
  var n = t.plus(new e(1));
  return n.s = -n.s || null, e.config({
    precision: r
  }), n;
}
function z_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function bitOr");
  var r = t.constructor;
  if (t.isNaN() || e.isNaN())
    return new r(NaN);
  var n = new r(-1);
  return t.isZero() || e.eq(n) || t.eq(e) ? e : e.isZero() || t.eq(n) ? t : !t.isFinite() || !e.isFinite() ? !t.isFinite() && !t.isNegative() && e.isNegative() || t.isNegative() && !e.isNegative() && !e.isFinite() ? n : t.isNegative() && e.isNegative() ? t.isFinite() ? t : e : t.isFinite() ? e : t : _d(t, e, function(i, a) {
    return i | a;
  });
}
function _d(t, e, r) {
  var n = t.constructor, i, a, o = +(t.s < 0), f = +(e.s < 0);
  if (o) {
    i = Ao(Ss(t));
    for (var u = 0; u < i.length; ++u)
      i[u] ^= 1;
  } else
    i = Ao(t);
  if (f) {
    a = Ao(Ss(e));
    for (var s = 0; s < a.length; ++s)
      a[s] ^= 1;
  } else
    a = Ao(e);
  var c, l, m;
  i.length <= a.length ? (c = i, l = a, m = o) : (c = a, l = i, m = f);
  var h = c.length, g = l.length, d = r(o, f) ^ 1, y = new n(d ^ 1), w = new n(1), E = new n(2), x = n.precision;
  for (n.config({
    precision: 1e9
  }); h > 0; )
    r(c[--h], l[--g]) === d && (y = y.plus(w)), w = w.times(E);
  for (; g > 0; )
    r(m, l[--g]) === d && (y = y.plus(w)), w = w.times(E);
  return n.config({
    precision: x
  }), d === 0 && (y.s = -y.s), y;
}
function Ao(t) {
  for (var e = t.d, r = e[0] + "", n = 1; n < e.length; ++n) {
    for (var i = e[n] + "", a = 7 - i.length; a--; )
      i = "0" + i;
    r += i;
  }
  for (var o = r.length; r.charAt(o) === "0"; )
    o--;
  var f = t.e, u = r.slice(0, o + 1 || 1), s = u.length;
  if (f > 0)
    if (++f > s)
      for (f -= s; f--; )
        u += "0";
    else f < s && (u = u.slice(0, f) + "." + u.slice(f));
  for (var c = [0], l = 0; l < u.length; ) {
    for (var m = c.length; m--; )
      c[m] *= 10;
    c[0] += parseInt(u.charAt(l++));
    for (var h = 0; h < c.length; ++h)
      c[h] > 1 && ((c[h + 1] === null || c[h + 1] === void 0) && (c[h + 1] = 0), c[h + 1] += c[h] >> 1, c[h] &= 1);
  }
  return c.reverse();
}
function $_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function bitXor");
  var r = t.constructor;
  if (t.isNaN() || e.isNaN())
    return new r(NaN);
  if (t.isZero())
    return e;
  if (e.isZero())
    return t;
  if (t.eq(e))
    return new r(0);
  var n = new r(-1);
  return t.eq(n) ? Ss(e) : e.eq(n) ? Ss(t) : !t.isFinite() || !e.isFinite() ? !t.isFinite() && !e.isFinite() ? n : new r(t.isNegative() === e.isNegative() ? 1 / 0 : -1 / 0) : _d(t, e, function(i, a) {
    return i ^ a;
  });
}
function U_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function leftShift");
  var r = t.constructor;
  return t.isNaN() || e.isNaN() || e.isNegative() && !e.isZero() ? new r(NaN) : t.isZero() || e.isZero() ? t : !t.isFinite() && !e.isFinite() ? new r(NaN) : e.lt(55) ? t.times(Math.pow(2, e.toNumber()) + "") : t.times(new r(2).pow(e));
}
function G_(t, e) {
  if (t.isFinite() && !t.isInteger() || e.isFinite() && !e.isInteger())
    throw new Error("Integers expected in function rightArithShift");
  var r = t.constructor;
  return t.isNaN() || e.isNaN() || e.isNegative() && !e.isZero() ? new r(NaN) : t.isZero() || e.isZero() ? t : e.isFinite() ? e.lt(55) ? t.div(Math.pow(2, e.toNumber()) + "").floor() : t.div(new r(2).pow(e)).floor() : t.isNegative() ? new r(-1) : t.isFinite() ? new r(0) : new r(NaN);
}
var Q1 = "bitAnd", H_ = ["typed", "matrix", "equalScalar", "concat"], Rs = /* @__PURE__ */ H(Q1, H_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    concat: i
  } = t, a = Mn({
    typed: e,
    equalScalar: n
  }), o = g0({
    typed: e,
    equalScalar: n
  }), f = Sr({
    typed: e,
    equalScalar: n
  }), u = Ut({
    typed: e,
    matrix: r,
    concat: i
  });
  return e(Q1, {
    "number, number": pw,
    "BigNumber, BigNumber": k_,
    "bigint, bigint": (s, c) => s & c
  }, u({
    SS: o,
    DS: a,
    Ss: f
  }));
}), V1 = "bitNot", Q_ = ["typed"], M0 = /* @__PURE__ */ H(V1, Q_, (t) => {
  var {
    typed: e
  } = t;
  return e(V1, {
    number: mw,
    BigNumber: Ss,
    bigint: (r) => ~r,
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), W1 = "bitOr", V_ = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Ps = /* @__PURE__ */ H(W1, V_, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Di({
    typed: e
  }), f = Td({
    typed: e,
    equalScalar: n
  }), u = ea({
    typed: e,
    DenseMatrix: i
  }), s = Ut({
    typed: e,
    matrix: r,
    concat: a
  });
  return e(W1, {
    "number, number": hw,
    "BigNumber, BigNumber": z_,
    "bigint, bigint": (c, l) => c | l
  }, s({
    SS: f,
    DS: o,
    Ss: u
  }));
}), W_ = "matAlgo07xSSf", j_ = ["typed", "DenseMatrix"], Ln = /* @__PURE__ */ H(W_, j_, (t) => {
  var {
    typed: e,
    DenseMatrix: r
  } = t;
  return function(a, o, f) {
    var u = a._size, s = a._datatype || a._data === void 0 ? a._datatype : a.getDataType(), c = o._size, l = o._datatype || o._data === void 0 ? o._datatype : o.getDataType();
    if (u.length !== c.length)
      throw new mt(u.length, c.length);
    if (u[0] !== c[0] || u[1] !== c[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + u + ") must match Matrix B (" + c + ")");
    var m = u[0], h = u[1], g, d = 0, y = f;
    typeof s == "string" && s === l && s !== "mixed" && (g = s, d = e.convert(0, g), y = e.find(f, [g, g]));
    var w, E, x = [];
    for (w = 0; w < m; w++)
      x[w] = [];
    var N = [], D = [], b = [], C = [];
    for (E = 0; E < h; E++) {
      var A = E + 1;
      for (n(a, E, b, N, A), n(o, E, C, D, A), w = 0; w < m; w++) {
        var T = b[w] === A ? N[w] : d, _ = C[w] === A ? D[w] : d;
        x[w][E] = y(T, _);
      }
    }
    return new r({
      data: x,
      size: [m, h],
      datatype: s === a._datatype && l === o._datatype ? g : void 0
    });
  };
  function n(i, a, o, f, u) {
    for (var s = i._values, c = i._index, l = i._ptr, m = l[a], h = l[a + 1]; m < h; m++) {
      var g = c[m];
      o[g] = u, f[g] = s[m];
    }
  }
}), j1 = "bitXor", Y_ = ["typed", "matrix", "DenseMatrix", "concat"], O0 = /* @__PURE__ */ H(j1, Y_, (t) => {
  var {
    typed: e,
    matrix: r,
    DenseMatrix: n,
    concat: i
  } = t, a = Ur({
    typed: e
  }), o = Ln({
    typed: e,
    DenseMatrix: n
  }), f = cr({
    typed: e,
    DenseMatrix: n
  }), u = Ut({
    typed: e,
    matrix: r,
    concat: i
  });
  return e(j1, {
    "number, number": dw,
    "BigNumber, BigNumber": $_,
    "bigint, bigint": (s, c) => s ^ c
  }, u({
    SS: o,
    DS: a,
    Ss: f
  }));
}), Y1 = "arg", Z_ = ["typed"], q0 = /* @__PURE__ */ H(Y1, Z_, (t) => {
  var {
    typed: e
  } = t;
  return e(Y1, {
    number: function(n) {
      return Math.atan2(0, n);
    },
    BigNumber: function(n) {
      return n.constructor.atan2(0, n);
    },
    Complex: function(n) {
      return n.arg();
    },
    // TODO: implement BigNumber support for function arg
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), Z1 = "conj", J_ = ["typed"], I0 = /* @__PURE__ */ H(Z1, J_, (t) => {
  var {
    typed: e
  } = t;
  return e(Z1, {
    "number | BigNumber | Fraction": (r) => r,
    Complex: (r) => r.conjugate(),
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), J1 = "im", X_ = ["typed"], F0 = /* @__PURE__ */ H(J1, X_, (t) => {
  var {
    typed: e
  } = t;
  return e(J1, {
    number: () => 0,
    "BigNumber | Fraction": (r) => r.mul(0),
    Complex: (r) => r.im,
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), X1 = "re", K_ = ["typed"], B0 = /* @__PURE__ */ H(X1, K_, (t) => {
  var {
    typed: e
  } = t;
  return e(X1, {
    "number | BigNumber | Fraction": (r) => r,
    Complex: (r) => r.re,
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), K1 = "not", eM = ["typed"], R0 = /* @__PURE__ */ H(K1, eM, (t) => {
  var {
    typed: e
  } = t;
  return e(K1, {
    "null | undefined": () => !0,
    number: bw,
    Complex: function(n) {
      return n.re === 0 && n.im === 0;
    },
    BigNumber: function(n) {
      return n.isZero() || n.isNaN();
    },
    bigint: (r) => !r,
    Unit: e.referToSelf((r) => (n) => e.find(r, n.valueType())(n.value)),
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), ey = "or", tM = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Ls = /* @__PURE__ */ H(ey, tM, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ur({
    typed: e
  }), f = h0({
    typed: e,
    equalScalar: n
  }), u = cr({
    typed: e,
    DenseMatrix: i
  }), s = Ut({
    typed: e,
    matrix: r,
    concat: a
  });
  return e(ey, {
    "number, number": Zh,
    "Complex, Complex": function(l, m) {
      return l.re !== 0 || l.im !== 0 || m.re !== 0 || m.im !== 0;
    },
    "BigNumber, BigNumber": function(l, m) {
      return !l.isZero() && !l.isNaN() || !m.isZero() && !m.isNaN();
    },
    "bigint, bigint": Zh,
    "Unit, Unit": e.referToSelf((c) => (l, m) => c(l.value || 0, m.value || 0))
  }, s({
    SS: f,
    DS: o,
    Ss: u
  }));
}), ty = "xor", rM = ["typed", "matrix", "DenseMatrix", "concat"], P0 = /* @__PURE__ */ H(ty, rM, (t) => {
  var {
    typed: e,
    matrix: r,
    DenseMatrix: n,
    concat: i
  } = t, a = Ur({
    typed: e
  }), o = Ln({
    typed: e,
    DenseMatrix: n
  }), f = cr({
    typed: e,
    DenseMatrix: n
  }), u = Ut({
    typed: e,
    matrix: r,
    concat: i
  });
  return e(ty, {
    "number, number": Jh,
    "Complex, Complex": function(c, l) {
      return (c.re !== 0 || c.im !== 0) != (l.re !== 0 || l.im !== 0);
    },
    "bigint, bigint": Jh,
    "BigNumber, BigNumber": function(c, l) {
      return (!c.isZero() && !c.isNaN()) != (!l.isZero() && !l.isNaN());
    },
    "Unit, Unit": e.referToSelf((s) => (c, l) => s(c.value || 0, l.value || 0))
  }, u({
    SS: o,
    DS: a,
    Ss: f
  }));
}), ry = "concat", nM = ["typed", "matrix", "isInteger"], ks = /* @__PURE__ */ H(ry, nM, (t) => {
  var {
    typed: e,
    matrix: r,
    isInteger: n
  } = t;
  return e(ry, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function(a) {
      var o, f = a.length, u = -1, s, c = !1, l = [];
      for (o = 0; o < f; o++) {
        var m = a[o];
        if (Ye(m) && (c = !0), ot(m) || at(m)) {
          if (o !== f - 1)
            throw new Error("Dimension must be specified as last argument");
          if (s = u, u = m.valueOf(), !n(u))
            throw new TypeError("Integer number expected for dimension");
          if (u < 0 || o > 0 && u > s)
            throw new nn(u, s + 1);
        } else {
          var h = Je(m).valueOf(), g = ft(h);
          if (l[o] = h, s = u, u = g.length - 1, o > 0 && u !== s)
            throw new mt(s + 1, u + 1);
        }
      }
      if (l.length === 0)
        throw new SyntaxError("At least one matrix expected");
      for (var d = l.shift(); l.length; )
        d = j2(d, l.shift(), u);
      return c ? r(d) : d;
    },
    "...string": function(a) {
      return a.join("");
    }
  });
}), ny = "column", iM = ["typed", "Index", "matrix", "range"], zs = /* @__PURE__ */ H(ny, iM, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: i
  } = t;
  return e(ny, {
    "Matrix, number": a,
    "Array, number": function(f, u) {
      return a(n(Je(f)), u).valueOf();
    }
  });
  function a(o, f) {
    if (o.size().length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    Pt(f, o.size()[1]);
    var u = i(0, o.size()[0]), s = new r(u, f), c = o.subset(s);
    return Ye(c) ? c : n([[c]]);
  }
}), iy = "count", aM = ["typed", "size", "prod"], L0 = /* @__PURE__ */ H(iy, aM, (t) => {
  var {
    typed: e,
    size: r,
    prod: n
  } = t;
  return e(iy, {
    string: function(a) {
      return a.length;
    },
    "Matrix | Array": function(a) {
      return n(r(a));
    }
  });
}), ay = "cross", sM = ["typed", "matrix", "subtract", "multiply"], k0 = /* @__PURE__ */ H(ay, sM, (t) => {
  var {
    typed: e,
    matrix: r,
    subtract: n,
    multiply: i
  } = t;
  return e(ay, {
    "Matrix, Matrix": function(f, u) {
      return r(a(f.toArray(), u.toArray()));
    },
    "Matrix, Array": function(f, u) {
      return r(a(f.toArray(), u));
    },
    "Array, Matrix": function(f, u) {
      return r(a(f, u.toArray()));
    },
    "Array, Array": a
  });
  function a(o, f) {
    var u = Math.max(ft(o).length, ft(f).length);
    o = Zo(o), f = Zo(f);
    var s = ft(o), c = ft(f);
    if (s.length !== 1 || c.length !== 1 || s[0] !== 3 || c[0] !== 3)
      throw new RangeError("Vectors with length 3 expected (Size A = [" + s.join(", ") + "], B = [" + c.join(", ") + "])");
    var l = [n(i(o[1], f[2]), i(o[2], f[1])), n(i(o[2], f[0]), i(o[0], f[2])), n(i(o[0], f[1]), i(o[1], f[0]))];
    return u > 1 ? [l] : l;
  }
}), sy = "diag", oM = ["typed", "matrix", "DenseMatrix", "SparseMatrix"], z0 = /* @__PURE__ */ H(sy, oM, (t) => {
  var {
    typed: e,
    matrix: r,
    DenseMatrix: n,
    SparseMatrix: i
  } = t;
  return e(sy, {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
    Array: function(s) {
      return a(s, 0, ft(s), null);
    },
    "Array, number": function(s, c) {
      return a(s, c, ft(s), null);
    },
    "Array, BigNumber": function(s, c) {
      return a(s, c.toNumber(), ft(s), null);
    },
    "Array, string": function(s, c) {
      return a(s, 0, ft(s), c);
    },
    "Array, number, string": function(s, c, l) {
      return a(s, c, ft(s), l);
    },
    "Array, BigNumber, string": function(s, c, l) {
      return a(s, c.toNumber(), ft(s), l);
    },
    Matrix: function(s) {
      return a(s, 0, s.size(), s.storage());
    },
    "Matrix, number": function(s, c) {
      return a(s, c, s.size(), s.storage());
    },
    "Matrix, BigNumber": function(s, c) {
      return a(s, c.toNumber(), s.size(), s.storage());
    },
    "Matrix, string": function(s, c) {
      return a(s, 0, s.size(), c);
    },
    "Matrix, number, string": function(s, c, l) {
      return a(s, c, s.size(), l);
    },
    "Matrix, BigNumber, string": function(s, c, l) {
      return a(s, c.toNumber(), s.size(), l);
    }
  });
  function a(u, s, c, l) {
    if (!Ve(s))
      throw new TypeError("Second parameter in function diag must be an integer");
    var m = s > 0 ? s : 0, h = s < 0 ? -s : 0;
    switch (c.length) {
      case 1:
        return o(u, s, l, c[0], h, m);
      case 2:
        return f(u, s, l, c, h, m);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function o(u, s, c, l, m, h) {
    var g = [l + m, l + h];
    if (c && c !== "sparse" && c !== "dense")
      throw new TypeError("Unknown matrix type ".concat(c, '"'));
    var d = c === "sparse" ? i.diagonal(g, u, s) : n.diagonal(g, u, s);
    return c !== null ? d : d.valueOf();
  }
  function f(u, s, c, l, m, h) {
    if (Ye(u)) {
      var g = u.diagonal(s);
      return c !== null ? c !== g.storage() ? r(g, c) : g : g.valueOf();
    }
    for (var d = Math.min(l[0] - m, l[1] - h), y = [], w = 0; w < d; w++)
      y[w] = u[w + m][w + h];
    return c !== null ? r(y) : y;
  }
});
function Ga(t, e, r, n, i) {
  if (Gi.isTypedFunction(t)) {
    var a = [e, r, n], o = Gi.resolve(t, a);
    if (o)
      return l(o.implementation, a);
    var f = [e, r], u = Gi.resolve(t, f);
    if (u)
      return l(u.implementation, f);
    var s = [e], c = Gi.resolve(t, s);
    return c ? l(c.implementation, s) : l(t, a);
  } else
    return t(e, r, n);
  function l(m, h) {
    try {
      return m.apply(m, h);
    } catch (y) {
      var g;
      if (y instanceof TypeError && ((g = y.data) === null || g === void 0 ? void 0 : g.category) === "wrongType") {
        var d = [];
        throw d.push("value: ".concat(kt(e))), h.length >= 2 && d.push("index: ".concat(kt(r))), h.length >= 3 && d.push("array: ".concat(kt(n))), new TypeError("Function ".concat(i, " cannot apply callback arguments ") + "".concat(t.name, "(").concat(d.join(", "), ") at index ").concat(JSON.stringify(r)));
      } else
        throw new TypeError("Function ".concat(i, " cannot apply callback arguments ") + "to function ".concat(t.name, ": ").concat(y.message));
    }
  }
}
var uM = "filter", lM = ["typed"], $0 = /* @__PURE__ */ H(uM, lM, (t) => {
  var {
    typed: e
  } = t;
  return e("filter", {
    "Array, function": oy,
    "Matrix, function": function(n, i) {
      return n.create(oy(n.toArray(), i));
    },
    "Array, RegExp": Jo,
    "Matrix, RegExp": function(n, i) {
      return n.create(Jo(n.toArray(), i));
    }
  });
});
function oy(t, e) {
  return V2(t, function(r, n, i) {
    return Ga(e, r, [n], i, "filter");
  });
}
var uy = "flatten", cM = ["typed", "matrix"], U0 = /* @__PURE__ */ H(uy, cM, (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return e(uy, {
    Array: function(i) {
      return Mt(i);
    },
    Matrix: function(i) {
      var a = Mt(i.toArray());
      return r(a);
    }
  });
}), ly = "forEach", fM = ["typed"], G0 = /* @__PURE__ */ H(ly, fM, (t) => {
  var {
    typed: e
  } = t;
  return e(ly, {
    "Array, function": pM,
    "Matrix, function": function(n, i) {
      n.forEach(i);
    }
  });
});
function pM(t, e) {
  var r = function n(i, a) {
    if (Array.isArray(i))
      Ou(i, function(o, f) {
        n(o, a.concat(f));
      });
    else
      return Ga(e, i, a, t, "forEach");
  };
  r(t, []);
}
var cy = "getMatrixDataType", mM = ["typed"], H0 = /* @__PURE__ */ H(cy, mM, (t) => {
  var {
    typed: e
  } = t;
  return e(cy, {
    Array: function(n) {
      return Es(n, kt);
    },
    Matrix: function(n) {
      return n.getDataType();
    }
  });
}), fy = "identity", hM = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"], Q0 = /* @__PURE__ */ H(fy, hM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: i,
    DenseMatrix: a,
    SparseMatrix: o
  } = t;
  return e(fy, {
    "": function() {
      return r.matrix === "Matrix" ? n([]) : [];
    },
    string: function(c) {
      return n(c);
    },
    "number | BigNumber": function(c) {
      return u(c, c, r.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function(c, l) {
      return u(c, c, l);
    },
    "number | BigNumber, number | BigNumber": function(c, l) {
      return u(c, l, r.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function(c, l, m) {
      return u(c, l, m);
    },
    Array: function(c) {
      return f(c);
    },
    "Array, string": function(c, l) {
      return f(c, l);
    },
    Matrix: function(c) {
      return f(c.valueOf(), c.storage());
    },
    "Matrix, string": function(c, l) {
      return f(c.valueOf(), l);
    }
  });
  function f(s, c) {
    switch (s.length) {
      case 0:
        return c ? n(c) : [];
      case 1:
        return u(s[0], s[0], c);
      case 2:
        return u(s[0], s[1], c);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function u(s, c, l) {
    var m = at(s) || at(c) ? i : null;
    if (at(s) && (s = s.toNumber()), at(c) && (c = c.toNumber()), !Ve(s) || s < 1)
      throw new Error("Parameters in function identity must be positive integers");
    if (!Ve(c) || c < 1)
      throw new Error("Parameters in function identity must be positive integers");
    var h = m ? new i(1) : 1, g = m ? new m(0) : 0, d = [s, c];
    if (l) {
      if (l === "sparse")
        return o.diagonal(d, h, 0, g);
      if (l === "dense")
        return a.diagonal(d, h, 0, g);
      throw new TypeError('Unknown matrix type "'.concat(l, '"'));
    }
    for (var y = Oa([], d, g), w = s < c ? s : c, E = 0; E < w; E++)
      y[E][E] = h;
    return y;
  }
}), py = "kron", dM = ["typed", "matrix", "multiplyScalar"], V0 = /* @__PURE__ */ H(py, dM, (t) => {
  var {
    typed: e,
    matrix: r,
    multiplyScalar: n
  } = t;
  return e(py, {
    "Matrix, Matrix": function(o, f) {
      return r(i(o.toArray(), f.toArray()));
    },
    "Matrix, Array": function(o, f) {
      return r(i(o.toArray(), f));
    },
    "Array, Matrix": function(o, f) {
      return r(i(o, f.toArray()));
    },
    "Array, Array": i
  });
  function i(a, o) {
    if (ft(a).length === 1 && (a = [a]), ft(o).length === 1 && (o = [o]), ft(a).length > 2 || ft(o).length > 2)
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(o.length) + ")");
    var f = [], u = [];
    return a.map(function(s) {
      return o.map(function(c) {
        return u = [], f.push(u), s.map(function(l) {
          return c.map(function(m) {
            return u.push(n(l, m));
          });
        });
      });
    }) && f;
  }
}), my = "map", gM = ["typed"], W0 = /* @__PURE__ */ H(my, gM, (t) => {
  var {
    typed: e
  } = t;
  return e(my, {
    "Array, function": vM,
    "Matrix, function": function(n, i) {
      return n.map(i);
    }
  });
});
function vM(t, e) {
  var r = function n(i, a) {
    return Array.isArray(i) ? i.map(function(o, f) {
      return n(o, a.concat(f));
    }) : Ga(e, i, a, t, "map");
  };
  return r(t, []);
}
var hy = "diff", yM = ["typed", "matrix", "subtract", "number"], $s = /* @__PURE__ */ H(hy, yM, (t) => {
  var {
    typed: e,
    matrix: r,
    subtract: n,
    number: i
  } = t;
  return e(hy, {
    "Array | Matrix": function(c) {
      return Ye(c) ? r(o(c.toArray())) : o(c);
    },
    "Array | Matrix, number": function(c, l) {
      if (!Ve(l)) throw new RangeError("Dimension must be a whole number");
      return Ye(c) ? r(a(c.toArray(), l)) : a(c, l);
    },
    "Array, BigNumber": e.referTo("Array,number", (s) => (c, l) => s(c, i(l))),
    "Matrix, BigNumber": e.referTo("Matrix,number", (s) => (c, l) => s(c, i(l)))
  });
  function a(s, c) {
    if (Ye(s) && (s = s.toArray()), !Array.isArray(s))
      throw RangeError("Array/Matrix does not have that many dimensions");
    if (c > 0) {
      var l = [];
      return s.forEach((m) => {
        l.push(a(m, c - 1));
      }), l;
    } else {
      if (c === 0)
        return o(s);
      throw RangeError("Cannot have negative dimension");
    }
  }
  function o(s) {
    for (var c = [], l = s.length, m = 1; m < l; m++)
      c.push(f(s[m - 1], s[m]));
    return c;
  }
  function f(s, c) {
    Ye(s) && (s = s.toArray()), Ye(c) && (c = c.toArray());
    var l = Array.isArray(s), m = Array.isArray(c);
    if (l && m)
      return u(s, c);
    if (!l && !m)
      return n(c, s);
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function u(s, c) {
    if (s.length !== c.length)
      throw RangeError("Not all sub-arrays have the same length");
    for (var l = [], m = s.length, h = 0; h < m; h++)
      l.push(f(s[h], c[h]));
    return l;
  }
}), xM = "ones", bM = ["typed", "config", "matrix", "BigNumber"], j0 = /* @__PURE__ */ H(xM, bM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: i
  } = t;
  return e("ones", {
    "": function() {
      return r.matrix === "Array" ? a([]) : a([], "default");
    },
    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function(s) {
      var c = s[s.length - 1];
      if (typeof c == "string") {
        var l = s.pop();
        return a(s, l);
      } else return r.matrix === "Array" ? a(s) : a(s, "default");
    },
    Array: a,
    Matrix: function(s) {
      var c = s.storage();
      return a(s.valueOf(), c);
    },
    "Array | Matrix, string": function(s, c) {
      return a(s.valueOf(), c);
    }
  });
  function a(u, s) {
    var c = o(u), l = c ? new i(1) : 1;
    if (f(u), s) {
      var m = n(s);
      return u.length > 0 ? m.resize(u, l) : m;
    } else {
      var h = [];
      return u.length > 0 ? Oa(h, u, l) : h;
    }
  }
  function o(u) {
    var s = !1;
    return u.forEach(function(c, l, m) {
      at(c) && (s = !0, m[l] = c.toNumber());
    }), s;
  }
  function f(u) {
    u.forEach(function(s) {
      if (typeof s != "number" || !Ve(s) || s < 0)
        throw new Error("Parameters in function ones must be positive integers");
    });
  }
});
function Md() {
  throw new Error('No "bignumber" implementation available');
}
function Gw() {
  throw new Error('No "fraction" implementation available');
}
function Hw() {
  throw new Error('No "matrix" implementation available');
}
var dy = "range", wM = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"], Us = /* @__PURE__ */ H(dy, wM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    bignumber: i,
    smaller: a,
    smallerEq: o,
    larger: f,
    largerEq: u,
    add: s,
    isPositive: c
  } = t;
  return e(dy, {
    // TODO: simplify signatures when typed-function supports default values and optional arguments
    // TODO: a number or boolean should not be converted to string here
    string: m,
    "string, boolean": m,
    "number, number": function(y, w) {
      return l(h(y, w, 1, !1));
    },
    "number, number, number": function(y, w, E) {
      return l(h(y, w, E, !1));
    },
    "number, number, boolean": function(y, w, E) {
      return l(h(y, w, 1, E));
    },
    "number, number, number, boolean": function(y, w, E, x) {
      return l(h(y, w, E, x));
    },
    "BigNumber, BigNumber": function(y, w) {
      var E = y.constructor;
      return l(h(y, w, new E(1), !1));
    },
    "BigNumber, BigNumber, BigNumber": function(y, w, E) {
      return l(h(y, w, E, !1));
    },
    "BigNumber, BigNumber, boolean": function(y, w, E) {
      var x = y.constructor;
      return l(h(y, w, new x(1), E));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function(y, w, E, x) {
      return l(h(y, w, E, x));
    },
    "Unit, Unit, Unit": function(y, w, E) {
      return l(h(y, w, E, !1));
    },
    "Unit, Unit, Unit, boolean": function(y, w, E, x) {
      return l(h(y, w, E, x));
    }
  });
  function l(d) {
    return r.matrix === "Matrix" ? n ? n(d) : Hw() : d;
  }
  function m(d, y) {
    var w = g(d);
    if (!w)
      throw new SyntaxError('String "' + d + '" is no valid range');
    return r.number === "BigNumber" ? (i === void 0 && Md(), l(h(i(w.start), i(w.end), i(w.step)))) : l(h(w.start, w.end, w.step, y));
  }
  function h(d, y, w, E) {
    for (var x = [], N = c(w) ? E ? o : a : E ? u : f, D = d; N(D, y); )
      x.push(D), D = s(D, w);
    return x;
  }
  function g(d) {
    var y = d.split(":"), w = y.map(function(x) {
      return Number(x);
    }), E = w.some(function(x) {
      return isNaN(x);
    });
    if (E)
      return null;
    switch (w.length) {
      case 2:
        return {
          start: w[0],
          end: w[1],
          step: 1
        };
      case 3:
        return {
          start: w[0],
          end: w[2],
          step: w[1]
        };
      default:
        return null;
    }
  }
}), gy = "reshape", NM = ["typed", "isInteger", "matrix"], Y0 = /* @__PURE__ */ H(gy, NM, (t) => {
  var {
    typed: e,
    isInteger: r
  } = t;
  return e(gy, {
    "Matrix, Array": function(i, a) {
      return i.reshape(a, !0);
    },
    "Array, Array": function(i, a) {
      return a.forEach(function(o) {
        if (!r(o))
          throw new TypeError("Invalid size for dimension: " + o);
      }), Ed(i, a);
    }
  });
}), DM = "resize", EM = ["config", "matrix"], Z0 = /* @__PURE__ */ H(DM, EM, (t) => {
  var {
    config: e,
    matrix: r
  } = t;
  return function(a, o, f) {
    if (arguments.length !== 2 && arguments.length !== 3)
      throw new Pn("resize", arguments.length, 2, 3);
    if (Ye(o) && (o = o.valueOf()), at(o[0]) && (o = o.map(function(c) {
      return at(c) ? c.toNumber() : c;
    })), Ye(a))
      return a.resize(o, f, !0);
    if (typeof a == "string")
      return n(a, o, f);
    var u = Array.isArray(a) ? !1 : e.matrix !== "Array";
    if (o.length === 0) {
      for (; Array.isArray(a); )
        a = a[0];
      return Je(a);
    } else {
      Array.isArray(a) || (a = [a]), a = Je(a);
      var s = Oa(a, o, f);
      return u ? r(s) : s;
    }
  };
  function n(i, a, o) {
    if (o !== void 0) {
      if (typeof o != "string" || o.length !== 1)
        throw new TypeError("Single character expected as defaultValue");
    } else
      o = " ";
    if (a.length !== 1)
      throw new mt(a.length, 1);
    var f = a[0];
    if (typeof f != "number" || !Ve(f))
      throw new TypeError("Invalid size, must contain positive integers (size: " + vt(a) + ")");
    if (i.length > f)
      return i.substring(0, f);
    if (i.length < f) {
      for (var u = i, s = 0, c = f - i.length; s < c; s++)
        u += o;
      return u;
    } else
      return i;
  }
}), vy = "rotate", SM = ["typed", "multiply", "rotationMatrix"], J0 = /* @__PURE__ */ H(vy, SM, (t) => {
  var {
    typed: e,
    multiply: r,
    rotationMatrix: n
  } = t;
  return e(vy, {
    "Array , number | BigNumber | Complex | Unit": function(o, f) {
      i(o, 2);
      var u = r(n(f), o);
      return u.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function(o, f) {
      return i(o, 2), r(n(f), o);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function(o, f, u) {
      i(o, 3);
      var s = r(n(f, u), o);
      return s;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function(o, f, u) {
      return i(o, 3), r(n(f, u), o);
    }
  });
  function i(a, o) {
    var f = Array.isArray(a) ? ft(a) : a.size();
    if (f.length > 2)
      throw new RangeError("Vector must be of dimensions 1x".concat(o));
    if (f.length === 2 && f[1] !== 1)
      throw new RangeError("Vector must be of dimensions 1x".concat(o));
    if (f[0] !== o)
      throw new RangeError("Vector must be of dimensions 1x".concat(o));
  }
}), yy = "rotationMatrix", AM = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"], X0 = /* @__PURE__ */ H(yy, AM, (t) => {
  var {
    typed: e,
    config: r,
    multiplyScalar: n,
    addScalar: i,
    unaryMinus: a,
    norm: o,
    BigNumber: f,
    matrix: u,
    DenseMatrix: s,
    SparseMatrix: c,
    cos: l,
    sin: m
  } = t;
  return e(yy, {
    "": function() {
      return r.matrix === "Matrix" ? u([]) : [];
    },
    string: function(x) {
      return u(x);
    },
    "number | BigNumber | Complex | Unit": function(x) {
      return h(x, r.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function(x, N) {
      return h(x, N);
    },
    "number | BigNumber | Complex | Unit, Array": function(x, N) {
      var D = u(N);
      return g(D), w(x, D, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function(x, N) {
      g(N);
      var D = N.storage() || (r.matrix === "Matrix" ? "dense" : void 0);
      return w(x, N, D);
    },
    "number | BigNumber | Complex | Unit, Array, string": function(x, N, D) {
      var b = u(N);
      return g(b), w(x, b, D);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function(x, N, D) {
      return g(N), w(x, N, D);
    }
  });
  function h(E, x) {
    var N = at(E), D = N ? new f(-1) : -1, b = l(E), C = m(E), A = [[b, n(D, C)], [C, b]];
    return y(A, x);
  }
  function g(E) {
    var x = E.size();
    if (x.length < 1 || x[0] !== 3)
      throw new RangeError("Vector must be of dimensions 1x3");
  }
  function d(E) {
    return E.reduce((x, N) => n(x, N));
  }
  function y(E, x) {
    if (x) {
      if (x === "sparse")
        return new c(E);
      if (x === "dense")
        return new s(E);
      throw new TypeError('Unknown matrix type "'.concat(x, '"'));
    }
    return E;
  }
  function w(E, x, N) {
    var D = o(x);
    if (D === 0)
      throw new RangeError("Rotation around zero vector");
    var b = at(E) ? f : null, C = b ? new b(1) : 1, A = b ? new b(-1) : -1, T = b ? new b(x.get([0]) / D) : x.get([0]) / D, _ = b ? new b(x.get([1]) / D) : x.get([1]) / D, O = b ? new b(x.get([2]) / D) : x.get([2]) / D, I = l(E), B = i(C, a(I)), k = m(E), L = i(I, d([T, T, B])), F = i(d([T, _, B]), d([A, O, k])), M = i(d([T, O, B]), d([_, k])), $ = i(d([T, _, B]), d([O, k])), R = i(I, d([_, _, B])), Q = i(d([_, O, B]), d([A, T, k])), ee = i(d([T, O, B]), d([A, _, k])), j = i(d([_, O, B]), d([T, k])), U = i(I, d([O, O, B])), pe = [[L, F, M], [$, R, Q], [ee, j, U]];
    return y(pe, N);
  }
}), xy = "row", CM = ["typed", "Index", "matrix", "range"], Gs = /* @__PURE__ */ H(xy, CM, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: i
  } = t;
  return e(xy, {
    "Matrix, number": a,
    "Array, number": function(f, u) {
      return a(n(Je(f)), u).valueOf();
    }
  });
  function a(o, f) {
    if (o.size().length !== 2)
      throw new Error("Only two dimensional matrix is supported");
    Pt(f, o.size()[0]);
    var u = i(0, o.size()[1]), s = new r(f, u), c = o.subset(s);
    return Ye(c) ? c : n([[c]]);
  }
}), by = "size", TM = ["typed", "config", "?matrix"], K0 = /* @__PURE__ */ H(by, TM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n
  } = t;
  return e(by, {
    Matrix: function(a) {
      return a.create(a.size());
    },
    Array: ft,
    string: function(a) {
      return r.matrix === "Array" ? [a.length] : n([a.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function(a) {
      return r.matrix === "Array" ? [] : n ? n([]) : Hw();
    }
  });
}), wy = "squeeze", _M = ["typed", "matrix"], el = /* @__PURE__ */ H(wy, _M, (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return e(wy, {
    Array: function(i) {
      return Zo(Je(i));
    },
    Matrix: function(i) {
      var a = Zo(i.toArray());
      return Array.isArray(a) ? r(a) : a;
    },
    any: function(i) {
      return Je(i);
    }
  });
}), Ny = "subset", MM = ["typed", "matrix", "zeros", "add"], Hs = /* @__PURE__ */ H(Ny, MM, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    add: i
  } = t;
  return e(Ny, {
    // get subset
    "Matrix, Index": function(f, u) {
      return Ma(u) ? r() : (Yo(f, u), f.subset(u));
    },
    "Array, Index": e.referTo("Matrix, Index", function(o) {
      return function(f, u) {
        var s = o(r(f), u);
        return u.isScalar() ? s : s.valueOf();
      };
    }),
    "Object, Index": qM,
    "string, Index": OM,
    // set subset
    "Matrix, Index, any, any": function(f, u, s, c) {
      return Ma(u) ? f : (Yo(f, u), f.clone().subset(u, a(s, u), c));
    },
    "Array, Index, any, any": e.referTo("Matrix, Index, any, any", function(o) {
      return function(f, u, s, c) {
        var l = o(r(f), u, s, c);
        return l.isMatrix ? l.valueOf() : l;
      };
    }),
    "Array, Index, any": e.referTo("Matrix, Index, any, any", function(o) {
      return function(f, u, s) {
        return o(r(f), u, s, void 0).valueOf();
      };
    }),
    "Matrix, Index, any": e.referTo("Matrix, Index, any, any", function(o) {
      return function(f, u, s) {
        return o(f, u, s, void 0);
      };
    }),
    "string, Index, string": Dy,
    "string, Index, string, string": Dy,
    "Object, Index, any": IM
  });
  function a(o, f) {
    if (typeof o == "string")
      throw new Error("can't boradcast a string");
    if (f._isScalar)
      return o;
    var u = f.size();
    if (u.every((s) => s > 0))
      try {
        return i(o, n(u));
      } catch {
        return o;
      }
    else
      return o;
  }
});
function OM(t, e) {
  if (!Ba(e))
    throw new TypeError("Index expected");
  if (Ma(e))
    return "";
  if (Yo(Array.from(t), e), e.size().length !== 1)
    throw new mt(e.size().length, 1);
  var r = t.length;
  Pt(e.min()[0], r), Pt(e.max()[0], r);
  var n = e.dimension(0), i = "";
  return n.forEach(function(a) {
    i += t.charAt(a);
  }), i;
}
function Dy(t, e, r, n) {
  if (!e || e.isIndex !== !0)
    throw new TypeError("Index expected");
  if (Ma(e))
    return t;
  if (Yo(Array.from(t), e), e.size().length !== 1)
    throw new mt(e.size().length, 1);
  if (n !== void 0) {
    if (typeof n != "string" || n.length !== 1)
      throw new TypeError("Single character expected as defaultValue");
  } else
    n = " ";
  var i = e.dimension(0), a = i.size()[0];
  if (a !== r.length)
    throw new mt(i.size()[0], r.length);
  var o = t.length;
  Pt(e.min()[0]), Pt(e.max()[0]);
  for (var f = [], u = 0; u < o; u++)
    f[u] = t.charAt(u);
  if (i.forEach(function(l, m) {
    f[l] = r.charAt(m[0]);
  }), f.length > o)
    for (var s = o - 1, c = f.length; s < c; s++)
      f[s] || (f[s] = n);
  return f.join("");
}
function qM(t, e) {
  if (!Ma(e)) {
    if (e.size().length !== 1)
      throw new mt(e.size(), 1);
    var r = e.dimension(0);
    if (typeof r != "string")
      throw new TypeError("String expected as index to retrieve an object property");
    return kr(t, r);
  }
}
function IM(t, e, r) {
  if (Ma(e))
    return t;
  if (e.size().length !== 1)
    throw new mt(e.size(), 1);
  var n = e.dimension(0);
  if (typeof n != "string")
    throw new TypeError("String expected as index to retrieve an object property");
  var i = Je(t);
  return Ta(i, n, r), i;
}
var Ey = "transpose", FM = ["typed", "matrix"], tl = /* @__PURE__ */ H(Ey, FM, (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return e(Ey, {
    Array: (o) => n(r(o)).valueOf(),
    Matrix: n,
    any: Je
    // scalars
  });
  function n(o) {
    var f = o.size(), u;
    switch (f.length) {
      case 1:
        u = o.clone();
        break;
      case 2:
        {
          var s = f[0], c = f[1];
          if (c === 0)
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + vt(f) + ")");
          switch (o.storage()) {
            case "dense":
              u = i(o, s, c);
              break;
            case "sparse":
              u = a(o, s, c);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + vt(f) + ")");
    }
    return u;
  }
  function i(o, f, u) {
    for (var s = o._data, c = [], l, m = 0; m < u; m++) {
      l = c[m] = [];
      for (var h = 0; h < f; h++)
        l[h] = Je(s[h][m]);
    }
    return o.createDenseMatrix({
      data: c,
      size: [u, f],
      datatype: o._datatype
    });
  }
  function a(o, f, u) {
    for (var s = o._values, c = o._index, l = o._ptr, m = s ? [] : void 0, h = [], g = [], d = [], y = 0; y < f; y++)
      d[y] = 0;
    var w, E, x;
    for (w = 0, E = c.length; w < E; w++)
      d[c[w]]++;
    for (var N = 0, D = 0; D < f; D++)
      g.push(N), N += d[D], d[D] = g[D];
    for (g.push(N), x = 0; x < u; x++)
      for (var b = l[x], C = l[x + 1], A = b; A < C; A++) {
        var T = d[c[A]]++;
        h[T] = x, s && (m[T] = Je(s[A]));
      }
    return o.createSparseMatrix({
      values: m,
      index: h,
      ptr: g,
      size: [u, f],
      datatype: o._datatype
    });
  }
}), Sy = "ctranspose", BM = ["typed", "transpose", "conj"], rl = /* @__PURE__ */ H(Sy, BM, (t) => {
  var {
    typed: e,
    transpose: r,
    conj: n
  } = t;
  return e(Sy, {
    any: function(a) {
      return n(r(a));
    }
  });
}), Ay = "zeros", RM = ["typed", "config", "matrix", "BigNumber"], nl = /* @__PURE__ */ H(Ay, RM, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    BigNumber: i
  } = t;
  return e(Ay, {
    "": function() {
      return r.matrix === "Array" ? a([]) : a([], "default");
    },
    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function(s) {
      var c = s[s.length - 1];
      if (typeof c == "string") {
        var l = s.pop();
        return a(s, l);
      } else return r.matrix === "Array" ? a(s) : a(s, "default");
    },
    Array: a,
    Matrix: function(s) {
      var c = s.storage();
      return a(s.valueOf(), c);
    },
    "Array | Matrix, string": function(s, c) {
      return a(s.valueOf(), c);
    }
  });
  function a(u, s) {
    var c = o(u), l = c ? new i(0) : 0;
    if (f(u), s) {
      var m = n(s);
      return u.length > 0 ? m.resize(u, l) : m;
    } else {
      var h = [];
      return u.length > 0 ? Oa(h, u, l) : h;
    }
  }
  function o(u) {
    var s = !1;
    return u.forEach(function(c, l, m) {
      at(c) && (s = !0, m[l] = c.toNumber());
    }), s;
  }
  function f(u) {
    u.forEach(function(s) {
      if (typeof s != "number" || !Ve(s) || s < 0)
        throw new Error("Parameters in function zeros must be positive integers");
    });
  }
}), Cy = "fft", PM = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"], il = /* @__PURE__ */ H(Cy, PM, (t) => {
  var {
    typed: e,
    matrix: r,
    addScalar: n,
    multiplyScalar: i,
    divideScalar: a,
    exp: o,
    tau: f,
    i: u,
    dotDivide: s,
    conj: c,
    pow: l,
    ceil: m,
    log2: h
  } = t;
  return e(Cy, {
    Array: g,
    Matrix: function(x) {
      return x.create(g(x.toArray()));
    }
  });
  function g(E) {
    var x = ft(E);
    return x.length === 1 ? w(E, x[0]) : d(E.map((N) => g(N, x.slice(1))), 0);
  }
  function d(E, x) {
    var N = ft(E);
    if (x !== 0) return new Array(N[0]).fill(0).map((b, C) => d(E[C], x - 1));
    if (N.length === 1) return w(E);
    function D(b) {
      var C = ft(b);
      return new Array(C[1]).fill(0).map((A, T) => new Array(C[0]).fill(0).map((_, O) => b[O][T]));
    }
    return D(d(D(E), 1));
  }
  function y(E) {
    for (var x = E.length, N = o(a(i(-1, i(u, f)), x)), D = [], b = 1 - x; b < x; b++)
      D.push(l(N, a(l(b, 2), 2)));
    for (var C = l(2, m(h(x + x - 1))), A = [...new Array(x).fill(0).map((F, M) => i(E[M], D[x - 1 + M])), ...new Array(C - x).fill(0)], T = [...new Array(x + x - 1).fill(0).map((F, M) => a(1, D[M])), ...new Array(C - (x + x - 1)).fill(0)], _ = w(A), O = w(T), I = new Array(C).fill(0).map((F, M) => i(_[M], O[M])), B = s(c(g(c(I))), C), k = [], L = x - 1; L < x + x - 1; L++)
      k.push(i(B[L], D[L]));
    return k;
  }
  function w(E) {
    var x = E.length;
    if (x === 1) return [E[0]];
    if (x % 2 === 0) {
      for (var N = [...w(E.filter((A, T) => T % 2 === 0)), ...w(E.filter((A, T) => T % 2 === 1))], D = 0; D < x / 2; D++) {
        var b = N[D], C = i(N[D + x / 2], o(i(i(f, u), a(-D, x))));
        N[D] = n(b, C), N[D + x / 2] = n(b, i(-1, C));
      }
      return N;
    } else
      return y(E);
  }
}), Ty = "ifft", LM = ["typed", "fft", "dotDivide", "conj"], al = /* @__PURE__ */ H(Ty, LM, (t) => {
  var {
    typed: e,
    fft: r,
    dotDivide: n,
    conj: i
  } = t;
  return e(Ty, {
    "Array | Matrix": function(o) {
      var f = Ye(o) ? o.size() : ft(o);
      return n(i(r(i(o))), f.reduce((u, s) => u * s, 1));
    }
  });
});
function As(t) {
  "@babel/helpers - typeof";
  return As = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, As(t);
}
function kM(t, e) {
  if (As(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e || "default");
    if (As(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function zM(t) {
  var e = kM(t, "string");
  return As(e) == "symbol" ? e : e + "";
}
function lr(t, e, r) {
  return (e = zM(e)) in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function _y(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function $M(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _y(Object(r), !0).forEach(function(n) {
      lr(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : _y(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var UM = "solveODE", GM = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"], sl = /* @__PURE__ */ H(UM, GM, (t) => {
  var {
    typed: e,
    add: r,
    subtract: n,
    multiply: i,
    divide: a,
    max: o,
    map: f,
    abs: u,
    isPositive: s,
    isNegative: c,
    larger: l,
    smaller: m,
    matrix: h,
    bignumber: g,
    unaryMinus: d
  } = t;
  function y(A) {
    return function(T, _, O, I) {
      var B = !(_.length === 2 && (_.every(b) || _.every(Lr)));
      if (B)
        throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
      var k = _[0], L = _[1], F = l(L, k), M = I.firstStep;
      if (M !== void 0 && !s(M))
        throw new Error('"firstStep" must be positive');
      var $ = I.maxStep;
      if ($ !== void 0 && !s($))
        throw new Error('"maxStep" must be positive');
      var R = I.minStep;
      if (R && c(R))
        throw new Error('"minStep" must be positive or zero');
      var Q = [k, L, M, R, $].filter((G) => G !== void 0);
      if (!(Q.every(b) || Q.every(Lr)))
        throw new Error('Inconsistent type of "t" dependant variables');
      for (var ee = 1, j = I.tol ? I.tol : 1e-4, U = I.minDelta ? I.minDelta : 0.2, pe = I.maxDelta ? I.maxDelta : 5, X = I.maxIter ? I.maxIter : 1e4, te = [k, L, ...O, $, R].some(at), [ue, ce, se, he] = te ? [g(A.a), g(A.c), g(A.b), g(A.bp)] : [A.a, A.c, A.b, A.bp], le = M ? F ? M : d(M) : a(n(L, k), ee), ve = [k], Ee = [O], _e = n(se, he), V = 0, J = 0, ye = N(F), K = D(F); ye(ve[V], L); ) {
        var ae = [];
        le = K(ve[V], L, le), ae.push(T(ve[V], Ee[V]));
        for (var de = 1; de < ce.length; ++de)
          ae.push(T(r(ve[V], i(ce[de], le)), r(Ee[V], i(le, ue[de], ae))));
        var xe = o(u(f(i(_e, ae), (G) => Lr(G) ? G.value : G)));
        xe < j && j / xe > 1 / 4 && (ve.push(r(ve[V], le)), Ee.push(r(Ee[V], i(le, se, ae))), V++);
        var Ce = 0.84 * (j / xe) ** (1 / 5);
        if (m(Ce, U) ? Ce = U : l(Ce, pe) && (Ce = pe), Ce = te ? g(Ce) : Ce, le = i(le, Ce), $ && l(u(le), $) ? le = F ? $ : d($) : R && m(u(le), R) && (le = F ? R : d(R)), J++, J > X)
          throw new Error("Maximum number of iterations reached, try changing options");
      }
      return {
        t: ve,
        y: Ee
      };
    };
  }
  function w(A, T, _, O) {
    var I = [[], [0.5], [0, 0.75], [0.2222222222222222, 0.3333333333333333, 0.4444444444444444]], B = [null, 1 / 2, 3 / 4, 1], k = [2 / 9, 1 / 3, 4 / 9, 0], L = [7 / 24, 1 / 4, 1 / 3, 1 / 8], F = {
      a: I,
      c: B,
      b: k,
      bp: L
    };
    return y(F)(A, T, _, O);
  }
  function E(A, T, _, O) {
    var I = [[], [0.2], [0.075, 0.225], [0.9777777777777777, -3.7333333333333334, 3.5555555555555554], [2.9525986892242035, -11.595793324188385, 9.822892851699436, -0.2908093278463649], [2.8462752525252526, -10.757575757575758, 8.906422717743473, 0.2784090909090909, -0.2735313036020583], [0.09114583333333333, 0, 0.44923629829290207, 0.6510416666666666, -0.322376179245283, 0.13095238095238096]], B = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1], k = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0], L = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40], F = {
      a: I,
      c: B,
      b: k,
      bp: L
    };
    return y(F)(A, T, _, O);
  }
  function x(A, T, _, O) {
    var I = O.method ? O.method : "RK45", B = {
      RK23: w,
      RK45: E
    };
    if (I.toUpperCase() in B) {
      var k = $M({}, O);
      return delete k.method, B[I.toUpperCase()](A, T, _, k);
    } else {
      var L = Object.keys(B).map((M) => '"'.concat(M, '"')), F = "".concat(L.slice(0, -1).join(", "), " and ").concat(L.slice(-1));
      throw new Error('Unavailable method "'.concat(I, '". Available methods are ').concat(F));
    }
  }
  function N(A) {
    return A ? m : l;
  }
  function D(A) {
    var T = A ? l : m;
    return function(_, O, I) {
      var B = r(_, I);
      return T(B, O) ? n(O, _) : I;
    };
  }
  function b(A) {
    return at(A) || ot(A);
  }
  function C(A, T, _, O) {
    var I = x(A, T.toArray(), _.toArray(), O);
    return {
      t: h(I.t),
      y: h(I.y)
    };
  }
  return e("solveODE", {
    "function, Array, Array, Object": x,
    "function, Matrix, Matrix, Object": C,
    "function, Array, Array": (A, T, _) => x(A, T, _, {}),
    "function, Matrix, Matrix": (A, T, _) => C(A, T, _, {}),
    "function, Array, number | BigNumber | Unit": (A, T, _) => {
      var O = x(A, T, [_], {});
      return {
        t: O.t,
        y: O.y.map((I) => I[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit": (A, T, _) => {
      var O = x(A, T.toArray(), [_], {});
      return {
        t: h(O.t),
        y: h(O.y.map((I) => I[0]))
      };
    },
    "function, Array, number | BigNumber | Unit, Object": (A, T, _, O) => {
      var I = x(A, T, [_], O);
      return {
        t: I.t,
        y: I.y.map((B) => B[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit, Object": (A, T, _, O) => {
      var I = x(A, T.toArray(), [_], O);
      return {
        t: h(I.t),
        y: h(I.y.map((B) => B[0]))
      };
    }
  });
}), HM = "erf", QM = ["typed"], ol = /* @__PURE__ */ H(HM, QM, (t) => {
  var {
    typed: e
  } = t;
  return e("name", {
    number: function(o) {
      var f = Math.abs(o);
      return f >= jM ? hi(o) : f <= VM ? hi(o) * r(f) : f <= 4 ? hi(o) * (1 - n(f)) : hi(o) * (1 - i(f));
    },
    "Array | Matrix": e.referToSelf((a) => (o) => gt(o, a))
    // TODO: For complex numbers, use the approximation for the Faddeeva function
    //  from "More Efficient Computation of the Complex Error Function" (AMS)
  });
  function r(a) {
    var o = a * a, f = Wn[0][4] * o, u = o, s;
    for (s = 0; s < 3; s += 1)
      f = (f + Wn[0][s]) * o, u = (u + ya[0][s]) * o;
    return a * (f + Wn[0][3]) / (u + ya[0][3]);
  }
  function n(a) {
    var o = Wn[1][8] * a, f = a, u;
    for (u = 0; u < 7; u += 1)
      o = (o + Wn[1][u]) * a, f = (f + ya[1][u]) * a;
    var s = (o + Wn[1][7]) / (f + ya[1][7]), c = parseInt(a * 16) / 16, l = (a - c) * (a + c);
    return Math.exp(-c * c) * Math.exp(-l) * s;
  }
  function i(a) {
    var o = 1 / (a * a), f = Wn[2][5] * o, u = o, s;
    for (s = 0; s < 4; s += 1)
      f = (f + Wn[2][s]) * o, u = (u + ya[2][s]) * o;
    var c = o * (f + Wn[2][4]) / (u + ya[2][4]);
    c = (WM - c) / a, o = parseInt(a * 16) / 16;
    var l = (a - o) * (a + o);
    return Math.exp(-o * o) * Math.exp(-l) * c;
  }
}), VM = 0.46875, WM = 0.5641895835477563, Wn = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]], ya = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]], jM = Math.pow(2, 53), My = "zeta", YM = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"], ul = /* @__PURE__ */ H(My, YM, (t) => {
  var {
    typed: e,
    config: r,
    multiply: n,
    pow: i,
    divide: a,
    factorial: o,
    equal: f,
    smallerEq: u,
    isNegative: s,
    gamma: c,
    sin: l,
    subtract: m,
    add: h,
    Complex: g,
    BigNumber: d,
    pi: y
  } = t;
  return e(My, {
    number: (b) => w(b, (C) => C, () => 20),
    BigNumber: (b) => w(b, (C) => new d(C), () => Math.abs(Math.log10(r.relTol))),
    Complex: E
  });
  function w(b, C, A) {
    return f(b, 0) ? C(-0.5) : f(b, 1) ? C(NaN) : isFinite(b) ? x(b, C, A, (T) => T) : s(b) ? C(NaN) : C(1);
  }
  function E(b) {
    return b.re === 0 && b.im === 0 ? new g(-0.5) : b.re === 1 ? new g(NaN, NaN) : b.re === 1 / 0 && b.im === 0 ? new g(1) : b.im === 1 / 0 || b.re === -1 / 0 ? new g(NaN, NaN) : x(b, (C) => C, (C) => Math.round(1.3 * 15 + 0.9 * Math.abs(C.im)), (C) => C.re);
  }
  function x(b, C, A, T) {
    var _ = A(b);
    if (T(b) > -(_ - 1) / 2)
      return D(b, C(_), C);
    var O = n(i(2, b), i(C(y), m(b, 1)));
    return O = n(O, l(n(a(C(y), 2), b))), O = n(O, c(m(1, b))), n(O, x(m(1, b), C, A, T));
  }
  function N(b, C) {
    for (var A = b, T = b; u(T, C); T = h(T, 1)) {
      var _ = a(n(o(h(C, m(T, 1))), i(4, T)), n(o(m(C, T)), o(n(2, T))));
      A = h(A, _);
    }
    return n(C, A);
  }
  function D(b, C, A) {
    for (var T = a(1, n(N(A(0), C), m(1, i(2, m(1, b))))), _ = A(0), O = A(1); u(O, C); O = h(O, 1))
      _ = h(_, a(n((-1) ** (O - 1), N(O, C)), i(O, b)));
    return n(T, _);
  }
}), Oy = "mode", ZM = ["typed", "isNaN", "isNumeric"], ll = /* @__PURE__ */ H(Oy, ZM, (t) => {
  var {
    typed: e,
    isNaN: r,
    isNumeric: n
  } = t;
  return e(Oy, {
    "Array | Matrix": i,
    "...": function(o) {
      return i(o);
    }
  });
  function i(a) {
    a = Mt(a.valueOf());
    var o = a.length;
    if (o === 0)
      throw new Error("Cannot calculate mode of an empty array");
    for (var f = {}, u = [], s = 0, c = 0; c < a.length; c++) {
      var l = a[c];
      if (n(l) && r(l))
        throw new Error("Cannot calculate mode of an array containing NaN values");
      l in f || (f[l] = 0), f[l]++, f[l] === s ? u.push(l) : f[l] > s && (s = f[l], u = [l]);
    }
    return u;
  }
});
function $r(t, e, r) {
  var n;
  return String(t).includes("Unexpected type") ? (n = arguments.length > 2 ? " (type: " + kt(r) + ", value: " + JSON.stringify(r) + ")" : " (type: " + t.data.actual + ")", new TypeError("Cannot calculate " + e + ", unexpected type of argument" + n)) : String(t).includes("complex numbers") ? (n = arguments.length > 2 ? " (type: " + kt(r) + ", value: " + JSON.stringify(r) + ")" : "", new TypeError("Cannot calculate " + e + ", no ordering relation is defined for complex numbers" + n)) : t;
}
var qy = "prod", JM = ["typed", "config", "multiplyScalar", "numeric"], cl = /* @__PURE__ */ H(qy, JM, (t) => {
  var {
    typed: e,
    config: r,
    multiplyScalar: n,
    numeric: i
  } = t;
  return e(qy, {
    // prod([a, b, c, d, ...])
    "Array | Matrix": a,
    // prod([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(f, u) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    // prod(a, b, c, d, ...)
    "...": function(f) {
      return a(f);
    }
  });
  function a(o) {
    var f;
    if (ei(o, function(u) {
      try {
        f = f === void 0 ? u : n(f, u);
      } catch (s) {
        throw $r(s, "prod", u);
      }
    }), typeof f == "string" && (f = i(f, wi(f, r))), f === void 0)
      throw new Error("Cannot calculate prod of an empty array");
    return f;
  }
}), Iy = "format", XM = ["typed"], fl = /* @__PURE__ */ H(Iy, XM, (t) => {
  var {
    typed: e
  } = t;
  return e(Iy, {
    any: vt,
    "any, Object | function | number | BigNumber": vt
  });
}), Fy = "bin", KM = ["typed", "format"], pl = H(Fy, KM, (t) => {
  var {
    typed: e,
    format: r
  } = t;
  return e(Fy, {
    "number | BigNumber": function(i) {
      return r(i, {
        notation: "bin"
      });
    },
    "number | BigNumber, number | BigNumber": function(i, a) {
      return r(i, {
        notation: "bin",
        wordSize: a
      });
    }
  });
}), By = "oct", eO = ["typed", "format"], ml = H(By, eO, (t) => {
  var {
    typed: e,
    format: r
  } = t;
  return e(By, {
    "number | BigNumber": function(i) {
      return r(i, {
        notation: "oct"
      });
    },
    "number | BigNumber, number | BigNumber": function(i, a) {
      return r(i, {
        notation: "oct",
        wordSize: a
      });
    }
  });
}), Ry = "hex", tO = ["typed", "format"], hl = H(Ry, tO, (t) => {
  var {
    typed: e,
    format: r
  } = t;
  return e(Ry, {
    "number | BigNumber": function(i) {
      return r(i, {
        notation: "hex"
      });
    },
    "number | BigNumber, number | BigNumber": function(i, a) {
      return r(i, {
        notation: "hex",
        wordSize: a
      });
    }
  });
}), Qw = /\$([\w.]+)/g, Py = "print", rO = ["typed"], Qs = /* @__PURE__ */ H(Py, rO, (t) => {
  var {
    typed: e
  } = t;
  return e(Py, {
    // note: Matrix will be converted automatically to an Array
    "string, Object | Array": Ly,
    "string, Object | Array, number | Object": Ly
  });
});
function Ly(t, e, r) {
  return t.replace(Qw, function(n, i) {
    var a = i.split("."), o = e[a.shift()];
    for (o !== void 0 && o.isMatrix && (o = o.toArray()); a.length && o !== void 0; ) {
      var f = a.shift();
      o = f ? o[f] : o + ".";
    }
    return o !== void 0 ? hr(o) ? o : vt(o, r) : n;
  });
}
var ky = "to", nO = ["typed", "matrix", "concat"], dl = /* @__PURE__ */ H(ky, nO, (t) => {
  var {
    typed: e,
    matrix: r,
    concat: n
  } = t, i = Ut({
    typed: e,
    matrix: r,
    concat: n
  });
  return e(ky, {
    "Unit, Unit | string": (a, o) => a.to(o)
  }, i({
    Ds: !0
  }));
}), zy = "isPrime", iO = ["typed"], gl = /* @__PURE__ */ H(zy, iO, (t) => {
  var {
    typed: e
  } = t;
  return e(zy, {
    number: function(n) {
      if (n <= 3)
        return n > 1;
      if (n % 2 === 0 || n % 3 === 0)
        return !1;
      for (var i = 5; i * i <= n; i += 6)
        if (n % i === 0 || n % (i + 2) === 0)
          return !1;
      return !0;
    },
    bigint: function(n) {
      if (n <= 3n)
        return n > 1n;
      if (n % 2n === 0n || n % 3n === 0n)
        return !1;
      for (var i = 5n; i * i <= n; i += 6n)
        if (n % i === 0n || n % (i + 2n) === 0n)
          return !1;
      return !0;
    },
    BigNumber: function(n) {
      if (n.lte(3)) return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0)) return !1;
      if (n.lt(Math.pow(2, 32))) {
        for (var i = n.toNumber(), a = 5; a * a <= i; a += 6)
          if (i % a === 0 || i % (a + 2) === 0)
            return !1;
        return !0;
      }
      function o(E, x, N) {
        for (var D = 1; !x.eq(0); )
          x.mod(2).eq(0) ? (x = x.div(2), E = E.mul(E).mod(N)) : (x = x.sub(1), D = E.mul(D).mod(N));
        return D;
      }
      var f = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new f(n);
      for (var u = 0, s = n.sub(1); s.mod(2).eq(0); )
        s = s.div(2), u += 1;
      var c = null;
      if (n.lt("3317044064679887385961981"))
        c = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((E) => E < n);
      else {
        var l = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        c = [];
        for (var m = 2; m <= l; m += 1)
          c.push(l);
      }
      for (var h = 0; h < c.length; h += 1) {
        var g = c[h], d = o(n.sub(n).add(g), s, n);
        if (!d.eq(1)) {
          for (var y = 0, w = d; !w.eq(n.sub(1)); y += 1, w = w.mul(w).mod(n))
            if (y === u - 1)
              return !1;
        }
      }
      return !0;
    },
    "Array | Matrix": e.referToSelf((r) => (n) => gt(n, r))
  });
}), aO = "numeric", sO = ["number", "?bignumber", "?fraction"], vl = /* @__PURE__ */ H(aO, sO, (t) => {
  var {
    number: e,
    bignumber: r,
    fraction: n
  } = t, i = {
    string: !0,
    number: !0,
    BigNumber: !0,
    Fraction: !0
  }, a = {
    number: (o) => e(o),
    BigNumber: r ? (o) => r(o) : Md,
    bigint: (o) => BigInt(o),
    Fraction: n ? (o) => n(o) : Gw
  };
  return function(f) {
    var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number", s = arguments.length > 2 ? arguments[2] : void 0;
    if (s !== void 0)
      throw new SyntaxError("numeric() takes one or two arguments");
    var c = kt(f);
    if (!(c in i))
      throw new TypeError("Cannot convert " + f + ' of type "' + c + '"; valid input types are ' + Object.keys(i).join(", "));
    if (!(u in a))
      throw new TypeError("Cannot convert " + f + ' to type "' + u + '"; valid output types are ' + Object.keys(a).join(", "));
    return u === c ? f : a[u](f);
  };
}), $y = "divideScalar", oO = ["typed", "numeric"], yl = /* @__PURE__ */ H($y, oO, (t) => {
  var {
    typed: e,
    numeric: r
  } = t;
  return e($y, {
    "number, number": function(i, a) {
      return i / a;
    },
    "Complex, Complex": function(i, a) {
      return i.div(a);
    },
    "BigNumber, BigNumber": function(i, a) {
      return i.div(a);
    },
    "bigint, bigint": function(i, a) {
      return i / a;
    },
    "Fraction, Fraction": function(i, a) {
      return i.div(a);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (n, i) => n.divide(i),
    "number | Fraction | Complex | BigNumber, Unit": (n, i) => i.divideInto(n)
  });
}), Uy = "pow", uO = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"], xl = /* @__PURE__ */ H(Uy, uO, (t) => {
  var {
    typed: e,
    config: r,
    identity: n,
    multiply: i,
    matrix: a,
    inv: o,
    number: f,
    fraction: u,
    Complex: s
  } = t;
  return e(Uy, {
    "number, number": c,
    "Complex, Complex": function(g, d) {
      return g.pow(d);
    },
    "BigNumber, BigNumber": function(g, d) {
      return d.isInteger() || g >= 0 || r.predictable ? g.pow(d) : new s(g.toNumber(), 0).pow(d.toNumber(), 0);
    },
    "bigint, bigint": (h, g) => h ** g,
    "Fraction, Fraction": function(g, d) {
      var y = g.pow(d);
      if (y != null)
        return y;
      if (r.predictable)
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      return c(g.valueOf(), d.valueOf());
    },
    "Array, number": l,
    "Array, BigNumber": function(g, d) {
      return l(g, d.toNumber());
    },
    "Matrix, number": m,
    "Matrix, BigNumber": function(g, d) {
      return m(g, d.toNumber());
    },
    "Unit, number | BigNumber": function(g, d) {
      return g.pow(d);
    }
  });
  function c(h, g) {
    if (r.predictable && !Ve(g) && h < 0)
      try {
        var d = u(g), y = f(d);
        if ((g === y || Math.abs((g - y) / g) < 1e-14) && d.d % 2 === 1)
          return (d.n % 2 === 0 ? 1 : -1) * Math.pow(-h, g);
      } catch {
      }
    return r.predictable && (h < -1 && g === 1 / 0 || h > -1 && h < 0 && g === -1 / 0) ? NaN : Ve(g) || h >= 0 || r.predictable ? fw(h, g) : h * h < 1 && g === 1 / 0 || h * h > 1 && g === -1 / 0 ? 0 : new s(h, 0).pow(g, 0);
  }
  function l(h, g) {
    if (!Ve(g))
      throw new TypeError("For A^b, b must be an integer (value is " + g + ")");
    var d = ft(h);
    if (d.length !== 2)
      throw new Error("For A^b, A must be 2 dimensional (A has " + d.length + " dimensions)");
    if (d[0] !== d[1])
      throw new Error("For A^b, A must be square (size is " + d[0] + "x" + d[1] + ")");
    if (g < 0)
      try {
        return l(o(h), -g);
      } catch (E) {
        throw E.message === "Cannot calculate inverse, determinant is zero" ? new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + g + ")") : E;
      }
    for (var y = n(d[0]).valueOf(), w = h; g >= 1; )
      (g & 1) === 1 && (y = i(w, y)), g >>= 1, w = i(w, w);
    return y;
  }
  function m(h, g) {
    return a(l(h.valueOf(), g));
  }
}), xa = "Number of decimals in function round must be an integer", Gy = "round", lO = ["typed", "config", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"], bl = /* @__PURE__ */ H(Gy, lO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    equalScalar: i,
    zeros: a,
    BigNumber: o,
    DenseMatrix: f
  } = t, u = Sr({
    typed: e,
    equalScalar: i
  }), s = cr({
    typed: e,
    DenseMatrix: f
  }), c = _n({
    typed: e
  });
  function l(m) {
    return Math.abs(Os(m).exponent);
  }
  return e(Gy, {
    number: function(h) {
      var g = gs(h, l(r.relTol)), d = Er(h, g, r.relTol, r.absTol) ? g : h;
      return gs(d);
    },
    "number, number": function(h, g) {
      var d = l(r.relTol);
      if (g >= d)
        return gs(h, g);
      var y = gs(h, d), w = Er(h, y, r.relTol, r.absTol) ? y : h;
      return gs(w, g);
    },
    "number, BigNumber": function(h, g) {
      if (!g.isInteger())
        throw new TypeError(xa);
      return new o(h).toDecimalPlaces(g.toNumber());
    },
    Complex: function(h) {
      return h.round();
    },
    "Complex, number": function(h, g) {
      if (g % 1)
        throw new TypeError(xa);
      return h.round(g);
    },
    "Complex, BigNumber": function(h, g) {
      if (!g.isInteger())
        throw new TypeError(xa);
      var d = g.toNumber();
      return h.round(d);
    },
    BigNumber: function(h) {
      var g = new o(h).toDecimalPlaces(l(r.relTol)), d = Jr(h, g, r.relTol, r.absTol) ? g : h;
      return d.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function(h, g) {
      if (!g.isInteger())
        throw new TypeError(xa);
      var d = l(r.relTol);
      if (g >= d)
        return h.toDecimalPlaces(g.toNumber());
      var y = h.toDecimalPlaces(d), w = Jr(h, y, r.relTol, r.absTol) ? y : h;
      return w.toDecimalPlaces(g.toNumber());
    },
    Fraction: function(h) {
      return h.round();
    },
    "Fraction, number": function(h, g) {
      if (g % 1)
        throw new TypeError(xa);
      return h.round(g);
    },
    "Fraction, BigNumber": function(h, g) {
      if (!g.isInteger())
        throw new TypeError(xa);
      return h.round(g.toNumber());
    },
    "Unit, number, Unit": e.referToSelf((m) => function(h, g, d) {
      var y = h.toNumeric(d);
      return d.multiply(m(y, g));
    }),
    "Unit, BigNumber, Unit": e.referToSelf((m) => (h, g, d) => m(h, g.toNumber(), d)),
    "Unit, Unit": e.referToSelf((m) => (h, g) => m(h, 0, g)),
    "Array | Matrix, number, Unit": e.referToSelf((m) => (h, g, d) => gt(h, (y) => m(y, g, d))),
    "Array | Matrix, BigNumber, Unit": e.referToSelf((m) => (h, g, d) => m(h, g.toNumber(), d)),
    "Array | Matrix, Unit": e.referToSelf((m) => (h, g) => m(h, 0, g)),
    "Array | Matrix": e.referToSelf((m) => (h) => gt(h, m)),
    "SparseMatrix, number | BigNumber": e.referToSelf((m) => (h, g) => u(h, g, m, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((m) => (h, g) => c(h, g, m, !1)),
    "Array, number | BigNumber": e.referToSelf((m) => (h, g) => c(n(h), g, m, !1).valueOf()),
    "number | Complex | BigNumber | Fraction, SparseMatrix": e.referToSelf((m) => (h, g) => i(h, 0) ? a(g.size(), g.storage()) : s(g, h, m, !0)),
    "number | Complex | BigNumber | Fraction, DenseMatrix": e.referToSelf((m) => (h, g) => i(h, 0) ? a(g.size(), g.storage()) : c(g, h, m, !0)),
    "number | Complex | BigNumber | Fraction, Array": e.referToSelf((m) => (h, g) => c(n(g), h, m, !0).valueOf())
  });
}), Hy = "log", cO = ["config", "typed", "divideScalar", "Complex"], wl = /* @__PURE__ */ H(Hy, cO, (t) => {
  var {
    typed: e,
    config: r,
    divideScalar: n,
    Complex: i
  } = t;
  return e(Hy, {
    number: function(o) {
      return o >= 0 || r.predictable ? GT(o) : new i(o, 0).log();
    },
    Complex: function(o) {
      return o.log();
    },
    BigNumber: function(o) {
      return !o.isNegative() || r.predictable ? o.ln() : new i(o.toNumber(), 0).log();
    },
    "any, any": e.referToSelf((a) => (o, f) => n(a(o), a(f)))
  });
}), Qy = "log1p", fO = ["typed", "config", "divideScalar", "log", "Complex"], Nl = /* @__PURE__ */ H(Qy, fO, (t) => {
  var {
    typed: e,
    config: r,
    divideScalar: n,
    log: i,
    Complex: a
  } = t;
  return e(Qy, {
    number: function(u) {
      return u >= -1 || r.predictable ? jA(u) : o(new a(u, 0));
    },
    Complex: o,
    BigNumber: function(u) {
      var s = u.plus(1);
      return !s.isNegative() || r.predictable ? s.ln() : o(new a(u.toNumber(), 0));
    },
    "Array | Matrix": e.referToSelf((f) => (u) => gt(u, f)),
    "any, any": e.referToSelf((f) => (u, s) => n(f(u), i(s)))
  });
  function o(f) {
    var u = f.re + 1;
    return new a(Math.log(Math.sqrt(u * u + f.im * f.im)), Math.atan2(f.im, u));
  }
}), Vy = "nthRoots", pO = ["config", "typed", "divideScalar", "Complex"], Dl = /* @__PURE__ */ H(Vy, pO, (t) => {
  var {
    typed: e,
    config: r,
    divideScalar: n,
    Complex: i
  } = t, a = [function(u) {
    return new i(u, 0);
  }, function(u) {
    return new i(0, u);
  }, function(u) {
    return new i(-u, 0);
  }, function(u) {
    return new i(0, -u);
  }];
  function o(f, u) {
    if (u < 0) throw new Error("Root must be greater than zero");
    if (u === 0) throw new Error("Root must be non-zero");
    if (u % 1 !== 0) throw new Error("Root must be an integer");
    if (f === 0 || f.abs() === 0) return [new i(0, 0)];
    var s = typeof f == "number", c;
    (s || f.re === 0 || f.im === 0) && (s ? c = 2 * +(f < 0) : f.im === 0 ? c = 2 * +(f.re < 0) : c = 2 * +(f.im < 0) + 1);
    for (var l = f.arg(), m = f.abs(), h = [], g = Math.pow(m, 1 / u), d = 0; d < u; d++) {
      var y = (c + 4 * d) / u;
      if (y === Math.round(y)) {
        h.push(a[y % 4](g));
        continue;
      }
      h.push(new i({
        r: g,
        phi: (l + 2 * Math.PI * d) / u
      }));
    }
    return h;
  }
  return e(Vy, {
    Complex: function(u) {
      return o(u, 2);
    },
    "Complex, number": o
  });
}), Wy = "dotPow", mO = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"], El = /* @__PURE__ */ H(Wy, mO, (t) => {
  var {
    typed: e,
    equalScalar: r,
    matrix: n,
    pow: i,
    DenseMatrix: a,
    concat: o
  } = t, f = Ur({
    typed: e
  }), u = Ln({
    typed: e,
    DenseMatrix: a
  }), s = Sr({
    typed: e,
    equalScalar: r
  }), c = cr({
    typed: e,
    DenseMatrix: a
  }), l = Ut({
    typed: e,
    matrix: n,
    concat: o
  }), m = {};
  for (var h in i.signatures)
    Object.prototype.hasOwnProperty.call(i.signatures, h) && !h.includes("Matrix") && !h.includes("Array") && (m[h] = i.signatures[h]);
  var g = e(m);
  return e(Wy, l({
    elop: g,
    SS: u,
    DS: f,
    Ss: s,
    sS: c
  }));
}), jy = "dotDivide", hO = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"], Sl = /* @__PURE__ */ H(jy, hO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    divideScalar: i,
    DenseMatrix: a,
    concat: o
  } = t, f = Mn({
    typed: e,
    equalScalar: n
  }), u = Ur({
    typed: e
  }), s = Ln({
    typed: e,
    DenseMatrix: a
  }), c = Sr({
    typed: e,
    equalScalar: n
  }), l = cr({
    typed: e,
    DenseMatrix: a
  }), m = Ut({
    typed: e,
    matrix: r,
    concat: o
  });
  return e(jy, m({
    elop: i,
    SS: s,
    DS: u,
    SD: f,
    Ss: c,
    sS: l
  }));
});
function Vs(t) {
  var {
    DenseMatrix: e
  } = t;
  return function(n, i, a) {
    var o = n.size();
    if (o.length !== 2)
      throw new RangeError("Matrix must be two dimensional (size: " + vt(o) + ")");
    var f = o[0], u = o[1];
    if (f !== u)
      throw new RangeError("Matrix must be square (size: " + vt(o) + ")");
    var s = [];
    if (Ye(i)) {
      var c = i.size(), l = i._data;
      if (c.length === 1) {
        if (c[0] !== f)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        for (var m = 0; m < f; m++)
          s[m] = [l[m]];
        return new e({
          data: s,
          size: [f, 1],
          datatype: i._datatype
        });
      }
      if (c.length === 2) {
        if (c[0] !== f || c[1] !== 1)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        if (Ca(i)) {
          if (a) {
            s = [];
            for (var h = 0; h < f; h++)
              s[h] = [l[h][0]];
            return new e({
              data: s,
              size: [f, 1],
              datatype: i._datatype
            });
          }
          return i;
        }
        if (jn(i)) {
          for (var g = 0; g < f; g++)
            s[g] = [0];
          for (var d = i._values, y = i._index, w = i._ptr, E = w[1], x = w[0]; x < E; x++) {
            var N = y[x];
            s[N][0] = d[x];
          }
          return new e({
            data: s,
            size: [f, 1],
            datatype: i._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (_t(i)) {
      var D = ft(i);
      if (D.length === 1) {
        if (D[0] !== f)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        for (var b = 0; b < f; b++)
          s[b] = [i[b]];
        return new e({
          data: s,
          size: [f, 1]
        });
      }
      if (D.length === 2) {
        if (D[0] !== f || D[1] !== 1)
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        for (var C = 0; C < f; C++)
          s[C] = [i[C][0]];
        return new e({
          data: s,
          size: [f, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}
var Yy = "lsolve", dO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], Al = /* @__PURE__ */ H(Yy, dO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: i,
    subtractScalar: a,
    equalScalar: o,
    DenseMatrix: f
  } = t, u = Vs({
    DenseMatrix: f
  });
  return e(Yy, {
    "SparseMatrix, Array | Matrix": function(m, h) {
      return c(m, h);
    },
    "DenseMatrix, Array | Matrix": function(m, h) {
      return s(m, h);
    },
    "Array, Array | Matrix": function(m, h) {
      var g = r(m), d = s(g, h);
      return d.valueOf();
    }
  });
  function s(l, m) {
    m = u(l, m, !0);
    for (var h = m._data, g = l._size[0], d = l._size[1], y = [], w = l._data, E = 0; E < d; E++) {
      var x = h[E][0] || 0, N = void 0;
      if (o(x, 0))
        N = 0;
      else {
        var D = w[E][E];
        if (o(D, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        N = n(x, D);
        for (var b = E + 1; b < g; b++)
          h[b] = [a(h[b][0] || 0, i(N, w[b][E]))];
      }
      y[E] = [N];
    }
    return new f({
      data: y,
      size: [g, 1]
    });
  }
  function c(l, m) {
    m = u(l, m, !0);
    for (var h = m._data, g = l._size[0], d = l._size[1], y = l._values, w = l._index, E = l._ptr, x = [], N = 0; N < d; N++) {
      var D = h[N][0] || 0;
      if (o(D, 0))
        x[N] = [0];
      else {
        for (var b = 0, C = [], A = [], T = E[N], _ = E[N + 1], O = T; O < _; O++) {
          var I = w[O];
          I === N ? b = y[O] : I > N && (C.push(y[O]), A.push(I));
        }
        if (o(b, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        for (var B = n(D, b), k = 0, L = A.length; k < L; k++) {
          var F = A[k];
          h[F] = [a(h[F][0] || 0, i(B, C[k]))];
        }
        x[N] = [B];
      }
    }
    return new f({
      data: x,
      size: [g, 1]
    });
  }
}), Zy = "usolve", gO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], Cl = /* @__PURE__ */ H(Zy, gO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: i,
    subtractScalar: a,
    equalScalar: o,
    DenseMatrix: f
  } = t, u = Vs({
    DenseMatrix: f
  });
  return e(Zy, {
    "SparseMatrix, Array | Matrix": function(m, h) {
      return c(m, h);
    },
    "DenseMatrix, Array | Matrix": function(m, h) {
      return s(m, h);
    },
    "Array, Array | Matrix": function(m, h) {
      var g = r(m), d = s(g, h);
      return d.valueOf();
    }
  });
  function s(l, m) {
    m = u(l, m, !0);
    for (var h = m._data, g = l._size[0], d = l._size[1], y = [], w = l._data, E = d - 1; E >= 0; E--) {
      var x = h[E][0] || 0, N = void 0;
      if (o(x, 0))
        N = 0;
      else {
        var D = w[E][E];
        if (o(D, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        N = n(x, D);
        for (var b = E - 1; b >= 0; b--)
          h[b] = [a(h[b][0] || 0, i(N, w[b][E]))];
      }
      y[E] = [N];
    }
    return new f({
      data: y,
      size: [g, 1]
    });
  }
  function c(l, m) {
    m = u(l, m, !0);
    for (var h = m._data, g = l._size[0], d = l._size[1], y = l._values, w = l._index, E = l._ptr, x = [], N = d - 1; N >= 0; N--) {
      var D = h[N][0] || 0;
      if (o(D, 0))
        x[N] = [0];
      else {
        for (var b = 0, C = [], A = [], T = E[N], _ = E[N + 1], O = _ - 1; O >= T; O--) {
          var I = w[O];
          I === N ? b = y[O] : I < N && (C.push(y[O]), A.push(I));
        }
        if (o(b, 0))
          throw new Error("Linear system cannot be solved since matrix is singular");
        for (var B = n(D, b), k = 0, L = A.length; k < L; k++) {
          var F = A[k];
          h[F] = [a(h[F][0], i(B, C[k]))];
        }
        x[N] = [B];
      }
    }
    return new f({
      data: x,
      size: [g, 1]
    });
  }
}), Jy = "lsolveAll", vO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], Tl = /* @__PURE__ */ H(Jy, vO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: i,
    subtractScalar: a,
    equalScalar: o,
    DenseMatrix: f
  } = t, u = Vs({
    DenseMatrix: f
  });
  return e(Jy, {
    "SparseMatrix, Array | Matrix": function(m, h) {
      return c(m, h);
    },
    "DenseMatrix, Array | Matrix": function(m, h) {
      return s(m, h);
    },
    "Array, Array | Matrix": function(m, h) {
      var g = r(m), d = s(g, h);
      return d.map((y) => y.valueOf());
    }
  });
  function s(l, m) {
    for (var h = [u(l, m, !0)._data.map((A) => A[0])], g = l._data, d = l._size[0], y = l._size[1], w = 0; w < y; w++)
      for (var E = h.length, x = 0; x < E; x++) {
        var N = h[x];
        if (o(g[w][w], 0))
          if (o(N[w], 0)) {
            if (x === 0) {
              var b = [...N];
              b[w] = 1;
              for (var C = w + 1; C < y; C++)
                b[C] = a(b[C], g[C][w]);
              h.push(b);
            }
          } else {
            if (x === 0)
              return [];
            h.splice(x, 1), x -= 1, E -= 1;
          }
        else {
          N[w] = n(N[w], g[w][w]);
          for (var D = w + 1; D < y; D++)
            N[D] = a(N[D], i(N[w], g[D][w]));
        }
      }
    return h.map((A) => new f({
      data: A.map((T) => [T]),
      size: [d, 1]
    }));
  }
  function c(l, m) {
    for (var h = [u(l, m, !0)._data.map((ee) => ee[0])], g = l._size[0], d = l._size[1], y = l._values, w = l._index, E = l._ptr, x = 0; x < d; x++)
      for (var N = h.length, D = 0; D < N; D++) {
        for (var b = h[D], C = [], A = [], T = E[x], _ = E[x + 1], O = 0, I = T; I < _; I++) {
          var B = w[I];
          B === x ? O = y[I] : B > x && (C.push(y[I]), A.push(B));
        }
        if (o(O, 0))
          if (o(b[x], 0)) {
            if (D === 0) {
              var M = [...b];
              M[x] = 1;
              for (var $ = 0, R = A.length; $ < R; $++) {
                var Q = A[$];
                M[Q] = a(M[Q], C[$]);
              }
              h.push(M);
            }
          } else {
            if (D === 0)
              return [];
            h.splice(D, 1), D -= 1, N -= 1;
          }
        else {
          b[x] = n(b[x], O);
          for (var k = 0, L = A.length; k < L; k++) {
            var F = A[k];
            b[F] = a(b[F], i(b[x], C[k]));
          }
        }
      }
    return h.map((ee) => new f({
      data: ee.map((j) => [j]),
      size: [g, 1]
    }));
  }
}), Xy = "usolveAll", yO = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"], _l = /* @__PURE__ */ H(Xy, yO, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    multiplyScalar: i,
    subtractScalar: a,
    equalScalar: o,
    DenseMatrix: f
  } = t, u = Vs({
    DenseMatrix: f
  });
  return e(Xy, {
    "SparseMatrix, Array | Matrix": function(m, h) {
      return c(m, h);
    },
    "DenseMatrix, Array | Matrix": function(m, h) {
      return s(m, h);
    },
    "Array, Array | Matrix": function(m, h) {
      var g = r(m), d = s(g, h);
      return d.map((y) => y.valueOf());
    }
  });
  function s(l, m) {
    for (var h = [u(l, m, !0)._data.map((A) => A[0])], g = l._data, d = l._size[0], y = l._size[1], w = y - 1; w >= 0; w--)
      for (var E = h.length, x = 0; x < E; x++) {
        var N = h[x];
        if (o(g[w][w], 0))
          if (o(N[w], 0)) {
            if (x === 0) {
              var b = [...N];
              b[w] = 1;
              for (var C = w - 1; C >= 0; C--)
                b[C] = a(b[C], g[C][w]);
              h.push(b);
            }
          } else {
            if (x === 0)
              return [];
            h.splice(x, 1), x -= 1, E -= 1;
          }
        else {
          N[w] = n(N[w], g[w][w]);
          for (var D = w - 1; D >= 0; D--)
            N[D] = a(N[D], i(N[w], g[D][w]));
        }
      }
    return h.map((A) => new f({
      data: A.map((T) => [T]),
      size: [d, 1]
    }));
  }
  function c(l, m) {
    for (var h = [u(l, m, !0)._data.map((ee) => ee[0])], g = l._size[0], d = l._size[1], y = l._values, w = l._index, E = l._ptr, x = d - 1; x >= 0; x--)
      for (var N = h.length, D = 0; D < N; D++) {
        for (var b = h[D], C = [], A = [], T = E[x], _ = E[x + 1], O = 0, I = _ - 1; I >= T; I--) {
          var B = w[I];
          B === x ? O = y[I] : B < x && (C.push(y[I]), A.push(B));
        }
        if (o(O, 0))
          if (o(b[x], 0)) {
            if (D === 0) {
              var M = [...b];
              M[x] = 1;
              for (var $ = 0, R = A.length; $ < R; $++) {
                var Q = A[$];
                M[Q] = a(M[Q], C[$]);
              }
              h.push(M);
            }
          } else {
            if (D === 0)
              return [];
            h.splice(D, 1), D -= 1, N -= 1;
          }
        else {
          b[x] = n(b[x], O);
          for (var k = 0, L = A.length; k < L; k++) {
            var F = A[k];
            b[F] = a(b[F], i(b[x], C[k]));
          }
        }
      }
    return h.map((ee) => new f({
      data: ee.map((j) => [j]),
      size: [g, 1]
    }));
  }
}), xO = "matAlgo08xS0Sid", bO = ["typed", "equalScalar"], Od = /* @__PURE__ */ H(xO, bO, (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return function(i, a, o) {
    var f = i._values, u = i._index, s = i._ptr, c = i._size, l = i._datatype || i._data === void 0 ? i._datatype : i.getDataType(), m = a._values, h = a._index, g = a._ptr, d = a._size, y = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (c.length !== d.length)
      throw new mt(c.length, d.length);
    if (c[0] !== d[0] || c[1] !== d[1])
      throw new RangeError("Dimension mismatch. Matrix A (" + c + ") must match Matrix B (" + d + ")");
    if (!f || !m)
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    var w = c[0], E = c[1], x, N = r, D = 0, b = o;
    typeof l == "string" && l === y && l !== "mixed" && (x = l, N = e.find(r, [x, x]), D = e.convert(0, x), b = e.find(o, [x, x]));
    for (var C = [], A = [], T = [], _ = [], O = [], I, B, k, L, F = 0; F < E; F++) {
      T[F] = A.length;
      var M = F + 1;
      for (B = s[F], k = s[F + 1], I = B; I < k; I++)
        L = u[I], O[L] = M, _[L] = f[I], A.push(L);
      for (B = g[F], k = g[F + 1], I = B; I < k; I++)
        L = h[I], O[L] === M && (_[L] = b(_[L], m[I]));
      for (I = T[F]; I < A.length; ) {
        L = A[I];
        var $ = _[L];
        N($, D) ? A.splice(I, 1) : (C.push($), I++);
      }
    }
    return T[E] = A.length, i.createSparseMatrix({
      values: C,
      index: A,
      ptr: T,
      size: [w, E],
      datatype: l === i._datatype && y === a._datatype ? x : void 0
    });
  };
}), qd = /* @__PURE__ */ H("useMatrixForArrayScalar", ["typed", "matrix"], (t) => {
  var {
    typed: e,
    matrix: r
  } = t;
  return {
    "Array, number": e.referTo("DenseMatrix, number", (n) => (i, a) => n(r(i), a).valueOf()),
    "Array, BigNumber": e.referTo("DenseMatrix, BigNumber", (n) => (i, a) => n(r(i), a).valueOf()),
    "number, Array": e.referTo("number, DenseMatrix", (n) => (i, a) => n(i, r(a)).valueOf()),
    "BigNumber, Array": e.referTo("BigNumber, DenseMatrix", (n) => (i, a) => n(i, r(a)).valueOf())
  };
}), Ky = "leftShift", wO = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], Ml = /* @__PURE__ */ H(Ky, wO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    DenseMatrix: a,
    concat: o
  } = t, f = Di({
    typed: e
  }), u = Mn({
    typed: e,
    equalScalar: n
  }), s = Od({
    typed: e,
    equalScalar: n
  }), c = ea({
    typed: e,
    DenseMatrix: a
  }), l = Sr({
    typed: e,
    equalScalar: n
  }), m = _n({
    typed: e
  }), h = Ut({
    typed: e,
    matrix: r,
    concat: o
  }), g = qd({
    typed: e,
    matrix: r
  });
  return e(Ky, {
    "number, number": gw,
    "BigNumber, BigNumber": U_,
    "bigint, bigint": (d, y) => d << y,
    "SparseMatrix, number | BigNumber": e.referToSelf((d) => (y, w) => n(w, 0) ? y.clone() : l(y, w, d, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((d) => (y, w) => n(w, 0) ? y.clone() : m(y, w, d, !1)),
    "number | BigNumber, SparseMatrix": e.referToSelf((d) => (y, w) => n(y, 0) ? i(w.size(), w.storage()) : c(w, y, d, !0)),
    "number | BigNumber, DenseMatrix": e.referToSelf((d) => (y, w) => n(y, 0) ? i(w.size(), w.storage()) : m(w, y, d, !0))
  }, g, h({
    SS: s,
    DS: f,
    SD: u
  }));
}), ex = "rightArithShift", NO = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], Ol = /* @__PURE__ */ H(ex, NO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    DenseMatrix: a,
    concat: o
  } = t, f = Di({
    typed: e
  }), u = Mn({
    typed: e,
    equalScalar: n
  }), s = Od({
    typed: e,
    equalScalar: n
  }), c = ea({
    typed: e,
    DenseMatrix: a
  }), l = Sr({
    typed: e,
    equalScalar: n
  }), m = _n({
    typed: e
  }), h = Ut({
    typed: e,
    matrix: r,
    concat: o
  }), g = qd({
    typed: e,
    matrix: r
  });
  return e(ex, {
    "number, number": vw,
    "BigNumber, BigNumber": G_,
    "bigint, bigint": (d, y) => d >> y,
    "SparseMatrix, number | BigNumber": e.referToSelf((d) => (y, w) => n(w, 0) ? y.clone() : l(y, w, d, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((d) => (y, w) => n(w, 0) ? y.clone() : m(y, w, d, !1)),
    "number | BigNumber, SparseMatrix": e.referToSelf((d) => (y, w) => n(y, 0) ? i(w.size(), w.storage()) : c(w, y, d, !0)),
    "number | BigNumber, DenseMatrix": e.referToSelf((d) => (y, w) => n(y, 0) ? i(w.size(), w.storage()) : m(w, y, d, !0))
  }, g, h({
    SS: s,
    DS: f,
    SD: u
  }));
}), tx = "rightLogShift", DO = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"], ql = /* @__PURE__ */ H(tx, DO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    DenseMatrix: a,
    concat: o
  } = t, f = Di({
    typed: e
  }), u = Mn({
    typed: e,
    equalScalar: n
  }), s = Od({
    typed: e,
    equalScalar: n
  }), c = ea({
    typed: e,
    DenseMatrix: a
  }), l = Sr({
    typed: e,
    equalScalar: n
  }), m = _n({
    typed: e
  }), h = Ut({
    typed: e,
    matrix: r,
    concat: o
  }), g = qd({
    typed: e,
    matrix: r
  });
  return e(tx, {
    "number, number": yw,
    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
    "SparseMatrix, number | BigNumber": e.referToSelf((d) => (y, w) => n(w, 0) ? y.clone() : l(y, w, d, !1)),
    "DenseMatrix, number | BigNumber": e.referToSelf((d) => (y, w) => n(w, 0) ? y.clone() : m(y, w, d, !1)),
    "number | BigNumber, SparseMatrix": e.referToSelf((d) => (y, w) => n(y, 0) ? i(w.size(), w.storage()) : c(w, y, d, !0)),
    "number | BigNumber, DenseMatrix": e.referToSelf((d) => (y, w) => n(y, 0) ? i(w.size(), w.storage()) : m(w, y, d, !0))
  }, g, h({
    SS: s,
    DS: f,
    SD: u
  }));
}), rx = "and", EO = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"], Ws = /* @__PURE__ */ H(rx, EO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    not: a,
    concat: o
  } = t, f = Mn({
    typed: e,
    equalScalar: n
  }), u = g0({
    typed: e,
    equalScalar: n
  }), s = Sr({
    typed: e,
    equalScalar: n
  }), c = _n({
    typed: e
  }), l = Ut({
    typed: e,
    matrix: r,
    concat: o
  });
  return e(rx, {
    "number, number": Xh,
    "Complex, Complex": function(h, g) {
      return (h.re !== 0 || h.im !== 0) && (g.re !== 0 || g.im !== 0);
    },
    "BigNumber, BigNumber": function(h, g) {
      return !h.isZero() && !g.isZero() && !h.isNaN() && !g.isNaN();
    },
    "bigint, bigint": Xh,
    "Unit, Unit": e.referToSelf((m) => (h, g) => m(h.value || 0, g.value || 0)),
    "SparseMatrix, any": e.referToSelf((m) => (h, g) => a(g) ? i(h.size(), h.storage()) : s(h, g, m, !1)),
    "DenseMatrix, any": e.referToSelf((m) => (h, g) => a(g) ? i(h.size(), h.storage()) : c(h, g, m, !1)),
    "any, SparseMatrix": e.referToSelf((m) => (h, g) => a(h) ? i(h.size(), h.storage()) : s(g, h, m, !0)),
    "any, DenseMatrix": e.referToSelf((m) => (h, g) => a(h) ? i(h.size(), h.storage()) : c(g, h, m, !0)),
    "Array, any": e.referToSelf((m) => (h, g) => m(r(h), g).valueOf()),
    "any, Array": e.referToSelf((m) => (h, g) => m(h, r(g)).valueOf())
  }, l({
    SS: u,
    DS: f
  }));
}), au = "compare", SO = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"], Il = /* @__PURE__ */ H(au, SO, (t) => {
  var {
    typed: e,
    config: r,
    equalScalar: n,
    matrix: i,
    BigNumber: a,
    Fraction: o,
    DenseMatrix: f,
    concat: u
  } = t, s = Ur({
    typed: e
  }), c = h0({
    typed: e,
    equalScalar: n
  }), l = cr({
    typed: e,
    DenseMatrix: f
  }), m = Ut({
    typed: e,
    matrix: i,
    concat: u
  }), h = $a({
    typed: e
  });
  return e(au, AO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": function(d, y) {
      return d === y ? 0 : d > y ? 1 : -1;
    },
    "BigNumber, BigNumber": function(d, y) {
      return Jr(d, y, r.relTol, r.absTol) ? new a(0) : new a(d.cmp(y));
    },
    "bigint, bigint": function(d, y) {
      return d === y ? 0n : d > y ? 1n : -1n;
    },
    "Fraction, Fraction": function(d, y) {
      return new o(d.compare(y));
    },
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, h, m({
    SS: c,
    DS: s,
    Ss: l
  }));
}), AO = /* @__PURE__ */ H(au, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(au, {
    "number, number": function(i, a) {
      return Er(i, a, r.relTol, r.absTol) ? 0 : i > a ? 1 : -1;
    }
  });
}), CO = function t(e, r) {
  var n = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, i = /(^[ ]*|[ ]*$)/g, a = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, o = /^0x[0-9a-f]+$/i, f = /^0/, u = function(x) {
    return t.insensitive && ("" + x).toLowerCase() || "" + x;
  }, s = u(e).replace(i, "") || "", c = u(r).replace(i, "") || "", l = s.replace(n, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), m = c.replace(n, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), h = parseInt(s.match(o), 16) || l.length !== 1 && s.match(a) && Date.parse(s), g = parseInt(c.match(o), 16) || h && c.match(a) && Date.parse(c) || null, d, y;
  if (g) {
    if (h < g)
      return -1;
    if (h > g)
      return 1;
  }
  for (var w = 0, E = Math.max(l.length, m.length); w < E; w++) {
    if (d = !(l[w] || "").match(f) && parseFloat(l[w]) || l[w] || 0, y = !(m[w] || "").match(f) && parseFloat(m[w]) || m[w] || 0, isNaN(d) !== isNaN(y))
      return isNaN(d) ? 1 : -1;
    if (typeof d != typeof y && (d += "", y += ""), d < y)
      return -1;
    if (d > y)
      return 1;
  }
  return 0;
};
const ba = /* @__PURE__ */ qs(CO);
var nx = "compareNatural", TO = ["typed", "compare"], Fl = /* @__PURE__ */ H(nx, TO, (t) => {
  var {
    typed: e,
    compare: r
  } = t, n = r.signatures["boolean,boolean"];
  return e(nx, {
    "any, any": i
  });
  function i(u, s) {
    var c = kt(u), l = kt(s), m;
    if ((c === "number" || c === "BigNumber" || c === "Fraction") && (l === "number" || l === "BigNumber" || l === "Fraction"))
      return m = r(u, s), m.toString() !== "0" ? m > 0 ? 1 : -1 : ba(c, l);
    var h = ["Array", "DenseMatrix", "SparseMatrix"];
    if (h.includes(c) || h.includes(l))
      return m = a(i, u, s), m !== 0 ? m : ba(c, l);
    if (c !== l)
      return ba(c, l);
    if (c === "Complex")
      return _O(u, s);
    if (c === "Unit")
      return u.equalBase(s) ? i(u.value, s.value) : o(i, u.formatUnits(), s.formatUnits());
    if (c === "boolean")
      return n(u, s);
    if (c === "string")
      return ba(u, s);
    if (c === "Object")
      return f(i, u, s);
    if (c === "null" || c === "undefined")
      return 0;
    throw new TypeError('Unsupported type of value "' + c + '"');
  }
  function a(u, s, c) {
    return jn(s) && jn(c) ? o(u, s.toJSON().values, c.toJSON().values) : jn(s) ? a(u, s.toArray(), c) : jn(c) ? a(u, s, c.toArray()) : Ca(s) ? a(u, s.toJSON().data, c) : Ca(c) ? a(u, s, c.toJSON().data) : Array.isArray(s) ? Array.isArray(c) ? o(u, s, c) : a(u, s, [c]) : a(u, [s], c);
  }
  function o(u, s, c) {
    for (var l = 0, m = Math.min(s.length, c.length); l < m; l++) {
      var h = u(s[l], c[l]);
      if (h !== 0)
        return h;
    }
    return s.length > c.length ? 1 : s.length < c.length ? -1 : 0;
  }
  function f(u, s, c) {
    var l = Object.keys(s), m = Object.keys(c);
    l.sort(ba), m.sort(ba);
    var h = o(u, l, m);
    if (h !== 0)
      return h;
    for (var g = 0; g < l.length; g++) {
      var d = u(s[l[g]], c[m[g]]);
      if (d !== 0)
        return d;
    }
    return 0;
  }
});
function _O(t, e) {
  return t.re > e.re ? 1 : t.re < e.re ? -1 : t.im > e.im ? 1 : t.im < e.im ? -1 : 0;
}
var ix = "compareText", MO = ["typed", "matrix", "concat"];
Wh.signature = "any, any";
var Bl = /* @__PURE__ */ H(ix, MO, (t) => {
  var {
    typed: e,
    matrix: r,
    concat: n
  } = t, i = Ut({
    typed: e,
    matrix: r,
    concat: n
  });
  return e(ix, Wh, i({
    elop: Wh,
    Ds: !0
  }));
}), su = "equal", OO = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Rl = /* @__PURE__ */ H(su, OO, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ur({
    typed: e
  }), f = Ln({
    typed: e,
    DenseMatrix: i
  }), u = cr({
    typed: e,
    DenseMatrix: i
  }), s = Ut({
    typed: e,
    matrix: r,
    concat: a
  });
  return e(su, qO({
    typed: e,
    equalScalar: n
  }), s({
    elop: n,
    SS: f,
    DS: o,
    Ss: u
  }));
}), qO = H(su, ["typed", "equalScalar"], (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return e(su, {
    "any, any": function(i, a) {
      return i === null ? a === null : a === null ? i === null : i === void 0 ? a === void 0 : a === void 0 ? i === void 0 : r(i, a);
    }
  });
}), ax = "equalText", IO = ["typed", "compareText", "isZero"], Pl = /* @__PURE__ */ H(ax, IO, (t) => {
  var {
    typed: e,
    compareText: r,
    isZero: n
  } = t;
  return e(ax, {
    "any, any": function(a, o) {
      return n(r(a, o));
    }
  });
}), ou = "smaller", FO = ["typed", "config", "matrix", "DenseMatrix", "concat"], Ll = /* @__PURE__ */ H(ou, FO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ur({
    typed: e
  }), f = Ln({
    typed: e,
    DenseMatrix: i
  }), u = cr({
    typed: e,
    DenseMatrix: i
  }), s = Ut({
    typed: e,
    matrix: n,
    concat: a
  }), c = $a({
    typed: e
  });
  return e(ou, BO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (l, m) => l < m,
    "BigNumber, BigNumber": function(m, h) {
      return m.lt(h) && !Jr(m, h, r.relTol, r.absTol);
    },
    "bigint, bigint": (l, m) => l < m,
    "Fraction, Fraction": (l, m) => l.compare(m) === -1,
    "Complex, Complex": function(m, h) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, c, s({
    SS: f,
    DS: o,
    Ss: u
  }));
}), BO = /* @__PURE__ */ H(ou, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(ou, {
    "number, number": function(i, a) {
      return i < a && !Er(i, a, r.relTol, r.absTol);
    }
  });
}), uu = "smallerEq", RO = ["typed", "config", "matrix", "DenseMatrix", "concat"], kl = /* @__PURE__ */ H(uu, RO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ur({
    typed: e
  }), f = Ln({
    typed: e,
    DenseMatrix: i
  }), u = cr({
    typed: e,
    DenseMatrix: i
  }), s = Ut({
    typed: e,
    matrix: n,
    concat: a
  }), c = $a({
    typed: e
  });
  return e(uu, PO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (l, m) => l <= m,
    "BigNumber, BigNumber": function(m, h) {
      return m.lte(h) || Jr(m, h, r.relTol, r.absTol);
    },
    "bigint, bigint": (l, m) => l <= m,
    "Fraction, Fraction": (l, m) => l.compare(m) !== 1,
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, c, s({
    SS: f,
    DS: o,
    Ss: u
  }));
}), PO = /* @__PURE__ */ H(uu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(uu, {
    "number, number": function(i, a) {
      return i <= a || Er(i, a, r.relTol, r.absTol);
    }
  });
}), lu = "larger", LO = ["typed", "config", "matrix", "DenseMatrix", "concat"], zl = /* @__PURE__ */ H(lu, LO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ur({
    typed: e
  }), f = Ln({
    typed: e,
    DenseMatrix: i
  }), u = cr({
    typed: e,
    DenseMatrix: i
  }), s = Ut({
    typed: e,
    matrix: n,
    concat: a
  }), c = $a({
    typed: e
  });
  return e(lu, kO({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (l, m) => l > m,
    "BigNumber, BigNumber": function(m, h) {
      return m.gt(h) && !Jr(m, h, r.relTol, r.absTol);
    },
    "bigint, bigint": (l, m) => l > m,
    "Fraction, Fraction": (l, m) => l.compare(m) === 1,
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, c, s({
    SS: f,
    DS: o,
    Ss: u
  }));
}), kO = /* @__PURE__ */ H(lu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(lu, {
    "number, number": function(i, a) {
      return i > a && !Er(i, a, r.relTol, r.absTol);
    }
  });
}), cu = "largerEq", zO = ["typed", "config", "matrix", "DenseMatrix", "concat"], $l = /* @__PURE__ */ H(cu, zO, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ur({
    typed: e
  }), f = Ln({
    typed: e,
    DenseMatrix: i
  }), u = cr({
    typed: e,
    DenseMatrix: i
  }), s = Ut({
    typed: e,
    matrix: n,
    concat: a
  }), c = $a({
    typed: e
  });
  return e(cu, $O({
    typed: e,
    config: r
  }), {
    "boolean, boolean": (l, m) => l >= m,
    "BigNumber, BigNumber": function(m, h) {
      return m.gte(h) || Jr(m, h, r.relTol, r.absTol);
    },
    "bigint, bigint": function(m, h) {
      return m >= h;
    },
    "Fraction, Fraction": (l, m) => l.compare(m) !== -1,
    "Complex, Complex": function() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, c, s({
    SS: f,
    DS: o,
    Ss: u
  }));
}), $O = /* @__PURE__ */ H(cu, ["typed", "config"], (t) => {
  var {
    typed: e,
    config: r
  } = t;
  return e(cu, {
    "number, number": function(i, a) {
      return i >= a || Er(i, a, r.relTol, r.absTol);
    }
  });
}), sx = "deepEqual", UO = ["typed", "equal"], Ul = /* @__PURE__ */ H(sx, UO, (t) => {
  var {
    typed: e,
    equal: r
  } = t;
  return e(sx, {
    "any, any": function(a, o) {
      return n(a.valueOf(), o.valueOf());
    }
  });
  function n(i, a) {
    if (Array.isArray(i))
      if (Array.isArray(a)) {
        var o = i.length;
        if (o !== a.length)
          return !1;
        for (var f = 0; f < o; f++)
          if (!n(i[f], a[f]))
            return !1;
        return !0;
      } else
        return !1;
    else
      return Array.isArray(a) ? !1 : r(i, a);
  }
}), fu = "unequal", GO = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"], Gl = /* @__PURE__ */ H(fu, GO, (t) => {
  var {
    typed: e,
    config: r,
    equalScalar: n,
    matrix: i,
    DenseMatrix: a,
    concat: o
  } = t, f = Ur({
    typed: e
  }), u = Ln({
    typed: e,
    DenseMatrix: a
  }), s = cr({
    typed: e,
    DenseMatrix: a
  }), c = Ut({
    typed: e,
    matrix: i,
    concat: o
  });
  return e(fu, HO({
    typed: e,
    equalScalar: n
  }), c({
    elop: l,
    SS: u,
    DS: f,
    Ss: s
  }));
  function l(m, h) {
    return !n(m, h);
  }
}), HO = H(fu, ["typed", "equalScalar"], (t) => {
  var {
    typed: e,
    equalScalar: r
  } = t;
  return e(fu, {
    "any, any": function(i, a) {
      return i === null ? a !== null : a === null ? i !== null : i === void 0 ? a !== void 0 : a === void 0 ? i !== void 0 : !r(i, a);
    }
  });
}), ox = "partitionSelect", QO = ["typed", "isNumeric", "isNaN", "compare"], Hl = /* @__PURE__ */ H(ox, QO, (t) => {
  var {
    typed: e,
    isNumeric: r,
    isNaN: n,
    compare: i
  } = t, a = i, o = (s, c) => -i(s, c);
  return e(ox, {
    "Array | Matrix, number": function(c, l) {
      return f(c, l, a);
    },
    "Array | Matrix, number, string": function(c, l, m) {
      if (m === "asc")
        return f(c, l, a);
      if (m === "desc")
        return f(c, l, o);
      throw new Error('Compare string must be "asc" or "desc"');
    },
    "Array | Matrix, number, function": f
  });
  function f(s, c, l) {
    if (!Ve(c) || c < 0)
      throw new Error("k must be a non-negative integer");
    if (Ye(s)) {
      var m = s.size();
      if (m.length > 1)
        throw new Error("Only one dimensional matrices supported");
      return u(s.valueOf(), c, l);
    }
    if (Array.isArray(s))
      return u(s, c, l);
  }
  function u(s, c, l) {
    if (c >= s.length)
      throw new Error("k out of bounds");
    for (var m = 0; m < s.length; m++)
      if (r(s[m]) && n(s[m]))
        return s[m];
    for (var h = 0, g = s.length - 1; h < g; ) {
      for (var d = h, y = g, w = s[Math.floor(Math.random() * (g - h + 1)) + h]; d < y; )
        if (l(s[d], w) >= 0) {
          var E = s[y];
          s[y] = s[d], s[d] = E, --y;
        } else
          ++d;
      l(s[d], w) > 0 && --d, c <= d ? g = d : h = d + 1;
    }
    return s[c];
  }
}), ux = "sort", VO = ["typed", "matrix", "compare", "compareNatural"], Ql = /* @__PURE__ */ H(ux, VO, (t) => {
  var {
    typed: e,
    matrix: r,
    compare: n,
    compareNatural: i
  } = t, a = n, o = (c, l) => -n(c, l);
  return e(ux, {
    Array: function(l) {
      return u(l), l.sort(a);
    },
    Matrix: function(l) {
      return s(l), r(l.toArray().sort(a), l.storage());
    },
    "Array, function": function(l, m) {
      return u(l), l.sort(m);
    },
    "Matrix, function": function(l, m) {
      return s(l), r(l.toArray().sort(m), l.storage());
    },
    "Array, string": function(l, m) {
      return u(l), l.sort(f(m));
    },
    "Matrix, string": function(l, m) {
      return s(l), r(l.toArray().sort(f(m)), l.storage());
    }
  });
  function f(c) {
    if (c === "asc")
      return a;
    if (c === "desc")
      return o;
    if (c === "natural")
      return i;
    throw new Error('String "asc", "desc", or "natural" expected');
  }
  function u(c) {
    if (ft(c).length !== 1)
      throw new Error("One dimensional array expected");
  }
  function s(c) {
    if (c.size().length !== 1)
      throw new Error("One dimensional matrix expected");
  }
}), lx = "max", WO = ["typed", "config", "numeric", "larger"], js = /* @__PURE__ */ H(lx, WO, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    larger: i
  } = t;
  return e(lx, {
    // max([a, b, c, d, ...])
    "Array | Matrix": o,
    // max([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(u, s) {
      return Fu(u, s.valueOf(), a);
    },
    // max(a, b, c, d, ...)
    "...": function(u) {
      if (La(u))
        throw new TypeError("Scalar values expected in function max");
      return o(u);
    }
  });
  function a(f, u) {
    try {
      return i(f, u) ? f : u;
    } catch (s) {
      throw $r(s, "max", u);
    }
  }
  function o(f) {
    var u;
    if (ei(f, function(s) {
      try {
        isNaN(s) && typeof s == "number" ? u = NaN : (u === void 0 || i(s, u)) && (u = s);
      } catch (c) {
        throw $r(c, "max", s);
      }
    }), u === void 0)
      throw new Error("Cannot calculate max of an empty array");
    return typeof u == "string" && (u = n(u, wi(u, r))), u;
  }
}), cx = "min", jO = ["typed", "config", "numeric", "smaller"], Ys = /* @__PURE__ */ H(cx, jO, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    smaller: i
  } = t;
  return e(cx, {
    // min([a, b, c, d, ...])
    "Array | Matrix": o,
    // min([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(u, s) {
      return Fu(u, s.valueOf(), a);
    },
    // min(a, b, c, d, ...)
    "...": function(u) {
      if (La(u))
        throw new TypeError("Scalar values expected in function min");
      return o(u);
    }
  });
  function a(f, u) {
    try {
      return i(f, u) ? f : u;
    } catch (s) {
      throw $r(s, "min", u);
    }
  }
  function o(f) {
    var u;
    if (ei(f, function(s) {
      try {
        isNaN(s) && typeof s == "number" ? u = NaN : (u === void 0 || i(s, u)) && (u = s);
      } catch (c) {
        throw $r(c, "min", s);
      }
    }), u === void 0)
      throw new Error("Cannot calculate min of an empty array");
    return typeof u == "string" && (u = n(u, wi(u, r))), u;
  }
}), YO = "ImmutableDenseMatrix", ZO = ["smaller", "DenseMatrix"], Vl = /* @__PURE__ */ H(YO, ZO, (t) => {
  var {
    smaller: e,
    DenseMatrix: r
  } = t;
  function n(i, a) {
    if (!(this instanceof n))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (a && !hr(a))
      throw new Error("Invalid datatype: " + a);
    if (Ye(i) || _t(i)) {
      var o = new r(i, a);
      this._data = o._data, this._size = o._size, this._datatype = o._datatype, this._min = null, this._max = null;
    } else if (i && _t(i.data) && _t(i.size))
      this._data = i.data, this._size = i.size, this._datatype = i.datatype, this._min = typeof i.min < "u" ? i.min : null, this._max = typeof i.max < "u" ? i.max : null;
    else {
      if (i)
        throw new TypeError("Unsupported type of data (" + kt(i) + ")");
      this._data = [], this._size = [0], this._datatype = a, this._min = null, this._max = null;
    }
  }
  return n.prototype = new r(), n.prototype.type = "ImmutableDenseMatrix", n.prototype.isImmutableDenseMatrix = !0, n.prototype.subset = function(i) {
    switch (arguments.length) {
      case 1: {
        var a = r.prototype.subset.call(this, i);
        return Ye(a) ? new n({
          data: a._data,
          size: a._size,
          datatype: a._datatype
        }) : a;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  }, n.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  }, n.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  }, n.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  }, n.prototype.clone = function() {
    return new n({
      data: Je(this._data),
      size: Je(this._size),
      datatype: this._datatype
    });
  }, n.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  }, n.fromJSON = function(i) {
    return new n(i);
  }, n.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  }, n.prototype.min = function() {
    if (this._min === null) {
      var i = null;
      this.forEach(function(a) {
        (i === null || e(a, i)) && (i = a);
      }), this._min = i !== null ? i : void 0;
    }
    return this._min;
  }, n.prototype.max = function() {
    if (this._max === null) {
      var i = null;
      this.forEach(function(a) {
        (i === null || e(i, a)) && (i = a);
      }), this._max = i !== null ? i : void 0;
    }
    return this._max;
  }, n;
}, {
  isClass: !0
}), JO = "Index", XO = ["ImmutableDenseMatrix", "getMatrixDataType"], Wl = /* @__PURE__ */ H(JO, XO, (t) => {
  var {
    ImmutableDenseMatrix: e,
    getMatrixDataType: r
  } = t;
  function n(a) {
    if (!(this instanceof n))
      throw new SyntaxError("Constructor must be called with the new operator");
    this._dimensions = [], this._sourceSize = [], this._isScalar = !0;
    for (var o = 0, f = arguments.length; o < f; o++) {
      var u = arguments[o], s = _t(u), c = Ye(u), l = null;
      if (Ms(u))
        this._dimensions.push(u), this._isScalar = !1;
      else if (s || c) {
        var m = void 0;
        r(u) === "boolean" ? (s && (m = i(fx(u).valueOf())), c && (m = i(fx(u._data).valueOf())), l = u.valueOf().length) : m = i(u.valueOf()), this._dimensions.push(m);
        var h = m.size();
        (h.length !== 1 || h[0] !== 1 || l !== null) && (this._isScalar = !1);
      } else if (typeof u == "number")
        this._dimensions.push(i([u]));
      else if (typeof u == "string")
        this._dimensions.push(u);
      else
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      this._sourceSize.push(l);
    }
  }
  n.prototype.type = "Index", n.prototype.isIndex = !0;
  function i(a) {
    for (var o = 0, f = a.length; o < f; o++)
      if (typeof a[o] != "number" || !Ve(a[o]))
        throw new TypeError("Index parameters must be positive integer numbers");
    return new e(a);
  }
  return n.prototype.clone = function() {
    var a = new n();
    return a._dimensions = Je(this._dimensions), a._isScalar = this._isScalar, a._sourceSize = this._sourceSize, a;
  }, n.create = function(a) {
    var o = new n();
    return n.apply(o, a), o;
  }, n.prototype.size = function() {
    for (var a = [], o = 0, f = this._dimensions.length; o < f; o++) {
      var u = this._dimensions[o];
      a[o] = typeof u == "string" ? 1 : u.size()[0];
    }
    return a;
  }, n.prototype.max = function() {
    for (var a = [], o = 0, f = this._dimensions.length; o < f; o++) {
      var u = this._dimensions[o];
      a[o] = typeof u == "string" ? u : u.max();
    }
    return a;
  }, n.prototype.min = function() {
    for (var a = [], o = 0, f = this._dimensions.length; o < f; o++) {
      var u = this._dimensions[o];
      a[o] = typeof u == "string" ? u : u.min();
    }
    return a;
  }, n.prototype.forEach = function(a) {
    for (var o = 0, f = this._dimensions.length; o < f; o++)
      a(this._dimensions[o], o, this);
  }, n.prototype.dimension = function(a) {
    return this._dimensions[a] || null;
  }, n.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] == "string";
  }, n.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  }, n.prototype.isScalar = function() {
    return this._isScalar;
  }, n.prototype.toArray = function() {
    for (var a = [], o = 0, f = this._dimensions.length; o < f; o++) {
      var u = this._dimensions[o];
      a.push(typeof u == "string" ? u : u.toArray());
    }
    return a;
  }, n.prototype.valueOf = n.prototype.toArray, n.prototype.toString = function() {
    for (var a = [], o = 0, f = this._dimensions.length; o < f; o++) {
      var u = this._dimensions[o];
      typeof u == "string" ? a.push(JSON.stringify(u)) : a.push(u.toString());
    }
    return "[" + a.join(", ") + "]";
  }, n.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  }, n.fromJSON = function(a) {
    return n.create(a.dimensions);
  }, n;
}, {
  isClass: !0
});
function fx(t) {
  var e = [];
  return t.forEach((r, n) => {
    r && e.push(n);
  }), e;
}
var KO = "FibonacciHeap", eq = ["smaller", "larger"], jl = /* @__PURE__ */ H(KO, eq, (t) => {
  var {
    smaller: e,
    larger: r
  } = t, n = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function i() {
    if (!(this instanceof i))
      throw new SyntaxError("Constructor must be called with the new operator");
    this._minimum = null, this._size = 0;
  }
  i.prototype.type = "FibonacciHeap", i.prototype.isFibonacciHeap = !0, i.prototype.insert = function(c, l) {
    var m = {
      key: c,
      value: l,
      degree: 0
    };
    if (this._minimum) {
      var h = this._minimum;
      m.left = h, m.right = h.right, h.right = m, m.right.left = m, e(c, h.key) && (this._minimum = m);
    } else
      m.left = m, m.right = m, this._minimum = m;
    return this._size++, m;
  }, i.prototype.size = function() {
    return this._size;
  }, i.prototype.clear = function() {
    this._minimum = null, this._size = 0;
  }, i.prototype.isEmpty = function() {
    return this._size === 0;
  }, i.prototype.extractMinimum = function() {
    var c = this._minimum;
    if (c === null)
      return c;
    for (var l = this._minimum, m = c.degree, h = c.child; m > 0; ) {
      var g = h.right;
      h.left.right = h.right, h.right.left = h.left, h.left = l, h.right = l.right, l.right = h, h.right.left = h, h.parent = null, h = g, m--;
    }
    return c.left.right = c.right, c.right.left = c.left, c === c.right ? l = null : (l = c.right, l = s(l, this._size)), this._size--, this._minimum = l, c;
  }, i.prototype.remove = function(c) {
    this._minimum = a(this._minimum, c, -1), this.extractMinimum();
  };
  function a(c, l, m) {
    l.key = m;
    var h = l.parent;
    return h && e(l.key, h.key) && (o(c, l, h), f(c, h)), e(l.key, c.key) && (c = l), c;
  }
  function o(c, l, m) {
    l.left.right = l.right, l.right.left = l.left, m.degree--, m.child === l && (m.child = l.right), m.degree === 0 && (m.child = null), l.left = c, l.right = c.right, c.right = l, l.right.left = l, l.parent = null, l.mark = !1;
  }
  function f(c, l) {
    var m = l.parent;
    m && (l.mark ? (o(c, l, m), f(m)) : l.mark = !0);
  }
  var u = function(l, m) {
    l.left.right = l.right, l.right.left = l.left, l.parent = m, m.child ? (l.left = m.child, l.right = m.child.right, m.child.right = l, l.right.left = l) : (m.child = l, l.right = l, l.left = l), m.degree++, l.mark = !1;
  };
  function s(c, l) {
    var m = Math.floor(Math.log(l) * n) + 1, h = new Array(m), g = 0, d = c;
    if (d)
      for (g++, d = d.right; d !== c; )
        g++, d = d.right;
    for (var y; g > 0; ) {
      for (var w = d.degree, E = d.right; y = h[w], !!y; ) {
        if (r(d.key, y.key)) {
          var x = y;
          y = d, d = x;
        }
        u(y, d), h[w] = null, w++;
      }
      h[w] = d, d = E, g--;
    }
    c = null;
    for (var N = 0; N < m; N++)
      y = h[N], y && (c ? (y.left.right = y.right, y.right.left = y.left, y.left = c, y.right = c.right, c.right = y, y.right.left = y, e(y.key, c.key) && (c = y)) : c = y);
    return c;
  }
  return i;
}, {
  isClass: !0
}), tq = "Spa", rq = ["addScalar", "equalScalar", "FibonacciHeap"], Yl = /* @__PURE__ */ H(tq, rq, (t) => {
  var {
    addScalar: e,
    equalScalar: r,
    FibonacciHeap: n
  } = t;
  function i() {
    if (!(this instanceof i))
      throw new SyntaxError("Constructor must be called with the new operator");
    this._values = [], this._heap = new n();
  }
  return i.prototype.type = "Spa", i.prototype.isSpa = !0, i.prototype.set = function(a, o) {
    if (this._values[a])
      this._values[a].value = o;
    else {
      var f = this._heap.insert(a, o);
      this._values[a] = f;
    }
  }, i.prototype.get = function(a) {
    var o = this._values[a];
    return o ? o.value : 0;
  }, i.prototype.accumulate = function(a, o) {
    var f = this._values[a];
    f ? f.value = e(f.value, o) : (f = this._heap.insert(a, o), this._values[a] = f);
  }, i.prototype.forEach = function(a, o, f) {
    var u = this._heap, s = this._values, c = [], l = u.extractMinimum();
    for (l && c.push(l); l && l.key <= o; )
      l.key >= a && (r(l.value, 0) || f(l.key, l.value, this)), l = u.extractMinimum(), l && c.push(l);
    for (var m = 0; m < c.length; m++) {
      var h = c[m];
      l = u.insert(h.key, h.value), s[l.key] = l;
    }
  }, i.prototype.swap = function(a, o) {
    var f = this._values[a], u = this._values[o];
    if (!f && u)
      f = this._heap.insert(a, u.value), this._heap.remove(u), this._values[a] = f, this._values[o] = void 0;
    else if (f && !u)
      u = this._heap.insert(o, f.value), this._heap.remove(f), this._values[o] = u, this._values[a] = void 0;
    else if (f && u) {
      var s = f.value;
      f.value = u.value, u.value = s;
    }
  }, i;
}, {
  isClass: !0
}), nq = Is(function(t) {
  return new t(1).exp();
}, {
  hasher: Zl
}), iq = Is(function(t) {
  return new t(1).plus(new t(5).sqrt()).div(2);
}, {
  hasher: Zl
}), Id = Is(function(t) {
  return t.acos(-1);
}, {
  hasher: Zl
}), aq = Is(function(t) {
  return Id(t).times(2);
}, {
  hasher: Zl
});
function Zl(t) {
  return t[0].precision;
}
function px(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Fh(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? px(Object(r), !0).forEach(function(n) {
      lr(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : px(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var sq = "Unit", oq = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"], Jl = /* @__PURE__ */ H(sq, oq, (t) => {
  var {
    on: e,
    config: r,
    addScalar: n,
    subtractScalar: i,
    multiplyScalar: a,
    divideScalar: o,
    pow: f,
    abs: u,
    fix: s,
    round: c,
    equal: l,
    isNumeric: m,
    format: h,
    number: g,
    Complex: d,
    BigNumber: y,
    Fraction: w
  } = t, E = g;
  function x(V, J) {
    if (!(this instanceof x))
      throw new Error("Constructor must be called with the new operator");
    if (!(V == null || m(V) || dn(V)))
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    if (this.fixPrefix = !1, this.skipAutomaticSimplification = !0, J === void 0)
      this.units = [], this.dimensions = $.map((K) => 0);
    else if (typeof J == "string") {
      var ye = x.parse(J);
      this.units = ye.units, this.dimensions = ye.dimensions;
    } else if (Lr(J) && J.value === null)
      this.fixPrefix = J.fixPrefix, this.skipAutomaticSimplification = J.skipAutomaticSimplification, this.dimensions = J.dimensions.slice(0), this.units = J.units.map((K) => nr({}, K));
    else
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    this.value = this._normalize(V);
  }
  Object.defineProperty(x, "name", {
    value: "Unit"
  }), x.prototype.constructor = x, x.prototype.type = "Unit", x.prototype.isUnit = !0;
  var N, D, b;
  function C() {
    for (; b === " " || b === "	"; )
      _();
  }
  function A(V) {
    return V >= "0" && V <= "9" || V === ".";
  }
  function T(V) {
    return V >= "0" && V <= "9";
  }
  function _() {
    D++, b = N.charAt(D);
  }
  function O(V) {
    D = V, b = N.charAt(D);
  }
  function I() {
    var V = "", J = D;
    if (b === "+" ? _() : b === "-" && (V += b, _()), !A(b))
      return O(J), null;
    if (b === ".") {
      if (V += b, _(), !T(b))
        return O(J), null;
    } else {
      for (; T(b); )
        V += b, _();
      b === "." && (V += b, _());
    }
    for (; T(b); )
      V += b, _();
    if (b === "E" || b === "e") {
      var ye = "", K = D;
      if (ye += b, _(), (b === "+" || b === "-") && (ye += b, _()), !T(b))
        return O(K), V;
      for (V = V + ye; T(b); )
        V += b, _();
    }
    return V;
  }
  function B() {
    for (var V = ""; T(b) || x.isValidAlpha(b); )
      V += b, _();
    var J = V.charAt(0);
    return x.isValidAlpha(J) ? V : null;
  }
  function k(V) {
    return b === V ? (_(), V) : null;
  }
  x.parse = function(V, J) {
    if (J = J || {}, N = V, D = -1, b = "", typeof N != "string")
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    var ye = new x();
    ye.units = [];
    var K = 1, ae = !1;
    _(), C();
    var de = I(), xe = null;
    if (de) {
      if (r.number === "BigNumber")
        xe = new y(de);
      else if (r.number === "Fraction")
        try {
          xe = new w(de);
        } catch {
          xe = parseFloat(de);
        }
      else
        xe = parseFloat(de);
      C(), k("*") ? (K = 1, ae = !0) : k("/") && (K = -1, ae = !0);
    }
    for (var Ce = [], G = 1; ; ) {
      for (C(); b === "("; )
        Ce.push(K), G *= K, K = 1, _(), C();
      var Z = void 0;
      if (b) {
        var ge = b;
        if (Z = B(), Z === null)
          throw new SyntaxError('Unexpected "' + ge + '" in "' + N + '" at index ' + D.toString());
      } else
        break;
      var be = L(Z);
      if (be === null)
        throw new SyntaxError('Unit "' + Z + '" not found.');
      var Se = K * G;
      if (C(), k("^")) {
        C();
        var De = I();
        if (De === null)
          throw new SyntaxError('In "' + V + '", "^" must be followed by a floating-point number');
        Se *= De;
      }
      ye.units.push({
        unit: be.unit,
        prefix: be.prefix,
        power: Se
      });
      for (var Me = 0; Me < $.length; Me++)
        ye.dimensions[Me] += (be.unit.dimensions[Me] || 0) * Se;
      for (C(); b === ")"; ) {
        if (Ce.length === 0)
          throw new SyntaxError('Unmatched ")" in "' + N + '" at index ' + D.toString());
        G /= Ce.pop(), _(), C();
      }
      if (ae = !1, k("*") ? (K = 1, ae = !0) : k("/") ? (K = -1, ae = !0) : K = 1, be.unit.base) {
        var Oe = be.unit.base.key;
        te.auto[Oe] = {
          unit: be.unit,
          prefix: be.prefix
        };
      }
    }
    if (C(), b)
      throw new SyntaxError('Could not parse: "' + V + '"');
    if (ae)
      throw new SyntaxError('Trailing characters: "' + V + '"');
    if (Ce.length !== 0)
      throw new SyntaxError('Unmatched "(" in "' + N + '"');
    if (ye.units.length === 0 && !J.allowNoUnits)
      throw new SyntaxError('"' + V + '" contains no units');
    return ye.value = xe !== void 0 ? ye._normalize(xe) : null, ye;
  }, x.prototype.clone = function() {
    var V = new x();
    V.fixPrefix = this.fixPrefix, V.skipAutomaticSimplification = this.skipAutomaticSimplification, V.value = Je(this.value), V.dimensions = this.dimensions.slice(0), V.units = [];
    for (var J = 0; J < this.units.length; J++) {
      V.units[J] = {};
      for (var ye in this.units[J])
        $e(this.units[J], ye) && (V.units[J][ye] = this.units[J][ye]);
    }
    return V;
  }, x.prototype.valueType = function() {
    return kt(this.value);
  }, x.prototype._isDerived = function() {
    return this.units.length === 0 ? !1 : this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  }, x.prototype._normalize = function(V) {
    if (V == null || this.units.length === 0)
      return V;
    for (var J = V, ye = x._getNumberConverter(kt(V)), K = 0; K < this.units.length; K++) {
      var ae = ye(this.units[K].unit.value), de = ye(this.units[K].prefix.value), xe = ye(this.units[K].power);
      J = a(J, f(a(ae, de), xe));
    }
    return J;
  }, x.prototype._denormalize = function(V, J) {
    if (V == null || this.units.length === 0)
      return V;
    for (var ye = V, K = x._getNumberConverter(kt(V)), ae = 0; ae < this.units.length; ae++) {
      var de = K(this.units[ae].unit.value), xe = K(this.units[ae].prefix.value), Ce = K(this.units[ae].power);
      ye = o(ye, f(a(de, xe), Ce));
    }
    return ye;
  };
  var L = Is((V) => {
    if ($e(U, V)) {
      var J = U[V], ye = J.prefixes[""];
      return {
        unit: J,
        prefix: ye
      };
    }
    for (var K in U)
      if ($e(U, K) && OT(V, K)) {
        var ae = U[K], de = V.length - K.length, xe = V.substring(0, de), Ce = $e(ae.prefixes, xe) ? ae.prefixes[xe] : void 0;
        if (Ce !== void 0)
          return {
            unit: ae,
            prefix: Ce
          };
      }
    return null;
  }, {
    hasher: (V) => V[0],
    limit: 100
  });
  x.isValuelessUnit = function(V) {
    return L(V) !== null;
  }, x.prototype.hasBase = function(V) {
    if (typeof V == "string" && (V = R[V]), !V)
      return !1;
    for (var J = 0; J < $.length; J++)
      if (Math.abs((this.dimensions[J] || 0) - (V.dimensions[J] || 0)) > 1e-12)
        return !1;
    return !0;
  }, x.prototype.equalBase = function(V) {
    for (var J = 0; J < $.length; J++)
      if (Math.abs((this.dimensions[J] || 0) - (V.dimensions[J] || 0)) > 1e-12)
        return !1;
    return !0;
  }, x.prototype.equals = function(V) {
    return this.equalBase(V) && l(this.value, V.value);
  }, x.prototype.multiply = function(V) {
    for (var J = this.clone(), ye = Lr(V) ? V : new x(V), K = 0; K < $.length; K++)
      J.dimensions[K] = (this.dimensions[K] || 0) + (ye.dimensions[K] || 0);
    for (var ae = 0; ae < ye.units.length; ae++) {
      var de = Fh({}, ye.units[ae]);
      J.units.push(de);
    }
    if (this.value !== null || ye.value !== null) {
      var xe = this.value === null ? this._normalize(1) : this.value, Ce = ye.value === null ? ye._normalize(1) : ye.value;
      J.value = a(xe, Ce);
    } else
      J.value = null;
    return Lr(V) && (J.skipAutomaticSimplification = !1), F(J);
  }, x.prototype.divideInto = function(V) {
    return new x(V).divide(this);
  }, x.prototype.divide = function(V) {
    for (var J = this.clone(), ye = Lr(V) ? V : new x(V), K = 0; K < $.length; K++)
      J.dimensions[K] = (this.dimensions[K] || 0) - (ye.dimensions[K] || 0);
    for (var ae = 0; ae < ye.units.length; ae++) {
      var de = Fh(Fh({}, ye.units[ae]), {}, {
        power: -ye.units[ae].power
      });
      J.units.push(de);
    }
    if (this.value !== null || ye.value !== null) {
      var xe = this.value === null ? this._normalize(1) : this.value, Ce = ye.value === null ? ye._normalize(1) : ye.value;
      J.value = o(xe, Ce);
    } else
      J.value = null;
    return Lr(V) && (J.skipAutomaticSimplification = !1), F(J);
  }, x.prototype.pow = function(V) {
    for (var J = this.clone(), ye = 0; ye < $.length; ye++)
      J.dimensions[ye] = (this.dimensions[ye] || 0) * V;
    for (var K = 0; K < J.units.length; K++)
      J.units[K].power *= V;
    return J.value !== null ? J.value = f(J.value, V) : J.value = null, J.skipAutomaticSimplification = !1, F(J);
  };
  function F(V) {
    return V.equalBase(R.NONE) && V.value !== null && !r.predictable ? V.value : V;
  }
  x.prototype.abs = function() {
    var V = this.clone();
    if (V.value !== null)
      if (V._isDerived() || V.units.length === 0 || V.units[0].unit.offset === 0)
        V.value = u(V.value);
      else {
        var J = V._numberConverter(), ye = J(V.units[0].unit.value), K = J(V.units[0].unit.offset), ae = a(ye, K);
        V.value = i(u(n(V.value, ae)), ae);
      }
    for (var de in V.units)
      (V.units[de].unit.name === "VA" || V.units[de].unit.name === "VAR") && (V.units[de].unit = U.W);
    return V;
  }, x.prototype.to = function(V) {
    var J = this.value === null ? this._normalize(1) : this.value, ye;
    if (typeof V == "string")
      ye = x.parse(V);
    else if (Lr(V))
      ye = V.clone();
    else
      throw new Error("String or Unit expected as parameter");
    if (!this.equalBase(ye))
      throw new Error("Units do not match ('".concat(ye.toString(), "' != '").concat(this.toString(), "')"));
    if (ye.value !== null)
      throw new Error("Cannot convert to a unit with a value");
    if (this.value === null || this._isDerived() || this.units.length === 0 || ye.units.length === 0 || this.units[0].unit.offset === ye.units[0].unit.offset)
      ye.value = Je(J);
    else {
      var K = x._getNumberConverter(kt(J)), ae = this.units[0].unit.value, de = this.units[0].unit.offset, xe = a(ae, de), Ce = ye.units[0].unit.value, G = ye.units[0].unit.offset, Z = a(Ce, G);
      ye.value = n(J, K(i(xe, Z)));
    }
    return ye.fixPrefix = !0, ye.skipAutomaticSimplification = !0, ye;
  }, x.prototype.toNumber = function(V) {
    return E(this.toNumeric(V));
  }, x.prototype.toNumeric = function(V) {
    var J;
    return V ? J = this.to(V) : J = this.clone(), J._isDerived() || J.units.length === 0 ? J._denormalize(J.value) : J._denormalize(J.value, J.units[0].prefix.value);
  }, x.prototype.toString = function() {
    return this.format();
  }, x.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.units.length > 0 ? this.formatUnits() : null,
      fixPrefix: this.fixPrefix
    };
  }, x.fromJSON = function(V) {
    var J, ye = new x(V.value, (J = V.unit) !== null && J !== void 0 ? J : void 0);
    return ye.fixPrefix = V.fixPrefix || !1, ye;
  }, x.prototype.valueOf = x.prototype.toString, x.prototype.simplify = function() {
    var V = this.clone(), J = [], ye;
    for (var K in ue)
      if ($e(ue, K) && V.hasBase(R[K])) {
        ye = K;
        break;
      }
    if (ye === "NONE")
      V.units = [];
    else {
      var ae;
      if (ye && $e(ue, ye) && (ae = ue[ye]), ae)
        V.units = [{
          unit: ae.unit,
          prefix: ae.prefix,
          power: 1
        }];
      else {
        for (var de = !1, xe = 0; xe < $.length; xe++) {
          var Ce = $[xe];
          Math.abs(V.dimensions[xe] || 0) > 1e-12 && ($e(ue, Ce) ? J.push({
            unit: ue[Ce].unit,
            prefix: ue[Ce].prefix,
            power: V.dimensions[xe] || 0
          }) : de = !0);
        }
        J.length < V.units.length && !de && (V.units = J);
      }
    }
    return V;
  }, x.prototype.toSI = function() {
    for (var V = this.clone(), J = [], ye = 0; ye < $.length; ye++) {
      var K = $[ye];
      if (Math.abs(V.dimensions[ye] || 0) > 1e-12)
        if ($e(te.si, K))
          J.push({
            unit: te.si[K].unit,
            prefix: te.si[K].prefix,
            power: V.dimensions[ye] || 0
          });
        else
          throw new Error("Cannot express custom unit " + K + " in SI units");
    }
    return V.units = J, V.fixPrefix = !0, V.skipAutomaticSimplification = !0, this.value !== null ? (V.value = null, this.to(V)) : V;
  }, x.prototype.formatUnits = function() {
    for (var V = "", J = "", ye = 0, K = 0, ae = 0; ae < this.units.length; ae++)
      this.units[ae].power > 0 ? (ye++, V += " " + this.units[ae].prefix.name + this.units[ae].unit.name, Math.abs(this.units[ae].power - 1) > 1e-15 && (V += "^" + this.units[ae].power)) : this.units[ae].power < 0 && K++;
    if (K > 0)
      for (var de = 0; de < this.units.length; de++)
        this.units[de].power < 0 && (ye > 0 ? (J += " " + this.units[de].prefix.name + this.units[de].unit.name, Math.abs(this.units[de].power + 1) > 1e-15 && (J += "^" + -this.units[de].power)) : (J += " " + this.units[de].prefix.name + this.units[de].unit.name, J += "^" + this.units[de].power));
    V = V.substr(1), J = J.substr(1), ye > 1 && K > 0 && (V = "(" + V + ")"), K > 1 && ye > 0 && (J = "(" + J + ")");
    var xe = V;
    return ye > 0 && K > 0 && (xe += " / "), xe += J, xe;
  }, x.prototype.format = function(V) {
    var J = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify(), ye = !1;
    typeof J.value < "u" && J.value !== null && dn(J.value) && (ye = Math.abs(J.value.re) < 1e-14);
    for (var K in J.units)
      $e(J.units, K) && J.units[K].unit && (J.units[K].unit.name === "VA" && ye ? J.units[K].unit = U.VAR : J.units[K].unit.name === "VAR" && !ye && (J.units[K].unit = U.VA));
    J.units.length === 1 && !J.fixPrefix && Math.abs(J.units[0].power - Math.round(J.units[0].power)) < 1e-14 && (J.units[0].prefix = J._bestPrefix());
    var ae = J._denormalize(J.value), de = J.value !== null ? h(ae, V || {}) : "", xe = J.formatUnits();
    return J.value && dn(J.value) && (de = "(" + de + ")"), xe.length > 0 && de.length > 0 && (de += " "), de += xe, de;
  }, x.prototype._bestPrefix = function() {
    if (this.units.length !== 1)
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14)
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    var V = this.value !== null ? u(this.value) : 0, J = u(this.units[0].unit.value), ye = this.units[0].prefix;
    if (V === 0)
      return ye;
    var K = this.units[0].power, ae = Math.log(V / Math.pow(ye.value * J, K)) / Math.LN10 - 1.2;
    if (ae > -2.200001 && ae < 1.800001) return ye;
    ae = Math.abs(ae);
    var de = this.units[0].unit.prefixes;
    for (var xe in de)
      if ($e(de, xe)) {
        var Ce = de[xe];
        if (Ce.scientific) {
          var G = Math.abs(Math.log(V / Math.pow(Ce.value * J, K)) / Math.LN10 - 1.2);
          (G < ae || G === ae && Ce.name.length < ye.name.length) && (ye = Ce, ae = G);
        }
      }
    return ye;
  }, x.prototype.splitUnit = function(V) {
    for (var J = this.clone(), ye = [], K = 0; K < V.length && (J = J.to(V[K]), K !== V.length - 1); K++) {
      var ae = J.toNumeric(), de = c(ae), xe = void 0, Ce = l(de, ae);
      Ce ? xe = de : xe = s(J.toNumeric());
      var G = new x(xe, V[K].toString());
      ye.push(G), J = i(J, G);
    }
    for (var Z = 0, ge = 0; ge < ye.length; ge++)
      Z = n(Z, ye[ge].value);
    return l(Z, this.value) && (J.value = 0), ye.push(J), ye;
  };
  var M = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      da: {
        name: "da",
        value: 10,
        scientific: !1
      },
      h: {
        name: "h",
        value: 100,
        scientific: !1
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: !0
      },
      R: {
        name: "R",
        value: 1e27,
        scientific: !0
      },
      Q: {
        name: "Q",
        value: 1e30,
        scientific: !0
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: !1
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: !1
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: !0
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: !0
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: !0
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: !0
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: !0
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: !0
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: !0
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: !0
      },
      r: {
        name: "r",
        value: 1e-27,
        scientific: !0
      },
      q: {
        name: "q",
        value: 1e-30,
        scientific: !0
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: !1
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: !1
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: !0
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: !0
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: !0
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: !0
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: !0
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: !0
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: !0
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: !0
      },
      ronna: {
        name: "ronna",
        value: 1e27,
        scientific: !0
      },
      quetta: {
        name: "quetta",
        value: 1e30,
        scientific: !0
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: !1
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: !1
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: !0
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: !0
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: !0
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: !0
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: !0
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: !0
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: !0
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: !0
      },
      ronto: {
        name: "ronto",
        value: 1e-27,
        scientific: !0
      },
      quecto: {
        name: "quecto",
        value: 1e-30,
        scientific: !0
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      da: {
        name: "da",
        value: 100,
        scientific: !1
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: !1
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: !0
      },
      R: {
        name: "R",
        value: 1e54,
        scientific: !0
      },
      Q: {
        name: "Q",
        value: 1e60,
        scientific: !0
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: !1
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: !1
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: !0
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: !0
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: !0
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: !0
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: !0
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: !0
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: !0
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: !0
      },
      r: {
        name: "r",
        value: 1e-54,
        scientific: !0
      },
      q: {
        name: "q",
        value: 1e-60,
        scientific: !0
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: !1
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: !1
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: !0
      },
      R: {
        name: "R",
        value: 1e81,
        scientific: !0
      },
      Q: {
        name: "Q",
        value: 1e90,
        scientific: !0
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: !1
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: !1
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: !0
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: !0
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: !0
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: !0
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: !0
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: !0
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: !0
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: !0
      },
      r: {
        name: "r",
        value: 1e-81,
        scientific: !0
      },
      q: {
        name: "q",
        value: 1e-90,
        scientific: !0
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: !0
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: !0
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: !0
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: !0
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: !0
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: !0
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: !0
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: !0
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: !0
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: !0
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: !0
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: !0
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: !0
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: !0
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: !0
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: !0
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: !0
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: !0
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: !0
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: !0
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: !0
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: !0
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: !0
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: !0
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: !0
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: !0
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: !0
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: !0
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: !0
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: !0
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: !0
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: !0
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: !0
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: !0
      }
    }
  };
  M.SHORTLONG = nr({}, M.SHORT, M.LONG), M.BINARY_SHORT = nr({}, M.BINARY_SHORT_SI, M.BINARY_SHORT_IEC), M.BINARY_LONG = nr({}, M.BINARY_LONG_SI, M.BINARY_LONG_IEC);
  var $ = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"], R = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var Q in R)
    $e(R, Q) && (R[Q].key = Q);
  var ee = {}, j = {
    name: "",
    base: ee,
    value: 1,
    offset: 0,
    dimensions: $.map((V) => 0)
  }, U = {
    // length
    meter: {
      name: "meter",
      base: R.LENGTH,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: R.LENGTH,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: R.LENGTH,
      prefixes: M.NONE,
      value: 254e-7,
      offset: 0
    },
    // 1/1000 inch
    // Surface
    m2: {
      name: "m2",
      base: R.SURFACE,
      prefixes: M.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 64516e-8,
      offset: 0
    },
    // 645.16 mm2
    sqft: {
      name: "sqft",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 0.09290304,
      offset: 0
    },
    // 0.09290304 m2
    sqyd: {
      name: "sqyd",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 0.83612736,
      offset: 0
    },
    // 0.83612736 m2
    sqmi: {
      name: "sqmi",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    // 2.589988110336 km2
    sqrd: {
      name: "sqrd",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 25.29295,
      offset: 0
    },
    // 25.29295 m2
    sqch: {
      name: "sqch",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 404.6873,
      offset: 0
    },
    // 404.6873 m2
    sqmil: {
      name: "sqmil",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 64516e-14,
      offset: 0
    },
    // 6.4516 * 10^-10 m2
    acre: {
      name: "acre",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 4046.86,
      offset: 0
    },
    // 4046.86 m2
    hectare: {
      name: "hectare",
      base: R.SURFACE,
      prefixes: M.NONE,
      value: 1e4,
      offset: 0
    },
    // 10000 m2
    // Volume
    m3: {
      name: "m3",
      base: R.VOLUME,
      prefixes: M.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: R.VOLUME,
      prefixes: M.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    l: {
      name: "l",
      base: R.VOLUME,
      prefixes: M.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    litre: {
      name: "litre",
      base: R.VOLUME,
      prefixes: M.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 16387064e-12,
      offset: 0
    },
    // 1.6387064e-5 m3
    cuft: {
      name: "cuft",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 0.028316846592,
      offset: 0
    },
    // 28.316 846 592 L
    cuyd: {
      name: "cuyd",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 0.764554857984,
      offset: 0
    },
    // 764.554 857 984 L
    teaspoon: {
      name: "teaspoon",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 5e-6,
      offset: 0
    },
    // 5 mL
    tablespoon: {
      name: "tablespoon",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 15e-6,
      offset: 0
    },
    // 15 mL
    // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: "drop",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    gtt: {
      name: "gtt",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    // Liquid volume
    minim: {
      name: "minim",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 6161152e-14,
      offset: 0
    },
    // 0.06161152 mL
    fluiddram: {
      name: "fluiddram",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    fluidounce: {
      name: "fluidounce",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gill: {
      name: "gill",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cc: {
      name: "cc",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 1e-6,
      offset: 0
    },
    // 1e-6 L
    cup: {
      name: "cup",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pint: {
      name: "pint",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    quart: {
      name: "quart",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gallon: {
      name: "gallon",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    beerbarrel: {
      name: "beerbarrel",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    oilbarrel: {
      name: "oilbarrel",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    hogshead: {
      name: "hogshead",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 0.238481,
      offset: 0
    },
    // 238.4810 L
    // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
    fldr: {
      name: "fldr",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    floz: {
      name: "floz",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gi: {
      name: "gi",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cp: {
      name: "cp",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pt: {
      name: "pt",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    qt: {
      name: "qt",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gal: {
      name: "gal",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    bbl: {
      name: "bbl",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    obl: {
      name: "obl",
      base: R.VOLUME,
      prefixes: M.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
    // Mass
    g: {
      name: "g",
      base: R.MASS,
      prefixes: M.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: R.MASS,
      prefixes: M.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: R.MASS,
      prefixes: M.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: R.MASS,
      prefixes: M.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: R.MASS,
      prefixes: M.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: R.MASS,
      prefixes: M.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: R.MASS,
      prefixes: M.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: R.MASS,
      prefixes: M.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: R.MASS,
      prefixes: M.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: R.MASS,
      prefixes: M.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: R.MASS,
      prefixes: M.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: R.MASS,
      prefixes: M.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: R.MASS,
      prefixes: M.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: R.MASS,
      prefixes: M.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: R.MASS,
      prefixes: M.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: R.MASS,
      prefixes: M.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: R.MASS,
      prefixes: M.NONE,
      value: 45.359237,
      offset: 0
    },
    // Time
    s: {
      name: "s",
      base: R.TIME,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: R.TIME,
      prefixes: M.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: R.TIME,
      prefixes: M.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: R.TIME,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: R.TIME,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: R.TIME,
      prefixes: M.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: R.TIME,
      prefixes: M.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: R.TIME,
      prefixes: M.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: R.TIME,
      prefixes: M.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: R.TIME,
      prefixes: M.NONE,
      value: 2629800,
      // 1/12th of Julian year
      offset: 0
    },
    year: {
      name: "year",
      base: R.TIME,
      prefixes: M.NONE,
      value: 31557600,
      // Julian year
      offset: 0
    },
    decade: {
      name: "decade",
      base: R.TIME,
      prefixes: M.NONE,
      value: 315576e3,
      // Julian decade
      offset: 0
    },
    century: {
      name: "century",
      base: R.TIME,
      prefixes: M.NONE,
      value: 315576e4,
      // Julian century
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: R.TIME,
      prefixes: M.NONE,
      value: 315576e5,
      // Julian millennium
      offset: 0
    },
    // Frequency
    hertz: {
      name: "Hertz",
      base: R.FREQUENCY,
      prefixes: M.LONG,
      value: 1,
      offset: 0,
      reciprocal: !0
    },
    Hz: {
      name: "Hz",
      base: R.FREQUENCY,
      prefixes: M.SHORT,
      value: 1,
      offset: 0,
      reciprocal: !0
    },
    // Angle
    rad: {
      name: "rad",
      base: R.ANGLE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: R.ANGLE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: "deg",
      base: R.ANGLE,
      prefixes: M.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    degree: {
      name: "degree",
      base: R.ANGLE,
      prefixes: M.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: "grad",
      base: R.ANGLE,
      prefixes: M.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: R.ANGLE,
      prefixes: M.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: "cycle",
      base: R.ANGLE,
      prefixes: M.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: "arcsec",
      base: R.ANGLE,
      prefixes: M.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: "arcmin",
      base: R.ANGLE,
      prefixes: M.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // Electric current
    A: {
      name: "A",
      base: R.CURRENT,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: R.CURRENT,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    // Temperature
    // K(C) = °C + 273.15
    // K(F) = (°F + 459.67) * (5 / 9)
    // K(R) = °R * (5 / 9)
    K: {
      name: "K",
      base: R.TEMPERATURE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: R.TEMPERATURE,
      prefixes: M.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: R.TEMPERATURE,
      prefixes: M.SHORT,
      value: new w(5, 9),
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: R.TEMPERATURE,
      prefixes: M.SHORT,
      value: new w(5, 9),
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: R.TEMPERATURE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: R.TEMPERATURE,
      prefixes: M.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: R.TEMPERATURE,
      prefixes: M.LONG,
      value: new w(5, 9),
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: R.TEMPERATURE,
      prefixes: M.LONG,
      value: new w(5, 9),
      offset: 0
    },
    // amount of substance
    mol: {
      name: "mol",
      base: R.AMOUNT_OF_SUBSTANCE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: R.AMOUNT_OF_SUBSTANCE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    // luminous intensity
    cd: {
      name: "cd",
      base: R.LUMINOUS_INTENSITY,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: R.LUMINOUS_INTENSITY,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // Force
    N: {
      name: "N",
      base: R.FORCE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: R.FORCE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: R.FORCE,
      prefixes: M.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: R.FORCE,
      prefixes: M.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: R.FORCE,
      prefixes: M.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: R.FORCE,
      prefixes: M.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: R.FORCE,
      prefixes: M.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: R.FORCE,
      prefixes: M.NONE,
      value: 9.80665,
      offset: 0
    },
    // Energy
    J: {
      name: "J",
      base: R.ENERGY,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: R.ENERGY,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: R.ENERGY,
      prefixes: M.SHORTLONG,
      // Both kiloerg and kerg are acceptable
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: R.ENERGY,
      prefixes: M.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: R.ENERGY,
      prefixes: M.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: R.ENERGY,
      prefixes: M.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: R.ENERGY,
      prefixes: M.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    // Power
    W: {
      name: "W",
      base: R.POWER,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: R.POWER,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: R.POWER,
      prefixes: M.NONE,
      value: 745.6998715386,
      offset: 0
    },
    // Electrical power units
    VAR: {
      name: "VAR",
      base: R.POWER,
      prefixes: M.SHORT,
      value: d.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: R.POWER,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Pressure
    Pa: {
      name: "Pa",
      base: R.PRESSURE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: R.PRESSURE,
      prefixes: M.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: R.PRESSURE,
      prefixes: M.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: R.PRESSURE,
      prefixes: M.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: R.PRESSURE,
      prefixes: M.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: R.PRESSURE,
      prefixes: M.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: R.PRESSURE,
      prefixes: M.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: R.PRESSURE,
      prefixes: M.NONE,
      value: 98.0665,
      offset: 0
    },
    // Electric charge
    coulomb: {
      name: "coulomb",
      base: R.ELECTRIC_CHARGE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: R.ELECTRIC_CHARGE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: "farad",
      base: R.ELECTRIC_CAPACITANCE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: R.ELECTRIC_CAPACITANCE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: "volt",
      base: R.ELECTRIC_POTENTIAL,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: R.ELECTRIC_POTENTIAL,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: "ohm",
      base: R.ELECTRIC_RESISTANCE,
      prefixes: M.SHORTLONG,
      // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: "henry",
      base: R.ELECTRIC_INDUCTANCE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: R.ELECTRIC_INDUCTANCE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: "siemens",
      base: R.ELECTRIC_CONDUCTANCE,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: R.ELECTRIC_CONDUCTANCE,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: "weber",
      base: R.MAGNETIC_FLUX,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: R.MAGNETIC_FLUX,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: "tesla",
      base: R.MAGNETIC_FLUX_DENSITY,
      prefixes: M.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: R.MAGNETIC_FLUX_DENSITY,
      prefixes: M.SHORT,
      value: 1,
      offset: 0
    },
    // Binary
    b: {
      name: "b",
      base: R.BIT,
      prefixes: M.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: R.BIT,
      prefixes: M.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: R.BIT,
      prefixes: M.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: R.BIT,
      prefixes: M.BINARY_LONG,
      value: 8,
      offset: 0
    }
  }, pe = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fluiddrams: "fluiddram",
    fluidounces: "fluidounce",
    gills: "gill",
    cups: "cup",
    pints: "pint",
    quarts: "quart",
    gallons: "gallon",
    beerbarrels: "beerbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function X(V) {
    if (V.number === "BigNumber") {
      var J = Id(y);
      U.rad.value = new y(1), U.deg.value = J.div(180), U.grad.value = J.div(200), U.cycle.value = J.times(2), U.arcsec.value = J.div(648e3), U.arcmin.value = J.div(10800);
    } else
      U.rad.value = 1, U.deg.value = Math.PI / 180, U.grad.value = Math.PI / 200, U.cycle.value = Math.PI * 2, U.arcsec.value = Math.PI / 648e3, U.arcmin.value = Math.PI / 10800;
    U.radian.value = U.rad.value, U.degree.value = U.deg.value, U.gradian.value = U.grad.value;
  }
  X(r), e && e("config", function(V, J) {
    V.number !== J.number && X(V);
  });
  var te = {
    si: {
      // Base units
      NONE: {
        unit: j,
        prefix: M.NONE[""]
      },
      LENGTH: {
        unit: U.m,
        prefix: M.SHORT[""]
      },
      MASS: {
        unit: U.g,
        prefix: M.SHORT.k
      },
      TIME: {
        unit: U.s,
        prefix: M.SHORT[""]
      },
      CURRENT: {
        unit: U.A,
        prefix: M.SHORT[""]
      },
      TEMPERATURE: {
        unit: U.K,
        prefix: M.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: U.cd,
        prefix: M.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: U.mol,
        prefix: M.SHORT[""]
      },
      ANGLE: {
        unit: U.rad,
        prefix: M.SHORT[""]
      },
      BIT: {
        unit: U.bits,
        prefix: M.SHORT[""]
      },
      // Derived units
      FORCE: {
        unit: U.N,
        prefix: M.SHORT[""]
      },
      ENERGY: {
        unit: U.J,
        prefix: M.SHORT[""]
      },
      POWER: {
        unit: U.W,
        prefix: M.SHORT[""]
      },
      PRESSURE: {
        unit: U.Pa,
        prefix: M.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: U.C,
        prefix: M.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: U.F,
        prefix: M.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: U.V,
        prefix: M.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: U.ohm,
        prefix: M.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: U.H,
        prefix: M.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: U.S,
        prefix: M.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: U.Wb,
        prefix: M.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: U.T,
        prefix: M.SHORT[""]
      },
      FREQUENCY: {
        unit: U.Hz,
        prefix: M.SHORT[""]
      }
    }
  };
  te.cgs = JSON.parse(JSON.stringify(te.si)), te.cgs.LENGTH = {
    unit: U.m,
    prefix: M.SHORT.c
  }, te.cgs.MASS = {
    unit: U.g,
    prefix: M.SHORT[""]
  }, te.cgs.FORCE = {
    unit: U.dyn,
    prefix: M.SHORT[""]
  }, te.cgs.ENERGY = {
    unit: U.erg,
    prefix: M.NONE[""]
  }, te.us = JSON.parse(JSON.stringify(te.si)), te.us.LENGTH = {
    unit: U.ft,
    prefix: M.NONE[""]
  }, te.us.MASS = {
    unit: U.lbm,
    prefix: M.NONE[""]
  }, te.us.TEMPERATURE = {
    unit: U.degF,
    prefix: M.NONE[""]
  }, te.us.FORCE = {
    unit: U.lbf,
    prefix: M.NONE[""]
  }, te.us.ENERGY = {
    unit: U.BTU,
    prefix: M.BTU[""]
  }, te.us.POWER = {
    unit: U.hp,
    prefix: M.NONE[""]
  }, te.us.PRESSURE = {
    unit: U.psi,
    prefix: M.NONE[""]
  }, te.auto = JSON.parse(JSON.stringify(te.si));
  var ue = te.auto;
  x.setUnitSystem = function(V) {
    if ($e(te, V))
      ue = te[V];
    else
      throw new Error("Unit system " + V + " does not exist. Choices are: " + Object.keys(te).join(", "));
  }, x.getUnitSystem = function() {
    for (var V in te)
      if ($e(te, V) && te[V] === ue)
        return V;
  }, x.typeConverters = {
    BigNumber: function(J) {
      return J != null && J.isFraction ? new y(J.n).div(J.d).times(J.s) : new y(J + "");
    },
    Fraction: function(J) {
      return new w(J);
    },
    Complex: function(J) {
      return J;
    },
    number: function(J) {
      return J != null && J.isFraction ? g(J) : J;
    }
  }, x.prototype._numberConverter = function() {
    var V = x.typeConverters[this.valueType()];
    if (V)
      return V;
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  }, x._getNumberConverter = function(V) {
    if (!x.typeConverters[V])
      throw new TypeError('Unsupported type "' + V + '"');
    return x.typeConverters[V];
  };
  for (var ce in U)
    if ($e(U, ce)) {
      var se = U[ce];
      se.dimensions = se.base.dimensions;
    }
  for (var he in pe)
    if ($e(pe, he)) {
      var le = U[pe[he]], ve = {};
      for (var Ee in le)
        $e(le, Ee) && (ve[Ee] = le[Ee]);
      ve.name = he, U[he] = ve;
    }
  x.isValidAlpha = function(J) {
    return /^[a-zA-Z]$/.test(J);
  };
  function _e(V) {
    for (var J = 0; J < V.length; J++) {
      if (b = V.charAt(J), J === 0 && !x.isValidAlpha(b))
        throw new Error('Invalid unit name (must begin with alpha character): "' + V + '"');
      if (J > 0 && !(x.isValidAlpha(b) || T(b)))
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + V + '"');
    }
  }
  return x.createUnit = function(V, J) {
    if (typeof V != "object")
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    if (J && J.override) {
      for (var ye in V)
        if ($e(V, ye) && x.deleteUnit(ye), V[ye].aliases)
          for (var K = 0; K < V[ye].aliases.length; K++)
            x.deleteUnit(V[ye].aliases[K]);
    }
    var ae;
    for (var de in V)
      $e(V, de) && (ae = x.createUnitSingle(de, V[de]));
    return ae;
  }, x.createUnitSingle = function(V, J) {
    if ((typeof J > "u" || J === null) && (J = {}), typeof V != "string")
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    if ($e(U, V))
      throw new Error('Cannot create unit "' + V + '": a unit with that name already exists');
    _e(V);
    var ye = null, K = [], ae = 0, de, xe, Ce;
    if (J && J.type === "Unit")
      ye = J.clone();
    else if (typeof J == "string")
      J !== "" && (de = J);
    else if (typeof J == "object")
      de = J.definition, xe = J.prefixes, ae = J.offset, Ce = J.baseName, J.aliases && (K = J.aliases.valueOf());
    else
      throw new TypeError('Cannot create unit "' + V + '" from "' + J.toString() + '": expecting "string" or "Unit" or "Object"');
    if (K) {
      for (var G = 0; G < K.length; G++)
        if ($e(U, K[G]))
          throw new Error('Cannot create alias "' + K[G] + '": a unit with that name already exists');
    }
    if (de && typeof de == "string" && !ye)
      try {
        ye = x.parse(de, {
          allowNoUnits: !0
        });
      } catch (P) {
        throw P.message = 'Could not create unit "' + V + '" from "' + de + '": ' + P.message, P;
      }
    else de && de.type === "Unit" && (ye = de.clone());
    K = K || [], ae = ae || 0, xe && xe.toUpperCase ? xe = M[xe.toUpperCase()] || M.NONE : xe = M.NONE;
    var Z = {};
    if (ye) {
      Z = {
        name: V,
        value: ye.value,
        dimensions: ye.dimensions.slice(0),
        prefixes: xe,
        offset: ae
      };
      var De = !1;
      for (var Me in R)
        if ($e(R, Me)) {
          for (var Oe = !0, Be = 0; Be < $.length; Be++)
            if (Math.abs((Z.dimensions[Be] || 0) - (R[Me].dimensions[Be] || 0)) > 1e-12) {
              Oe = !1;
              break;
            }
          if (Oe) {
            De = !0, Z.base = R[Me];
            break;
          }
        }
      if (!De) {
        Ce = Ce || V + "_STUFF";
        var Ie = {
          dimensions: ye.dimensions.slice(0)
        };
        Ie.key = Ce, R[Ce] = Ie, ue[Ce] = {
          unit: Z,
          prefix: M.NONE[""]
        }, Z.base = R[Ce];
      }
    } else {
      if (Ce = Ce || V + "_STUFF", $.indexOf(Ce) >= 0)
        throw new Error('Cannot create new base unit "' + V + '": a base unit with that name already exists (and cannot be overridden)');
      $.push(Ce);
      for (var ge in R)
        $e(R, ge) && (R[ge].dimensions[$.length - 1] = 0);
      for (var be = {
        dimensions: []
      }, Se = 0; Se < $.length; Se++)
        be.dimensions[Se] = 0;
      be.dimensions[$.length - 1] = 1, be.key = Ce, R[Ce] = be, Z = {
        name: V,
        value: 1,
        dimensions: R[Ce].dimensions.slice(0),
        prefixes: xe,
        offset: ae,
        base: R[Ce]
      }, ue[Ce] = {
        unit: Z,
        prefix: M.NONE[""]
      };
    }
    x.UNITS[V] = Z;
    for (var nt = 0; nt < K.length; nt++) {
      var We = K[nt], Qe = {};
      for (var Gt in Z)
        $e(Z, Gt) && (Qe[Gt] = Z[Gt]);
      Qe.name = We, x.UNITS[We] = Qe;
    }
    return delete L.cache, new x(null, V);
  }, x.deleteUnit = function(V) {
    delete x.UNITS[V], delete L.cache;
  }, x.PREFIXES = M, x.BASE_DIMENSIONS = $, x.BASE_UNITS = R, x.UNIT_SYSTEMS = te, x.UNITS = U, x;
}, {
  isClass: !0
}), mx = "unit", uq = ["typed", "Unit"], Xl = /* @__PURE__ */ H(mx, uq, (t) => {
  var {
    typed: e,
    Unit: r
  } = t;
  return e(mx, {
    Unit: function(i) {
      return i.clone();
    },
    string: function(i) {
      return r.isValuelessUnit(i) ? new r(null, i) : r.parse(i, {
        allowNoUnits: !0
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function(i, a) {
      return new r(i, a);
    },
    "number | BigNumber | Fraction": function(i) {
      return new r(i);
    },
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), hx = "sparse", lq = ["typed", "SparseMatrix"], Kl = /* @__PURE__ */ H(hx, lq, (t) => {
  var {
    typed: e,
    SparseMatrix: r
  } = t;
  return e(hx, {
    "": function() {
      return new r([]);
    },
    string: function(i) {
      return new r([], i);
    },
    "Array | Matrix": function(i) {
      return new r(i);
    },
    "Array | Matrix, string": function(i, a) {
      return new r(i, a);
    }
  });
}), dx = "createUnit", cq = ["typed", "Unit"], ec = /* @__PURE__ */ H(dx, cq, (t) => {
  var {
    typed: e,
    Unit: r
  } = t;
  return e(dx, {
    // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
    "Object, Object": function(i, a) {
      return r.createUnit(i, a);
    },
    // Same as above but without the options.
    Object: function(i) {
      return r.createUnit(i, {});
    },
    // Shortcut method for creating one unit.
    "string, Unit | string | Object, Object": function(i, a, o) {
      var f = {};
      return f[i] = a, r.createUnit(f, o);
    },
    // Same as above but without the options.
    "string, Unit | string | Object": function(i, a) {
      var o = {};
      return o[i] = a, r.createUnit(o, {});
    },
    // Without a definition, creates a base unit.
    string: function(i) {
      var a = {};
      return a[i] = {}, r.createUnit(a, {});
    }
  });
}), gx = "acos", fq = ["typed", "config", "Complex"], tc = /* @__PURE__ */ H(gx, fq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(gx, {
    number: function(a) {
      return a >= -1 && a <= 1 || r.predictable ? Math.acos(a) : new n(a, 0).acos();
    },
    Complex: function(a) {
      return a.acos();
    },
    BigNumber: function(a) {
      return a.acos();
    }
  });
}), vx = "acosh", pq = ["typed", "config", "Complex"], rc = /* @__PURE__ */ H(vx, pq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(vx, {
    number: function(a) {
      return a >= 1 || r.predictable ? Dw(a) : a <= -1 ? new n(Math.log(Math.sqrt(a * a - 1) - a), Math.PI) : new n(a, 0).acosh();
    },
    Complex: function(a) {
      return a.acosh();
    },
    BigNumber: function(a) {
      return a.acosh();
    }
  });
}), yx = "acot", mq = ["typed", "BigNumber"], nc = /* @__PURE__ */ H(yx, mq, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(yx, {
    number: Ew,
    Complex: function(i) {
      return i.acot();
    },
    BigNumber: function(i) {
      return new r(1).div(i).atan();
    }
  });
}), xx = "acoth", hq = ["typed", "config", "Complex", "BigNumber"], ic = /* @__PURE__ */ H(xx, hq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: i
  } = t;
  return e(xx, {
    number: function(o) {
      return o >= 1 || o <= -1 || r.predictable ? Sw(o) : new n(o, 0).acoth();
    },
    Complex: function(o) {
      return o.acoth();
    },
    BigNumber: function(o) {
      return new i(1).div(o).atanh();
    }
  });
}), bx = "acsc", dq = ["typed", "config", "Complex", "BigNumber"], ac = /* @__PURE__ */ H(bx, dq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: i
  } = t;
  return e(bx, {
    number: function(o) {
      return o <= -1 || o >= 1 || r.predictable ? Aw(o) : new n(o, 0).acsc();
    },
    Complex: function(o) {
      return o.acsc();
    },
    BigNumber: function(o) {
      return new i(1).div(o).asin();
    }
  });
}), wx = "acsch", gq = ["typed", "BigNumber"], sc = /* @__PURE__ */ H(wx, gq, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(wx, {
    number: Cw,
    Complex: function(i) {
      return i.acsch();
    },
    BigNumber: function(i) {
      return new r(1).div(i).asinh();
    }
  });
}), Nx = "asec", vq = ["typed", "config", "Complex", "BigNumber"], oc = /* @__PURE__ */ H(Nx, vq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: i
  } = t;
  return e(Nx, {
    number: function(o) {
      return o <= -1 || o >= 1 || r.predictable ? Tw(o) : new n(o, 0).asec();
    },
    Complex: function(o) {
      return o.asec();
    },
    BigNumber: function(o) {
      return new i(1).div(o).acos();
    }
  });
}), Dx = "asech", yq = ["typed", "config", "Complex", "BigNumber"], uc = /* @__PURE__ */ H(Dx, yq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n,
    BigNumber: i
  } = t;
  return e(Dx, {
    number: function(o) {
      if (o <= 1 && o >= -1 || r.predictable) {
        var f = 1 / o;
        if (f > 0 || r.predictable)
          return _w(o);
        var u = Math.sqrt(f * f - 1);
        return new n(Math.log(u - f), Math.PI);
      }
      return new n(o, 0).asech();
    },
    Complex: function(o) {
      return o.asech();
    },
    BigNumber: function(o) {
      return new i(1).div(o).acosh();
    }
  });
}), Ex = "asin", xq = ["typed", "config", "Complex"], lc = /* @__PURE__ */ H(Ex, xq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(Ex, {
    number: function(a) {
      return a >= -1 && a <= 1 || r.predictable ? Math.asin(a) : new n(a, 0).asin();
    },
    Complex: function(a) {
      return a.asin();
    },
    BigNumber: function(a) {
      return a.asin();
    }
  });
}), bq = "asinh", wq = ["typed"], cc = /* @__PURE__ */ H(bq, wq, (t) => {
  var {
    typed: e
  } = t;
  return e("asinh", {
    number: Mw,
    Complex: function(n) {
      return n.asinh();
    },
    BigNumber: function(n) {
      return n.asinh();
    }
  });
}), Nq = "atan", Dq = ["typed"], fc = /* @__PURE__ */ H(Nq, Dq, (t) => {
  var {
    typed: e
  } = t;
  return e("atan", {
    number: function(n) {
      return Math.atan(n);
    },
    Complex: function(n) {
      return n.atan();
    },
    BigNumber: function(n) {
      return n.atan();
    }
  });
}), Sx = "atan2", Eq = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"], pc = /* @__PURE__ */ H(Sx, Eq, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    BigNumber: i,
    DenseMatrix: a,
    concat: o
  } = t, f = Mn({
    typed: e,
    equalScalar: n
  }), u = Ur({
    typed: e
  }), s = Uw({
    typed: e,
    equalScalar: n
  }), c = Sr({
    typed: e,
    equalScalar: n
  }), l = cr({
    typed: e,
    DenseMatrix: a
  }), m = Ut({
    typed: e,
    matrix: r,
    concat: o
  });
  return e(Sx, {
    "number, number": Math.atan2,
    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored
    // the imaginary.
    "BigNumber, BigNumber": (h, g) => i.atan2(h, g)
  }, m({
    scalar: "number | BigNumber",
    SS: s,
    DS: u,
    SD: f,
    Ss: c,
    sS: l
  }));
}), Ax = "atanh", Sq = ["typed", "config", "Complex"], mc = /* @__PURE__ */ H(Ax, Sq, (t) => {
  var {
    typed: e,
    config: r,
    Complex: n
  } = t;
  return e(Ax, {
    number: function(a) {
      return a <= 1 && a >= -1 || r.predictable ? Ow(a) : new n(a, 0).atanh();
    },
    Complex: function(a) {
      return a.atanh();
    },
    BigNumber: function(a) {
      return a.atanh();
    }
  });
}), Ha = /* @__PURE__ */ H("trigUnit", ["typed"], (t) => {
  var {
    typed: e
  } = t;
  return {
    Unit: e.referToSelf((r) => (n) => {
      if (!n.hasBase(n.constructor.BASE_UNITS.ANGLE))
        throw new TypeError("Unit in function cot is no angle");
      return e.find(r, n.valueType())(n.value);
    })
  };
}), Cx = "cos", Aq = ["typed"], hc = /* @__PURE__ */ H(Cx, Aq, (t) => {
  var {
    typed: e
  } = t, r = Ha({
    typed: e
  });
  return e(Cx, {
    number: Math.cos,
    "Complex | BigNumber": (n) => n.cos()
  }, r);
}), Tx = "cosh", Cq = ["typed"], dc = /* @__PURE__ */ H(Tx, Cq, (t) => {
  var {
    typed: e
  } = t;
  return e(Tx, {
    number: nC,
    "Complex | BigNumber": (r) => r.cosh()
  });
}), _x = "cot", Tq = ["typed", "BigNumber"], gc = /* @__PURE__ */ H(_x, Tq, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t, n = Ha({
    typed: e
  });
  return e(_x, {
    number: qw,
    Complex: (i) => i.cot(),
    BigNumber: (i) => new r(1).div(i.tan())
  }, n);
}), Mx = "coth", _q = ["typed", "BigNumber"], vc = /* @__PURE__ */ H(Mx, _q, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(Mx, {
    number: Iw,
    Complex: (n) => n.coth(),
    BigNumber: (n) => new r(1).div(n.tanh())
  });
}), Ox = "csc", Mq = ["typed", "BigNumber"], yc = /* @__PURE__ */ H(Ox, Mq, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t, n = Ha({
    typed: e
  });
  return e(Ox, {
    number: Fw,
    Complex: (i) => i.csc(),
    BigNumber: (i) => new r(1).div(i.sin())
  }, n);
}), qx = "csch", Oq = ["typed", "BigNumber"], xc = /* @__PURE__ */ H(qx, Oq, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(qx, {
    number: Bw,
    Complex: (n) => n.csch(),
    BigNumber: (n) => new r(1).div(n.sinh())
  });
}), Ix = "sec", qq = ["typed", "BigNumber"], bc = /* @__PURE__ */ H(Ix, qq, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t, n = Ha({
    typed: e
  });
  return e(Ix, {
    number: Rw,
    Complex: (i) => i.sec(),
    BigNumber: (i) => new r(1).div(i.cos())
  }, n);
}), Fx = "sech", Iq = ["typed", "BigNumber"], wc = /* @__PURE__ */ H(Fx, Iq, (t) => {
  var {
    typed: e,
    BigNumber: r
  } = t;
  return e(Fx, {
    number: Pw,
    Complex: (n) => n.sech(),
    BigNumber: (n) => new r(1).div(n.cosh())
  });
}), Bx = "sin", Fq = ["typed"], Nc = /* @__PURE__ */ H(Bx, Fq, (t) => {
  var {
    typed: e
  } = t, r = Ha({
    typed: e
  });
  return e(Bx, {
    number: Math.sin,
    "Complex | BigNumber": (n) => n.sin()
  }, r);
}), Rx = "sinh", Bq = ["typed"], Dc = /* @__PURE__ */ H(Rx, Bq, (t) => {
  var {
    typed: e
  } = t;
  return e(Rx, {
    number: Lw,
    "Complex | BigNumber": (r) => r.sinh()
  });
}), Px = "tan", Rq = ["typed"], Ec = /* @__PURE__ */ H(Px, Rq, (t) => {
  var {
    typed: e
  } = t, r = Ha({
    typed: e
  });
  return e(Px, {
    number: Math.tan,
    "Complex | BigNumber": (n) => n.tan()
  }, r);
}), Pq = "tanh", Lq = ["typed"], Sc = /* @__PURE__ */ H(Pq, Lq, (t) => {
  var {
    typed: e
  } = t;
  return e("tanh", {
    number: aC,
    "Complex | BigNumber": (r) => r.tanh()
  });
}), Lx = "setCartesian", kq = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], Ac = /* @__PURE__ */ H(Lx, kq, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: i,
    Index: a,
    DenseMatrix: o
  } = t;
  return e(Lx, {
    "Array | Matrix, Array | Matrix": function(u, s) {
      var c = [];
      if (n(r(u), new a(0)) !== 0 && n(r(s), new a(0)) !== 0) {
        var l = Mt(Array.isArray(u) ? u : u.toArray()).sort(i), m = Mt(Array.isArray(s) ? s : s.toArray()).sort(i);
        c = [];
        for (var h = 0; h < l.length; h++)
          for (var g = 0; g < m.length; g++)
            c.push([l[h], m[g]]);
      }
      return Array.isArray(u) && Array.isArray(s) ? c : new o(c);
    }
  });
}), kx = "setDifference", zq = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], Cc = /* @__PURE__ */ H(kx, zq, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: i,
    Index: a,
    DenseMatrix: o
  } = t;
  return e(kx, {
    "Array | Matrix, Array | Matrix": function(u, s) {
      var c;
      if (n(r(u), new a(0)) === 0)
        c = [];
      else {
        if (n(r(s), new a(0)) === 0)
          return Mt(u.toArray());
        var l = qa(Mt(Array.isArray(u) ? u : u.toArray()).sort(i)), m = qa(Mt(Array.isArray(s) ? s : s.toArray()).sort(i));
        c = [];
        for (var h, g = 0; g < l.length; g++) {
          h = !1;
          for (var d = 0; d < m.length; d++)
            if (i(l[g].value, m[d].value) === 0 && l[g].identifier === m[d].identifier) {
              h = !0;
              break;
            }
          h || c.push(l[g]);
        }
      }
      return Array.isArray(u) && Array.isArray(s) ? Xo(c) : new o(Xo(c));
    }
  });
}), zx = "setDistinct", $q = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], Tc = /* @__PURE__ */ H(zx, $q, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: i,
    Index: a,
    DenseMatrix: o
  } = t;
  return e(zx, {
    "Array | Matrix": function(u) {
      var s;
      if (n(r(u), new a(0)) === 0)
        s = [];
      else {
        var c = Mt(Array.isArray(u) ? u : u.toArray()).sort(i);
        s = [], s.push(c[0]);
        for (var l = 1; l < c.length; l++)
          i(c[l], c[l - 1]) !== 0 && s.push(c[l]);
      }
      return Array.isArray(u) ? s : new o(s);
    }
  });
}), $x = "setIntersect", Uq = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"], _c = /* @__PURE__ */ H($x, Uq, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: i,
    Index: a,
    DenseMatrix: o
  } = t;
  return e($x, {
    "Array | Matrix, Array | Matrix": function(u, s) {
      var c;
      if (n(r(u), new a(0)) === 0 || n(r(s), new a(0)) === 0)
        c = [];
      else {
        var l = qa(Mt(Array.isArray(u) ? u : u.toArray()).sort(i)), m = qa(Mt(Array.isArray(s) ? s : s.toArray()).sort(i));
        c = [];
        for (var h = 0; h < l.length; h++)
          for (var g = 0; g < m.length; g++)
            if (i(l[h].value, m[g].value) === 0 && l[h].identifier === m[g].identifier) {
              c.push(l[h]);
              break;
            }
      }
      return Array.isArray(u) && Array.isArray(s) ? Xo(c) : new o(Xo(c));
    }
  });
}), Ux = "setIsSubset", Gq = ["typed", "size", "subset", "compareNatural", "Index"], Mc = /* @__PURE__ */ H(Ux, Gq, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: i,
    Index: a
  } = t;
  return e(Ux, {
    "Array | Matrix, Array | Matrix": function(f, u) {
      if (n(r(f), new a(0)) === 0)
        return !0;
      if (n(r(u), new a(0)) === 0)
        return !1;
      for (var s = qa(Mt(Array.isArray(f) ? f : f.toArray()).sort(i)), c = qa(Mt(Array.isArray(u) ? u : u.toArray()).sort(i)), l, m = 0; m < s.length; m++) {
        l = !1;
        for (var h = 0; h < c.length; h++)
          if (i(s[m].value, c[h].value) === 0 && s[m].identifier === c[h].identifier) {
            l = !0;
            break;
          }
        if (l === !1)
          return !1;
      }
      return !0;
    }
  });
}), Gx = "setMultiplicity", Hq = ["typed", "size", "subset", "compareNatural", "Index"], Oc = /* @__PURE__ */ H(Gx, Hq, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: i,
    Index: a
  } = t;
  return e(Gx, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function(f, u) {
      if (n(r(u), new a(0)) === 0)
        return 0;
      for (var s = Mt(Array.isArray(u) ? u : u.toArray()), c = 0, l = 0; l < s.length; l++)
        i(s[l], f) === 0 && c++;
      return c;
    }
  });
}), Hx = "setPowerset", Qq = ["typed", "size", "subset", "compareNatural", "Index"], qc = /* @__PURE__ */ H(Hx, Qq, (t) => {
  var {
    typed: e,
    size: r,
    subset: n,
    compareNatural: i,
    Index: a
  } = t;
  return e(Hx, {
    "Array | Matrix": function(s) {
      if (n(r(s), new a(0)) === 0)
        return [];
      for (var c = Mt(Array.isArray(s) ? s : s.toArray()).sort(i), l = [], m = 0; m.toString(2).length <= c.length; )
        l.push(o(c, m.toString(2).split("").reverse())), m++;
      return f(l);
    }
  });
  function o(u, s) {
    for (var c = [], l = 0; l < s.length; l++)
      s[l] === "1" && c.push(u[l]);
    return c;
  }
  function f(u) {
    for (var s = [], c = u.length - 1; c > 0; c--)
      for (var l = 0; l < c; l++)
        u[l].length > u[l + 1].length && (s = u[l], u[l] = u[l + 1], u[l + 1] = s);
    return u;
  }
}), Qx = "setSize", Vq = ["typed", "compareNatural"], Ic = /* @__PURE__ */ H(Qx, Vq, (t) => {
  var {
    typed: e,
    compareNatural: r
  } = t;
  return e(Qx, {
    "Array | Matrix": function(i) {
      return Array.isArray(i) ? Mt(i).length : Mt(i.toArray()).length;
    },
    "Array | Matrix, boolean": function(i, a) {
      if (a === !1 || i.length === 0)
        return Array.isArray(i) ? Mt(i).length : Mt(i.toArray()).length;
      for (var o = Mt(Array.isArray(i) ? i : i.toArray()).sort(r), f = 1, u = 1; u < o.length; u++)
        r(o[u], o[u - 1]) !== 0 && f++;
      return f;
    }
  });
}), Vx = "setSymDifference", Wq = ["typed", "size", "concat", "subset", "setDifference", "Index"], Fc = /* @__PURE__ */ H(Vx, Wq, (t) => {
  var {
    typed: e,
    size: r,
    concat: n,
    subset: i,
    setDifference: a,
    Index: o
  } = t;
  return e(Vx, {
    "Array | Matrix, Array | Matrix": function(u, s) {
      if (i(r(u), new o(0)) === 0)
        return Mt(s);
      if (i(r(s), new o(0)) === 0)
        return Mt(u);
      var c = Mt(u), l = Mt(s);
      return n(a(c, l), a(l, c));
    }
  });
}), Wx = "setUnion", jq = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"], Bc = /* @__PURE__ */ H(Wx, jq, (t) => {
  var {
    typed: e,
    size: r,
    concat: n,
    subset: i,
    setIntersect: a,
    setSymDifference: o,
    Index: f
  } = t;
  return e(Wx, {
    "Array | Matrix, Array | Matrix": function(s, c) {
      if (i(r(s), new f(0)) === 0)
        return Mt(c);
      if (i(r(c), new f(0)) === 0)
        return Mt(s);
      var l = Mt(s), m = Mt(c);
      return n(o(l, m), a(l, m));
    }
  });
}), jx = "add", Yq = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"], Rc = /* @__PURE__ */ H(jx, Yq, (t) => {
  var {
    typed: e,
    matrix: r,
    addScalar: n,
    equalScalar: i,
    DenseMatrix: a,
    SparseMatrix: o,
    concat: f
  } = t, u = Di({
    typed: e
  }), s = Td({
    typed: e,
    equalScalar: i
  }), c = ea({
    typed: e,
    DenseMatrix: a
  }), l = Ut({
    typed: e,
    matrix: r,
    concat: f
  });
  return e(jx, {
    "any, any": n,
    "any, any, ...any": e.referToSelf((m) => (h, g, d) => {
      for (var y = m(h, g), w = 0; w < d.length; w++)
        y = m(y, d[w]);
      return y;
    })
  }, l({
    elop: n,
    DS: u,
    SS: s,
    Ss: c
  }));
}), Yx = "hypot", Zq = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"], Pc = /* @__PURE__ */ H(Yx, Zq, (t) => {
  var {
    typed: e,
    abs: r,
    addScalar: n,
    divideScalar: i,
    multiplyScalar: a,
    sqrt: o,
    smaller: f,
    isPositive: u
  } = t;
  return e(Yx, {
    "... number | BigNumber": s,
    Array: s,
    Matrix: (c) => s(Mt(c.toArray()))
  });
  function s(c) {
    for (var l = 0, m = 0, h = 0; h < c.length; h++) {
      if (dn(c[h]))
        throw new TypeError("Unexpected type of argument to hypot");
      var g = r(c[h]);
      f(m, g) ? (l = a(l, a(i(m, g), i(m, g))), l = n(l, 1), m = g) : l = n(l, u(g) ? a(i(g, m), i(g, m)) : g);
    }
    return a(m, o(l));
  }
}), Zx = "norm", Jq = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"], Lc = /* @__PURE__ */ H(Zx, Jq, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    pow: i,
    conj: a,
    sqrt: o,
    multiply: f,
    equalScalar: u,
    larger: s,
    smaller: c,
    matrix: l,
    ctranspose: m,
    eigs: h
  } = t;
  return e(Zx, {
    number: Math.abs,
    Complex: function(A) {
      return A.abs();
    },
    BigNumber: function(A) {
      return A.abs();
    },
    boolean: function(A) {
      return Math.abs(A);
    },
    Array: function(A) {
      return b(l(A), 2);
    },
    Matrix: function(A) {
      return b(A, 2);
    },
    "Array, number | BigNumber | string": function(A, T) {
      return b(l(A), T);
    },
    "Matrix, number | BigNumber | string": function(A, T) {
      return b(A, T);
    }
  });
  function g(C) {
    var A = 0;
    return C.forEach(function(T) {
      var _ = r(T);
      s(_, A) && (A = _);
    }, !0), A;
  }
  function d(C) {
    var A;
    return C.forEach(function(T) {
      var _ = r(T);
      (!A || c(_, A)) && (A = _);
    }, !0), A || 0;
  }
  function y(C, A) {
    if (A === Number.POSITIVE_INFINITY || A === "inf")
      return g(C);
    if (A === Number.NEGATIVE_INFINITY || A === "-inf")
      return d(C);
    if (A === "fro")
      return b(C, 2);
    if (typeof A == "number" && !isNaN(A)) {
      if (!u(A, 0)) {
        var T = 0;
        return C.forEach(function(_) {
          T = n(i(r(_), A), T);
        }, !0), i(T, 1 / A);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function w(C) {
    var A = 0;
    return C.forEach(function(T, _) {
      A = n(A, f(T, a(T)));
    }), r(o(A));
  }
  function E(C) {
    var A = [], T = 0;
    return C.forEach(function(_, O) {
      var I = O[1], B = n(A[I] || 0, r(_));
      s(B, T) && (T = B), A[I] = B;
    }, !0), T;
  }
  function x(C) {
    var A = C.size();
    if (A[0] !== A[1])
      throw new RangeError("Invalid matrix dimensions");
    var T = m(C), _ = f(T, C), O = h(_).values.toArray(), I = O[O.length - 1];
    return r(o(I));
  }
  function N(C) {
    var A = [], T = 0;
    return C.forEach(function(_, O) {
      var I = O[0], B = n(A[I] || 0, r(_));
      s(B, T) && (T = B), A[I] = B;
    }, !0), T;
  }
  function D(C, A) {
    if (A === 1)
      return E(C);
    if (A === Number.POSITIVE_INFINITY || A === "inf")
      return N(C);
    if (A === "fro")
      return w(C);
    if (A === 2)
      return x(C);
    throw new Error("Unsupported parameter value " + A);
  }
  function b(C, A) {
    var T = C.size();
    if (T.length === 1)
      return y(C, A);
    if (T.length === 2) {
      if (T[0] && T[1])
        return D(C, A);
      throw new RangeError("Invalid matrix dimensions");
    }
  }
}), Jx = "dot", Xq = ["typed", "addScalar", "multiplyScalar", "conj", "size"], kc = /* @__PURE__ */ H(Jx, Xq, (t) => {
  var {
    typed: e,
    addScalar: r,
    multiplyScalar: n,
    conj: i,
    size: a
  } = t;
  return e(Jx, {
    "Array | DenseMatrix, Array | DenseMatrix": f,
    "SparseMatrix, SparseMatrix": u
  });
  function o(c, l) {
    var m = s(c), h = s(l), g, d;
    if (m.length === 1)
      g = m[0];
    else if (m.length === 2 && m[1] === 1)
      g = m[0];
    else
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + m.join(", ") + ")");
    if (h.length === 1)
      d = h[0];
    else if (h.length === 2 && h[1] === 1)
      d = h[0];
    else
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + h.join(", ") + ")");
    if (g !== d) throw new RangeError("Vectors must have equal length (" + g + " != " + d + ")");
    if (g === 0) throw new RangeError("Cannot calculate the dot product of empty vectors");
    return g;
  }
  function f(c, l) {
    var m = o(c, l), h = Ye(c) ? c._data : c, g = Ye(c) ? c._datatype || c.getDataType() : void 0, d = Ye(l) ? l._data : l, y = Ye(l) ? l._datatype || l.getDataType() : void 0, w = s(c).length === 2, E = s(l).length === 2, x = r, N = n;
    if (g && y && g === y && typeof g == "string" && g !== "mixed") {
      var D = g;
      x = e.find(r, [D, D]), N = e.find(n, [D, D]);
    }
    if (!w && !E) {
      for (var b = N(i(h[0]), d[0]), C = 1; C < m; C++)
        b = x(b, N(i(h[C]), d[C]));
      return b;
    }
    if (!w && E) {
      for (var A = N(i(h[0]), d[0][0]), T = 1; T < m; T++)
        A = x(A, N(i(h[T]), d[T][0]));
      return A;
    }
    if (w && !E) {
      for (var _ = N(i(h[0][0]), d[0]), O = 1; O < m; O++)
        _ = x(_, N(i(h[O][0]), d[O]));
      return _;
    }
    if (w && E) {
      for (var I = N(i(h[0][0]), d[0][0]), B = 1; B < m; B++)
        I = x(I, N(i(h[B][0]), d[B][0]));
      return I;
    }
  }
  function u(c, l) {
    o(c, l);
    for (var m = c._index, h = c._values, g = l._index, d = l._values, y = 0, w = r, E = n, x = 0, N = 0; x < m.length && N < g.length; ) {
      var D = m[x], b = g[N];
      if (D < b) {
        x++;
        continue;
      }
      if (D > b) {
        N++;
        continue;
      }
      D === b && (y = w(y, E(h[x], d[N])), x++, N++);
    }
    return y;
  }
  function s(c) {
    return Ye(c) ? c.size() : a(c);
  }
}), Kq = "trace", eI = ["typed", "matrix", "add"], zc = /* @__PURE__ */ H(Kq, eI, (t) => {
  var {
    typed: e,
    matrix: r,
    add: n
  } = t;
  return e("trace", {
    Array: function(f) {
      return i(r(f));
    },
    SparseMatrix: a,
    DenseMatrix: i,
    any: Je
  });
  function i(o) {
    var f = o._size, u = o._data;
    switch (f.length) {
      case 1:
        if (f[0] === 1)
          return Je(u[0]);
        throw new RangeError("Matrix must be square (size: " + vt(f) + ")");
      case 2: {
        var s = f[0], c = f[1];
        if (s === c) {
          for (var l = 0, m = 0; m < s; m++)
            l = n(l, u[m][m]);
          return l;
        } else
          throw new RangeError("Matrix must be square (size: " + vt(f) + ")");
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + vt(f) + ")");
    }
  }
  function a(o) {
    var f = o._values, u = o._index, s = o._ptr, c = o._size, l = c[0], m = c[1];
    if (l === m) {
      var h = 0;
      if (f.length > 0)
        for (var g = 0; g < m; g++)
          for (var d = s[g], y = s[g + 1], w = d; w < y; w++) {
            var E = u[w];
            if (E === g) {
              h = n(h, f[w]);
              break;
            }
            if (E > g)
              break;
          }
      return h;
    }
    throw new RangeError("Matrix must be square (size: " + vt(c) + ")");
  }
}), Xx = "index", tI = ["typed", "Index"], $c = /* @__PURE__ */ H(Xx, tI, (t) => {
  var {
    typed: e,
    Index: r
  } = t;
  return e(Xx, {
    "...number | string | BigNumber | Range | Array | Matrix": function(i) {
      var a = i.map(function(f) {
        return at(f) ? f.toNumber() : _t(f) || Ye(f) ? f.map(function(u) {
          return at(u) ? u.toNumber() : u;
        }) : f;
      }), o = new r();
      return r.apply(o, a), o;
    }
  });
}), Vw = /* @__PURE__ */ new Set(["end"]), rI = "Node", nI = ["mathWithTransform"], Uc = /* @__PURE__ */ H(rI, nI, (t) => {
  var {
    mathWithTransform: e
  } = t;
  function r(i) {
    for (var a of [...Vw])
      if (i.has(a))
        throw new Error('Scope contains an illegal symbol, "' + a + '" is a reserved keyword');
  }
  class n {
    get type() {
      return "Node";
    }
    get isNode() {
      return !0;
    }
    /**
     * Evaluate the node
     * @param {Object} [scope]  Scope to read/write variables
     * @return {*}              Returns the result
     */
    evaluate(a) {
      return this.compile().evaluate(a);
    }
    /**
     * Compile the node into an optimized, evauatable JavaScript function
     * @return {{evaluate: function([Object])}} object
     *                Returns an object with a function 'evaluate',
     *                which can be invoked as expr.evaluate([scope: Object]),
     *                where scope is an optional object with
     *                variables.
     */
    compile() {
      var a = this._compile(e, {}), o = {}, f = null;
      function u(s) {
        var c = Sa(s);
        return r(c), a(c, o, f);
      }
      return {
        evaluate: u
      };
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, o) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    /**
     * Create a new Node whose children are the results of calling the
     * provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(a) {
      throw new Error("Cannot run map on a Node interface");
    }
    /**
     * Validate whether an object is a Node, for use with map
     * @param {Node} node
     * @returns {Node} Returns the input if it's a node, else throws an Error
     * @protected
     */
    _ifNode(a) {
      if (!Bt(a))
        throw new TypeError("Callback function must return a Node");
      return a;
    }
    /**
     * Recursively traverse all nodes in a node tree. Executes given callback for
     * this node and each of its child nodes.
     * @param {function(node: Node, path: string, parent: Node)} callback
     *          A callback called for every node in the node tree.
     */
    traverse(a) {
      a(this, null, null);
      function o(f, u) {
        f.forEach(function(s, c, l) {
          u(s, c, l), o(s, u);
        });
      }
      o(this, a);
    }
    /**
     * Recursively transform a node tree via a transform function.
     *
     * For example, to replace all nodes of type SymbolNode having name 'x' with
     * a ConstantNode with value 2:
     *
     *     const res = Node.transform(function (node, path, parent) {
     *       if (node && node.isSymbolNode) && (node.name === 'x')) {
     *         return new ConstantNode(2)
     *       }
     *       else {
     *         return node
     *       }
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *          A mapping function accepting a node, and returning
     *          a replacement for the node or the original node. The "signature"
     *          of the callback must be:
     *          callback(node: Node, index: string, parent: Node) : Node
     * @return {Node} Returns the original node or its replacement
     */
    transform(a) {
      function o(f, u, s) {
        var c = a(f, u, s);
        return c !== f ? c : f.map(o);
      }
      return o(this, null, null);
    }
    /**
     * Find any node in the node tree matching given filter function. For
     * example, to find all nodes of type SymbolNode having name 'x':
     *
     *     const results = Node.filter(function (node) {
     *       return (node && node.isSymbolNode) && (node.name === 'x')
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *            A test function returning true when a node matches, and false
     *            otherwise. Function signature:
     *            callback(node: Node, index: string, parent: Node) : boolean
     * @return {Node[]} nodes
     *            An array with nodes matching given filter criteria
     */
    filter(a) {
      var o = [];
      return this.traverse(function(f, u, s) {
        a(f, u, s) && o.push(f);
      }), o;
    }
    /**
     * Create a shallow clone of this node
     * @return {Node}
     */
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    /**
     * Create a deep clone of this node
     * @return {Node}
     */
    cloneDeep() {
      return this.map(function(a) {
        return a.cloneDeep();
      });
    }
    /**
     * Deep compare this node with another node.
     * @param {Node} other
     * @return {boolean} Returns true when both nodes are of the same type and
     *                   contain the same values (as do their childs)
     */
    equals(a) {
      return a ? this.type === a.type && Wi(this, a) : !1;
    }
    /**
     * Get string representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toString(a) {
      var o = this._getCustomString(a);
      return typeof o < "u" ? o : this._toString(a);
    }
    /**
     * Internal function to generate the string output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    /**
     * Get a JSON representation of the node
     * Both .toJSON() and the static .fromJSON(json) should be implemented by all
     * implementations of Node
     * @returns {Object}
     */
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    /**
     * Get HTML representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)" or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toHTML(a) {
      var o = this._getCustomString(a);
      return typeof o < "u" ? o : this._toHTML(a);
    }
    /**
     * Internal function to generate the HTML output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toHTML() {
      throw new Error("_toHTML not implemented for " + this.type);
    }
    /**
     * Get LaTeX representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toTex(a) {
      var o = this._getCustomString(a);
      return typeof o < "u" ? o : this._toTex(a);
    }
    /**
     * Internal function to generate the LaTeX output.
     * This has to be implemented by every Node
     *
     * @param {Object} [options]
     * @throws {Error}
     */
    _toTex(a) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    /**
     * Helper used by `to...` functions.
     */
    _getCustomString(a) {
      if (a && typeof a == "object")
        switch (typeof a.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return a.handler(this, a);
          default:
            throw new TypeError("Object or function expected as callback");
        }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type;
    }
    /**
     * Get the content of the current Node.
     * @return {Node} node
     **/
    getContent() {
      return this;
    }
  }
  return n;
}, {
  isClass: !0,
  isNode: !0
});
function Gr(t) {
  return t && t.isIndexError ? new nn(t.index + 1, t.min + 1, t.max !== void 0 ? t.max + 1 : void 0) : t;
}
function Ww(t) {
  var {
    subset: e
  } = t;
  return function(n, i) {
    try {
      if (Array.isArray(n))
        return e(n, i);
      if (n && typeof n.subset == "function")
        return n.subset(i);
      if (typeof n == "string")
        return e(n, i);
      if (typeof n == "object") {
        if (!i.isObjectProperty())
          throw new TypeError("Cannot apply a numeric index as object property");
        return kr(n, i.getObjectProperty());
      } else
        throw new TypeError("Cannot apply index: unsupported type of object");
    } catch (a) {
      throw Gr(a);
    }
  };
}
var Co = "AccessorNode", iI = ["subset", "Node"], Gc = /* @__PURE__ */ H(Co, iI, (t) => {
  var {
    subset: e,
    Node: r
  } = t, n = Ww({
    subset: e
  });
  function i(o) {
    return !(Kn(o) || Wr(o) || wt(o) || Bn(o) || Pa(o) || Cn(o) || ir(o));
  }
  class a extends r {
    /**
     * @constructor AccessorNode
     * @extends {Node}
     * Access an object property or get a matrix subset
     *
     * @param {Node} object                 The object from which to retrieve
     *                                      a property or subset.
     * @param {IndexNode} index             IndexNode containing ranges
     */
    constructor(f, u) {
      if (super(), !Bt(f))
        throw new TypeError('Node expected for parameter "object"');
      if (!bi(u))
        throw new TypeError('IndexNode expected for parameter "index"');
      this.object = f, this.index = u;
    }
    // readonly property name
    get name() {
      return this.index ? this.index.isObjectProperty() ? this.index.getObjectProperty() : "" : this.object.name || "";
    }
    get type() {
      return Co;
    }
    get isAccessorNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(f, u) {
      var s = this.object._compile(f, u), c = this.index._compile(f, u);
      if (this.index.isObjectProperty()) {
        var l = this.index.getObjectProperty();
        return function(h, g, d) {
          return kr(s(h, g, d), l);
        };
      } else
        return function(h, g, d) {
          var y = s(h, g, d), w = c(h, g, y);
          return n(y, w);
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(f) {
      f(this.object, "object", this), f(this.index, "index", this);
    }
    /**
     * Create a new AccessorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AccessorNode} Returns a transformed copy of the node
     */
    map(f) {
      return new a(this._ifNode(f(this.object, "object", this)), this._ifNode(f(this.index, "index", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AccessorNode}
     */
    clone() {
      return new a(this.object, this.index);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(f) {
      var u = this.object.toString(f);
      return i(this.object) && (u = "(" + u + ")"), u + this.index.toString(f);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(f) {
      var u = this.object.toHTML(f);
      return i(this.object) && (u = '<span class="math-parenthesis math-round-parenthesis">(</span>' + u + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u + this.index.toHTML(f);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(f) {
      var u = this.object.toTex(f);
      return i(this.object) && (u = "\\left(' + object + '\\right)"), u + this.index.toTex(f);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Co,
        object: this.object,
        index: this.index
      };
    }
    /**
     * Instantiate an AccessorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
     *     where mathjs is optional
     * @returns {AccessorNode}
     */
    static fromJSON(f) {
      return new a(f.object, f.index);
    }
  }
  return lr(a, "name", Co), a;
}, {
  isClass: !0,
  isNode: !0
}), To = "ArrayNode", aI = ["Node"], Hc = /* @__PURE__ */ H(To, aI, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * @constructor ArrayNode
     * @extends {Node}
     * Holds an 1-dimensional array with items
     * @param {Node[]} [items]   1 dimensional array with items
     */
    constructor(i) {
      if (super(), this.items = i || [], !Array.isArray(this.items) || !this.items.every(Bt))
        throw new TypeError("Array containing Nodes expected");
    }
    get type() {
      return To;
    }
    get isArrayNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(i, a) {
      var o = Xn(this.items, function(s) {
        return s._compile(i, a);
      }), f = i.config.matrix !== "Array";
      if (f) {
        var u = i.matrix;
        return function(c, l, m) {
          return u(Xn(o, function(h) {
            return h(c, l, m);
          }));
        };
      } else
        return function(c, l, m) {
          return Xn(o, function(h) {
            return h(c, l, m);
          });
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(i) {
      for (var a = 0; a < this.items.length; a++) {
        var o = this.items[a];
        i(o, "items[" + a + "]", this);
      }
    }
    /**
     * Create a new ArrayNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ArrayNode} Returns a transformed copy of the node
     */
    map(i) {
      for (var a = [], o = 0; o < this.items.length; o++)
        a[o] = this._ifNode(i(this.items[o], "items[" + o + "]", this));
      return new r(a);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ArrayNode}
     */
    clone() {
      return new r(this.items.slice(0));
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(i) {
      var a = this.items.map(function(o) {
        return o.toString(i);
      });
      return "[" + a.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: To,
        items: this.items
      };
    }
    /**
     * Instantiate an ArrayNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ArrayNode", items: [...]}`,
     *                       where mathjs is optional
     * @returns {ArrayNode}
     */
    static fromJSON(i) {
      return new r(i.items);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(i) {
      var a = this.items.map(function(o) {
        return o.toHTML(i);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + a.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(i) {
      function a(o, f) {
        var u = o.some(Wr) && !o.every(Wr), s = f || u, c = s ? "&" : "\\\\", l = o.map(function(m) {
          return m.items ? a(m.items, !f) : m.toTex(i);
        }).join(c);
        return u || !s || s && !f ? "\\begin{bmatrix}" + l + "\\end{bmatrix}" : l;
      }
      return a(this.items, !1);
    }
  }
  return lr(r, "name", To), r;
}, {
  isClass: !0,
  isNode: !0
});
function sI(t) {
  var {
    subset: e,
    matrix: r
  } = t;
  return function(i, a, o) {
    try {
      if (Array.isArray(i)) {
        var f = r(i).subset(a, o).valueOf();
        return f.forEach((u, s) => {
          i[s] = u;
        }), i;
      } else {
        if (i && typeof i.subset == "function")
          return i.subset(a, o);
        if (typeof i == "string")
          return e(i, a, o);
        if (typeof i == "object") {
          if (!a.isObjectProperty())
            throw TypeError("Cannot apply a numeric index as object property");
          return Ta(i, a.getObjectProperty(), o), i;
        } else
          throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (u) {
      throw Gr(u);
    }
  };
}
var En = [{
  // assignment
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  // conditional expression
  ConditionalNode: {
    latexLeftParens: !1,
    latexRightParens: !1,
    latexParens: !1
    // conditionals don't need parentheses in LaTeX because
    // they are 2 dimensional
  }
}, {
  // logical or
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical xor
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical and
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise or
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise xor
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise and
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  // relational operators
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitshift operators
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  // unit conversion
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  // range
  RangeNode: {}
}, {
  // addition, subtraction
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  // multiply, divide, modulus
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: !1,
    latexRightParens: !1,
    latexParens: !1
    // fractions don't require parentheses because
    // they're 2 dimensional, so parens aren't needed
    // in LaTeX
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  // Repeat multiplication for implicit multiplication
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  // unary prefix operators
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  // exponentiation
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: !1
    // the exponent doesn't need parentheses in
    // LaTeX because it's 2 dimensional
    // (it's on top)
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  // factorial
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  // matrix transpose
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];
function _o(t, e) {
  if (!e || e !== "auto") return t;
  for (var r = t; Cn(r); ) r = r.content;
  return r;
}
function Lt(t, e, r, n) {
  var i = t;
  e !== "keep" && (i = t.getContent());
  for (var a = i.getIdentifier(), o = null, f = 0; f < En.length; f++)
    if (a in En[f]) {
      o = f;
      break;
    }
  if (a === "OperatorNode:multiply" && i.implicit && r !== "show") {
    var u = _o(i.args[0], e);
    !(wt(u) && n && n.getIdentifier() === "OperatorNode:divide" && kh(_o(n.args[0], e))) && !(u.getIdentifier() === "OperatorNode:divide" && kh(_o(u.args[0], e)) && wt(_o(u.args[1]))) && (o += 1);
  }
  return o;
}
function vs(t, e) {
  var r = t;
  e !== "keep" && (r = t.getContent());
  var n = r.getIdentifier(), i = Lt(r, e);
  if (i === null)
    return null;
  var a = En[i][n];
  if ($e(a, "associativity")) {
    if (a.associativity === "left")
      return "left";
    if (a.associativity === "right")
      return "right";
    throw Error("'" + n + "' has the invalid associativity '" + a.associativity + "'.");
  }
  return null;
}
function Bh(t, e, r) {
  var n = r !== "keep" ? t.getContent() : t, i = r !== "keep" ? t.getContent() : e, a = n.getIdentifier(), o = i.getIdentifier(), f = Lt(n, r);
  if (f === null)
    return null;
  var u = En[f][a];
  if ($e(u, "associativeWith") && u.associativeWith instanceof Array) {
    for (var s = 0; s < u.associativeWith.length; s++)
      if (u.associativeWith[s] === o)
        return !0;
    return !1;
  }
  return null;
}
function oI(t) {
  var e = "OperatorNode:" + t;
  for (var r of En)
    if (e in r)
      return r[e].op;
  return null;
}
var Mo = "AssignmentNode", uI = [
  "subset",
  "?matrix",
  // FIXME: should not be needed at all, should be handled by subset
  "Node"
], Qc = /* @__PURE__ */ H(Mo, uI, (t) => {
  var {
    subset: e,
    matrix: r,
    Node: n
  } = t, i = Ww({
    subset: e
  }), a = sI({
    subset: e,
    matrix: r
  });
  function o(u, s, c) {
    s || (s = "keep");
    var l = Lt(u, s, c), m = Lt(u.value, s, c);
    return s === "all" || m !== null && m <= l;
  }
  class f extends n {
    /**
     * @constructor AssignmentNode
     * @extends {Node}
     *
     * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
     * replace a subset of a matrix like `A[2,2]=42`.
     *
     * Syntax:
     *
     *     new AssignmentNode(symbol, value)
     *     new AssignmentNode(object, index, value)
     *
     * Usage:
     *
     *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode('b'),
     *                       new ConstantNode(2))   // a.b=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode(1, 2),
     *                       new ConstantNode(3))  // a[1,2]=3
     *
     * @param {SymbolNode | AccessorNode} object
     *     Object on which to assign a value
     * @param {IndexNode} [index=null]
     *     Index, property name or matrix index. Optional. If not provided
     *     and `object` is a SymbolNode, the property is assigned to the
     *     global scope.
     * @param {Node} value
     *     The value to be assigned
     */
    constructor(s, c, l) {
      if (super(), this.object = s, this.index = l ? c : null, this.value = l || c, !ir(s) && !Kn(s))
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      if (ir(s) && s.name === "end")
        throw new Error('Cannot assign to symbol "end"');
      if (this.index && !bi(this.index))
        throw new TypeError('IndexNode expected as "index"');
      if (!Bt(this.value))
        throw new TypeError('Node expected as "value"');
    }
    // class name for typing purposes:
    // readonly property name
    get name() {
      return this.index ? this.index.isObjectProperty() ? this.index.getObjectProperty() : "" : this.object.name || "";
    }
    get type() {
      return Mo;
    }
    get isAssignmentNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, c) {
      var l = this.object._compile(s, c), m = this.index ? this.index._compile(s, c) : null, h = this.value._compile(s, c), g = this.object.name;
      if (this.index)
        if (this.index.isObjectProperty()) {
          var d = this.index.getObjectProperty();
          return function(N, D, b) {
            var C = l(N, D, b), A = h(N, D, b);
            return Ta(C, d, A), A;
          };
        } else {
          if (ir(this.object))
            return function(N, D, b) {
              var C = l(N, D, b), A = h(N, D, b), T = m(N, D, C);
              return N.set(g, a(C, T, A)), A;
            };
          var y = this.object.object._compile(s, c);
          if (this.object.index.isObjectProperty()) {
            var w = this.object.index.getObjectProperty();
            return function(N, D, b) {
              var C = y(N, D, b), A = kr(C, w), T = m(N, D, A), _ = h(N, D, b);
              return Ta(C, w, a(A, T, _)), _;
            };
          } else {
            var E = this.object.index._compile(s, c);
            return function(N, D, b) {
              var C = y(N, D, b), A = E(N, D, C), T = i(C, A), _ = m(N, D, T), O = h(N, D, b);
              return a(C, A, a(T, _, O)), O;
            };
          }
        }
      else {
        if (!ir(this.object))
          throw new TypeError("SymbolNode expected as object");
        return function(N, D, b) {
          var C = h(N, D, b);
          return N.set(g, C), C;
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      s(this.object, "object", this), this.index && s(this.index, "index", this), s(this.value, "value", this);
    }
    /**
     * Create a new AssignmentNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AssignmentNode} Returns a transformed copy of the node
     */
    map(s) {
      var c = this._ifNode(s(this.object, "object", this)), l = this.index ? this._ifNode(s(this.index, "index", this)) : null, m = this._ifNode(s(this.value, "value", this));
      return new f(c, l, m);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AssignmentNode}
     */
    clone() {
      return new f(this.object, this.index, this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(s) {
      var c = this.object.toString(s), l = this.index ? this.index.toString(s) : "", m = this.value.toString(s);
      return o(this, s && s.parenthesis, s && s.implicit) && (m = "(" + m + ")"), c + l + " = " + m;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Mo,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
     *     where mathjs is optional
     * @returns {AssignmentNode}
     */
    static fromJSON(s) {
      return new f(s.object, s.index, s.value);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(s) {
      var c = this.object.toHTML(s), l = this.index ? this.index.toHTML(s) : "", m = this.value.toHTML(s);
      return o(this, s && s.parenthesis, s && s.implicit) && (m = '<span class="math-paranthesis math-round-parenthesis">(</span>' + m + '<span class="math-paranthesis math-round-parenthesis">)</span>'), c + l + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + m;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(s) {
      var c = this.object.toTex(s), l = this.index ? this.index.toTex(s) : "", m = this.value.toTex(s);
      return o(this, s && s.parenthesis, s && s.implicit) && (m = "\\left(".concat(m, "\\right)")), c + l + "=" + m;
    }
  }
  return lr(f, "name", Mo), f;
}, {
  isClass: !0,
  isNode: !0
}), Oo = "BlockNode", lI = ["ResultSet", "Node"], Vc = /* @__PURE__ */ H(Oo, lI, (t) => {
  var {
    ResultSet: e,
    Node: r
  } = t;
  class n extends r {
    /**
     * @constructor BlockNode
     * @extends {Node}
     * Holds a set with blocks
     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
     *            An array with blocks, where a block is constructed as an
     *            Object with properties block, which is a Node, and visible,
     *            which is a boolean. The property visible is optional and
     *            is true by default
     */
    constructor(a) {
      if (super(), !Array.isArray(a)) throw new Error("Array expected");
      this.blocks = a.map(function(o) {
        var f = o && o.node, u = o && o.visible !== void 0 ? o.visible : !0;
        if (!Bt(f)) throw new TypeError('Property "node" must be a Node');
        if (typeof u != "boolean")
          throw new TypeError('Property "visible" must be a boolean');
        return {
          node: f,
          visible: u
        };
      });
    }
    get type() {
      return Oo;
    }
    get isBlockNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, o) {
      var f = Xn(this.blocks, function(u) {
        return {
          evaluate: u.node._compile(a, o),
          visible: u.visible
        };
      });
      return function(s, c, l) {
        var m = [];
        return Ou(f, function(g) {
          var d = g.evaluate(s, c, l);
          g.visible && m.push(d);
        }), new e(m);
      };
    }
    /**
     * Execute a callback for each of the child blocks of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      for (var o = 0; o < this.blocks.length; o++)
        a(this.blocks[o].node, "blocks[" + o + "].node", this);
    }
    /**
     * Create a new BlockNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {BlockNode} Returns a transformed copy of the node
     */
    map(a) {
      for (var o = [], f = 0; f < this.blocks.length; f++) {
        var u = this.blocks[f], s = this._ifNode(a(u.node, "blocks[" + f + "].node", this));
        o[f] = {
          node: s,
          visible: u.visible
        };
      }
      return new n(o);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {BlockNode}
     */
    clone() {
      var a = this.blocks.map(function(o) {
        return {
          node: o.node,
          visible: o.visible
        };
      });
      return new n(a);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(a) {
      return this.blocks.map(function(o) {
        return o.node.toString(a) + (o.visible ? "" : ";");
      }).join(`
`);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Oo,
        blocks: this.blocks
      };
    }
    /**
     * Instantiate an BlockNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
     *     where mathjs is optional
     * @returns {BlockNode}
     */
    static fromJSON(a) {
      return new n(a.blocks);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(a) {
      return this.blocks.map(function(o) {
        return o.node.toHTML(a) + (o.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(a) {
      return this.blocks.map(function(o) {
        return o.node.toTex(a) + (o.visible ? "" : ";");
      }).join(`\\;\\;
`);
    }
  }
  return lr(n, "name", Oo), n;
}, {
  isClass: !0,
  isNode: !0
}), qo = "ConditionalNode", cI = ["Node"], Wc = /* @__PURE__ */ H(qo, cI, (t) => {
  var {
    Node: e
  } = t;
  function r(i) {
    if (typeof i == "number" || typeof i == "boolean" || typeof i == "string")
      return !!i;
    if (i) {
      if (at(i))
        return !i.isZero();
      if (dn(i))
        return !!(i.re || i.im);
      if (Lr(i))
        return !!i.value;
    }
    if (i == null)
      return !1;
    throw new TypeError('Unsupported type of condition "' + kt(i) + '"');
  }
  class n extends e {
    /**
     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
     *
     * @param {Node} condition   Condition, must result in a boolean
     * @param {Node} trueExpr    Expression evaluated when condition is true
     * @param {Node} falseExpr   Expression evaluated when condition is true
     *
     * @constructor ConditionalNode
     * @extends {Node}
     */
    constructor(a, o, f) {
      if (super(), !Bt(a))
        throw new TypeError("Parameter condition must be a Node");
      if (!Bt(o))
        throw new TypeError("Parameter trueExpr must be a Node");
      if (!Bt(f))
        throw new TypeError("Parameter falseExpr must be a Node");
      this.condition = a, this.trueExpr = o, this.falseExpr = f;
    }
    get type() {
      return qo;
    }
    get isConditionalNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, o) {
      var f = this.condition._compile(a, o), u = this.trueExpr._compile(a, o), s = this.falseExpr._compile(a, o);
      return function(l, m, h) {
        return r(f(l, m, h)) ? u(l, m, h) : s(l, m, h);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      a(this.condition, "condition", this), a(this.trueExpr, "trueExpr", this), a(this.falseExpr, "falseExpr", this);
    }
    /**
     * Create a new ConditionalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ConditionalNode} Returns a transformed copy of the node
     */
    map(a) {
      return new n(this._ifNode(a(this.condition, "condition", this)), this._ifNode(a(this.trueExpr, "trueExpr", this)), this._ifNode(a(this.falseExpr, "falseExpr", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConditionalNode}
     */
    clone() {
      return new n(this.condition, this.trueExpr, this.falseExpr);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(a) {
      var o = a && a.parenthesis ? a.parenthesis : "keep", f = Lt(this, o, a && a.implicit), u = this.condition.toString(a), s = Lt(this.condition, o, a && a.implicit);
      (o === "all" || this.condition.type === "OperatorNode" || s !== null && s <= f) && (u = "(" + u + ")");
      var c = this.trueExpr.toString(a), l = Lt(this.trueExpr, o, a && a.implicit);
      (o === "all" || this.trueExpr.type === "OperatorNode" || l !== null && l <= f) && (c = "(" + c + ")");
      var m = this.falseExpr.toString(a), h = Lt(this.falseExpr, o, a && a.implicit);
      return (o === "all" || this.falseExpr.type === "OperatorNode" || h !== null && h <= f) && (m = "(" + m + ")"), u + " ? " + c + " : " + m;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: qo,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    /**
     * Instantiate an ConditionalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "ConditionalNode",
     *      "condition": ...,
     *      "trueExpr": ...,
     *      "falseExpr": ...}
     *     ```
     *     where mathjs is optional
     * @returns {ConditionalNode}
     */
    static fromJSON(a) {
      return new n(a.condition, a.trueExpr, a.falseExpr);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(a) {
      var o = a && a.parenthesis ? a.parenthesis : "keep", f = Lt(this, o, a && a.implicit), u = this.condition.toHTML(a), s = Lt(this.condition, o, a && a.implicit);
      (o === "all" || this.condition.type === "OperatorNode" || s !== null && s <= f) && (u = '<span class="math-parenthesis math-round-parenthesis">(</span>' + u + '<span class="math-parenthesis math-round-parenthesis">)</span>');
      var c = this.trueExpr.toHTML(a), l = Lt(this.trueExpr, o, a && a.implicit);
      (o === "all" || this.trueExpr.type === "OperatorNode" || l !== null && l <= f) && (c = '<span class="math-parenthesis math-round-parenthesis">(</span>' + c + '<span class="math-parenthesis math-round-parenthesis">)</span>');
      var m = this.falseExpr.toHTML(a), h = Lt(this.falseExpr, o, a && a.implicit);
      return (o === "all" || this.falseExpr.type === "OperatorNode" || h !== null && h <= f) && (m = '<span class="math-parenthesis math-round-parenthesis">(</span>' + m + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u + '<span class="math-operator math-conditional-operator">?</span>' + c + '<span class="math-operator math-conditional-operator">:</span>' + m;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(a) {
      return "\\begin{cases} {" + this.trueExpr.toTex(a) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(a) + "}\\\\{" + this.falseExpr.toTex(a) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  return lr(n, "name", qo), n;
}, {
  isClass: !0,
  isNode: !0
}), rd = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e];
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
  }
  return t;
}, fI = {
  "{": "\\{",
  "}": "\\}",
  "\\": "\\textbackslash{}",
  "#": "\\#",
  $: "\\$",
  "%": "\\%",
  "&": "\\&",
  "^": "\\textasciicircum{}",
  _: "\\_",
  "~": "\\textasciitilde{}"
}, pI = {
  "–": "\\--",
  "—": "\\---",
  " ": "~",
  "	": "\\qquad{}",
  "\r\n": "\\newline{}",
  "\n": "\\newline{}"
}, mI = function(e, r) {
  return rd({}, e, r);
}, hI = function(t) {
  for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = e.preserveFormatting, n = r === void 0 ? !1 : r, i = e.escapeMapFn, a = i === void 0 ? mI : i, o = String(t), f = "", u = a(rd({}, fI), n ? rd({}, pI) : {}), s = Object.keys(u), c = function() {
    var m = !1;
    s.forEach(function(h, g) {
      m || o.length >= h.length && o.slice(0, h.length) === h && (f += u[s[g]], o = o.slice(h.length, o.length), m = !0);
    }), m || (f += o.slice(0, 1), o = o.slice(1, o.length));
  }; o; )
    c();
  return f;
};
const dI = /* @__PURE__ */ qs(hI);
var nd = {
  // GREEK LETTERS
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  // logic
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  // other
  i: "i",
  // TODO use \i ??
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
}, Tt = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  // TODO find ideal solution
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  // TODO find ideal solution
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  // TODO how to handle that properly?
  dotMultiply: ".\\cdot",
  // TODO find ideal solution
  dotDivide: ".:",
  // TODO find ideal solution
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
}, Kx = {
  // arithmetic
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(Tt.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(Tt.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(Tt.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(Tt.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(Tt.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(Tt.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(Tt.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: void 0
    // use default template
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(Tt.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: void 0
    // use default template
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(Tt.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(Tt.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(Tt.unaryPlus, "\\left(${args[0]}\\right)")
  },
  // bitwise
  bitAnd: {
    2: "\\left(${args[0]}".concat(Tt.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: Tt.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(Tt.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(Tt.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(Tt.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(Tt.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(Tt.rightLogShift, "${args[1]}\\right)")
  },
  // combinatorics
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  // complex
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  // logical
  and: {
    2: "\\left(${args[0]}".concat(Tt.and, "${args[1]}\\right)")
  },
  not: {
    1: Tt.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(Tt.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(Tt.xor, "${args[1]}\\right)")
  },
  // matrix
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(Tt.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(Tt.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(Tt.transpose)
  },
  // probability
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(Tt.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  // relational
  equal: {
    2: "\\left(${args[0]}".concat(Tt.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(Tt.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(Tt.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(Tt.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(Tt.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(Tt.unequal, "${args[1]}\\right)")
  },
  // special
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  // statistics
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  // trigonometry
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  // unit
  to: {
    2: "\\left(${args[0]}".concat(Tt.to, "${args[1]}\\right)")
  },
  // utils
  numeric: function(e, r) {
    return e.args[0].toTex();
  },
  // type
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  bigint: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(nd.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
}, gI = "\\mathrm{${name}}\\left(${args}\\right)", eb = {
  deg: "^\\circ"
};
function id(t) {
  return dI(t, {
    preserveFormatting: !0
  });
}
function jw(t, e) {
  return e = typeof e > "u" ? !1 : e, e ? $e(eb, t) ? eb[t] : "\\mathrm{" + id(t) + "}" : $e(nd, t) ? nd[t] : id(t);
}
var Io = "ConstantNode", vI = ["Node"], jc = /* @__PURE__ */ H(Io, vI, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * A ConstantNode holds a constant value like a number or string.
     *
     * Usage:
     *
     *     new ConstantNode(2.3)
     *     new ConstantNode('hello')
     *
     * @param {*} value    Value can be any type (number, BigNumber, bigint, string, ...)
     * @constructor ConstantNode
     * @extends {Node}
     */
    constructor(i) {
      super(), this.value = i;
    }
    get type() {
      return Io;
    }
    get isConstantNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(i, a) {
      var o = this.value;
      return function() {
        return o;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(i) {
    }
    /**
     * Create a new ConstantNode with children produced by the given callback.
     * Trivial because there are no children.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ConstantNode} Returns a clone of the node
     */
    map(i) {
      return this.clone();
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConstantNode}
     */
    clone() {
      return new r(this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(i) {
      return vt(this.value, i);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(i) {
      var a = this._toString(i);
      switch (kt(this.value)) {
        case "number":
        case "bigint":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + a + "</span>";
        case "string":
          return '<span class="math-string">' + a + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + a + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + a + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + a + "</span>";
        default:
          return '<span class="math-symbol">' + a + "</span>";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Io,
        value: this.value
      };
    }
    /**
     * Instantiate a ConstantNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", value: 2.3}`,
     *                       where mathjs is optional
     * @returns {ConstantNode}
     */
    static fromJSON(i) {
      return new r(i.value);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(i) {
      var a = this._toString(i), o = kt(this.value);
      switch (o) {
        case "string":
          return "\\mathtt{" + id(a) + "}";
        case "number":
        case "BigNumber": {
          var f = o === "BigNumber" ? this.value.isFinite() : isFinite(this.value);
          if (!f)
            return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
          var u = a.toLowerCase().indexOf("e");
          return u !== -1 ? a.substring(0, u) + "\\cdot10^{" + a.substring(u + 1) + "}" : a;
        }
        case "bigint":
          return a.toString();
        case "Fraction":
          return this.value.toLatex();
        default:
          return a;
      }
    }
  }
  return lr(r, "name", Io), r;
}, {
  isClass: !0,
  isNode: !0
}), Fo = "FunctionAssignmentNode", yI = ["typed", "Node"], Yc = /* @__PURE__ */ H(Fo, yI, (t) => {
  var {
    typed: e,
    Node: r
  } = t;
  function n(a, o, f) {
    var u = Lt(a, o, f), s = Lt(a.expr, o, f);
    return o === "all" || s !== null && s <= u;
  }
  class i extends r {
    /**
     * @constructor FunctionAssignmentNode
     * @extends {Node}
     * Function assignment
     *
     * @param {string} name           Function name
     * @param {string[] | Array.<{name: string, type: string}>} params
     *                                Array with function parameter names, or an
     *                                array with objects containing the name
     *                                and type of the parameter
     * @param {Node} expr             The function expression
     */
    constructor(o, f, u) {
      if (super(), typeof o != "string")
        throw new TypeError('String expected for parameter "name"');
      if (!Array.isArray(f))
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      if (!Bt(u))
        throw new TypeError('Node expected for parameter "expr"');
      if (Vw.has(o))
        throw new Error('Illegal function name, "' + o + '" is a reserved keyword');
      var s = /* @__PURE__ */ new Set();
      for (var c of f) {
        var l = typeof c == "string" ? c : c.name;
        if (s.has(l))
          throw new Error('Duplicate parameter name "'.concat(l, '"'));
        s.add(l);
      }
      this.name = o, this.params = f.map(function(m) {
        return m && m.name || m;
      }), this.types = f.map(function(m) {
        return m && m.type || "any";
      }), this.expr = u;
    }
    get type() {
      return Fo;
    }
    get isFunctionAssignmentNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(o, f) {
      var u = Object.create(f);
      Ou(this.params, function(g) {
        u[g] = !0;
      });
      var s = this.expr._compile(o, u), c = this.name, l = this.params, m = e1(this.types, ","), h = c + "(" + e1(this.params, ", ") + ")";
      return function(d, y, w) {
        var E = {};
        E[m] = function() {
          for (var N = Object.create(y), D = 0; D < l.length; D++)
            N[l[D]] = arguments[D];
          return s(d, N, w);
        };
        var x = e(c, E);
        return x.syntax = h, d.set(c, x), x;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(o) {
      o(this.expr, "expr", this);
    }
    /**
     * Create a new FunctionAssignmentNode whose children are the results of
     * calling the provided callback function for each child of the original
     * node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
     */
    map(o) {
      var f = this._ifNode(o(this.expr, "expr", this));
      return new i(this.name, this.params.slice(0), f);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionAssignmentNode}
     */
    clone() {
      return new i(this.name, this.params.slice(0), this.expr);
    }
    /**
     * get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(o) {
      var f = o && o.parenthesis ? o.parenthesis : "keep", u = this.expr.toString(o);
      return n(this, f, o && o.implicit) && (u = "(" + u + ")"), this.name + "(" + this.params.join(", ") + ") = " + u;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      var o = this.types;
      return {
        mathjs: Fo,
        name: this.name,
        params: this.params.map(function(f, u) {
          return {
            name: f,
            type: o[u]
          };
        }),
        expr: this.expr
      };
    }
    /**
     * Instantiate an FunctionAssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "FunctionAssignmentNode",
     *      name: ..., params: ..., expr: ...}
     *     ```
     *     where mathjs is optional
     * @returns {FunctionAssignmentNode}
     */
    static fromJSON(o) {
      return new i(o.name, o.params, o.expr);
    }
    /**
     * get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(o) {
      for (var f = o && o.parenthesis ? o.parenthesis : "keep", u = [], s = 0; s < this.params.length; s++)
        u.push('<span class="math-symbol math-parameter">' + hn(this.params[s]) + "</span>");
      var c = this.expr.toHTML(o);
      return n(this, f, o && o.implicit) && (c = '<span class="math-parenthesis math-round-parenthesis">(</span>' + c + '<span class="math-parenthesis math-round-parenthesis">)</span>'), '<span class="math-function">' + hn(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + u.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + c;
    }
    /**
     * get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(o) {
      var f = o && o.parenthesis ? o.parenthesis : "keep", u = this.expr.toTex(o);
      return n(this, f, o && o.implicit) && (u = "\\left(".concat(u, "\\right)")), "\\mathrm{" + this.name + "}\\left(" + this.params.map(jw).join(",") + "\\right)=" + u;
    }
  }
  return lr(i, "name", Fo), i;
}, {
  isClass: !0,
  isNode: !0
}), Bo = "IndexNode", xI = ["Node", "size"], Zc = /* @__PURE__ */ H(Bo, xI, (t) => {
  var {
    Node: e,
    size: r
  } = t;
  class n extends e {
    /**
     * @constructor IndexNode
     * @extends Node
     *
     * Describes a subset of a matrix or an object property.
     * Cannot be used on its own, needs to be used within an AccessorNode or
     * AssignmentNode.
     *
     * @param {Node[]} dimensions
     * @param {boolean} [dotNotation=false]
     *     Optional property describing whether this index was written using dot
     *     notation like `a.b`, or using bracket notation like `a["b"]`
     *     (which is the default). This property is used for string conversion.
     */
    constructor(a, o) {
      if (super(), this.dimensions = a, this.dotNotation = o || !1, !Array.isArray(a) || !a.every(Bt))
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      if (this.dotNotation && !this.isObjectProperty())
        throw new Error("dotNotation only applicable for object properties");
    }
    get type() {
      return Bo;
    }
    get isIndexNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, o) {
      var f = Xn(this.dimensions, function(s, c) {
        var l = s.filter((g) => g.isSymbolNode && g.name === "end").length > 0;
        if (l) {
          var m = Object.create(o);
          m.end = !0;
          var h = s._compile(a, m);
          return function(d, y, w) {
            if (!Ye(w) && !_t(w) && !hr(w))
              throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + kt(w));
            var E = r(w).valueOf(), x = Object.create(y);
            return x.end = E[c], h(d, x, w);
          };
        } else
          return s._compile(a, o);
      }), u = kr(a, "index");
      return function(c, l, m) {
        var h = Xn(f, function(g) {
          return g(c, l, m);
        });
        return u(...h);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      for (var o = 0; o < this.dimensions.length; o++)
        a(this.dimensions[o], "dimensions[" + o + "]", this);
    }
    /**
     * Create a new IndexNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {IndexNode} Returns a transformed copy of the node
     */
    map(a) {
      for (var o = [], f = 0; f < this.dimensions.length; f++)
        o[f] = this._ifNode(a(this.dimensions[f], "dimensions[" + f + "]", this));
      return new n(o, this.dotNotation);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {IndexNode}
     */
    clone() {
      return new n(this.dimensions.slice(0), this.dotNotation);
    }
    /**
     * Test whether this IndexNode contains a single property name
     * @return {boolean}
     */
    isObjectProperty() {
      return this.dimensions.length === 1 && wt(this.dimensions[0]) && typeof this.dimensions[0].value == "string";
    }
    /**
     * Returns the property name if IndexNode contains a property.
     * If not, returns null.
     * @return {string | null}
     */
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(a) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Bo,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    /**
     * Instantiate an IndexNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
     *     where mathjs is optional
     * @returns {IndexNode}
     */
    static fromJSON(a) {
      return new n(a.dimensions, a.dotNotation);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(a) {
      for (var o = [], f = 0; f < this.dimensions.length; f++)
        o[f] = this.dimensions[f].toHTML();
      return this.dotNotation ? '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + hn(this.getObjectProperty()) + "</span>" : '<span class="math-parenthesis math-square-parenthesis">[</span>' + o.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(a) {
      var o = this.dimensions.map(function(f) {
        return f.toTex(a);
      });
      return this.dotNotation ? "." + this.getObjectProperty() : "_{" + o.join(",") + "}";
    }
  }
  return lr(n, "name", Bo), n;
}, {
  isClass: !0,
  isNode: !0
}), Ro = "ObjectNode", bI = ["Node"], Jc = /* @__PURE__ */ H(Ro, bI, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * @constructor ObjectNode
     * @extends {Node}
     * Holds an object with keys/values
     * @param {Object.<string, Node>} [properties]   object with key/value pairs
     */
    constructor(i) {
      if (super(), this.properties = i || {}, i && (typeof i != "object" || !Object.keys(i).every(function(a) {
        return Bt(i[a]);
      })))
        throw new TypeError("Object containing Nodes expected");
    }
    get type() {
      return Ro;
    }
    get isObjectNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(i, a) {
      var o = {};
      for (var f in this.properties)
        if ($e(this.properties, f)) {
          var u = Da(f), s = JSON.parse(u), c = kr(this.properties, f);
          o[s] = c._compile(i, a);
        }
      return function(m, h, g) {
        var d = {};
        for (var y in o)
          $e(o, y) && (d[y] = o[y](m, h, g));
        return d;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(i) {
      for (var a in this.properties)
        $e(this.properties, a) && i(this.properties[a], "properties[" + Da(a) + "]", this);
    }
    /**
     * Create a new ObjectNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ObjectNode} Returns a transformed copy of the node
     */
    map(i) {
      var a = {};
      for (var o in this.properties)
        $e(this.properties, o) && (a[o] = this._ifNode(i(this.properties[o], "properties[" + Da(o) + "]", this)));
      return new r(a);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ObjectNode}
     */
    clone() {
      var i = {};
      for (var a in this.properties)
        $e(this.properties, a) && (i[a] = this.properties[a]);
      return new r(i);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(i) {
      var a = [];
      for (var o in this.properties)
        $e(this.properties, o) && a.push(Da(o) + ": " + this.properties[o].toString(i));
      return "{" + a.join(", ") + "}";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Ro,
        properties: this.properties
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
     *                       where mathjs is optional
     * @returns {ObjectNode}
     */
    static fromJSON(i) {
      return new r(i.properties);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(i) {
      var a = [];
      for (var o in this.properties)
        $e(this.properties, o) && a.push('<span class="math-symbol math-property">' + hn(o) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[o].toHTML(i));
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + a.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(i) {
      var a = [];
      for (var o in this.properties)
        $e(this.properties, o) && a.push("\\mathbf{" + o + ":} & " + this.properties[o].toTex(i) + "\\\\");
      var f = "\\left\\{\\begin{array}{ll}" + a.join(`
`) + "\\end{array}\\right\\}";
      return f;
    }
  }
  return lr(r, "name", Ro), r;
}, {
  isClass: !0,
  isNode: !0
});
function xs(t, e) {
  return new E2(t, new bu(e), new Set(Object.keys(e)));
}
var Po = "OperatorNode", wI = ["Node"], Xc = /* @__PURE__ */ H(Po, wI, (t) => {
  var {
    Node: e
  } = t;
  function r(a, o) {
    var f = a;
    if (o === "auto")
      for (; Cn(f); ) f = f.content;
    return wt(f) ? !0 : Kt(f) ? r(f.args[0], o) : !1;
  }
  function n(a, o, f, u, s) {
    var c = Lt(a, o, f), l = vs(a, o);
    if (o === "all" || u.length > 2 && a.getIdentifier() !== "OperatorNode:add" && a.getIdentifier() !== "OperatorNode:multiply")
      return u.map(function(_) {
        switch (_.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return !1;
          default:
            return !0;
        }
      });
    var m;
    switch (u.length) {
      case 0:
        m = [];
        break;
      case 1:
        {
          var h = Lt(u[0], o, f, a);
          if (s && h !== null) {
            var g, d;
            if (o === "keep" ? (g = u[0].getIdentifier(), d = a.getIdentifier()) : (g = u[0].getContent().getIdentifier(), d = a.getContent().getIdentifier()), En[c][d].latexLeftParens === !1) {
              m = [!1];
              break;
            }
            if (En[h][g].latexParens === !1) {
              m = [!1];
              break;
            }
          }
          if (h === null) {
            m = [!1];
            break;
          }
          if (h <= c) {
            m = [!0];
            break;
          }
          m = [!1];
        }
        break;
      case 2:
        {
          var y, w = Lt(u[0], o, f, a), E = Bh(a, u[0], o);
          w === null ? y = !1 : w === c && l === "right" && !E || w < c ? y = !0 : y = !1;
          var x, N = Lt(u[1], o, f, a), D = Bh(a, u[1], o);
          if (N === null ? x = !1 : N === c && l === "left" && !D || N < c ? x = !0 : x = !1, s) {
            var b, C, A;
            o === "keep" ? (b = a.getIdentifier(), C = a.args[0].getIdentifier(), A = a.args[1].getIdentifier()) : (b = a.getContent().getIdentifier(), C = a.args[0].getContent().getIdentifier(), A = a.args[1].getContent().getIdentifier()), w !== null && (En[c][b].latexLeftParens === !1 && (y = !1), En[w][C].latexParens === !1 && (y = !1)), N !== null && (En[c][b].latexRightParens === !1 && (x = !1), En[N][A].latexParens === !1 && (x = !1));
          }
          m = [y, x];
        }
        break;
      default:
        (a.getIdentifier() === "OperatorNode:add" || a.getIdentifier() === "OperatorNode:multiply") && (m = u.map(function(_) {
          var O = Lt(_, o, f, a), I = Bh(a, _, o), B = vs(_, o);
          return O === null ? !1 : c === O && l === B && !I ? !0 : O < c;
        }));
        break;
    }
    if (u.length >= 2 && a.getIdentifier() === "OperatorNode:multiply" && a.implicit && o !== "all" && f === "hide")
      for (var T = 1; T < m.length; ++T)
        r(u[T], o) && !m[T - 1] && (o !== "keep" || !Cn(u[T - 1])) && (m[T] = !0);
    return m;
  }
  class i extends e {
    /**
     * @constructor OperatorNode
     * @extends {Node}
     * An operator with two arguments, like 2+3
     *
     * @param {string} op           Operator name, for example '+'
     * @param {string} fn           Function name, for example 'add'
     * @param {Node[]} args         Operator arguments
     * @param {boolean} [implicit]  Is this an implicit multiplication?
     * @param {boolean} [isPercentage] Is this an percentage Operation?
     */
    constructor(o, f, u, s, c) {
      if (super(), typeof o != "string")
        throw new TypeError('string expected for parameter "op"');
      if (typeof f != "string")
        throw new TypeError('string expected for parameter "fn"');
      if (!Array.isArray(u) || !u.every(Bt))
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      this.implicit = s === !0, this.isPercentage = c === !0, this.op = o, this.fn = f, this.args = u || [];
    }
    get type() {
      return Po;
    }
    get isOperatorNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(o, f) {
      if (typeof this.fn != "string" || !wd(o, this.fn))
        throw o[this.fn] ? new Error('No access to function "' + this.fn + '"') : new Error("Function " + this.fn + ' missing in provided namespace "math"');
      var u = kr(o, this.fn), s = Xn(this.args, function(g) {
        return g._compile(o, f);
      });
      if (typeof u == "function" && u.rawArgs === !0) {
        var c = this.args;
        return function(d, y, w) {
          return u(c, o, xs(d, y));
        };
      } else if (s.length === 1) {
        var l = s[0];
        return function(d, y, w) {
          return u(l(d, y, w));
        };
      } else if (s.length === 2) {
        var m = s[0], h = s[1];
        return function(d, y, w) {
          return u(m(d, y, w), h(d, y, w));
        };
      } else
        return function(d, y, w) {
          return u.apply(null, Xn(s, function(E) {
            return E(d, y, w);
          }));
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(o) {
      for (var f = 0; f < this.args.length; f++)
        o(this.args[f], "args[" + f + "]", this);
    }
    /**
     * Create a new OperatorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(o) {
      for (var f = [], u = 0; u < this.args.length; u++)
        f[u] = this._ifNode(o(this.args[u], "args[" + u + "]", this));
      return new i(this.op, this.fn, f, this.implicit, this.isPercentage);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {OperatorNode}
     */
    clone() {
      return new i(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    /**
     * Check whether this is an unary OperatorNode:
     * has exactly one argument, like `-a`.
     * @return {boolean}
     *     Returns true when an unary operator node, false otherwise.
     */
    isUnary() {
      return this.args.length === 1;
    }
    /**
     * Check whether this is a binary OperatorNode:
     * has exactly two arguments, like `a + b`.
     * @return {boolean}
     *     Returns true when a binary operator node, false otherwise.
     */
    isBinary() {
      return this.args.length === 2;
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(o) {
      var f = o && o.parenthesis ? o.parenthesis : "keep", u = o && o.implicit ? o.implicit : "hide", s = this.args, c = n(this, f, u, s, !1);
      if (s.length === 1) {
        var l = vs(this, f), m = s[0].toString(o);
        c[0] && (m = "(" + m + ")");
        var h = /[a-zA-Z]+/.test(this.op);
        return l === "right" ? this.op + (h ? " " : "") + m : l === "left" ? m + (h ? " " : "") + this.op : m + this.op;
      } else if (s.length === 2) {
        var g = s[0].toString(o), d = s[1].toString(o);
        return c[0] && (g = "(" + g + ")"), c[1] && (d = "(" + d + ")"), this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? g + " " + d : g + " " + this.op + " " + d;
      } else if (s.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var y = s.map(function(w, E) {
          return w = w.toString(o), c[E] && (w = "(" + w + ")"), w;
        });
        return this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? y.join(" ") : y.join(" " + this.op + " ");
      } else
        return this.fn + "(" + this.args.join(", ") + ")";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Po,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "OperatorNode",
     *      "op": "+", "fn": "add", "args": [...],
     *      "implicit": false,
     *      "isPercentage":false}
     *     ```
     *     where mathjs is optional
     * @returns {OperatorNode}
     */
    static fromJSON(o) {
      return new i(o.op, o.fn, o.args, o.implicit, o.isPercentage);
    }
    /**
     * Get HTML representation.
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(o) {
      var f = o && o.parenthesis ? o.parenthesis : "keep", u = o && o.implicit ? o.implicit : "hide", s = this.args, c = n(this, f, u, s, !1);
      if (s.length === 1) {
        var l = vs(this, f), m = s[0].toHTML(o);
        return c[0] && (m = '<span class="math-parenthesis math-round-parenthesis">(</span>' + m + '<span class="math-parenthesis math-round-parenthesis">)</span>'), l === "right" ? '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + hn(this.op) + "</span>" + m : m + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + hn(this.op) + "</span>";
      } else if (s.length === 2) {
        var h = s[0].toHTML(o), g = s[1].toHTML(o);
        return c[0] && (h = '<span class="math-parenthesis math-round-parenthesis">(</span>' + h + '<span class="math-parenthesis math-round-parenthesis">)</span>'), c[1] && (g = '<span class="math-parenthesis math-round-parenthesis">(</span>' + g + '<span class="math-parenthesis math-round-parenthesis">)</span>'), this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? h + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + g : h + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + hn(this.op) + "</span>" + g;
      } else {
        var d = s.map(function(y, w) {
          return y = y.toHTML(o), c[w] && (y = '<span class="math-parenthesis math-round-parenthesis">(</span>' + y + '<span class="math-parenthesis math-round-parenthesis">)</span>'), y;
        });
        return s.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply") ? this.implicit && this.getIdentifier() === "OperatorNode:multiply" && u === "hide" ? d.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>') : d.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + hn(this.op) + "</span>") : '<span class="math-function">' + hn(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + d.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(o) {
      var f = o && o.parenthesis ? o.parenthesis : "keep", u = o && o.implicit ? o.implicit : "hide", s = this.args, c = n(this, f, u, s, !0), l = Tt[this.fn];
      if (l = typeof l > "u" ? this.op : l, s.length === 1) {
        var m = vs(this, f), h = s[0].toTex(o);
        return c[0] && (h = "\\left(".concat(h, "\\right)")), m === "right" ? l + h : h + l;
      } else if (s.length === 2) {
        var g = s[0], d = g.toTex(o);
        c[0] && (d = "\\left(".concat(d, "\\right)"));
        var y = s[1], w = y.toTex(o);
        c[1] && (w = "\\left(".concat(w, "\\right)"));
        var E;
        switch (f === "keep" ? E = g.getIdentifier() : E = g.getContent().getIdentifier(), this.getIdentifier()) {
          case "OperatorNode:divide":
            return l + "{" + d + "}{" + w + "}";
          case "OperatorNode:pow":
            switch (d = "{" + d + "}", w = "{" + w + "}", E) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                d = "\\left(".concat(d, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && u === "hide")
              return d + "~" + w;
        }
        return d + l + w;
      } else if (s.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var x = s.map(function(N, D) {
          return N = N.toTex(o), c[D] && (N = "\\left(".concat(N, "\\right)")), N;
        });
        return this.getIdentifier() === "OperatorNode:multiply" && this.implicit && u === "hide" ? x.join("~") : x.join(l);
      } else
        return "\\mathrm{" + this.fn + "}\\left(" + s.map(function(N) {
          return N.toTex(o);
        }).join(",") + "\\right)";
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  return lr(i, "name", Po), i;
}, {
  isClass: !0,
  isNode: !0
}), Lo = "ParenthesisNode", NI = ["Node"], Kc = /* @__PURE__ */ H(Lo, NI, (t) => {
  var {
    Node: e
  } = t;
  class r extends e {
    /**
     * @constructor ParenthesisNode
     * @extends {Node}
     * A parenthesis node describes manual parenthesis from the user input
     * @param {Node} content
     * @extends {Node}
     */
    constructor(i) {
      if (super(), !Bt(i))
        throw new TypeError('Node expected for parameter "content"');
      this.content = i;
    }
    get type() {
      return Lo;
    }
    get isParenthesisNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(i, a) {
      return this.content._compile(i, a);
    }
    /**
     * Get the content of the current Node.
     * @return {Node} content
     * @override
     **/
    getContent() {
      return this.content.getContent();
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(i) {
      i(this.content, "content", this);
    }
    /**
     * Create a new ParenthesisNode whose child is the result of calling
     * the provided callback function on the child of this node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ParenthesisNode} Returns a clone of the node
     */
    map(i) {
      var a = i(this.content, "content", this);
      return new r(a);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ParenthesisNode}
     */
    clone() {
      return new r(this.content);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(i) {
      return !i || i && !i.parenthesis || i && i.parenthesis === "keep" ? "(" + this.content.toString(i) + ")" : this.content.toString(i);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: Lo,
        content: this.content
      };
    }
    /**
     * Instantiate an ParenthesisNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
     *                       where mathjs is optional
     * @returns {ParenthesisNode}
     */
    static fromJSON(i) {
      return new r(i.content);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(i) {
      return !i || i && !i.parenthesis || i && i.parenthesis === "keep" ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(i) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : this.content.toHTML(i);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(i) {
      return !i || i && !i.parenthesis || i && i.parenthesis === "keep" ? "\\left(".concat(this.content.toTex(i), "\\right)") : this.content.toTex(i);
    }
  }
  return lr(r, "name", Lo), r;
}, {
  isClass: !0,
  isNode: !0
}), ko = "RangeNode", DI = ["Node"], ef = /* @__PURE__ */ H(ko, DI, (t) => {
  var {
    Node: e
  } = t;
  function r(i, a, o) {
    var f = Lt(i, a, o), u = {}, s = Lt(i.start, a, o);
    if (u.start = s !== null && s <= f || a === "all", i.step) {
      var c = Lt(i.step, a, o);
      u.step = c !== null && c <= f || a === "all";
    }
    var l = Lt(i.end, a, o);
    return u.end = l !== null && l <= f || a === "all", u;
  }
  class n extends e {
    /**
     * @constructor RangeNode
     * @extends {Node}
     * create a range
     * @param {Node} start  included lower-bound
     * @param {Node} end    included upper-bound
     * @param {Node} [step] optional step
     */
    constructor(a, o, f) {
      if (super(), !Bt(a)) throw new TypeError("Node expected");
      if (!Bt(o)) throw new TypeError("Node expected");
      if (f && !Bt(f)) throw new TypeError("Node expected");
      if (arguments.length > 3) throw new Error("Too many arguments");
      this.start = a, this.end = o, this.step = f || null;
    }
    get type() {
      return ko;
    }
    get isRangeNode() {
      return !0;
    }
    /**
     * Check whether the RangeNode needs the `end` symbol to be defined.
     * This end is the size of the Matrix in current dimension.
     * @return {boolean}
     */
    needsEnd() {
      var a = this.filter(function(o) {
        return ir(o) && o.name === "end";
      });
      return a.length > 0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, o) {
      var f = a.range, u = this.start._compile(a, o), s = this.end._compile(a, o);
      if (this.step) {
        var c = this.step._compile(a, o);
        return function(m, h, g) {
          return f(u(m, h, g), s(m, h, g), c(m, h, g));
        };
      } else
        return function(m, h, g) {
          return f(u(m, h, g), s(m, h, g));
        };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      a(this.start, "start", this), a(this.end, "end", this), this.step && a(this.step, "step", this);
    }
    /**
     * Create a new RangeNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RangeNode} Returns a transformed copy of the node
     */
    map(a) {
      return new n(this._ifNode(a(this.start, "start", this)), this._ifNode(a(this.end, "end", this)), this.step && this._ifNode(a(this.step, "step", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RangeNode}
     */
    clone() {
      return new n(this.start, this.end, this.step && this.step);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(a) {
      var o = a && a.parenthesis ? a.parenthesis : "keep", f = r(this, o, a && a.implicit), u, s = this.start.toString(a);
      if (f.start && (s = "(" + s + ")"), u = s, this.step) {
        var c = this.step.toString(a);
        f.step && (c = "(" + c + ")"), u += ":" + c;
      }
      var l = this.end.toString(a);
      return f.end && (l = "(" + l + ")"), u += ":" + l, u;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: ko,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    /**
     * Instantiate an RangeNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
     *     where mathjs is optional
     * @returns {RangeNode}
     */
    static fromJSON(a) {
      return new n(a.start, a.end, a.step);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(a) {
      var o = a && a.parenthesis ? a.parenthesis : "keep", f = r(this, o, a && a.implicit), u, s = this.start.toHTML(a);
      if (f.start && (s = '<span class="math-parenthesis math-round-parenthesis">(</span>' + s + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u = s, this.step) {
        var c = this.step.toHTML(a);
        f.step && (c = '<span class="math-parenthesis math-round-parenthesis">(</span>' + c + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u += '<span class="math-operator math-range-operator">:</span>' + c;
      }
      var l = this.end.toHTML(a);
      return f.end && (l = '<span class="math-parenthesis math-round-parenthesis">(</span>' + l + '<span class="math-parenthesis math-round-parenthesis">)</span>'), u += '<span class="math-operator math-range-operator">:</span>' + l, u;
    }
    /**
     * Get LaTeX representation
     * @params {Object} options
     * @return {string} str
     */
    _toTex(a) {
      var o = a && a.parenthesis ? a.parenthesis : "keep", f = r(this, o, a && a.implicit), u = this.start.toTex(a);
      if (f.start && (u = "\\left(".concat(u, "\\right)")), this.step) {
        var s = this.step.toTex(a);
        f.step && (s = "\\left(".concat(s, "\\right)")), u += ":" + s;
      }
      var c = this.end.toTex(a);
      return f.end && (c = "\\left(".concat(c, "\\right)")), u += ":" + c, u;
    }
  }
  return lr(n, "name", ko), n;
}, {
  isClass: !0,
  isNode: !0
}), zo = "RelationalNode", EI = ["Node"], tf = /* @__PURE__ */ H(zo, EI, (t) => {
  var {
    Node: e
  } = t, r = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };
  class n extends e {
    /**
     * A node representing a chained conditional expression, such as 'x > y > z'
     *
     * @param {String[]} conditionals
     *     An array of conditional operators used to compare the parameters
     * @param {Node[]} params
     *     The parameters that will be compared
     *
     * @constructor RelationalNode
     * @extends {Node}
     */
    constructor(a, o) {
      if (super(), !Array.isArray(a))
        throw new TypeError("Parameter conditionals must be an array");
      if (!Array.isArray(o))
        throw new TypeError("Parameter params must be an array");
      if (a.length !== o.length - 1)
        throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
      this.conditionals = a, this.params = o;
    }
    get type() {
      return zo;
    }
    get isRelationalNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(a, o) {
      var f = this, u = this.params.map((s) => s._compile(a, o));
      return function(c, l, m) {
        for (var h, g = u[0](c, l, m), d = 0; d < f.conditionals.length; d++) {
          h = g, g = u[d + 1](c, l, m);
          var y = kr(a, f.conditionals[d]);
          if (!y(h, g))
            return !1;
        }
        return !0;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(a) {
      this.params.forEach((o, f) => a(o, "params[" + f + "]", this), this);
    }
    /**
     * Create a new RelationalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RelationalNode} Returns a transformed copy of the node
     */
    map(a) {
      return new n(this.conditionals.slice(), this.params.map((o, f) => this._ifNode(a(o, "params[" + f + "]", this)), this));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RelationalNode}
     */
    clone() {
      return new n(this.conditionals, this.params);
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(a) {
      for (var o = a && a.parenthesis ? a.parenthesis : "keep", f = Lt(this, o, a && a.implicit), u = this.params.map(function(l, m) {
        var h = Lt(l, o, a && a.implicit);
        return o === "all" || h !== null && h <= f ? "(" + l.toString(a) + ")" : l.toString(a);
      }), s = u[0], c = 0; c < this.conditionals.length; c++)
        s += " " + r[this.conditionals[c]], s += " " + u[c + 1];
      return s;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: zo,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    /**
     * Instantiate a RelationalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
     *     where mathjs is optional
     * @returns {RelationalNode}
     */
    static fromJSON(a) {
      return new n(a.conditionals, a.params);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(a) {
      for (var o = a && a.parenthesis ? a.parenthesis : "keep", f = Lt(this, o, a && a.implicit), u = this.params.map(function(l, m) {
        var h = Lt(l, o, a && a.implicit);
        return o === "all" || h !== null && h <= f ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + l.toHTML(a) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : l.toHTML(a);
      }), s = u[0], c = 0; c < this.conditionals.length; c++)
        s += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + hn(r[this.conditionals[c]]) + "</span>" + u[c + 1];
      return s;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(a) {
      for (var o = a && a.parenthesis ? a.parenthesis : "keep", f = Lt(this, o, a && a.implicit), u = this.params.map(function(l, m) {
        var h = Lt(l, o, a && a.implicit);
        return o === "all" || h !== null && h <= f ? "\\left(" + l.toTex(a) + "\right)" : l.toTex(a);
      }), s = u[0], c = 0; c < this.conditionals.length; c++)
        s += Tt[this.conditionals[c]] + u[c + 1];
      return s;
    }
  }
  return lr(n, "name", zo), n;
}, {
  isClass: !0,
  isNode: !0
}), SI = "SymbolNode", AI = ["math", "?Unit", "Node"], rf = /* @__PURE__ */ H(SI, AI, (t) => {
  var {
    math: e,
    Unit: r,
    Node: n
  } = t;
  function i(o) {
    return r ? r.isValuelessUnit(o) : !1;
  }
  class a extends n {
    /**
     * @constructor SymbolNode
     * @extends {Node}
     * A symbol node can hold and resolve a symbol
     * @param {string} name
     * @extends {Node}
     */
    constructor(f) {
      if (super(), typeof f != "string")
        throw new TypeError('String expected for parameter "name"');
      this.name = f;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(f, u) {
      var s = this.name;
      if (u[s] === !0)
        return function(l, m, h) {
          return kr(m, s);
        };
      if (s in f)
        return function(l, m, h) {
          return l.has(s) ? l.get(s) : kr(f, s);
        };
      var c = i(s);
      return function(l, m, h) {
        return l.has(s) ? l.get(s) : c ? new r(null, s) : a.onUndefinedSymbol(s);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(f) {
    }
    /**
     * Create a new SymbolNode with children produced by the given callback.
     * Trivial since a SymbolNode has no children
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {SymbolNode} Returns a clone of the node
     */
    map(f) {
      return this.clone();
    }
    /**
     * Throws an error 'Undefined symbol {name}'
     * @param {string} name
     */
    static onUndefinedSymbol(f) {
      throw new Error("Undefined symbol " + f);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {SymbolNode}
     */
    clone() {
      return new a(this.name);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(f) {
      return this.name;
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(f) {
      var u = hn(this.name);
      return u === "true" || u === "false" ? '<span class="math-symbol math-boolean">' + u + "</span>" : u === "i" ? '<span class="math-symbol math-imaginary-symbol">' + u + "</span>" : u === "Infinity" ? '<span class="math-symbol math-infinity-symbol">' + u + "</span>" : u === "NaN" ? '<span class="math-symbol math-nan-symbol">' + u + "</span>" : u === "null" ? '<span class="math-symbol math-null-symbol">' + u + "</span>" : u === "undefined" ? '<span class="math-symbol math-undefined-symbol">' + u + "</span>" : '<span class="math-symbol">' + u + "</span>";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    /**
     * Instantiate a SymbolNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", name: "x"}`,
     *                       where mathjs is optional
     * @returns {SymbolNode}
     */
    static fromJSON(f) {
      return new a(f.name);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(f) {
      var u = !1;
      typeof e[this.name] > "u" && i(this.name) && (u = !0);
      var s = jw(this.name, u);
      return s[0] === "\\" ? s : " " + s;
    }
  }
  return a;
}, {
  isClass: !0,
  isNode: !0
}), $o = "FunctionNode", CI = ["math", "Node", "SymbolNode"], nf = /* @__PURE__ */ H($o, CI, (t) => {
  var e, {
    math: r,
    Node: n,
    SymbolNode: i
  } = t, a = (u) => vt(u, {
    truncate: 78
  });
  function o(u, s, c) {
    for (var l = "", m = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi, h = 0, g; (g = m.exec(u)) !== null; )
      if (l += u.substring(h, g.index), h = g.index, g[0] === "$$")
        l += "$", h++;
      else {
        h += g[0].length;
        var d = s[g[1]];
        if (!d)
          throw new ReferenceError("Template: Property " + g[1] + " does not exist.");
        if (g[2] === void 0)
          switch (typeof d) {
            case "string":
              l += d;
              break;
            case "object":
              if (Bt(d))
                l += d.toTex(c);
              else if (Array.isArray(d))
                l += d.map(function(y, w) {
                  if (Bt(y))
                    return y.toTex(c);
                  throw new TypeError("Template: " + g[1] + "[" + w + "] is not a Node.");
                }).join(",");
              else
                throw new TypeError("Template: " + g[1] + " has to be a Node, String or array of Nodes");
              break;
            default:
              throw new TypeError("Template: " + g[1] + " has to be a Node, String or array of Nodes");
          }
        else if (Bt(d[g[2]] && d[g[2]]))
          l += d[g[2]].toTex(c);
        else
          throw new TypeError("Template: " + g[1] + "[" + g[2] + "] is not a Node.");
      }
    return l += u.slice(h), l;
  }
  class f extends n {
    /**
     * @constructor FunctionNode
     * @extends {./Node}
     * invoke a list with arguments on a node
     * @param {./Node | string} fn
     *     Item resolving to a function on which to invoke
     *     the arguments, typically a SymboNode or AccessorNode
     * @param {./Node[]} args
     */
    constructor(s, c) {
      if (super(), typeof s == "string" && (s = new i(s)), !Bt(s)) throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(c) || !c.every(Bt))
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      this.fn = s, this.args = c || [];
    }
    // readonly property name
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return $o;
    }
    get isFunctionNode() {
      return !0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(s, c) {
      var l = this.args.map((A) => A._compile(s, c));
      if (ir(this.fn)) {
        var m = this.fn.name;
        if (c[m]) {
          var w = this.args;
          return function(T, _, O) {
            var I = kr(_, m);
            if (typeof I != "function")
              throw new TypeError("Argument '".concat(m, "' was not a function; received: ").concat(a(I)));
            if (I.rawArgs)
              return I(w, s, xs(T, _));
            var B = l.map((k) => k(T, _, O));
            return I.apply(I, B);
          };
        } else {
          var h = m in s ? kr(s, m) : void 0, g = typeof h == "function" && h.rawArgs === !0, d = (A) => {
            var T;
            if (A.has(m))
              T = A.get(m);
            else if (m in s)
              T = kr(s, m);
            else
              return f.onUndefinedFunction(m);
            if (typeof T == "function")
              return T;
            throw new TypeError("'".concat(m, `' is not a function; its value is:
  `).concat(a(T)));
          };
          if (g) {
            var y = this.args;
            return function(T, _, O) {
              var I = d(T);
              return I(y, s, xs(T, _));
            };
          } else
            switch (l.length) {
              case 0:
                return function(T, _, O) {
                  var I = d(T);
                  return I();
                };
              case 1:
                return function(T, _, O) {
                  var I = d(T), B = l[0];
                  return I(B(T, _, O));
                };
              case 2:
                return function(T, _, O) {
                  var I = d(T), B = l[0], k = l[1];
                  return I(B(T, _, O), k(T, _, O));
                };
              default:
                return function(T, _, O) {
                  var I = d(T), B = l.map((k) => k(T, _, O));
                  return I(...B);
                };
            }
        }
      } else if (Kn(this.fn) && bi(this.fn.index) && this.fn.index.isObjectProperty()) {
        var E = this.fn.object._compile(s, c), x = this.fn.index.getObjectProperty(), N = this.args;
        return function(T, _, O) {
          var I = E(T, _, O), B = cC(I, x);
          if (B != null && B.rawArgs)
            return B(N, s, xs(T, _));
          var k = l.map((L) => L(T, _, O));
          return B.apply(I, k);
        };
      } else {
        var D = this.fn.toString(), b = this.fn._compile(s, c), C = this.args;
        return function(T, _, O) {
          var I = b(T, _, O);
          if (typeof I != "function")
            throw new TypeError("Expression '".concat(D, "' did not evaluate to a function; value is:") + `
  `.concat(a(I)));
          if (I.rawArgs)
            return I(C, s, xs(T, _));
          var B = l.map((k) => k(T, _, O));
          return I.apply(I, B);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(s) {
      s(this.fn, "fn", this);
      for (var c = 0; c < this.args.length; c++)
        s(this.args[c], "args[" + c + "]", this);
    }
    /**
     * Create a new FunctionNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionNode} Returns a transformed copy of the node
     */
    map(s) {
      for (var c = this._ifNode(s(this.fn, "fn", this)), l = [], m = 0; m < this.args.length; m++)
        l[m] = this._ifNode(s(this.args[m], "args[" + m + "]", this));
      return new f(c, l);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionNode}
     */
    clone() {
      return new f(this.fn, this.args.slice(0));
    }
    /**
     * Throws an error 'Undefined function {name}'
     * @param {string} name
     */
    /**
     * Get string representation. (wrapper function)
     * This overrides parts of Node's toString function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toString
     * function.
     *
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toString(s) {
      var c, l = this.fn.toString(s);
      return s && typeof s.handler == "object" && $e(s.handler, l) && (c = s.handler[l](this, s)), typeof c < "u" ? c : super.toString(s);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(s) {
      var c = this.args.map(function(m) {
        return m.toString(s);
      }), l = Xi(this.fn) ? "(" + this.fn.toString(s) + ")" : this.fn.toString(s);
      return l + "(" + c.join(", ") + ")";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: $o,
        fn: this.fn,
        args: this.args
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     */
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(s) {
      var c = this.args.map(function(l) {
        return l.toHTML(s);
      });
      return '<span class="math-function">' + hn(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + c.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    /**
     * Get LaTeX representation. (wrapper function)
     * This overrides parts of Node's toTex function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toTex
     * function.
     *
     * @param {Object} options
     * @return {string}
     */
    toTex(s) {
      var c;
      return s && typeof s.handler == "object" && $e(s.handler, this.name) && (c = s.handler[this.name](this, s)), typeof c < "u" ? c : super.toTex(s);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(s) {
      var c = this.args.map(function(h) {
        return h.toTex(s);
      }), l;
      Kx[this.name] && (l = Kx[this.name]), r[this.name] && (typeof r[this.name].toTex == "function" || typeof r[this.name].toTex == "object" || typeof r[this.name].toTex == "string") && (l = r[this.name].toTex);
      var m;
      switch (typeof l) {
        case "function":
          m = l(this, s);
          break;
        case "string":
          m = o(l, this, s);
          break;
        case "object":
          switch (typeof l[c.length]) {
            case "function":
              m = l[c.length](this, s);
              break;
            case "string":
              m = o(l[c.length], this, s);
              break;
          }
      }
      return typeof m < "u" ? m : o(gI, this, s);
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  return e = f, lr(f, "name", $o), lr(f, "onUndefinedFunction", function(u) {
    throw new Error("Undefined function " + u);
  }), lr(f, "fromJSON", function(u) {
    return new e(u.fn, u.args);
  }), f;
}, {
  isClass: !0,
  isNode: !0
}), tb = "parse", TI = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"], af = /* @__PURE__ */ H(tb, TI, (t) => {
  var {
    typed: e,
    numeric: r,
    config: n,
    AccessorNode: i,
    ArrayNode: a,
    AssignmentNode: o,
    BlockNode: f,
    ConditionalNode: u,
    ConstantNode: s,
    FunctionAssignmentNode: c,
    FunctionNode: l,
    IndexNode: m,
    ObjectNode: h,
    OperatorNode: g,
    ParenthesisNode: d,
    RangeNode: y,
    RelationalNode: w,
    SymbolNode: E
  } = t, x = e(tb, {
    string: function(fe) {
      return ee(fe, {});
    },
    "Array | Matrix": function(fe) {
      return N(fe, {});
    },
    "string, Object": function(fe, Ne) {
      var Fe = Ne.nodes !== void 0 ? Ne.nodes : {};
      return ee(fe, Fe);
    },
    "Array | Matrix, Object": N
  });
  function N(P) {
    var fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Ne = fe.nodes !== void 0 ? fe.nodes : {};
    return gt(P, function(Fe) {
      if (typeof Fe != "string") throw new TypeError("String expected");
      return ee(Fe, Ne);
    });
  }
  var D = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  }, b = {
    ",": !0,
    "(": !0,
    ")": !0,
    "[": !0,
    "]": !0,
    "{": !0,
    "}": !0,
    '"': !0,
    "'": !0,
    ";": !0,
    "+": !0,
    "-": !0,
    "*": !0,
    ".*": !0,
    "/": !0,
    "./": !0,
    "%": !0,
    "^": !0,
    ".^": !0,
    "~": !0,
    "!": !0,
    "&": !0,
    "|": !0,
    "^|": !0,
    "=": !0,
    ":": !0,
    "?": !0,
    "==": !0,
    "!=": !0,
    "<": !0,
    ">": !0,
    "<=": !0,
    ">=": !0,
    "<<": !0,
    ">>": !0,
    ">>>": !0
  }, C = {
    mod: !0,
    to: !0,
    in: !0,
    and: !0,
    xor: !0,
    or: !0,
    not: !0
  }, A = {
    true: !0,
    false: !1,
    null: null,
    undefined: void 0
  }, T = ["NaN", "Infinity"], _ = {
    '"': '"',
    "'": "'",
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
    // note that \u is handled separately in parseStringToken()
  };
  function O() {
    return {
      extraNodes: {},
      // current extra nodes, must be careful not to mutate
      expression: "",
      // current expression
      comment: "",
      // last parsed comment
      index: 0,
      // current index in expr
      token: "",
      // current token
      tokenType: D.NULL,
      // type of the token
      nestingLevel: 0,
      // level of nesting inside parameters, used to ignore newline characters
      conditionalLevel: null
      // when a conditional is being parsed, the level of the conditional is stored here
    };
  }
  function I(P, fe) {
    return P.expression.substr(P.index, fe);
  }
  function B(P) {
    return I(P, 1);
  }
  function k(P) {
    P.index++;
  }
  function L(P) {
    return P.expression.charAt(P.index - 1);
  }
  function F(P) {
    return P.expression.charAt(P.index + 1);
  }
  function M(P) {
    for (P.tokenType = D.NULL, P.token = "", P.comment = ""; ; ) {
      if (B(P) === "#")
        for (; B(P) !== `
` && B(P) !== ""; )
          P.comment += B(P), k(P);
      if (x.isWhitespace(B(P), P.nestingLevel))
        k(P);
      else
        break;
    }
    if (B(P) === "") {
      P.tokenType = D.DELIMITER;
      return;
    }
    if (B(P) === `
` && !P.nestingLevel) {
      P.tokenType = D.DELIMITER, P.token = B(P), k(P);
      return;
    }
    var fe = B(P), Ne = I(P, 2), Fe = I(P, 3);
    if (Fe.length === 3 && b[Fe]) {
      P.tokenType = D.DELIMITER, P.token = Fe, k(P), k(P), k(P);
      return;
    }
    if (Ne.length === 2 && b[Ne]) {
      P.tokenType = D.DELIMITER, P.token = Ne, k(P), k(P);
      return;
    }
    if (b[fe]) {
      P.tokenType = D.DELIMITER, P.token = fe, k(P);
      return;
    }
    if (x.isDigitDot(fe)) {
      P.tokenType = D.NUMBER;
      var Ze = I(P, 2);
      if (Ze === "0b" || Ze === "0o" || Ze === "0x") {
        for (P.token += B(P), k(P), P.token += B(P), k(P); x.isHexDigit(B(P)); )
          P.token += B(P), k(P);
        if (B(P) === ".")
          for (P.token += ".", k(P); x.isHexDigit(B(P)); )
            P.token += B(P), k(P);
        else if (B(P) === "i")
          for (P.token += "i", k(P); x.isDigit(B(P)); )
            P.token += B(P), k(P);
        return;
      }
      if (B(P) === ".") {
        if (P.token += B(P), k(P), !x.isDigit(B(P))) {
          P.tokenType = D.DELIMITER;
          return;
        }
      } else {
        for (; x.isDigit(B(P)); )
          P.token += B(P), k(P);
        x.isDecimalMark(B(P), F(P)) && (P.token += B(P), k(P));
      }
      for (; x.isDigit(B(P)); )
        P.token += B(P), k(P);
      if (B(P) === "E" || B(P) === "e") {
        if (x.isDigit(F(P)) || F(P) === "-" || F(P) === "+") {
          if (P.token += B(P), k(P), (B(P) === "+" || B(P) === "-") && (P.token += B(P), k(P)), !x.isDigit(B(P)))
            throw Qe(P, 'Digit expected, got "' + B(P) + '"');
          for (; x.isDigit(B(P)); )
            P.token += B(P), k(P);
          if (x.isDecimalMark(B(P), F(P)))
            throw Qe(P, 'Digit expected, got "' + B(P) + '"');
        } else if (F(P) === ".")
          throw k(P), Qe(P, 'Digit expected, got "' + B(P) + '"');
      }
      return;
    }
    if (x.isAlpha(B(P), L(P), F(P))) {
      for (; x.isAlpha(B(P), L(P), F(P)) || x.isDigit(B(P)); )
        P.token += B(P), k(P);
      $e(C, P.token) ? P.tokenType = D.DELIMITER : P.tokenType = D.SYMBOL;
      return;
    }
    for (P.tokenType = D.UNKNOWN; B(P) !== ""; )
      P.token += B(P), k(P);
    throw Qe(P, 'Syntax error in part "' + P.token + '"');
  }
  function $(P) {
    do
      M(P);
    while (P.token === `
`);
  }
  function R(P) {
    P.nestingLevel++;
  }
  function Q(P) {
    P.nestingLevel--;
  }
  x.isAlpha = function(fe, Ne, Fe) {
    return x.isValidLatinOrGreek(fe) || x.isValidMathSymbol(fe, Fe) || x.isValidMathSymbol(Ne, fe);
  }, x.isValidLatinOrGreek = function(fe) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(fe);
  }, x.isValidMathSymbol = function(fe, Ne) {
    return /^[\uD835]$/.test(fe) && /^[\uDC00-\uDFFF]$/.test(Ne) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(Ne);
  }, x.isWhitespace = function(fe, Ne) {
    return fe === " " || fe === "	" || fe === `
` && Ne > 0;
  }, x.isDecimalMark = function(fe, Ne) {
    return fe === "." && Ne !== "/" && Ne !== "*" && Ne !== "^";
  }, x.isDigitDot = function(fe) {
    return fe >= "0" && fe <= "9" || fe === ".";
  }, x.isDigit = function(fe) {
    return fe >= "0" && fe <= "9";
  }, x.isHexDigit = function(fe) {
    return fe >= "0" && fe <= "9" || fe >= "a" && fe <= "f" || fe >= "A" && fe <= "F";
  };
  function ee(P, fe) {
    var Ne = O();
    nr(Ne, {
      expression: P,
      extraNodes: fe
    }), M(Ne);
    var Fe = j(Ne);
    if (Ne.token !== "")
      throw Ne.tokenType === D.DELIMITER ? Gt(Ne, "Unexpected operator " + Ne.token) : Qe(Ne, 'Unexpected part "' + Ne.token + '"');
    return Fe;
  }
  function j(P) {
    var fe, Ne = [], Fe;
    for (P.token !== "" && P.token !== `
` && P.token !== ";" && (fe = U(P), P.comment && (fe.comment = P.comment)); P.token === `
` || P.token === ";"; )
      Ne.length === 0 && fe && (Fe = P.token !== ";", Ne.push({
        node: fe,
        visible: Fe
      })), M(P), P.token !== `
` && P.token !== ";" && P.token !== "" && (fe = U(P), P.comment && (fe.comment = P.comment), Fe = P.token !== ";", Ne.push({
        node: fe,
        visible: Fe
      }));
    return Ne.length > 0 ? new f(Ne) : (fe || (fe = new s(void 0), P.comment && (fe.comment = P.comment)), fe);
  }
  function U(P) {
    var fe, Ne, Fe, Ze, it = pe(P);
    if (P.token === "=") {
      if (ir(it))
        return fe = it.name, $(P), Fe = U(P), new o(new E(fe), Fe);
      if (Kn(it))
        return $(P), Fe = U(P), new o(it.object, it.index, Fe);
      if (Bn(it) && ir(it.fn) && (Ze = !0, Ne = [], fe = it.name, it.args.forEach(function(pr, Li) {
        ir(pr) ? Ne[Li] = pr.name : Ze = !1;
      }), Ze))
        return $(P), Fe = U(P), new c(fe, Ne, Fe);
      throw Qe(P, "Invalid left hand side of assignment operator =");
    }
    return it;
  }
  function pe(P) {
    for (var fe = X(P); P.token === "?"; ) {
      var Ne = P.conditionalLevel;
      P.conditionalLevel = P.nestingLevel, $(P);
      var Fe = fe, Ze = U(P);
      if (P.token !== ":") throw Qe(P, "False part of conditional expression expected");
      P.conditionalLevel = null, $(P);
      var it = U(P);
      fe = new u(Fe, Ze, it), P.conditionalLevel = Ne;
    }
    return fe;
  }
  function X(P) {
    for (var fe = te(P); P.token === "or"; )
      $(P), fe = new g("or", "or", [fe, te(P)]);
    return fe;
  }
  function te(P) {
    for (var fe = ue(P); P.token === "xor"; )
      $(P), fe = new g("xor", "xor", [fe, ue(P)]);
    return fe;
  }
  function ue(P) {
    for (var fe = ce(P); P.token === "and"; )
      $(P), fe = new g("and", "and", [fe, ce(P)]);
    return fe;
  }
  function ce(P) {
    for (var fe = se(P); P.token === "|"; )
      $(P), fe = new g("|", "bitOr", [fe, se(P)]);
    return fe;
  }
  function se(P) {
    for (var fe = he(P); P.token === "^|"; )
      $(P), fe = new g("^|", "bitXor", [fe, he(P)]);
    return fe;
  }
  function he(P) {
    for (var fe = le(P); P.token === "&"; )
      $(P), fe = new g("&", "bitAnd", [fe, le(P)]);
    return fe;
  }
  function le(P) {
    for (var fe = [ve(P)], Ne = [], Fe = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    }; $e(Fe, P.token); ) {
      var Ze = {
        name: P.token,
        fn: Fe[P.token]
      };
      Ne.push(Ze), $(P), fe.push(ve(P));
    }
    return fe.length === 1 ? fe[0] : fe.length === 2 ? new g(Ne[0].name, Ne[0].fn, fe) : new w(Ne.map((it) => it.fn), fe);
  }
  function ve(P) {
    var fe, Ne, Fe, Ze;
    fe = Ee(P);
    for (var it = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    }; $e(it, P.token); )
      Ne = P.token, Fe = it[Ne], $(P), Ze = [fe, Ee(P)], fe = new g(Ne, Fe, Ze);
    return fe;
  }
  function Ee(P) {
    var fe, Ne, Fe, Ze;
    fe = _e(P);
    for (var it = {
      to: "to",
      in: "to"
      // alias of 'to'
    }; $e(it, P.token); )
      Ne = P.token, Fe = it[Ne], $(P), Ne === "in" && P.token === "" ? fe = new g("*", "multiply", [fe, new E("in")], !0) : (Ze = [fe, _e(P)], fe = new g(Ne, Fe, Ze));
    return fe;
  }
  function _e(P) {
    var fe, Ne = [];
    if (P.token === ":" ? fe = new s(1) : fe = V(P), P.token === ":" && P.conditionalLevel !== P.nestingLevel) {
      for (Ne.push(fe); P.token === ":" && Ne.length < 3; )
        $(P), P.token === ")" || P.token === "]" || P.token === "," || P.token === "" ? Ne.push(new E("end")) : Ne.push(V(P));
      Ne.length === 3 ? fe = new y(Ne[0], Ne[2], Ne[1]) : fe = new y(Ne[0], Ne[1]);
    }
    return fe;
  }
  function V(P) {
    var fe, Ne, Fe, Ze;
    fe = J(P);
    for (var it = {
      "+": "add",
      "-": "subtract"
    }; $e(it, P.token); ) {
      Ne = P.token, Fe = it[Ne], $(P);
      var pr = J(P);
      pr.isPercentage ? Ze = [fe, new g("*", "multiply", [fe, pr])] : Ze = [fe, pr], fe = new g(Ne, Fe, Ze);
    }
    return fe;
  }
  function J(P) {
    var fe, Ne, Fe, Ze;
    fe = ye(P), Ne = fe;
    for (var it = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide"
    }; $e(it, P.token); )
      Fe = P.token, Ze = it[Fe], $(P), Ne = ye(P), fe = new g(Fe, Ze, [fe, Ne]);
    return fe;
  }
  function ye(P) {
    var fe, Ne;
    for (fe = K(P), Ne = fe; P.tokenType === D.SYMBOL || P.token === "in" && wt(fe) || P.tokenType === D.NUMBER && !wt(Ne) && (!Kt(Ne) || Ne.op === "!") || P.token === "("; )
      Ne = K(P), fe = new g(
        "*",
        "multiply",
        [fe, Ne],
        !0
        /* implicit */
      );
    return fe;
  }
  function K(P) {
    for (var fe = ae(P), Ne = fe, Fe = []; P.token === "/" && kh(Ne); )
      if (Fe.push(nr({}, P)), $(P), P.tokenType === D.NUMBER)
        if (Fe.push(nr({}, P)), $(P), P.tokenType === D.SYMBOL || P.token === "(")
          nr(P, Fe.pop()), Fe.pop(), Ne = ae(P), fe = new g("/", "divide", [fe, Ne]);
        else {
          Fe.pop(), nr(P, Fe.pop());
          break;
        }
      else {
        nr(P, Fe.pop());
        break;
      }
    return fe;
  }
  function ae(P) {
    var fe, Ne, Fe, Ze;
    fe = de(P);
    for (var it = {
      "%": "mod",
      mod: "mod"
    }; $e(it, P.token); )
      Ne = P.token, Fe = it[Ne], $(P), Ne === "%" && P.tokenType === D.DELIMITER && P.token !== "(" ? fe = new g("/", "divide", [fe, new s(100)], !1, !0) : (Ze = [fe, de(P)], fe = new g(Ne, Fe, Ze));
    return fe;
  }
  function de(P) {
    var fe, Ne, Fe, Ze = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    return $e(Ze, P.token) ? (Fe = Ze[P.token], fe = P.token, $(P), Ne = [de(P)], new g(fe, Fe, Ne)) : xe(P);
  }
  function xe(P) {
    var fe, Ne, Fe, Ze;
    return fe = Ce(P), (P.token === "^" || P.token === ".^") && (Ne = P.token, Fe = Ne === "^" ? "pow" : "dotPow", $(P), Ze = [fe, de(P)], fe = new g(Ne, Fe, Ze)), fe;
  }
  function Ce(P) {
    var fe, Ne, Fe, Ze;
    fe = G(P);
    for (var it = {
      "!": "factorial",
      "'": "ctranspose"
    }; $e(it, P.token); )
      Ne = P.token, Fe = it[Ne], M(P), Ze = [fe], fe = new g(Ne, Fe, Ze), fe = ge(P, fe);
    return fe;
  }
  function G(P) {
    var fe = [];
    if (P.tokenType === D.SYMBOL && $e(P.extraNodes, P.token)) {
      var Ne = P.extraNodes[P.token];
      if (M(P), P.token === "(") {
        if (fe = [], R(P), M(P), P.token !== ")")
          for (fe.push(U(P)); P.token === ","; )
            M(P), fe.push(U(P));
        if (P.token !== ")")
          throw Qe(P, "Parenthesis ) expected");
        Q(P), M(P);
      }
      return new Ne(fe);
    }
    return Z(P);
  }
  function Z(P) {
    var fe, Ne;
    return P.tokenType === D.SYMBOL || P.tokenType === D.DELIMITER && P.token in C ? (Ne = P.token, M(P), $e(A, Ne) ? fe = new s(A[Ne]) : T.includes(Ne) ? fe = new s(r(Ne, "number")) : fe = new E(Ne), fe = ge(P, fe), fe) : be(P);
  }
  function ge(P, fe, Ne) {
    for (var Fe; (P.token === "(" || P.token === "[" || P.token === ".") && !Ne; )
      if (Fe = [], P.token === "(")
        if (ir(fe) || Kn(fe)) {
          if (R(P), M(P), P.token !== ")")
            for (Fe.push(U(P)); P.token === ","; )
              M(P), Fe.push(U(P));
          if (P.token !== ")")
            throw Qe(P, "Parenthesis ) expected");
          Q(P), M(P), fe = new l(fe, Fe);
        } else
          return fe;
      else if (P.token === "[") {
        if (R(P), M(P), P.token !== "]")
          for (Fe.push(U(P)); P.token === ","; )
            M(P), Fe.push(U(P));
        if (P.token !== "]")
          throw Qe(P, "Parenthesis ] expected");
        Q(P), M(P), fe = new i(fe, new m(Fe));
      } else {
        M(P);
        var Ze = P.tokenType === D.SYMBOL || P.tokenType === D.DELIMITER && P.token in C;
        if (!Ze)
          throw Qe(P, "Property name expected after dot");
        Fe.push(new s(P.token)), M(P);
        var it = !0;
        fe = new i(fe, new m(Fe, it));
      }
    return fe;
  }
  function be(P) {
    var fe, Ne;
    return P.token === '"' || P.token === "'" ? (Ne = Se(P, P.token), fe = new s(Ne), fe = ge(P, fe), fe) : De(P);
  }
  function Se(P, fe) {
    for (var Ne = ""; B(P) !== "" && B(P) !== fe; )
      if (B(P) === "\\") {
        k(P);
        var Fe = B(P), Ze = _[Fe];
        if (Ze !== void 0)
          Ne += Ze, P.index += 1;
        else if (Fe === "u") {
          var it = P.expression.slice(P.index + 1, P.index + 5);
          if (/^[0-9A-Fa-f]{4}$/.test(it))
            Ne += String.fromCharCode(parseInt(it, 16)), P.index += 5;
          else
            throw Qe(P, "Invalid unicode character \\u".concat(it));
        } else
          throw Qe(P, "Bad escape character \\".concat(Fe));
      } else
        Ne += B(P), k(P);
    if (M(P), P.token !== fe)
      throw Qe(P, "End of string ".concat(fe, " expected"));
    return M(P), Ne;
  }
  function De(P) {
    var fe, Ne, Fe, Ze;
    if (P.token === "[") {
      if (R(P), M(P), P.token !== "]") {
        var it = Me(P);
        if (P.token === ";") {
          for (Fe = 1, Ne = [it]; P.token === ";"; )
            M(P), P.token !== "]" && (Ne[Fe] = Me(P), Fe++);
          if (P.token !== "]")
            throw Qe(P, "End of matrix ] expected");
          Q(P), M(P), Ze = Ne[0].items.length;
          for (var pr = 1; pr < Fe; pr++)
            if (Ne[pr].items.length !== Ze)
              throw Gt(P, "Column dimensions mismatch (" + Ne[pr].items.length + " !== " + Ze + ")");
          fe = new a(Ne);
        } else {
          if (P.token !== "]")
            throw Qe(P, "End of matrix ] expected");
          Q(P), M(P), fe = it;
        }
      } else
        Q(P), M(P), fe = new a([]);
      return ge(P, fe);
    }
    return Oe(P);
  }
  function Me(P) {
    for (var fe = [U(P)], Ne = 1; P.token === ","; )
      M(P), P.token !== "]" && P.token !== ";" && (fe[Ne] = U(P), Ne++);
    return new a(fe);
  }
  function Oe(P) {
    if (P.token === "{") {
      R(P);
      var fe, Ne = {};
      do
        if (M(P), P.token !== "}") {
          if (P.token === '"' || P.token === "'")
            fe = Se(P, P.token);
          else if (P.tokenType === D.SYMBOL || P.tokenType === D.DELIMITER && P.token in C)
            fe = P.token, M(P);
          else
            throw Qe(P, "Symbol or string expected as object key");
          if (P.token !== ":")
            throw Qe(P, "Colon : expected after object key");
          M(P), Ne[fe] = U(P);
        }
      while (P.token === ",");
      if (P.token !== "}")
        throw Qe(P, "Comma , or bracket } expected after object value");
      Q(P), M(P);
      var Fe = new h(Ne);
      return Fe = ge(P, Fe), Fe;
    }
    return Be(P);
  }
  function Be(P) {
    var fe;
    if (P.tokenType === D.NUMBER) {
      fe = P.token, M(P);
      var Ne = wi(fe, n), Fe = r(fe, Ne);
      return new s(Fe);
    }
    return Ie(P);
  }
  function Ie(P) {
    var fe;
    if (P.token === "(") {
      if (R(P), M(P), fe = U(P), P.token !== ")")
        throw Qe(P, "Parenthesis ) expected");
      return Q(P), M(P), fe = new d(fe), fe = ge(P, fe), fe;
    }
    return nt(P);
  }
  function nt(P) {
    throw P.token === "" ? Qe(P, "Unexpected end of expression") : Qe(P, "Value expected");
  }
  function We(P) {
    return P.index - P.token.length + 1;
  }
  function Qe(P, fe) {
    var Ne = We(P), Fe = new SyntaxError(fe + " (char " + Ne + ")");
    return Fe.char = Ne, Fe;
  }
  function Gt(P, fe) {
    var Ne = We(P), Fe = new SyntaxError(fe + " (char " + Ne + ")");
    return Fe.char = Ne, Fe;
  }
  return e.addConversion({
    from: "string",
    to: "Node",
    convert: x
  }), x;
}), rb = "compile", _I = ["typed", "parse"], sf = /* @__PURE__ */ H(rb, _I, (t) => {
  var {
    typed: e,
    parse: r
  } = t;
  return e(rb, {
    string: function(i) {
      return r(i).compile();
    },
    "Array | Matrix": function(i) {
      return gt(i, function(a) {
        return r(a).compile();
      });
    }
  });
}), nb = "evaluate", MI = ["typed", "parse"], of = /* @__PURE__ */ H(nb, MI, (t) => {
  var {
    typed: e,
    parse: r
  } = t;
  return e(nb, {
    string: function(i) {
      var a = Ns();
      return r(i).compile().evaluate(a);
    },
    "string, Map | Object": function(i, a) {
      return r(i).compile().evaluate(a);
    },
    "Array | Matrix": function(i) {
      var a = Ns();
      return gt(i, function(o) {
        return r(o).compile().evaluate(a);
      });
    },
    "Array | Matrix, Map | Object": function(i, a) {
      return gt(i, function(o) {
        return r(o).compile().evaluate(a);
      });
    }
  });
}), OI = "Parser", qI = ["evaluate"], uf = /* @__PURE__ */ H(OI, qI, (t) => {
  var {
    evaluate: e
  } = t;
  function r() {
    if (!(this instanceof r))
      throw new SyntaxError("Constructor must be called with the new operator");
    Object.defineProperty(this, "scope", {
      value: Ns(),
      writable: !1
    });
  }
  return r.prototype.type = "Parser", r.prototype.isParser = !0, r.prototype.evaluate = function(n) {
    return e(n, this.scope);
  }, r.prototype.get = function(n) {
    if (this.scope.has(n))
      return this.scope.get(n);
  }, r.prototype.getAll = function() {
    return mC(this.scope);
  }, r.prototype.getAllAsMap = function() {
    return this.scope;
  }, r.prototype.set = function(n, i) {
    return this.scope.set(n, i), i;
  }, r.prototype.remove = function(n) {
    this.scope.delete(n);
  }, r.prototype.clear = function() {
    this.scope.clear();
  }, r;
}, {
  isClass: !0
}), ib = "parser", II = ["typed", "Parser"], lf = /* @__PURE__ */ H(ib, II, (t) => {
  var {
    typed: e,
    Parser: r
  } = t;
  return e(ib, {
    "": function() {
      return new r();
    }
  });
}), ab = "lup", FI = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"], cf = /* @__PURE__ */ H(ab, FI, (t) => {
  var {
    typed: e,
    matrix: r,
    abs: n,
    addScalar: i,
    divideScalar: a,
    multiplyScalar: o,
    subtractScalar: f,
    larger: u,
    equalScalar: s,
    unaryMinus: c,
    DenseMatrix: l,
    SparseMatrix: m,
    Spa: h
  } = t;
  return e(ab, {
    DenseMatrix: function(w) {
      return g(w);
    },
    SparseMatrix: function(w) {
      return d(w);
    },
    Array: function(w) {
      var E = r(w), x = g(E);
      return {
        L: x.L.valueOf(),
        U: x.U.valueOf(),
        p: x.p
      };
    }
  });
  function g(y) {
    var w = y._size[0], E = y._size[1], x = Math.min(w, E), N = Je(y._data), D = [], b = [w, x], C = [], A = [x, E], T, _, O, I = [];
    for (T = 0; T < w; T++)
      I[T] = T;
    for (_ = 0; _ < E; _++) {
      if (_ > 0)
        for (T = 0; T < w; T++) {
          var B = Math.min(T, _), k = 0;
          for (O = 0; O < B; O++)
            k = i(k, o(N[T][O], N[O][_]));
          N[T][_] = f(N[T][_], k);
        }
      var L = _, F = 0, M = 0;
      for (T = _; T < w; T++) {
        var $ = N[T][_], R = n($);
        u(R, F) && (L = T, F = R, M = $);
      }
      if (_ !== L && (I[_] = [I[L], I[L] = I[_]][0], l._swapRows(_, L, N)), _ < w)
        for (T = _ + 1; T < w; T++) {
          var Q = N[T][_];
          s(Q, 0) || (N[T][_] = a(N[T][_], M));
        }
    }
    for (_ = 0; _ < E; _++)
      for (T = 0; T < w; T++) {
        if (_ === 0 && (T < E && (C[T] = []), D[T] = []), T < _) {
          T < E && (C[T][_] = N[T][_]), _ < w && (D[T][_] = 0);
          continue;
        }
        if (T === _) {
          T < E && (C[T][_] = N[T][_]), _ < w && (D[T][_] = 1);
          continue;
        }
        T < E && (C[T][_] = 0), _ < w && (D[T][_] = N[T][_]);
      }
    var ee = new l({
      data: D,
      size: b
    }), j = new l({
      data: C,
      size: A
    }), U = [];
    for (T = 0, x = I.length; T < x; T++)
      U[I[T]] = T;
    return {
      L: ee,
      U: j,
      p: U,
      toString: function() {
        return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
P: ` + this.p;
      }
    };
  }
  function d(y) {
    var w = y._size[0], E = y._size[1], x = Math.min(w, E), N = y._values, D = y._index, b = y._ptr, C = [], A = [], T = [], _ = [w, x], O = [], I = [], B = [], k = [x, E], L, F, M, $ = [], R = [];
    for (L = 0; L < w; L++)
      $[L] = L, R[L] = L;
    var Q = function(U, pe) {
      var X = R[U], te = R[pe];
      $[X] = pe, $[te] = U, R[U] = te, R[pe] = X;
    }, ee = function() {
      var U = new h();
      F < w && (T.push(C.length), C.push(1), A.push(F)), B.push(O.length);
      var pe = b[F], X = b[F + 1];
      for (M = pe; M < X; M++)
        L = D[M], U.set($[L], N[M]);
      F > 0 && U.forEach(0, F - 1, function(se, he) {
        m._forEachRow(se, C, A, T, function(le, ve) {
          le > se && U.accumulate(le, c(o(ve, he)));
        });
      });
      var te = F, ue = U.get(F), ce = n(ue);
      U.forEach(F + 1, w - 1, function(se, he) {
        var le = n(he);
        u(le, ce) && (te = se, ce = le, ue = he);
      }), F !== te && (m._swapRows(F, te, _[1], C, A, T), m._swapRows(F, te, k[1], O, I, B), U.swap(F, te), Q(F, te)), U.forEach(0, w - 1, function(se, he) {
        se <= F ? (O.push(he), I.push(se)) : (he = a(he, ue), s(he, 0) || (C.push(he), A.push(se)));
      });
    };
    for (F = 0; F < E; F++)
      ee();
    return B.push(O.length), T.push(C.length), {
      L: new m({
        values: C,
        index: A,
        ptr: T,
        size: _
      }),
      U: new m({
        values: O,
        index: I,
        ptr: B,
        size: k
      }),
      p: $,
      toString: function() {
        return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
P: ` + this.p;
      }
    };
  }
}), sb = "qr", BI = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"], ff = /* @__PURE__ */ H(sb, BI, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    identity: i,
    isZero: a,
    equal: o,
    sign: f,
    sqrt: u,
    conj: s,
    unaryMinus: c,
    addScalar: l,
    divideScalar: m,
    multiplyScalar: h,
    subtractScalar: g,
    complex: d
  } = t;
  return nr(e(sb, {
    DenseMatrix: function(N) {
      return w(N);
    },
    SparseMatrix: function(N) {
      return E();
    },
    Array: function(N) {
      var D = r(N), b = w(D);
      return {
        Q: b.Q.valueOf(),
        R: b.R.valueOf()
      };
    }
  }), {
    _denseQRimpl: y
  });
  function y(x) {
    var N = x._size[0], D = x._size[1], b = i([N], "dense"), C = b._data, A = x.clone(), T = A._data, _, O, I, B = n([N], "");
    for (I = 0; I < Math.min(D, N); ++I) {
      var k = T[I][I], L = c(o(k, 0) ? 1 : f(k)), F = s(L), M = 0;
      for (_ = I; _ < N; _++)
        M = l(M, h(T[_][I], s(T[_][I])));
      var $ = h(L, u(M));
      if (!a($)) {
        var R = g(k, $);
        for (B[I] = 1, _ = I + 1; _ < N; _++)
          B[_] = m(T[_][I], R);
        var Q = c(s(m(R, $))), ee = void 0;
        for (O = I; O < D; O++) {
          for (ee = 0, _ = I; _ < N; _++)
            ee = l(ee, h(s(B[_]), T[_][O]));
          for (ee = h(ee, Q), _ = I; _ < N; _++)
            T[_][O] = h(g(T[_][O], h(B[_], ee)), F);
        }
        for (_ = 0; _ < N; _++) {
          for (ee = 0, O = I; O < N; O++)
            ee = l(ee, h(C[_][O], B[O]));
          for (ee = h(ee, Q), O = I; O < N; ++O)
            C[_][O] = m(g(C[_][O], h(ee, s(B[O]))), F);
        }
      }
    }
    return {
      Q: b,
      R: A,
      toString: function() {
        return "Q: " + this.Q.toString() + `
R: ` + this.R.toString();
      }
    };
  }
  function w(x) {
    var N = y(x), D = N.R._data;
    if (x._data.length > 0)
      for (var b = D[0][0].type === "Complex" ? d(0) : 0, C = 0; C < D.length; ++C)
        for (var A = 0; A < C && A < (D[0] || []).length; ++A)
          D[C][A] = b;
    return N;
  }
  function E(x) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});
function RI(t, e, r, n) {
  t._values;
  for (var i = t._index, a = t._ptr, o = t._size, f = t._datatype, u = o[0], s = o[1], c = null, l = [], m = [], h = 0, g = 0; g < s; g++) {
    m[g] = h;
    for (var d = r ? r[g] : g, y = a[d], w = a[d + 1], E = y; E < w; E++) {
      var x = i[E];
      l[h] = x, h++;
    }
  }
  return m[s] = h, t.createSparseMatrix({
    values: c,
    index: l,
    ptr: m,
    size: [u, s],
    datatype: f
  });
}
function Yw(t, e, r, n, i, a, o) {
  var f = 0;
  for (r[o] = t; f >= 0; ) {
    var u = r[o + f], s = r[n + u];
    s === -1 ? (f--, a[e++] = u) : (r[n + u] = r[i + s], ++f, r[o + f] = s);
  }
  return e;
}
function PI(t, e) {
  if (!t)
    return null;
  var r = 0, n, i = [], a = [], o = 0, f = e, u = 2 * e;
  for (n = 0; n < e; n++)
    a[o + n] = -1;
  for (n = e - 1; n >= 0; n--)
    t[n] !== -1 && (a[f + n] = a[o + t[n]], a[o + t[n]] = n);
  for (n = 0; n < e; n++)
    t[n] === -1 && (r = Yw(n, r, a, o, f, i, u));
  return i;
}
function LI(t, e) {
  if (!t)
    return null;
  var r = t._index, n = t._ptr, i = t._size, a = i[0], o = i[1], f = [], u = [], s = 0, c = o, l, m;
  for (l = 0; l < a; l++)
    u[c + l] = -1;
  for (var h = 0; h < o; h++) {
    f[h] = -1, u[s + h] = -1;
    for (var g = n[h], d = n[h + 1], y = g; y < d; y++) {
      var w = r[y];
      for (l = u[c + w]; l !== -1 && l < h; l = m)
        m = u[s + l], u[s + l] = h, m === -1 && (f[l] = h);
      u[c + w] = h;
    }
  }
  return f;
}
function kI(t, e, r) {
  for (var n = t._values, i = t._index, a = t._ptr, o = t._size, f = o[1], u = 0, s = 0; s < f; s++) {
    var c = a[s];
    for (a[s] = u; c < a[s + 1]; c++)
      e(i[c], s, n ? n[c] : 1, r) && (i[u] = i[c], n && (n[u] = n[c]), u++);
  }
  return a[f] = u, i.splice(u, i.length - u), n && n.splice(u, n.length - u), u;
}
function mi(t) {
  return -t - 2;
}
var zI = "csAmd", $I = ["add", "multiply", "transpose"], UI = /* @__PURE__ */ H(zI, $I, (t) => {
  var {
    add: e,
    multiply: r,
    transpose: n
  } = t;
  return function(c, l) {
    if (!l || c <= 0 || c > 3)
      return null;
    var m = l._size, h = m[0], g = m[1], d = 0, y = Math.max(16, 10 * Math.sqrt(g));
    y = Math.min(g - 2, y);
    var w = i(c, l, h, g, y);
    kI(w, u, null);
    for (var E = w._index, x = w._ptr, N = x[g], D = [], b = [], C = 0, A = g + 1, T = 2 * (g + 1), _ = 3 * (g + 1), O = 4 * (g + 1), I = 5 * (g + 1), B = 6 * (g + 1), k = 7 * (g + 1), L = D, F = a(g, x, b, C, _, L, T, k, A, B, O, I), M = o(g, x, b, I, O, B, y, A, _, L, T), $ = 0, R, Q, ee, j, U, pe, X, te, ue, ce, se, he, le, ve, Ee, _e; M < g; ) {
      for (ee = -1; $ < g && (ee = b[_ + $]) === -1; $++) ;
      b[T + ee] !== -1 && (L[b[T + ee]] = -1), b[_ + $] = b[T + ee];
      var V = b[O + ee], J = b[A + ee];
      M += J;
      var ye = 0;
      b[A + ee] = -J;
      var K = x[ee], ae = V === 0 ? K : N, de = ae;
      for (j = 1; j <= V + 1; j++) {
        for (j > V ? (pe = ee, X = K, te = b[C + ee] - V) : (pe = E[K++], X = x[pe], te = b[C + pe]), U = 1; U <= te; U++)
          R = E[X++], !((ue = b[A + R]) <= 0) && (ye += ue, b[A + R] = -ue, E[de++] = R, b[T + R] !== -1 && (L[b[T + R]] = L[R]), L[R] !== -1 ? b[T + L[R]] = b[T + R] : b[_ + b[I + R]] = b[T + R]);
        pe !== ee && (x[pe] = mi(ee), b[B + pe] = 0);
      }
      for (V !== 0 && (N = de), b[I + ee] = ye, x[ee] = ae, b[C + ee] = de - ae, b[O + ee] = -2, F = f(F, d, b, B, g), ce = ae; ce < de; ce++)
        if (R = E[ce], !((se = b[O + R]) <= 0)) {
          ue = -b[A + R];
          var xe = F - ue;
          for (K = x[R], he = x[R] + se - 1; K <= he; K++)
            pe = E[K], b[B + pe] >= F ? b[B + pe] -= ue : b[B + pe] !== 0 && (b[B + pe] = b[I + pe] + xe);
        }
      for (ce = ae; ce < de; ce++) {
        for (R = E[ce], he = x[R], le = he + b[O + R] - 1, ve = he, Ee = 0, _e = 0, K = he; K <= le; K++)
          if (pe = E[K], b[B + pe] !== 0) {
            var Ce = b[B + pe] - F;
            Ce > 0 ? (_e += Ce, E[ve++] = pe, Ee += pe) : (x[pe] = mi(ee), b[B + pe] = 0);
          }
        b[O + R] = ve - he + 1;
        var G = ve, Z = he + b[C + R];
        for (K = le + 1; K < Z; K++) {
          Q = E[K];
          var ge = b[A + Q];
          ge <= 0 || (_e += ge, E[ve++] = Q, Ee += Q);
        }
        _e === 0 ? (x[R] = mi(ee), ue = -b[A + R], ye -= ue, J += ue, M += ue, b[A + R] = 0, b[O + R] = -1) : (b[I + R] = Math.min(b[I + R], _e), E[ve] = E[G], E[G] = E[he], E[he] = ee, b[C + R] = ve - he + 1, Ee = (Ee < 0 ? -Ee : Ee) % g, b[T + R] = b[k + Ee], b[k + Ee] = R, L[R] = Ee);
      }
      for (b[I + ee] = ye, d = Math.max(d, ye), F = f(F + d, d, b, B, g), ce = ae; ce < de; ce++)
        if (R = E[ce], !(b[A + R] >= 0))
          for (Ee = L[R], R = b[k + Ee], b[k + Ee] = -1; R !== -1 && b[T + R] !== -1; R = b[T + R], F++) {
            for (te = b[C + R], se = b[O + R], K = x[R] + 1; K <= x[R] + te - 1; K++)
              b[B + E[K]] = F;
            var be = R;
            for (Q = b[T + R]; Q !== -1; ) {
              var Se = b[C + Q] === te && b[O + Q] === se;
              for (K = x[Q] + 1; Se && K <= x[Q] + te - 1; K++)
                b[B + E[K]] !== F && (Se = 0);
              Se ? (x[Q] = mi(R), b[A + R] += b[A + Q], b[A + Q] = 0, b[O + Q] = -1, Q = b[T + Q], b[T + be] = Q) : (be = Q, Q = b[T + Q]);
            }
          }
      for (K = ae, ce = ae; ce < de; ce++)
        R = E[ce], !((ue = -b[A + R]) <= 0) && (b[A + R] = ue, _e = b[I + R] + ye - ue, _e = Math.min(_e, g - M - ue), b[_ + _e] !== -1 && (L[b[_ + _e]] = R), b[T + R] = b[_ + _e], L[R] = -1, b[_ + _e] = R, $ = Math.min($, _e), b[I + R] = _e, E[K++] = R);
      b[A + ee] = J, (b[C + ee] = K - ae) === 0 && (x[ee] = -1, b[B + ee] = 0), V !== 0 && (N = K);
    }
    for (R = 0; R < g; R++)
      x[R] = mi(x[R]);
    for (Q = 0; Q <= g; Q++)
      b[_ + Q] = -1;
    for (Q = g; Q >= 0; Q--)
      b[A + Q] > 0 || (b[T + Q] = b[_ + x[Q]], b[_ + x[Q]] = Q);
    for (pe = g; pe >= 0; pe--)
      b[A + pe] <= 0 || x[pe] !== -1 && (b[T + pe] = b[_ + x[pe]], b[_ + x[pe]] = pe);
    for (ee = 0, R = 0; R <= g; R++)
      x[R] === -1 && (ee = Yw(R, ee, b, _, T, D, B));
    return D.splice(D.length - 1, 1), D;
  };
  function i(s, c, l, m, h) {
    var g = n(c);
    if (s === 1 && m === l)
      return e(c, g);
    if (s === 2) {
      for (var d = g._index, y = g._ptr, w = 0, E = 0; E < l; E++) {
        var x = y[E];
        if (y[E] = w, !(y[E + 1] - x > h))
          for (var N = y[E + 1]; x < N; x++)
            d[w++] = d[x];
      }
      return y[l] = w, c = n(g), r(g, c);
    }
    return r(g, c);
  }
  function a(s, c, l, m, h, g, d, y, w, E, x, N) {
    for (var D = 0; D < s; D++)
      l[m + D] = c[D + 1] - c[D];
    l[m + s] = 0;
    for (var b = 0; b <= s; b++)
      l[h + b] = -1, g[b] = -1, l[d + b] = -1, l[y + b] = -1, l[w + b] = 1, l[E + b] = 1, l[x + b] = 0, l[N + b] = l[m + b];
    var C = f(0, 0, l, E, s);
    return l[x + s] = -2, c[s] = -1, l[E + s] = 0, C;
  }
  function o(s, c, l, m, h, g, d, y, w, E, x) {
    for (var N = 0, D = 0; D < s; D++) {
      var b = l[m + D];
      if (b === 0)
        l[h + D] = -2, N++, c[D] = -1, l[g + D] = 0;
      else if (b > d)
        l[y + D] = 0, l[h + D] = -1, N++, c[D] = mi(s), l[y + s]++;
      else {
        var C = l[w + b];
        C !== -1 && (E[C] = D), l[x + D] = l[w + b], l[w + b] = D;
      }
    }
    return N;
  }
  function f(s, c, l, m, h) {
    if (s < 2 || s + c < 0) {
      for (var g = 0; g < h; g++)
        l[m + g] !== 0 && (l[m + g] = 1);
      s = 2;
    }
    return s;
  }
  function u(s, c) {
    return s !== c;
  }
});
function GI(t, e, r, n, i, a, o) {
  var f, u, s = 0, c;
  if (t <= e || r[n + e] <= r[i + t])
    return -1;
  r[i + t] = r[n + e];
  var l = r[a + t];
  if (r[a + t] = e, l === -1)
    s = 1, c = t;
  else {
    for (s = 2, c = l; c !== r[o + c]; c = r[o + c]) ;
    for (f = l; f !== c; f = u)
      u = r[o + f], r[o + f] = c;
  }
  return {
    jleaf: s,
    q: c
  };
}
var HI = "csCounts", QI = ["transpose"], VI = /* @__PURE__ */ H(HI, QI, (t) => {
  var {
    transpose: e
  } = t;
  return function(r, n, i, a) {
    if (!r || !n || !i)
      return null;
    var o = r._size, f = o[0], u = o[1], s, c, l, m, h, g, d, y = 4 * u + (a ? u + f + 1 : 0), w = [], E = 0, x = u, N = 2 * u, D = 3 * u, b = 4 * u, C = 5 * u + 1;
    for (l = 0; l < y; l++)
      w[l] = -1;
    var A = [], T = e(r), _ = T._index, O = T._ptr;
    for (l = 0; l < u; l++)
      for (c = i[l], A[c] = w[D + c] === -1 ? 1 : 0; c !== -1 && w[D + c] === -1; c = n[c])
        w[D + c] = l;
    if (a) {
      for (l = 0; l < u; l++)
        w[i[l]] = l;
      for (s = 0; s < f; s++) {
        for (l = u, g = O[s], d = O[s + 1], h = g; h < d; h++)
          l = Math.min(l, w[_[h]]);
        w[C + s] = w[b + l], w[b + l] = s;
      }
    }
    for (s = 0; s < u; s++)
      w[E + s] = s;
    for (l = 0; l < u; l++) {
      for (c = i[l], n[c] !== -1 && A[n[c]]--, m = a ? w[b + l] : c; m !== -1; m = a ? w[C + m] : -1)
        for (h = O[m]; h < O[m + 1]; h++) {
          s = _[h];
          var I = GI(s, c, w, D, x, N, E);
          I.jleaf >= 1 && A[c]++, I.jleaf === 2 && A[I.q]--;
        }
      n[c] !== -1 && (w[E + c] = n[c]);
    }
    for (c = 0; c < u; c++)
      n[c] !== -1 && (A[n[c]] += A[c]);
    return A;
  };
}), WI = "csSqr", jI = ["add", "multiply", "transpose"], YI = /* @__PURE__ */ H(WI, jI, (t) => {
  var {
    add: e,
    multiply: r,
    transpose: n
  } = t, i = UI({
    add: e,
    multiply: r,
    transpose: n
  }), a = VI({
    transpose: n
  });
  return function(u, s, c) {
    var l = s._ptr, m = s._size, h = m[1], g, d = {};
    if (d.q = i(u, s), u && !d.q)
      return null;
    if (c) {
      var y = u ? RI(s, null, d.q) : s;
      d.parent = LI(y);
      var w = PI(d.parent, h);
      if (d.cp = a(y, d.parent, w, 1), y && d.parent && d.cp && o(y, d))
        for (d.unz = 0, g = 0; g < h; g++)
          d.unz += d.cp[g];
    } else
      d.unz = 4 * l[h] + h, d.lnz = d.unz;
    return d;
  };
  function o(f, u) {
    var s = f._ptr, c = f._index, l = f._size, m = l[0], h = l[1];
    u.pinv = [], u.leftmost = [];
    var g = u.parent, d = u.pinv, y = u.leftmost, w = [], E = 0, x = m, N = m + h, D = m + 2 * h, b, C, A, T, _;
    for (C = 0; C < h; C++)
      w[x + C] = -1, w[N + C] = -1, w[D + C] = 0;
    for (b = 0; b < m; b++)
      y[b] = -1;
    for (C = h - 1; C >= 0; C--)
      for (T = s[C], _ = s[C + 1], A = T; A < _; A++)
        y[c[A]] = C;
    for (b = m - 1; b >= 0; b--)
      d[b] = -1, C = y[b], C !== -1 && (w[D + C]++ === 0 && (w[N + C] = b), w[E + b] = w[x + C], w[x + C] = b);
    for (u.lnz = 0, u.m2 = m, C = 0; C < h; C++)
      if (b = w[x + C], u.lnz++, b < 0 && (b = u.m2++), d[b] = C, !(--D[C] <= 0)) {
        u.lnz += w[D + C];
        var O = g[C];
        O !== -1 && (w[D + O] === 0 && (w[N + O] = w[N + C]), w[E + w[N + C]] = w[x + O], w[x + O] = w[E + b], w[D + O] += w[D + C]);
      }
    for (b = 0; b < m; b++)
      d[b] < 0 && (d[b] = C++);
    return !0;
  }
});
function ad(t, e) {
  return t[e] < 0;
}
function Zw(t, e) {
  t[e] = mi(t[e]);
}
function ob(t) {
  return t < 0 ? mi(t) : t;
}
function ZI(t, e, r, n, i) {
  var a = e._index, o = e._ptr, f = e._size, u = f[1], s, c, l, m = 0;
  for (n[0] = t; m >= 0; ) {
    t = n[m];
    var h = i ? i[t] : t;
    ad(o, t) || (Zw(o, t), n[u + m] = h < 0 ? 0 : ob(o[h]));
    var g = 1;
    for (c = n[u + m], l = h < 0 ? 0 : ob(o[h + 1]); c < l; c++)
      if (s = a[c], !ad(o, s)) {
        n[u + m] = c, n[++m] = s, g = 0;
        break;
      }
    g && (m--, n[--r] = t);
  }
  return r;
}
function JI(t, e, r, n, i) {
  var a = t._ptr, o = t._size, f = e._index, u = e._ptr, s = o[1], c, l, m, h = s;
  for (l = u[r], m = u[r + 1], c = l; c < m; c++) {
    var g = f[c];
    ad(a, g) || (h = ZI(g, t, h, n, i));
  }
  for (c = h; c < s; c++)
    Zw(a, n[c]);
  return h;
}
var XI = "csSpsolve", KI = ["divideScalar", "multiply", "subtract"], eF = /* @__PURE__ */ H(XI, KI, (t) => {
  var {
    divideScalar: e,
    multiply: r,
    subtract: n
  } = t;
  return function(a, o, f, u, s, c, l) {
    var m = a._values, h = a._index, g = a._ptr, d = a._size, y = d[1], w = o._values, E = o._index, x = o._ptr, N, D, b, C, A = JI(a, o, f, u, c);
    for (N = A; N < y; N++)
      s[u[N]] = 0;
    for (D = x[f], b = x[f + 1], N = D; N < b; N++)
      s[E[N]] = w[N];
    for (var T = A; T < y; T++) {
      var _ = u[T], O = c ? c[_] : _;
      if (!(O < 0))
        for (D = g[O], b = g[O + 1], s[_] = e(s[_], m[l ? D : b - 1]), N = l ? D + 1 : D, C = l ? b : b - 1; N < C; N++) {
          var I = h[N];
          s[I] = n(s[I], r(m[N], s[_]));
        }
    }
    return A;
  };
}), tF = "csLu", rF = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"], nF = /* @__PURE__ */ H(tF, rF, (t) => {
  var {
    abs: e,
    divideScalar: r,
    multiply: n,
    subtract: i,
    larger: a,
    largerEq: o,
    SparseMatrix: f
  } = t, u = eF({
    divideScalar: r,
    multiply: n,
    subtract: i
  });
  return function(c, l, m) {
    if (!c)
      return null;
    var h = c._size, g = h[1], d, y = 100, w = 100;
    l && (d = l.q, y = l.lnz || y, w = l.unz || w);
    var E = [], x = [], N = [], D = new f({
      values: E,
      index: x,
      ptr: N,
      size: [g, g]
    }), b = [], C = [], A = [], T = new f({
      values: b,
      index: C,
      ptr: A,
      size: [g, g]
    }), _ = [], O, I, B = [], k = [];
    for (O = 0; O < g; O++)
      B[O] = 0, _[O] = -1, N[O + 1] = 0;
    y = 0, w = 0;
    for (var L = 0; L < g; L++) {
      N[L] = y, A[L] = w;
      var F = d ? d[L] : L, M = u(D, c, F, k, B, _, 1), $ = -1, R = -1;
      for (I = M; I < g; I++)
        if (O = k[I], _[O] < 0) {
          var Q = e(B[O]);
          a(Q, R) && (R = Q, $ = O);
        } else
          C[w] = _[O], b[w++] = B[O];
      if ($ === -1 || R <= 0)
        return null;
      _[F] < 0 && o(e(B[F]), n(R, m)) && ($ = F);
      var ee = B[$];
      for (C[w] = L, b[w++] = ee, _[$] = L, x[y] = $, E[y++] = 1, I = M; I < g; I++)
        O = k[I], _[O] < 0 && (x[y] = O, E[y++] = r(B[O], ee)), B[O] = 0;
    }
    for (N[g] = y, A[g] = w, I = 0; I < y; I++)
      x[I] = _[x[I]];
    return E.splice(y, E.length - y), x.splice(y, x.length - y), b.splice(w, b.length - w), C.splice(w, C.length - w), {
      L: D,
      U: T,
      pinv: _
    };
  };
}), ub = "slu", iF = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"], pf = /* @__PURE__ */ H(ub, iF, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    multiply: i,
    transpose: a,
    divideScalar: o,
    subtract: f,
    larger: u,
    largerEq: s,
    SparseMatrix: c
  } = t, l = YI({
    add: n,
    multiply: i,
    transpose: a
  }), m = nF({
    abs: r,
    divideScalar: o,
    multiply: i,
    subtract: f,
    larger: u,
    largerEq: s,
    SparseMatrix: c
  });
  return e(ub, {
    "SparseMatrix, number, number": function(g, d, y) {
      if (!Ve(d) || d < 0 || d > 3)
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      if (y < 0 || y > 1)
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      var w = l(d, g, !1), E = m(g, w, y);
      return {
        L: E.L,
        U: E.U,
        p: E.pinv,
        q: w.q,
        toString: function() {
          return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
p: ` + this.p.toString() + (this.q ? `
q: ` + this.q.toString() : "") + `
`;
        }
      };
    }
  });
});
function lb(t, e) {
  var r, n = e.length, i = [];
  if (t)
    for (r = 0; r < n; r++)
      i[t[r]] = e[r];
  else
    for (r = 0; r < n; r++)
      i[r] = e[r];
  return i;
}
var cb = "lusolve", aF = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"], mf = /* @__PURE__ */ H(cb, aF, (t) => {
  var {
    typed: e,
    matrix: r,
    lup: n,
    slu: i,
    usolve: a,
    lsolve: o,
    DenseMatrix: f
  } = t, u = Vs({
    DenseMatrix: f
  });
  return e(cb, {
    "Array, Array | Matrix": function(m, h) {
      m = r(m);
      var g = n(m), d = c(g.L, g.U, g.p, null, h);
      return d.valueOf();
    },
    "DenseMatrix, Array | Matrix": function(m, h) {
      var g = n(m);
      return c(g.L, g.U, g.p, null, h);
    },
    "SparseMatrix, Array | Matrix": function(m, h) {
      var g = n(m);
      return c(g.L, g.U, g.p, null, h);
    },
    "SparseMatrix, Array | Matrix, number, number": function(m, h, g, d) {
      var y = i(m, g, d);
      return c(y.L, y.U, y.p, y.q, h);
    },
    "Object, Array | Matrix": function(m, h) {
      return c(m.L, m.U, m.p, m.q, h);
    }
  });
  function s(l) {
    if (Ye(l))
      return l;
    if (_t(l))
      return r(l);
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function c(l, m, h, g, d) {
    l = s(l), m = s(m), h && (d = u(l, d, !0), d._data = lb(h, d._data));
    var y = o(l, d), w = a(m, y);
    return g && (w._data = lb(g, w._data)), w;
  }
}), fb = "polynomialRoot", sF = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"], hf = /* @__PURE__ */ H(fb, sF, (t) => {
  var {
    typed: e,
    isZero: r,
    equalScalar: n,
    add: i,
    subtract: a,
    multiply: o,
    divide: f,
    sqrt: u,
    unaryMinus: s,
    cbrt: c,
    typeOf: l,
    im: m,
    re: h
  } = t;
  return e(fb, {
    "number|Complex, ...number|Complex": (g, d) => {
      for (var y = [g, ...d]; y.length > 0 && r(y[y.length - 1]); )
        y.pop();
      if (y.length < 2)
        throw new RangeError("Polynomial [".concat(g, ", ").concat(d, "] must have a non-zero non-constant coefficient"));
      switch (y.length) {
        case 2:
          return [s(f(y[0], y[1]))];
        case 3: {
          var [w, E, x] = y, N = o(2, x), D = o(E, E), b = o(4, x, w);
          if (n(D, b)) return [f(s(E), N)];
          var C = u(a(D, b));
          return [f(a(C, E), N), f(a(s(C), E), N)];
        }
        case 4: {
          var [A, T, _, O] = y, I = s(o(3, O)), B = o(_, _), k = o(3, O, T), L = i(o(2, _, _, _), o(27, O, O, A)), F = o(9, O, _, T);
          if (n(B, k) && n(L, F))
            return [f(_, I)];
          var M = a(B, k), $ = a(L, F), R = i(o(18, O, _, T, A), o(_, _, T, T)), Q = i(o(4, _, _, _, A), o(4, O, T, T, T), o(27, O, O, A, A));
          if (n(R, Q))
            return [
              f(a(o(4, O, _, T), i(o(9, O, O, A), o(_, _, _))), o(O, M)),
              // simple root
              f(a(o(9, O, A), o(_, T)), o(2, M))
              // double root
            ];
          var ee;
          n(B, k) ? ee = $ : ee = f(i($, u(a(o($, $), o(4, M, M, M)))), 2);
          var j = !0, U = c(ee, j).toArray().map((pe) => f(i(_, pe, f(M, pe)), I));
          return U.map((pe) => l(pe) === "Complex" && n(h(pe), h(pe) + m(pe)) ? h(pe) : pe);
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(y));
      }
    }
  });
}), oF = "Help", uF = ["evaluate"], df = /* @__PURE__ */ H(oF, uF, (t) => {
  var {
    evaluate: e
  } = t;
  function r(n) {
    if (!(this instanceof r))
      throw new SyntaxError("Constructor must be called with the new operator");
    if (!n) throw new Error('Argument "doc" missing');
    this.doc = n;
  }
  return r.prototype.type = "Help", r.prototype.isHelp = !0, r.prototype.toString = function() {
    var n = this.doc || {}, i = `
`;
    if (n.name && (i += "Name: " + n.name + `

`), n.category && (i += "Category: " + n.category + `

`), n.description && (i += `Description:
    ` + n.description + `

`), n.syntax && (i += `Syntax:
    ` + n.syntax.join(`
    `) + `

`), n.examples) {
      i += `Examples:
`;
      for (var a = !1, o = e("config()"), f = {
        config: (l) => (a = !0, e("config(newConfig)", {
          newConfig: l
        }))
      }, u = 0; u < n.examples.length; u++) {
        var s = n.examples[u];
        i += "    " + s + `
`;
        var c = void 0;
        try {
          c = e(s, f);
        } catch (l) {
          c = l;
        }
        c !== void 0 && !vu(c) && (i += "        " + vt(c, {
          precision: 14
        }) + `
`);
      }
      i += `
`, a && e("config(originalConfig)", {
        originalConfig: o
      });
    }
    return n.mayThrow && n.mayThrow.length && (i += "Throws: " + n.mayThrow.join(", ") + `

`), n.seealso && n.seealso.length && (i += "See also: " + n.seealso.join(", ") + `
`), i;
  }, r.prototype.toJSON = function() {
    var n = Je(this.doc);
    return n.mathjs = "Help", n;
  }, r.fromJSON = function(n) {
    var i = {};
    return Object.keys(n).filter((a) => a !== "mathjs").forEach((a) => {
      i[a] = n[a];
    }), new r(i);
  }, r.prototype.valueOf = r.prototype.toString, r;
}, {
  isClass: !0
}), lF = "Chain", cF = ["?on", "math", "typed"], gf = /* @__PURE__ */ H(lF, cF, (t) => {
  var {
    on: e,
    math: r,
    typed: n
  } = t;
  function i(s) {
    if (!(this instanceof i))
      throw new SyntaxError("Constructor must be called with the new operator");
    yu(s) ? this.value = s.value : this.value = s;
  }
  i.prototype.type = "Chain", i.prototype.isChain = !0, i.prototype.done = function() {
    return this.value;
  }, i.prototype.valueOf = function() {
    return this.value;
  }, i.prototype.toString = function() {
    return vt(this.value);
  }, i.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  }, i.fromJSON = function(s) {
    return new i(s.value);
  };
  function a(s, c) {
    typeof c == "function" && (i.prototype[s] = f(c));
  }
  function o(s, c) {
    Go(i.prototype, s, function() {
      var m = c();
      if (typeof m == "function")
        return f(m);
    });
  }
  function f(s) {
    return function() {
      if (arguments.length === 0)
        return new i(s(this.value));
      for (var c = [this.value], l = 0; l < arguments.length; l++)
        c[l + 1] = arguments[l];
      if (n.isTypedFunction(s)) {
        var m = n.resolve(s, c);
        if (m.params.length === 1)
          throw new Error("chain function " + s.name + " cannot match rest parameter between chain value and additional arguments.");
        return new i(m.implementation.apply(s, c));
      }
      return new i(s.apply(s, c));
    };
  }
  i.createProxy = function(s, c) {
    if (typeof s == "string")
      a(s, c);
    else {
      var l = function(g) {
        $e(s, g) && u[g] === void 0 && o(g, () => s[g]);
      };
      for (var m in s)
        l(m);
    }
  };
  var u = {
    expression: !0,
    docs: !0,
    type: !0,
    classes: !0,
    json: !0,
    error: !0,
    isChain: !0
    // conflicts with the property isChain of a Chain instance
  };
  return i.createProxy(r), e && e("import", function(s, c, l) {
    l || o(s, c);
  }), i;
}, {
  isClass: !0
}), pb = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
}, fF = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
}, pF = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
}, mF = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
}, hF = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
}, dF = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
}, gF = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
}, vF = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
}, yF = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
}, xF = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
}, bF = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
}, mb = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
}, wF = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
}, NF = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
}, DF = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
}, EF = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
}, SF = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
}, AF = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "bigint", "complex", "fraction", "index", "matrix", "string", "unit"]
}, CF = {
  name: "bigint",
  category: "Construction",
  syntax: ["bigint(x)"],
  description: "Create a bigint, an integer with an arbitrary number of digits, from a number or string.",
  examples: ["123123123123123123 # a large number will lose digits", 'bigint("123123123123123123")', 'bignumber(["1", "3", "5"])'],
  seealso: ["boolean", "bignumber", "number", "complex", "fraction", "index", "matrix", "string", "unit"]
}, TF = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
}, _F = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
}, MF = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
}, OF = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
}, qF = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
}, IF = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
}, FF = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "bigint", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
}, BF = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
}, RF = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
}, PF = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
}, LF = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
}, kF = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
}, zF = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
}, $F = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
  seealso: []
}, UF = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
}, GF = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
}, HF = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
}, QF = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
}, VF = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
}, WF = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
}, jF = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
  seealso: ["cbrt", "sqrt"]
}, YF = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
}, ZF = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
}, JF = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
}, XF = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
}, KF = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
}, e4 = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
}, t4 = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
}, r4 = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
}, n4 = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
}, i4 = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
}, a4 = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
}, s4 = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
}, o4 = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
}, u4 = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
  seealso: ["floor", "fix", "round"]
}, l4 = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
}, c4 = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
}, f4 = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
}, p4 = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
}, m4 = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
}, h4 = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
  seealso: ["expm", "expm1", "pow", "log"]
}, d4 = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
}, g4 = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
}, v4 = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
  seealso: ["ceil", "floor", "round"]
}, y4 = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
  seealso: ["ceil", "fix", "round"]
}, x4 = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
}, b4 = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenusa of a list with values. ",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
}, w4 = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)",
  examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
  seealso: ["gcd", "xgcd"]
}, N4 = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
}, D4 = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
}, E4 = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
}, S4 = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
}, A4 = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
}, C4 = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
}, T4 = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
}, _4 = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
}, M4 = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
}, O4 = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
}, q4 = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
}, I4 = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)", "round(unit, valuelessUnit)", "round(unit, n, valuelessUnit)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)", "round(3.241cm, 2, cm)", "round([3.2, 3.8, -4.7])"],
  seealso: ["ceil", "floor", "fix"]
}, F4 = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
}, B4 = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
}, R4 = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
}, P4 = {
  name: "sylvester",
  category: "Algebra",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
  seealso: ["schur", "lyap"]
}, L4 = {
  name: "schur",
  category: "Algebra",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU'",
  examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
  seealso: ["lyap", "sylvester"]
}, k4 = {
  name: "lyap",
  category: "Algebra",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
  examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
  seealso: ["schur", "sylvester"]
}, z4 = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
}, $4 = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
}, U4 = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
}, G4 = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
}, H4 = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
}, Q4 = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
}, V4 = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
}, W4 = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
}, j4 = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
}, Y4 = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
}, Z4 = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
}, J4 = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
}, X4 = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
}, K4 = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
}, e5 = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
}, t5 = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
}, r5 = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
}, n5 = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
}, i5 = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
}, a5 = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
}, s5 = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
  seealso: []
}, o5 = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
}, u5 = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
}, l5 = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
}, c5 = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
}, f5 = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
}, p5 = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
}, m5 = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
}, h5 = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
}, d5 = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, g5 = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
}, v5 = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
}, y5 = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
}, x5 = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, b5 = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, w5 = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
  seealso: ["subtract", "partitionSelect"]
}, N5 = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
}, D5 = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])", "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"],
  seealso: ["inv"]
}, E5 = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
}, S5 = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
}, A5 = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
}, C5 = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
}, T5 = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, _5 = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, M5 = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore–Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
}, O5 = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
}, q5 = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
  examples: ["map([1, 2, 3], square)"],
  seealso: ["filter", "forEach"]
}, I5 = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
}, F5 = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
}, B5 = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
}, R5 = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, P5 = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
  seealso: ["sort"]
}, L5 = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
}, k5 = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
  seealso: ["size", "squeeze", "resize"]
}, z5 = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
}, $5 = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
}, U5 = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
}, G5 = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
}, H5 = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
}, Q5 = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
}, V5 = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
}, W5 = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
}, j5 = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
}, Y5 = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
}, Z5 = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
}, J5 = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
}, X5 = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
}, K5 = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
}, eB = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
}, tB = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
}, rB = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
}, nB = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
}, iB = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
}, aB = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
}, sB = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
}, oB = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
}, uB = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
}, lB = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
}, cB = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
}, fB = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
}, pB = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
}, mB = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
}, hB = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
}, dB = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
}, gB = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
}, vB = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
}, yB = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
}, xB = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
}, bB = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
}, wB = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
}, NB = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
}, DB = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
}, EB = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
}, SB = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
}, AB = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
}, CB = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
}, TB = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
}, _B = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
}, MB = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
}, OB = {
  name: "zpk2tf",
  category: "Signal",
  syntax: ["zpk2tf(z, p, k)"],
  description: "Compute the transfer function of a zero-pole-gain model.",
  examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
  seealso: []
}, qB = {
  name: "freqz",
  category: "Signal",
  syntax: ["freqz(b, a)", "freqz(b, a, w)"],
  description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
  examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
  seealso: []
}, IB = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
}, FB = {
  name: "zeta",
  category: "Special",
  syntax: ["zeta(s)"],
  description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
  examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
  seealso: []
}, BB = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
}, RB = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
}, PB = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
}, LB = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
}, kB = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
}, zB = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
}, $B = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
}, UB = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: `Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. 

In case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.`,
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
}, GB = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
}, HB = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
}, QB = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
}, VB = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
}, WB = {
  name: "corr",
  category: "Statistics",
  syntax: ["corr(A,B)"],
  description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
  examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
}, jB = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
}, YB = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
}, ZB = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
}, JB = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
}, XB = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
}, KB = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
}, e8 = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
}, t8 = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
}, r8 = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
}, n8 = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
}, i8 = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
}, a8 = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
}, s8 = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
}, o8 = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
}, u8 = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
}, l8 = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
}, c8 = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
}, f8 = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
}, p8 = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
}, m8 = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
}, h8 = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
}, d8 = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
}, g8 = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
}, v8 = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
}, y8 = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
}, x8 = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
}, b8 = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
}, w8 = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
}, N8 = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
}, D8 = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
}, E8 = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
}, S8 = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
}, A8 = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
}, C8 = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
}, T8 = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
}, _8 = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
}, M8 = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
}, O8 = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
}, q8 = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "bigint")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
  seealso: ["number", "bigint", "fraction", "bignumber", "string", "format"]
}, I8 = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
}, F8 = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
  seealso: ["format"]
}, B8 = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
}, R8 = {
  name: "solveODE",
  category: "Numeric",
  syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
  description: "Numerical Integration of Ordinary Differential Equations.",
  examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
  seealso: ["derivative", "simplifyCore"]
}, Jw = {
  // construction functions
  bignumber: AF,
  bigint: CF,
  boolean: TF,
  complex: _F,
  createUnit: MF,
  fraction: OF,
  index: qF,
  matrix: IF,
  number: FF,
  sparse: BF,
  splitUnit: RF,
  string: PF,
  unit: LF,
  // constants
  e: pb,
  E: pb,
  false: fF,
  i: pF,
  Infinity: mF,
  LN2: dF,
  LN10: hF,
  LOG2E: vF,
  LOG10E: gF,
  NaN: yF,
  null: xF,
  pi: mb,
  PI: mb,
  phi: bF,
  SQRT1_2: wF,
  SQRT2: NF,
  tau: DF,
  true: EF,
  version: SF,
  // physical constants
  // TODO: more detailed docs for physical constants
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Borh magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  // josephson: {description: 'Josephson constant', examples: ['josephson']},
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Borh radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro's number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  // functions - algebra
  derivative: UF,
  lsolve: HF,
  lsolveAll: QF,
  lup: VF,
  lusolve: WF,
  leafCount: GF,
  polynomialRoot: jF,
  resolve: JF,
  simplify: XF,
  simplifyConstant: KF,
  simplifyCore: e4,
  symbolicEqual: r4,
  rationalize: ZF,
  slu: t4,
  usolve: n4,
  usolveAll: i4,
  qr: YF,
  // functions - arithmetic
  abs: a4,
  add: s4,
  cbrt: o4,
  ceil: u4,
  cube: l4,
  divide: c4,
  dotDivide: f4,
  dotMultiply: p4,
  dotPow: m4,
  exp: h4,
  expm: d4,
  expm1: g4,
  fix: v4,
  floor: y4,
  gcd: x4,
  hypot: b4,
  lcm: N4,
  log: D4,
  log2: A4,
  log1p: S4,
  log10: E4,
  mod: C4,
  multiply: T4,
  norm: _4,
  nthRoot: M4,
  nthRoots: O4,
  pow: q4,
  round: I4,
  sign: F4,
  sqrt: B4,
  sqrtm: R4,
  square: z4,
  subtract: $4,
  unaryMinus: U4,
  unaryPlus: G4,
  xgcd: H4,
  invmod: w4,
  // functions - bitwise
  bitAnd: Q4,
  bitNot: V4,
  bitOr: W4,
  bitXor: j4,
  leftShift: Y4,
  rightArithShift: Z4,
  rightLogShift: J4,
  // functions - combinatorics
  bellNumbers: X4,
  catalan: K4,
  composition: e5,
  stirlingS2: t5,
  // functions - core
  config: kF,
  import: zF,
  typed: $F,
  // functions - complex
  arg: r5,
  conj: n5,
  re: a5,
  im: i5,
  // functions - expression
  evaluate: s5,
  help: o5,
  // functions - geometry
  distance: u5,
  intersect: l5,
  // functions - logical
  and: c5,
  not: f5,
  or: p5,
  xor: m5,
  // functions - matrix
  concat: d5,
  count: g5,
  cross: v5,
  column: h5,
  ctranspose: y5,
  det: x5,
  diag: b5,
  diff: w5,
  dot: N5,
  getMatrixDataType: C5,
  identity: T5,
  filter: E5,
  flatten: S5,
  forEach: A5,
  inv: _5,
  pinv: M5,
  eigs: D5,
  kron: O5,
  matrixFromFunction: F5,
  matrixFromRows: B5,
  matrixFromColumns: I5,
  map: q5,
  ones: R5,
  partitionSelect: P5,
  range: L5,
  resize: z5,
  reshape: k5,
  rotate: $5,
  rotationMatrix: U5,
  row: G5,
  size: H5,
  sort: Q5,
  squeeze: V5,
  subset: W5,
  trace: j5,
  transpose: Y5,
  zeros: Z5,
  fft: J5,
  ifft: X5,
  sylvester: P4,
  schur: L4,
  lyap: k4,
  // functions - numeric
  solveODE: R8,
  // functions - probability
  combinations: K5,
  combinationsWithRep: eB,
  // distribution: distributionDocs,
  factorial: tB,
  gamma: rB,
  kldivergence: iB,
  lgamma: nB,
  multinomial: aB,
  permutations: sB,
  pickRandom: oB,
  random: uB,
  randomInt: lB,
  // functions - relational
  compare: cB,
  compareNatural: fB,
  compareText: pB,
  deepEqual: mB,
  equal: hB,
  equalText: dB,
  larger: gB,
  largerEq: vB,
  smaller: yB,
  smallerEq: xB,
  unequal: bB,
  // functions - set
  setCartesian: wB,
  setDifference: NB,
  setDistinct: DB,
  setIntersect: EB,
  setIsSubset: SB,
  setMultiplicity: AB,
  setPowerset: CB,
  setSize: TB,
  setSymDifference: _B,
  setUnion: MB,
  // functions - signal
  zpk2tf: OB,
  freqz: qB,
  // functions - special
  erf: IB,
  zeta: FB,
  // functions - statistics
  cumsum: HB,
  mad: BB,
  max: RB,
  mean: PB,
  median: LB,
  min: kB,
  mode: zB,
  prod: $B,
  quantileSeq: UB,
  std: GB,
  sum: QB,
  variance: VB,
  corr: WB,
  // functions - trigonometry
  acos: jB,
  acosh: YB,
  acot: ZB,
  acoth: JB,
  acsc: XB,
  acsch: KB,
  asec: e8,
  asech: t8,
  asin: r8,
  asinh: n8,
  atan: i8,
  atanh: s8,
  atan2: a8,
  cos: o8,
  cosh: u8,
  cot: l8,
  coth: c8,
  csc: f8,
  csch: p8,
  sec: m8,
  sech: h8,
  sin: d8,
  sinh: g8,
  tan: v8,
  tanh: y8,
  // functions - units
  to: x8,
  // functions - utils
  clone: w8,
  format: N8,
  bin: b8,
  oct: I8,
  hex: E8,
  isNaN: A8,
  isInteger: S8,
  isNegative: C8,
  isNumeric: T8,
  hasNumericValue: D8,
  isPositive: _8,
  isPrime: M8,
  isZero: O8,
  print: F8,
  typeOf: B8,
  numeric: q8
}, hb = "help", P8 = ["typed", "mathWithTransform", "Help"], vf = /* @__PURE__ */ H(hb, P8, (t) => {
  var {
    typed: e,
    mathWithTransform: r,
    Help: n
  } = t;
  return e(hb, {
    any: function(a) {
      var o, f = a;
      if (typeof a != "string") {
        for (o in r)
          if ($e(r, o) && a === r[o]) {
            f = o;
            break;
          }
      }
      var u = kr(Jw, f);
      if (!u) {
        var s = typeof f == "function" ? f.name : f;
        throw new Error('No documentation found on "' + s + '"');
      }
      return new n(u);
    }
  });
}), db = "chain", L8 = ["typed", "Chain"], yf = /* @__PURE__ */ H(db, L8, (t) => {
  var {
    typed: e,
    Chain: r
  } = t;
  return e(db, {
    "": function() {
      return new r();
    },
    any: function(i) {
      return new r(i);
    }
  });
}), gb = "det", k8 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"], xf = /* @__PURE__ */ H(gb, k8, (t) => {
  var {
    typed: e,
    matrix: r,
    subtractScalar: n,
    multiply: i,
    divideScalar: a,
    isZero: o,
    unaryMinus: f
  } = t;
  return e(gb, {
    any: function(c) {
      return Je(c);
    },
    "Array | Matrix": function(c) {
      var l;
      switch (Ye(c) ? l = c.size() : Array.isArray(c) ? (c = r(c), l = c.size()) : l = [], l.length) {
        case 0:
          return Je(c);
        case 1:
          if (l[0] === 1)
            return Je(c.valueOf()[0]);
          if (l[0] === 0)
            return 1;
          throw new RangeError("Matrix must be square (size: " + vt(l) + ")");
        case 2: {
          var m = l[0], h = l[1];
          if (m === h)
            return u(c.clone().valueOf(), m);
          if (h === 0)
            return 1;
          throw new RangeError("Matrix must be square (size: " + vt(l) + ")");
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + vt(l) + ")");
      }
    }
  });
  function u(s, c, l) {
    if (c === 1)
      return Je(s[0][0]);
    if (c === 2)
      return n(i(s[0][0], s[1][1]), i(s[1][0], s[0][1]));
    for (var m = !1, h = new Array(c).fill(0).map((C, A) => A), g = 0; g < c; g++) {
      var d = h[g];
      if (o(s[d][g])) {
        var y = void 0;
        for (y = g + 1; y < c; y++)
          if (!o(s[h[y]][g])) {
            d = h[y], h[y] = h[g], h[g] = d, m = !m;
            break;
          }
        if (y === c) return s[d][g];
      }
      for (var w = s[d][g], E = g === 0 ? 1 : s[h[g - 1]][g - 1], x = g + 1; x < c; x++)
        for (var N = h[x], D = g + 1; D < c; D++)
          s[N][D] = a(n(i(s[N][D], w), i(s[N][g], s[d][D])), E);
    }
    var b = s[h[c - 1]][c - 1];
    return m ? f(b) : b;
  }
}), vb = "inv", z8 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"], bf = /* @__PURE__ */ H(vb, z8, (t) => {
  var {
    typed: e,
    matrix: r,
    divideScalar: n,
    addScalar: i,
    multiply: a,
    unaryMinus: o,
    det: f,
    identity: u,
    abs: s
  } = t;
  return e(vb, {
    "Array | Matrix": function(m) {
      var h = Ye(m) ? m.size() : ft(m);
      switch (h.length) {
        case 1:
          if (h[0] === 1)
            return Ye(m) ? r([n(1, m.valueOf()[0])]) : [n(1, m[0])];
          throw new RangeError("Matrix must be square (size: " + vt(h) + ")");
        case 2: {
          var g = h[0], d = h[1];
          if (g === d)
            return Ye(m) ? r(c(m.valueOf(), g, d), m.storage()) : c(m, g, d);
          throw new RangeError("Matrix must be square (size: " + vt(h) + ")");
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + vt(h) + ")");
      }
    },
    any: function(m) {
      return n(1, m);
    }
  });
  function c(l, m, h) {
    var g, d, y, w, E;
    if (m === 1) {
      if (w = l[0][0], w === 0)
        throw Error("Cannot calculate inverse, determinant is zero");
      return [[n(1, w)]];
    } else if (m === 2) {
      var x = f(l);
      if (x === 0)
        throw Error("Cannot calculate inverse, determinant is zero");
      return [[n(l[1][1], x), n(o(l[0][1]), x)], [n(o(l[1][0]), x), n(l[0][0], x)]];
    } else {
      var N = l.concat();
      for (g = 0; g < m; g++)
        N[g] = N[g].concat();
      for (var D = u(m).valueOf(), b = 0; b < h; b++) {
        var C = s(N[b][b]), A = b;
        for (g = b + 1; g < m; )
          s(N[g][b]) > C && (C = s(N[g][b]), A = g), g++;
        if (C === 0)
          throw Error("Cannot calculate inverse, determinant is zero");
        g = A, g !== b && (E = N[b], N[b] = N[g], N[g] = E, E = D[b], D[b] = D[g], D[g] = E);
        var T = N[b], _ = D[b];
        for (g = 0; g < m; g++) {
          var O = N[g], I = D[g];
          if (g !== b) {
            if (O[b] !== 0) {
              for (y = n(o(O[b]), T[b]), d = b; d < h; d++)
                O[d] = i(O[d], a(y, T[d]));
              for (d = 0; d < h; d++)
                I[d] = i(I[d], a(y, _[d]));
            }
          } else {
            for (y = T[b], d = b; d < h; d++)
              O[d] = n(O[d], y);
            for (d = 0; d < h; d++)
              I[d] = n(I[d], y);
          }
        }
      }
      return D;
    }
  }
}), yb = "pinv", $8 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"], wf = /* @__PURE__ */ H(yb, $8, (t) => {
  var {
    typed: e,
    matrix: r,
    inv: n,
    deepEqual: i,
    equal: a,
    dotDivide: o,
    dot: f,
    ctranspose: u,
    divideScalar: s,
    multiply: c,
    add: l,
    Complex: m
  } = t;
  return e(yb, {
    "Array | Matrix": function(x) {
      var N = Ye(x) ? x.size() : ft(x);
      switch (N.length) {
        case 1:
          return w(x) ? u(x) : N[0] === 1 ? n(x) : o(u(x), f(x, x));
        case 2: {
          if (w(x)) return u(x);
          var D = N[0], b = N[1];
          if (D === b)
            try {
              return n(x);
            } catch (C) {
              if (!(C instanceof Error && C.message.match(/Cannot calculate inverse, determinant is zero/))) throw C;
            }
          return Ye(x) ? r(h(x.valueOf(), D, b), x.storage()) : h(x, D, b);
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + vt(N) + ")");
      }
    },
    any: function(x) {
      return a(x, 0) ? Je(x) : s(1, x);
    }
  });
  function h(E, x, N) {
    var {
      C: D,
      F: b
    } = d(E, x, N), C = c(n(c(u(D), D)), u(D)), A = c(u(b), n(c(b, u(b))));
    return c(A, C);
  }
  function g(E, x, N) {
    for (var D = Je(E), b = 0, C = 0; C < x; C++) {
      if (N <= b)
        return D;
      for (var A = C; y(D[A][b]); )
        if (A++, x === A && (A = C, b++, N === b))
          return D;
      [D[A], D[C]] = [D[C], D[A]];
      for (var T = D[C][b], _ = 0; _ < N; _++)
        D[C][_] = o(D[C][_], T);
      for (var O = 0; O < x; O++)
        if (O !== C) {
          T = D[O][b];
          for (var I = 0; I < N; I++)
            D[O][I] = l(D[O][I], c(-1, c(T, D[C][I])));
        }
      b++;
    }
    return D;
  }
  function d(E, x, N) {
    var D = g(E, x, N), b = E.map((A, T) => A.filter((_, O) => O < x && !y(f(D[O], D[O])))), C = D.filter((A, T) => !y(f(D[T], D[T])));
    return {
      C: b,
      F: C
    };
  }
  function y(E) {
    return a(l(E, m(1, 1)), l(0, m(1, 1)));
  }
  function w(E) {
    return i(l(E, m(1, 1)), l(c(E, 0), m(1, 1)));
  }
});
function U8(t) {
  var {
    addScalar: e,
    subtract: r,
    flatten: n,
    multiply: i,
    multiplyScalar: a,
    divideScalar: o,
    sqrt: f,
    abs: u,
    bignumber: s,
    diag: c,
    size: l,
    reshape: m,
    inv: h,
    qr: g,
    usolve: d,
    usolveAll: y,
    equal: w,
    complex: E,
    larger: x,
    smaller: N,
    matrixFromColumns: D,
    dot: b
  } = t;
  function C(j, U, pe, X) {
    var te = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, ue = A(j, U, pe, X, te);
    T(j, U, pe, X, te, ue);
    var {
      values: ce,
      C: se
    } = _(j, U, pe, X, te);
    if (te) {
      var he = O(j, U, se, ue, ce, pe, X);
      return {
        values: ce,
        eigenvectors: he
      };
    }
    return {
      values: ce
    };
  }
  function A(j, U, pe, X, te) {
    var ue = X === "BigNumber", ce = X === "Complex", se = ue ? s(0) : 0, he = ue ? s(1) : ce ? E(1) : 1, le = ue ? s(1) : 1, ve = ue ? s(10) : 2, Ee = a(ve, ve), _e;
    te && (_e = Array(U).fill(he));
    for (var V = !1; !V; ) {
      V = !0;
      for (var J = 0; J < U; J++) {
        for (var ye = se, K = se, ae = 0; ae < U; ae++)
          J !== ae && (ye = e(ye, u(j[ae][J])), K = e(K, u(j[J][ae])));
        if (!w(ye, 0) && !w(K, 0)) {
          for (var de = le, xe = ye, Ce = o(K, ve), G = a(K, ve); N(xe, Ce); )
            xe = a(xe, Ee), de = a(de, ve);
          for (; x(xe, G); )
            xe = o(xe, Ee), de = o(de, ve);
          var Z = N(o(e(xe, K), de), a(e(ye, K), 0.95));
          if (Z) {
            V = !1;
            for (var ge = o(1, de), be = 0; be < U; be++)
              J !== be && (j[J][be] = a(j[J][be], ge), j[be][J] = a(j[be][J], de));
            te && (_e[J] = a(_e[J], ge));
          }
        }
      }
    }
    return te ? c(_e) : null;
  }
  function T(j, U, pe, X, te, ue) {
    var ce = X === "BigNumber", se = X === "Complex", he = ce ? s(0) : se ? E(0) : 0;
    ce && (pe = s(pe));
    for (var le = 0; le < U - 2; le++) {
      for (var ve = 0, Ee = he, _e = le + 1; _e < U; _e++) {
        var V = j[_e][le];
        N(u(Ee), u(V)) && (Ee = V, ve = _e);
      }
      if (!N(u(Ee), pe)) {
        if (ve !== le + 1) {
          var J = j[ve];
          j[ve] = j[le + 1], j[le + 1] = J;
          for (var ye = 0; ye < U; ye++) {
            var K = j[ye][ve];
            j[ye][ve] = j[ye][le + 1], j[ye][le + 1] = K;
          }
          if (te) {
            var ae = ue[ve];
            ue[ve] = ue[le + 1], ue[le + 1] = ae;
          }
        }
        for (var de = le + 2; de < U; de++) {
          var xe = o(j[de][le], Ee);
          if (xe !== 0) {
            for (var Ce = 0; Ce < U; Ce++)
              j[de][Ce] = r(j[de][Ce], a(xe, j[le + 1][Ce]));
            for (var G = 0; G < U; G++)
              j[G][le + 1] = e(j[G][le + 1], a(xe, j[G][de]));
            if (te)
              for (var Z = 0; Z < U; Z++)
                ue[de][Z] = r(ue[de][Z], a(xe, ue[le + 1][Z]));
          }
        }
      }
    }
    return ue;
  }
  function _(j, U, pe, X, te) {
    var ue = X === "BigNumber", ce = X === "Complex", se = ue ? s(1) : ce ? E(1) : 1;
    ue && (pe = s(pe));
    for (var he = Je(j), le = [], ve = U, Ee = [], _e = te ? c(Array(U).fill(se)) : void 0, V = te ? c(Array(ve).fill(se)) : void 0, J = 0; J <= 100; ) {
      J += 1;
      for (var ye = he[ve - 1][ve - 1], K = 0; K < ve; K++)
        he[K][K] = r(he[K][K], ye);
      var {
        Q: ae,
        R: de
      } = g(he);
      he = i(de, ae);
      for (var xe = 0; xe < ve; xe++)
        he[xe][xe] = e(he[xe][xe], ye);
      if (te && (V = i(V, ae)), ve === 1 || N(u(he[ve - 1][ve - 2]), pe)) {
        J = 0, le.push(he[ve - 1][ve - 1]), te && (Ee.unshift([[1]]), k(V, U), _e = i(_e, V), ve > 1 && (V = c(Array(ve - 1).fill(se)))), ve -= 1, he.pop();
        for (var Ce = 0; Ce < ve; Ce++)
          he[Ce].pop();
      } else if (ve === 2 || N(u(he[ve - 2][ve - 3]), pe)) {
        J = 0;
        var G = I(he[ve - 2][ve - 2], he[ve - 2][ve - 1], he[ve - 1][ve - 2], he[ve - 1][ve - 1]);
        le.push(...G), te && (Ee.unshift(B(he[ve - 2][ve - 2], he[ve - 2][ve - 1], he[ve - 1][ve - 2], he[ve - 1][ve - 1], G[0], G[1], pe, X)), k(V, U), _e = i(_e, V), ve > 2 && (V = c(Array(ve - 2).fill(se)))), ve -= 2, he.pop(), he.pop();
        for (var Z = 0; Z < ve; Z++)
          he[Z].pop(), he[Z].pop();
      }
      if (ve === 0)
        break;
    }
    if (le.sort((Se, De) => +r(u(Se), u(De))), J > 100) {
      var ge = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + le.join(", "));
      throw ge.values = le, ge.vectors = [], ge;
    }
    var be = te ? i(_e, L(Ee, U)) : void 0;
    return {
      values: le,
      C: be
    };
  }
  function O(j, U, pe, X, te, ue, ce) {
    var se = h(pe), he = i(se, j, pe), le = ce === "BigNumber", ve = ce === "Complex", Ee = le ? s(0) : ve ? E(0) : 0, _e = le ? s(1) : ve ? E(1) : 1, V = [], J = [];
    for (var ye of te) {
      var K = F(V, ye, w);
      K === -1 ? (V.push(ye), J.push(1)) : J[K] += 1;
    }
    for (var ae = [], de = V.length, xe = Array(U).fill(Ee), Ce = c(Array(U).fill(_e)), G = function() {
      var be = V[Z], Se = r(he, i(be, Ce)), De = y(Se, xe);
      for (De.shift(); De.length < J[Z]; ) {
        var Me = M(Se, U, De, ue, ce);
        if (Me === null)
          break;
        De.push(Me);
      }
      var Oe = i(h(X), pe);
      De = De.map((Be) => i(Oe, Be)), ae.push(...De.map((Be) => ({
        value: be,
        vector: n(Be)
      })));
    }, Z = 0; Z < de; Z++)
      G();
    return ae;
  }
  function I(j, U, pe, X) {
    var te = e(j, X), ue = r(a(j, X), a(U, pe)), ce = a(te, 0.5), se = a(f(r(a(te, te), a(4, ue))), 0.5);
    return [e(ce, se), r(ce, se)];
  }
  function B(j, U, pe, X, te, ue, ce, se) {
    var he = se === "BigNumber", le = se === "Complex", ve = he ? s(0) : le ? E(0) : 0, Ee = he ? s(1) : le ? E(1) : 1;
    if (N(u(pe), ce))
      return [[Ee, ve], [ve, Ee]];
    if (x(u(r(te, ue)), ce))
      return [[r(te, X), r(ue, X)], [pe, pe]];
    var _e = r(j, te), V = r(X, te);
    return N(u(U), ce) && N(u(V), ce) ? [[_e, Ee], [pe, ve]] : [[U, ve], [V, Ee]];
  }
  function k(j, U) {
    for (var pe = 0; pe < j.length; pe++)
      j[pe].push(...Array(U - j[pe].length).fill(0));
    for (var X = j.length; X < U; X++)
      j.push(Array(U).fill(0)), j[X][X] = 1;
    return j;
  }
  function L(j, U) {
    for (var pe = [], X = 0; X < U; X++)
      pe[X] = Array(U).fill(0);
    var te = 0;
    for (var ue of j) {
      for (var ce = ue.length, se = 0; se < ce; se++)
        for (var he = 0; he < ce; he++)
          pe[te + se][te + he] = ue[se][he];
      te += ce;
    }
    return pe;
  }
  function F(j, U, pe) {
    for (var X = 0; X < j.length; X++)
      if (pe(j[X], U))
        return X;
    return -1;
  }
  function M(j, U, pe, X, te) {
    for (var ue = te === "BigNumber" ? s(1e3) : 1e3, ce, se = 0; se < 5; ++se) {
      ce = $(U, pe, te);
      try {
        ce = d(j, ce);
      } catch {
        continue;
      }
      if (x(Q(ce), ue))
        break;
    }
    if (se >= 5)
      return null;
    for (se = 0; ; ) {
      var he = d(j, ce);
      if (N(Q(R(ce, [he])), X))
        break;
      if (++se >= 10)
        return null;
      ce = ee(he);
    }
    return ce;
  }
  function $(j, U, pe) {
    var X = pe === "BigNumber", te = pe === "Complex", ue = Array(j).fill(0).map((ce) => 2 * Math.random() - 1);
    return X && (ue = ue.map((ce) => s(ce))), te && (ue = ue.map((ce) => E(ce))), ue = R(ue, U), ee(ue, pe);
  }
  function R(j, U) {
    var pe = l(j);
    for (var X of U)
      X = m(X, pe), j = r(j, i(o(b(X, j), b(X, X)), X));
    return j;
  }
  function Q(j) {
    return u(f(b(j, j)));
  }
  function ee(j, U) {
    var pe = U === "BigNumber", X = U === "Complex", te = pe ? s(1) : X ? E(1) : 1;
    return i(o(te, Q(j)), j);
  }
  return C;
}
function G8(t) {
  var {
    config: e,
    addScalar: r,
    subtract: n,
    abs: i,
    atan: a,
    cos: o,
    sin: f,
    multiplyScalar: u,
    inv: s,
    bignumber: c,
    multiply: l,
    add: m
  } = t;
  function h(T, _) {
    var O = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.relTol, I = arguments.length > 3 ? arguments[3] : void 0, B = arguments.length > 4 ? arguments[4] : void 0;
    if (I === "number")
      return g(T, O, B);
    if (I === "BigNumber")
      return d(T, O, B);
    throw TypeError("Unsupported data type: " + I);
  }
  function g(T, _, O) {
    var I = T.length, B = Math.abs(_ / I), k, L;
    if (O) {
      L = new Array(I);
      for (var F = 0; F < I; F++)
        L[F] = Array(I).fill(0), L[F][F] = 1;
    }
    for (var M = b(T); Math.abs(M[1]) >= Math.abs(B); ) {
      var $ = M[0][0], R = M[0][1];
      k = y(T[$][$], T[R][R], T[$][R]), T = D(T, k, $, R), O && (L = E(L, k, $, R)), M = b(T);
    }
    for (var Q = Array(I).fill(0), ee = 0; ee < I; ee++)
      Q[ee] = T[ee][ee];
    return A(Je(Q), L, O);
  }
  function d(T, _, O) {
    var I = T.length, B = i(_ / I), k, L;
    if (O) {
      L = new Array(I);
      for (var F = 0; F < I; F++)
        L[F] = Array(I).fill(0), L[F][F] = 1;
    }
    for (var M = C(T); i(M[1]) >= i(B); ) {
      var $ = M[0][0], R = M[0][1];
      k = w(T[$][$], T[R][R], T[$][R]), T = N(T, k, $, R), O && (L = x(L, k, $, R)), M = C(T);
    }
    for (var Q = Array(I).fill(0), ee = 0; ee < I; ee++)
      Q[ee] = T[ee][ee];
    return A(Je(Q), L, O);
  }
  function y(T, _, O) {
    var I = _ - T;
    return Math.abs(I) <= e.relTol ? Math.PI / 4 : 0.5 * Math.atan(2 * O / (_ - T));
  }
  function w(T, _, O) {
    var I = n(_, T);
    return i(I) <= e.relTol ? c(-1).acos().div(4) : u(0.5, a(l(2, O, s(I))));
  }
  function E(T, _, O, I) {
    for (var B = T.length, k = Math.cos(_), L = Math.sin(_), F = Array(B).fill(0), M = Array(B).fill(0), $ = 0; $ < B; $++)
      F[$] = k * T[$][O] - L * T[$][I], M[$] = L * T[$][O] + k * T[$][I];
    for (var R = 0; R < B; R++)
      T[R][O] = F[R], T[R][I] = M[R];
    return T;
  }
  function x(T, _, O, I) {
    for (var B = T.length, k = o(_), L = f(_), F = Array(B).fill(c(0)), M = Array(B).fill(c(0)), $ = 0; $ < B; $++)
      F[$] = n(u(k, T[$][O]), u(L, T[$][I])), M[$] = r(u(L, T[$][O]), u(k, T[$][I]));
    for (var R = 0; R < B; R++)
      T[R][O] = F[R], T[R][I] = M[R];
    return T;
  }
  function N(T, _, O, I) {
    for (var B = T.length, k = c(o(_)), L = c(f(_)), F = u(k, k), M = u(L, L), $ = Array(B).fill(c(0)), R = Array(B).fill(c(0)), Q = l(c(2), k, L, T[O][I]), ee = r(n(u(F, T[O][O]), Q), u(M, T[I][I])), j = m(u(M, T[O][O]), Q, u(F, T[I][I])), U = 0; U < B; U++)
      $[U] = n(u(k, T[O][U]), u(L, T[I][U])), R[U] = r(u(L, T[O][U]), u(k, T[I][U]));
    T[O][O] = ee, T[I][I] = j, T[O][I] = c(0), T[I][O] = c(0);
    for (var pe = 0; pe < B; pe++)
      pe !== O && pe !== I && (T[O][pe] = $[pe], T[pe][O] = $[pe], T[I][pe] = R[pe], T[pe][I] = R[pe]);
    return T;
  }
  function D(T, _, O, I) {
    for (var B = T.length, k = Math.cos(_), L = Math.sin(_), F = k * k, M = L * L, $ = Array(B).fill(0), R = Array(B).fill(0), Q = F * T[O][O] - 2 * k * L * T[O][I] + M * T[I][I], ee = M * T[O][O] + 2 * k * L * T[O][I] + F * T[I][I], j = 0; j < B; j++)
      $[j] = k * T[O][j] - L * T[I][j], R[j] = L * T[O][j] + k * T[I][j];
    T[O][O] = Q, T[I][I] = ee, T[O][I] = 0, T[I][O] = 0;
    for (var U = 0; U < B; U++)
      U !== O && U !== I && (T[O][U] = $[U], T[U][O] = $[U], T[I][U] = R[U], T[U][I] = R[U]);
    return T;
  }
  function b(T) {
    for (var _ = T.length, O = 0, I = [0, 1], B = 0; B < _; B++)
      for (var k = B + 1; k < _; k++)
        Math.abs(O) < Math.abs(T[B][k]) && (O = Math.abs(T[B][k]), I = [B, k]);
    return [I, O];
  }
  function C(T) {
    for (var _ = T.length, O = 0, I = [0, 1], B = 0; B < _; B++)
      for (var k = B + 1; k < _; k++)
        i(O) < i(T[B][k]) && (O = i(T[B][k]), I = [B, k]);
    return [I, O];
  }
  function A(T, _, O) {
    var I = T.length, B = Array(I), k;
    if (O) {
      k = Array(I);
      for (var L = 0; L < I; L++)
        k[L] = Array(I);
    }
    for (var F = 0; F < I; F++) {
      for (var M = 0, $ = T[0], R = 0; R < T.length; R++)
        i(T[R]) < i($) && (M = R, $ = T[M]);
      if (B[F] = T.splice(M, 1)[0], O)
        for (var Q = 0; Q < I; Q++)
          k[F][Q] = _[Q][M], _[Q].splice(M, 1);
    }
    if (!O) return {
      values: B
    };
    var ee = k.map((j, U) => ({
      value: B[U],
      vector: j
    }));
    return {
      values: B,
      eigenvectors: ee
    };
  }
  return h;
}
var H8 = "eigs", Q8 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"], Nf = /* @__PURE__ */ H(H8, Q8, (t) => {
  var {
    config: e,
    typed: r,
    matrix: n,
    addScalar: i,
    subtract: a,
    equal: o,
    abs: f,
    atan: u,
    cos: s,
    sin: c,
    multiplyScalar: l,
    divideScalar: m,
    inv: h,
    bignumber: g,
    multiply: d,
    add: y,
    larger: w,
    column: E,
    flatten: x,
    number: N,
    complex: D,
    sqrt: b,
    diag: C,
    size: A,
    reshape: T,
    qr: _,
    usolve: O,
    usolveAll: I,
    im: B,
    re: k,
    smaller: L,
    matrixFromColumns: F,
    dot: M
  } = t, $ = G8({
    config: e,
    addScalar: i,
    subtract: a,
    column: E,
    flatten: x,
    equal: o,
    abs: f,
    atan: u,
    cos: s,
    sin: c,
    multiplyScalar: l,
    inv: h,
    bignumber: g,
    complex: D,
    multiply: d,
    add: y
  }), R = U8({
    config: e,
    addScalar: i,
    subtract: a,
    multiply: d,
    multiplyScalar: l,
    flatten: x,
    divideScalar: m,
    sqrt: b,
    abs: f,
    bignumber: g,
    diag: C,
    size: A,
    reshape: T,
    qr: _,
    inv: h,
    usolve: O,
    usolveAll: I,
    equal: o,
    complex: D,
    larger: w,
    smaller: L,
    matrixFromColumns: F,
    dot: M
  });
  return r("eigs", {
    // The conversion to matrix in the first two implementations,
    // just to convert back to an array right away in
    // computeValuesAndVectors, is unfortunate, and should perhaps be
    // streamlined. It is done because the Matrix object carries some
    // type information about its entries, and so constructing the matrix
    // is a roundabout way of doing type detection.
    Array: function(ue) {
      return Q(n(ue));
    },
    "Array, number|BigNumber": function(ue, ce) {
      return Q(n(ue), {
        precision: ce
      });
    },
    "Array, Object"(te, ue) {
      return Q(n(te), ue);
    },
    Matrix: function(ue) {
      return Q(ue, {
        matricize: !0
      });
    },
    "Matrix, number|BigNumber": function(ue, ce) {
      return Q(ue, {
        precision: ce,
        matricize: !0
      });
    },
    "Matrix, Object": function(ue, ce) {
      var se = {
        matricize: !0
      };
      return nr(se, ce), Q(ue, se);
    }
  });
  function Q(te) {
    var ue, ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, se = "eigenvectors" in ce ? ce.eigenvectors : !0, he = (ue = ce.precision) !== null && ue !== void 0 ? ue : e.relTol, le = ee(te, he, se);
    return ce.matricize && (le.values = n(le.values), se && (le.eigenvectors = le.eigenvectors.map((ve) => {
      var {
        value: Ee,
        vector: _e
      } = ve;
      return {
        value: Ee,
        vector: n(_e)
      };
    }))), se && Object.defineProperty(le, "vectors", {
      enumerable: !1,
      // to make sure that the eigenvectors can still be
      // converted to string.
      get: () => {
        throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
      }
    }), le;
  }
  function ee(te, ue, ce) {
    var se = te.toArray(), he = te.size();
    if (he.length !== 2 || he[0] !== he[1])
      throw new RangeError("Matrix must be square (size: ".concat(vt(he), ")"));
    var le = he[0];
    if (U(se, le, ue) && (pe(se, le), j(se, le, ue))) {
      var ve = X(te, se, le);
      return $(se, le, ue, ve, ce);
    }
    var Ee = X(te, se, le);
    return R(se, le, ue, Ee, ce);
  }
  function j(te, ue, ce) {
    for (var se = 0; se < ue; se++)
      for (var he = se; he < ue; he++)
        if (w(g(f(a(te[se][he], te[he][se]))), ce))
          return !1;
    return !0;
  }
  function U(te, ue, ce) {
    for (var se = 0; se < ue; se++)
      for (var he = 0; he < ue; he++)
        if (w(g(f(B(te[se][he]))), ce))
          return !1;
    return !0;
  }
  function pe(te, ue) {
    for (var ce = 0; ce < ue; ce++)
      for (var se = 0; se < ue; se++)
        te[ce][se] = k(te[ce][se]);
  }
  function X(te, ue, ce) {
    var se = te.datatype();
    if (se === "number" || se === "BigNumber" || se === "Complex")
      return se;
    for (var he = !1, le = !1, ve = !1, Ee = 0; Ee < ce; Ee++)
      for (var _e = 0; _e < ce; _e++) {
        var V = ue[Ee][_e];
        if (ot(V) || xi(V))
          he = !0;
        else if (at(V))
          le = !0;
        else if (dn(V))
          ve = !0;
        else
          throw TypeError("Unsupported type in Matrix: " + kt(V));
      }
    if (le && ve && console.warn("Complex BigNumbers not supported, this operation will lose precission."), ve) {
      for (var J = 0; J < ce; J++)
        for (var ye = 0; ye < ce; ye++)
          ue[J][ye] = D(ue[J][ye]);
      return "Complex";
    }
    if (le) {
      for (var K = 0; K < ce; K++)
        for (var ae = 0; ae < ce; ae++)
          ue[K][ae] = g(ue[K][ae]);
      return "BigNumber";
    }
    if (he) {
      for (var de = 0; de < ce; de++)
        for (var xe = 0; xe < ce; xe++)
          ue[de][xe] = N(ue[de][xe]);
      return "number";
    } else
      throw TypeError("Matrix contains unsupported types only.");
  }
}), xb = "expm", V8 = ["typed", "abs", "add", "identity", "inv", "multiply"], Df = /* @__PURE__ */ H(xb, V8, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    identity: i,
    inv: a,
    multiply: o
  } = t;
  return e(xb, {
    Matrix: function(l) {
      var m = l.size();
      if (m.length !== 2 || m[0] !== m[1])
        throw new RangeError("Matrix must be square (size: " + vt(m) + ")");
      for (var h = m[0], g = 1e-15, d = f(l), y = u(d, g), w = y.q, E = y.j, x = o(l, Math.pow(2, -E)), N = i(h), D = i(h), b = 1, C = x, A = -1, T = 1; T <= w; T++)
        T > 1 && (C = o(C, x), A = -A), b = b * (w - T + 1) / ((2 * w - T + 1) * T), N = n(N, o(b, C)), D = n(D, o(b * A, C));
      for (var _ = o(a(D), N), O = 0; O < E; O++)
        _ = o(_, _);
      return jn(l) ? l.createSparseMatrix(_) : _;
    }
  });
  function f(c) {
    for (var l = c.size()[0], m = 0, h = 0; h < l; h++) {
      for (var g = 0, d = 0; d < l; d++)
        g += r(c.get([h, d]));
      m = Math.max(g, m);
    }
    return m;
  }
  function u(c, l) {
    for (var m = 30, h = 0; h < m; h++)
      for (var g = 0; g <= h; g++) {
        var d = h - g;
        if (s(c, g, d) < l)
          return {
            q: g,
            j: d
          };
      }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function s(c, l, m) {
    for (var h = 1, g = 2; g <= l; g++)
      h *= g;
    for (var d = h, y = l + 1; y <= 2 * l; y++)
      d *= y;
    var w = d * (2 * l + 1);
    return 8 * Math.pow(c / Math.pow(2, m), 2 * l) * h * h / (d * w);
  }
}), bb = "sqrtm", W8 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"], Ef = /* @__PURE__ */ H(bb, W8, (t) => {
  var {
    typed: e,
    abs: r,
    add: n,
    multiply: i,
    map: a,
    sqrt: o,
    subtract: f,
    inv: u,
    size: s,
    max: c,
    identity: l
  } = t, m = 1e3, h = 1e-6;
  function g(d) {
    var y, w = 0, E = d, x = l(s(d));
    do {
      var N = E;
      if (E = i(0.5, n(N, u(x))), x = i(0.5, n(x, u(N))), y = c(r(f(E, N))), y > h && ++w > m)
        throw new Error("computing square root of matrix: iterative method could not converge");
    } while (y > h);
    return E;
  }
  return e(bb, {
    "Array | Matrix": function(y) {
      var w = Ye(y) ? y.size() : ft(y);
      switch (w.length) {
        case 1:
          if (w[0] === 1)
            return a(y, o);
          throw new RangeError("Matrix must be square (size: " + vt(w) + ")");
        case 2: {
          var E = w[0], x = w[1];
          if (E === x)
            return g(y);
          throw new RangeError("Matrix must be square (size: " + vt(w) + ")");
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + vt(w) + ")");
      }
    }
  });
}), wb = "sylvester", j8 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"], Sf = /* @__PURE__ */ H(wb, j8, (t) => {
  var {
    typed: e,
    schur: r,
    matrixFromColumns: n,
    matrix: i,
    multiply: a,
    range: o,
    concat: f,
    transpose: u,
    index: s,
    subset: c,
    add: l,
    subtract: m,
    identity: h,
    lusolve: g,
    abs: d
  } = t;
  return e(wb, {
    "Matrix, Matrix, Matrix": y,
    "Array, Matrix, Matrix": function(E, x, N) {
      return y(i(E), x, N);
    },
    "Array, Array, Matrix": function(E, x, N) {
      return y(i(E), i(x), N);
    },
    "Array, Matrix, Array": function(E, x, N) {
      return y(i(E), x, i(N));
    },
    "Matrix, Array, Matrix": function(E, x, N) {
      return y(E, i(x), N);
    },
    "Matrix, Array, Array": function(E, x, N) {
      return y(E, i(x), i(N));
    },
    "Matrix, Matrix, Array": function(E, x, N) {
      return y(E, x, i(N));
    },
    "Array, Array, Array": function(E, x, N) {
      return y(i(E), i(x), i(N)).toArray();
    }
  });
  function y(w, E, x) {
    for (var N = E.size()[0], D = w.size()[0], b = r(w), C = b.T, A = b.U, T = r(a(-1, E)), _ = T.T, O = T.U, I = a(a(u(A), x), O), B = o(0, D), k = [], L = (ve, Ee) => f(ve, Ee, 1), F = (ve, Ee) => f(ve, Ee, 0), M = 0; M < N; M++)
      if (M < N - 1 && d(c(_, s(M + 1, M))) > 1e-5) {
        for (var $ = F(c(I, s(B, M)), c(I, s(B, M + 1))), R = 0; R < M; R++)
          $ = l($, F(a(k[R], c(_, s(R, M))), a(k[R], c(_, s(R, M + 1)))));
        var Q = a(h(D), a(-1, c(_, s(M, M)))), ee = a(h(D), a(-1, c(_, s(M + 1, M)))), j = a(h(D), a(-1, c(_, s(M, M + 1)))), U = a(h(D), a(-1, c(_, s(M + 1, M + 1)))), pe = F(L(l(C, Q), ee), L(j, l(C, U))), X = g(pe, $);
        k[M] = X.subset(s(o(0, D), 0)), k[M + 1] = X.subset(s(o(D, 2 * D), 0)), M++;
      } else {
        for (var te = c(I, s(B, M)), ue = 0; ue < M; ue++)
          te = l(te, a(k[ue], c(_, s(ue, M))));
        var ce = c(_, s(M, M)), se = m(C, a(ce, h(D)));
        k[M] = g(se, te);
      }
    var he = i(n(...k)), le = a(A, a(he, u(O)));
    return le;
  }
}), Nb = "schur", Y8 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"], Af = /* @__PURE__ */ H(Nb, Y8, (t) => {
  var {
    typed: e,
    matrix: r,
    identity: n,
    multiply: i,
    qr: a,
    norm: o,
    subtract: f
  } = t;
  return e(Nb, {
    Array: function(c) {
      var l = u(r(c));
      return {
        U: l.U.valueOf(),
        T: l.T.valueOf()
      };
    },
    Matrix: function(c) {
      return u(c);
    }
  });
  function u(s) {
    var c = s.size()[0], l = s, m = n(c), h = 0, g;
    do {
      g = l;
      var d = a(l), y = d.Q, w = d.R;
      if (l = i(w, y), m = i(m, y), h++ > 100)
        break;
    } while (o(f(l, g)) > 1e-4);
    return {
      U: m,
      T: l
    };
  }
}), Db = "lyap", Z8 = ["typed", "matrix", "sylvester", "multiply", "transpose"], Cf = /* @__PURE__ */ H(Db, Z8, (t) => {
  var {
    typed: e,
    matrix: r,
    sylvester: n,
    multiply: i,
    transpose: a
  } = t;
  return e(Db, {
    "Matrix, Matrix": function(f, u) {
      return n(f, a(f), i(-1, u));
    },
    "Array, Matrix": function(f, u) {
      return n(r(f), a(r(f)), i(-1, u));
    },
    "Matrix, Array": function(f, u) {
      return n(f, a(r(f)), r(i(-1, u)));
    },
    "Array, Array": function(f, u) {
      return n(r(f), a(r(f)), r(i(-1, u))).toArray();
    }
  });
}), J8 = "divide", X8 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"], Tf = /* @__PURE__ */ H(J8, X8, (t) => {
  var {
    typed: e,
    matrix: r,
    multiply: n,
    equalScalar: i,
    divideScalar: a,
    inv: o
  } = t, f = Sr({
    typed: e,
    equalScalar: i
  }), u = _n({
    typed: e
  });
  return e("divide", h2({
    // we extend the signatures of divideScalar with signatures dealing with matrices
    "Array | Matrix, Array | Matrix": function(c, l) {
      return n(c, o(l));
    },
    "DenseMatrix, any": function(c, l) {
      return u(c, l, a, !1);
    },
    "SparseMatrix, any": function(c, l) {
      return f(c, l, a, !1);
    },
    "Array, any": function(c, l) {
      return u(r(c), l, a, !1).valueOf();
    },
    "any, Array | Matrix": function(c, l) {
      return n(c, o(l));
    }
  }, a.signatures));
}), Eb = "distance", K8 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"], _f = /* @__PURE__ */ H(Eb, K8, (t) => {
  var {
    typed: e,
    addScalar: r,
    subtractScalar: n,
    multiplyScalar: i,
    divideScalar: a,
    deepEqual: o,
    sqrt: f,
    abs: u
  } = t;
  return e(Eb, {
    "Array, Array, Array": function(D, b, C) {
      if (D.length === 2 && b.length === 2 && C.length === 2) {
        if (!c(D))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        if (!c(b))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        if (!c(C))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        if (o(b, C))
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        var A = n(C[1], b[1]), T = n(b[0], C[0]), _ = n(i(C[0], b[1]), i(b[0], C[1]));
        return y(D[0], D[1], A, T, _);
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    "Object, Object, Object": function(D, b, C) {
      if (Object.keys(D).length === 2 && Object.keys(b).length === 2 && Object.keys(C).length === 2) {
        if (!c(D))
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        if (!c(b))
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        if (!c(C))
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        if (o(g(b), g(C)))
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        if ("pointX" in D && "pointY" in D && "lineOnePtX" in b && "lineOnePtY" in b && "lineTwoPtX" in C && "lineTwoPtY" in C) {
          var A = n(C.lineTwoPtY, b.lineOnePtY), T = n(b.lineOnePtX, C.lineTwoPtX), _ = n(i(C.lineTwoPtX, b.lineOnePtY), i(b.lineOnePtX, C.lineTwoPtY));
          return y(D.pointX, D.pointY, A, T, _);
        } else
          throw new TypeError("Key names do not match");
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    "Array, Array": function(D, b) {
      if (D.length === 2 && b.length === 3) {
        if (!c(D))
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        if (!l(b))
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        return y(D[0], D[1], b[0], b[1], b[2]);
      } else if (D.length === 3 && b.length === 6) {
        if (!l(D))
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        if (!h(b))
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        return w(D[0], D[1], D[2], b[0], b[1], b[2], b[3], b[4], b[5]);
      } else if (D.length === b.length && D.length > 0) {
        if (!m(D))
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        if (!m(b))
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        return E(D, b);
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    "Object, Object": function(D, b) {
      if (Object.keys(D).length === 2 && Object.keys(b).length === 3) {
        if (!c(D))
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        if (!l(b))
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        if ("pointX" in D && "pointY" in D && "xCoeffLine" in b && "yCoeffLine" in b && "constant" in b)
          return y(D.pointX, D.pointY, b.xCoeffLine, b.yCoeffLine, b.constant);
        throw new TypeError("Key names do not match");
      } else if (Object.keys(D).length === 3 && Object.keys(b).length === 6) {
        if (!l(D))
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        if (!h(b))
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        if ("pointX" in D && "pointY" in D && "x0" in b && "y0" in b && "z0" in b && "a" in b && "b" in b && "c" in b)
          return w(D.pointX, D.pointY, D.pointZ, b.x0, b.y0, b.z0, b.a, b.b, b.c);
        throw new TypeError("Key names do not match");
      } else if (Object.keys(D).length === 2 && Object.keys(b).length === 2) {
        if (!c(D))
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        if (!c(b))
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        if ("pointOneX" in D && "pointOneY" in D && "pointTwoX" in b && "pointTwoY" in b)
          return E([D.pointOneX, D.pointOneY], [b.pointTwoX, b.pointTwoY]);
        throw new TypeError("Key names do not match");
      } else if (Object.keys(D).length === 3 && Object.keys(b).length === 3) {
        if (!l(D))
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        if (!l(b))
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        if ("pointOneX" in D && "pointOneY" in D && "pointOneZ" in D && "pointTwoX" in b && "pointTwoY" in b && "pointTwoZ" in b)
          return E([D.pointOneX, D.pointOneY, D.pointOneZ], [b.pointTwoX, b.pointTwoY, b.pointTwoZ]);
        throw new TypeError("Key names do not match");
      } else
        throw new TypeError("Invalid Arguments: Try again");
    },
    Array: function(D) {
      if (!d(D))
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      return x(D);
    }
  });
  function s(N) {
    return typeof N == "number" || at(N);
  }
  function c(N) {
    return N.constructor !== Array && (N = g(N)), s(N[0]) && s(N[1]);
  }
  function l(N) {
    return N.constructor !== Array && (N = g(N)), s(N[0]) && s(N[1]) && s(N[2]);
  }
  function m(N) {
    return Array.isArray(N) || (N = g(N)), N.every(s);
  }
  function h(N) {
    return N.constructor !== Array && (N = g(N)), s(N[0]) && s(N[1]) && s(N[2]) && s(N[3]) && s(N[4]) && s(N[5]);
  }
  function g(N) {
    for (var D = Object.keys(N), b = [], C = 0; C < D.length; C++)
      b.push(N[D[C]]);
    return b;
  }
  function d(N) {
    if (N[0].length === 2 && s(N[0][0]) && s(N[0][1])) {
      if (N.some((D) => D.length !== 2 || !s(D[0]) || !s(D[1])))
        return !1;
    } else if (N[0].length === 3 && s(N[0][0]) && s(N[0][1]) && s(N[0][2])) {
      if (N.some((D) => D.length !== 3 || !s(D[0]) || !s(D[1]) || !s(D[2])))
        return !1;
    } else
      return !1;
    return !0;
  }
  function y(N, D, b, C, A) {
    var T = u(r(r(i(b, N), i(C, D)), A)), _ = f(r(i(b, b), i(C, C)));
    return a(T, _);
  }
  function w(N, D, b, C, A, T, _, O, I) {
    var B = [n(i(n(A, D), I), i(n(T, b), O)), n(i(n(T, b), _), i(n(C, N), I)), n(i(n(C, N), O), i(n(A, D), _))];
    B = f(r(r(i(B[0], B[0]), i(B[1], B[1])), i(B[2], B[2])));
    var k = f(r(r(i(_, _), i(O, O)), i(I, I)));
    return a(B, k);
  }
  function E(N, D) {
    for (var b = N.length, C = 0, A = 0, T = 0; T < b; T++)
      A = n(N[T], D[T]), C = r(i(A, A), C);
    return f(C);
  }
  function x(N) {
    for (var D = [], b = [], C = [], A = 0; A < N.length - 1; A++)
      for (var T = A + 1; T < N.length; T++)
        N[0].length === 2 ? (b = [N[A][0], N[A][1]], C = [N[T][0], N[T][1]]) : N[0].length === 3 && (b = [N[A][0], N[A][1], N[A][2]], C = [N[T][0], N[T][1], N[T][2]]), D.push(E(b, C));
    return D;
  }
}), e7 = "intersect", t7 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"], Mf = /* @__PURE__ */ H(e7, t7, (t) => {
  var {
    typed: e,
    config: r,
    abs: n,
    add: i,
    addScalar: a,
    matrix: o,
    multiply: f,
    multiplyScalar: u,
    divideScalar: s,
    subtract: c,
    smaller: l,
    equalScalar: m,
    flatten: h,
    isZero: g,
    isNumeric: d
  } = t;
  return e("intersect", {
    "Array, Array, Array": y,
    "Array, Array, Array, Array": w,
    "Matrix, Matrix, Matrix": function(O, I, B) {
      var k = y(O.valueOf(), I.valueOf(), B.valueOf());
      return k === null ? null : o(k);
    },
    "Matrix, Matrix, Matrix, Matrix": function(O, I, B, k) {
      var L = w(O.valueOf(), I.valueOf(), B.valueOf(), k.valueOf());
      return L === null ? null : o(L);
    }
  });
  function y(_, O, I) {
    if (_ = E(_), O = E(O), I = E(I), !N(_))
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    if (!N(O))
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    if (!D(I))
      throw new TypeError("Array with 4 numbers expected as third argument");
    return T(_[0], _[1], _[2], O[0], O[1], O[2], I[0], I[1], I[2], I[3]);
  }
  function w(_, O, I, B) {
    if (_ = E(_), O = E(O), I = E(I), B = E(B), _.length === 2) {
      if (!x(_))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      if (!x(O))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      if (!x(I))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      if (!x(B))
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      return b(_, O, I, B);
    } else if (_.length === 3) {
      if (!N(_))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      if (!N(O))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      if (!N(I))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      if (!N(B))
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      return A(_[0], _[1], _[2], O[0], O[1], O[2], I[0], I[1], I[2], B[0], B[1], B[2]);
    } else
      throw new TypeError("Arrays with two or thee dimensional points expected");
  }
  function E(_) {
    return _.length === 1 ? _[0] : _.length > 1 && Array.isArray(_[0]) && _.every((O) => Array.isArray(O) && O.length === 1) ? h(_) : _;
  }
  function x(_) {
    return _.length === 2 && d(_[0]) && d(_[1]);
  }
  function N(_) {
    return _.length === 3 && d(_[0]) && d(_[1]) && d(_[2]);
  }
  function D(_) {
    return _.length === 4 && d(_[0]) && d(_[1]) && d(_[2]) && d(_[3]);
  }
  function b(_, O, I, B) {
    var k = _, L = I, F = c(k, O), M = c(L, B), $ = c(u(F[0], M[1]), u(M[0], F[1]));
    if (g($) || l(n($), r.relTol))
      return null;
    var R = u(M[0], k[1]), Q = u(M[1], k[0]), ee = u(M[0], L[1]), j = u(M[1], L[0]), U = s(a(c(c(R, Q), ee), j), $);
    return i(f(F, U), k);
  }
  function C(_, O, I, B, k, L, F, M, $, R, Q, ee) {
    var j = u(c(_, O), c(I, B)), U = u(c(k, L), c(F, M)), pe = u(c($, R), c(Q, ee));
    return a(a(j, U), pe);
  }
  function A(_, O, I, B, k, L, F, M, $, R, Q, ee) {
    var j = C(_, F, R, F, O, M, Q, M, I, $, ee, $), U = C(R, F, B, _, Q, M, k, O, ee, $, L, I), pe = C(_, F, B, _, O, M, k, O, I, $, L, I), X = C(R, F, R, F, Q, M, Q, M, ee, $, ee, $), te = C(B, _, B, _, k, O, k, O, L, I, L, I), ue = c(u(j, U), u(pe, X)), ce = c(u(te, X), u(U, U));
    if (g(ce)) return null;
    var se = s(ue, ce), he = s(a(j, u(se, U)), X), le = a(_, u(se, c(B, _))), ve = a(O, u(se, c(k, O))), Ee = a(I, u(se, c(L, I))), _e = a(F, u(he, c(R, F))), V = a(M, u(he, c(Q, M))), J = a($, u(he, c(ee, $)));
    return m(le, _e) && m(ve, V) && m(Ee, J) ? [le, ve, Ee] : null;
  }
  function T(_, O, I, B, k, L, F, M, $, R) {
    var Q = u(_, F), ee = u(B, F), j = u(O, M), U = u(k, M), pe = u(I, $), X = u(L, $), te = c(c(c(R, Q), j), pe), ue = c(c(c(a(a(ee, U), X), Q), j), pe), ce = s(te, ue), se = a(_, u(ce, c(B, _))), he = a(O, u(ce, c(k, O))), le = a(I, u(ce, c(L, I)));
    return [se, he, le];
  }
}), Sb = "sum", r7 = ["typed", "config", "add", "numeric"], Zs = /* @__PURE__ */ H(Sb, r7, (t) => {
  var {
    typed: e,
    config: r,
    add: n,
    numeric: i
  } = t;
  return e(Sb, {
    // sum([a, b, c, d, ...])
    "Array | Matrix": a,
    // sum([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": o,
    // sum(a, b, c, d, ...)
    "...": function(u) {
      if (La(u))
        throw new TypeError("Scalar values expected in function sum");
      return a(u);
    }
  });
  function a(f) {
    var u;
    return ei(f, function(s) {
      try {
        u = u === void 0 ? s : n(u, s);
      } catch (c) {
        throw $r(c, "sum", s);
      }
    }), u === void 0 && (u = i(0, r.number)), typeof u == "string" && (u = i(u, wi(u, r))), u;
  }
  function o(f, u) {
    try {
      var s = Fu(f, u, n);
      return s;
    } catch (c) {
      throw $r(c, "sum");
    }
  }
}), Uo = "cumsum", n7 = ["typed", "add", "unaryPlus"], Js = /* @__PURE__ */ H(Uo, n7, (t) => {
  var {
    typed: e,
    add: r,
    unaryPlus: n
  } = t;
  return e(Uo, {
    // sum([a, b, c, d, ...])
    Array: i,
    Matrix: function(s) {
      return s.create(i(s.valueOf()));
    },
    // sum([a, b, c, d, ...], dim)
    "Array, number | BigNumber": o,
    "Matrix, number | BigNumber": function(s, c) {
      return s.create(o(s.valueOf(), c));
    },
    // cumsum(a, b, c, d, ...)
    "...": function(s) {
      if (La(s))
        throw new TypeError("All values expected to be scalar in function cumsum");
      return i(s);
    }
  });
  function i(u) {
    try {
      return a(u);
    } catch (s) {
      throw $r(s, Uo);
    }
  }
  function a(u) {
    if (u.length === 0)
      return [];
    for (var s = [n(u[0])], c = 1; c < u.length; ++c)
      s.push(r(s[c - 1], u[c]));
    return s;
  }
  function o(u, s) {
    var c = ft(u);
    if (s < 0 || s >= c.length)
      throw new nn(s, c.length);
    try {
      return f(u, s);
    } catch (l) {
      throw $r(l, Uo);
    }
  }
  function f(u, s) {
    var c, l, m;
    if (s <= 0) {
      var h = u[0][0];
      if (Array.isArray(h)) {
        for (m = Z2(u), l = [], c = 0; c < m.length; c++)
          l[c] = f(m[c], s - 1);
        return l;
      } else
        return a(u);
    } else {
      for (l = [], c = 0; c < u.length; c++)
        l[c] = f(u[c], s - 1);
      return l;
    }
  }
}), Ab = "mean", i7 = ["typed", "add", "divide"], Xs = /* @__PURE__ */ H(Ab, i7, (t) => {
  var {
    typed: e,
    add: r,
    divide: n
  } = t;
  return e(Ab, {
    // mean([a, b, c, d, ...])
    "Array | Matrix": a,
    // mean([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": i,
    // mean(a, b, c, d, ...)
    "...": function(f) {
      if (La(f))
        throw new TypeError("Scalar values expected in function mean");
      return a(f);
    }
  });
  function i(o, f) {
    try {
      var u = Fu(o, f, r), s = Array.isArray(o) ? ft(o) : o.size();
      return n(u, s[f]);
    } catch (c) {
      throw $r(c, "mean");
    }
  }
  function a(o) {
    var f, u = 0;
    if (ei(o, function(s) {
      try {
        f = f === void 0 ? s : r(f, s), u++;
      } catch (c) {
        throw $r(c, "mean", s);
      }
    }), u === 0)
      throw new Error("Cannot calculate the mean of an empty array");
    return n(f, u);
  }
}), Cb = "median", a7 = ["typed", "add", "divide", "compare", "partitionSelect"], Of = /* @__PURE__ */ H(Cb, a7, (t) => {
  var {
    typed: e,
    add: r,
    divide: n,
    compare: i,
    partitionSelect: a
  } = t;
  function o(s) {
    try {
      s = Mt(s.valueOf());
      var c = s.length;
      if (c === 0)
        throw new Error("Cannot calculate median of an empty array");
      if (c % 2 === 0) {
        for (var l = c / 2 - 1, m = a(s, l + 1), h = s[l], g = 0; g < l; ++g)
          i(s[g], h) > 0 && (h = s[g]);
        return u(h, m);
      } else {
        var d = a(s, (c - 1) / 2);
        return f(d);
      }
    } catch (y) {
      throw $r(y, "median");
    }
  }
  var f = e({
    "number | BigNumber | Complex | Unit": function(c) {
      return c;
    }
  }), u = e({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function(c, l) {
      return n(r(c, l), 2);
    }
  });
  return e(Cb, {
    // median([a, b, c, d, ...])
    "Array | Matrix": o,
    // median([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function(c, l) {
      throw new Error("median(A, dim) is not yet supported");
    },
    // median(a, b, c, d, ...)
    "...": function(c) {
      if (La(c))
        throw new TypeError("Scalar values expected in function median");
      return o(c);
    }
  });
}), Tb = "mad", s7 = ["typed", "abs", "map", "median", "subtract"], qf = /* @__PURE__ */ H(Tb, s7, (t) => {
  var {
    typed: e,
    abs: r,
    map: n,
    median: i,
    subtract: a
  } = t;
  return e(Tb, {
    // mad([a, b, c, d, ...])
    "Array | Matrix": o,
    // mad(a, b, c, d, ...)
    "...": function(u) {
      return o(u);
    }
  });
  function o(f) {
    if (f = Mt(f.valueOf()), f.length === 0)
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    try {
      var u = i(f);
      return i(n(f, function(s) {
        return r(a(s, u));
      }));
    } catch (s) {
      throw s instanceof TypeError && s.message.includes("median") ? new TypeError(s.message.replace("median", "mad")) : $r(s, "mad");
    }
  }
}), Rh = "unbiased", _b = "variance", o7 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"], Ks = /* @__PURE__ */ H(_b, o7, (t) => {
  var {
    typed: e,
    add: r,
    subtract: n,
    multiply: i,
    divide: a,
    apply: o,
    isNaN: f
  } = t;
  return e(_b, {
    // variance([a, b, c, d, ...])
    "Array | Matrix": function(l) {
      return u(l, Rh);
    },
    // variance([a, b, c, d, ...], normalization)
    "Array | Matrix, string": u,
    // variance([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": function(l, m) {
      return s(l, m, Rh);
    },
    // variance([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": s,
    // variance(a, b, c, d, ...)
    "...": function(l) {
      return u(l, Rh);
    }
  });
  function u(c, l) {
    var m, h = 0;
    if (c.length === 0)
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    if (ei(c, function(y) {
      try {
        m = m === void 0 ? y : r(m, y), h++;
      } catch (w) {
        throw $r(w, "variance", y);
      }
    }), h === 0) throw new Error("Cannot calculate variance of an empty array");
    var g = a(m, h);
    if (m = void 0, ei(c, function(y) {
      var w = n(y, g);
      m = m === void 0 ? i(w, w) : r(m, i(w, w));
    }), f(m))
      return m;
    switch (l) {
      case "uncorrected":
        return a(m, h);
      case "biased":
        return a(m, h + 1);
      case "unbiased": {
        var d = at(m) ? m.mul(0) : 0;
        return h === 1 ? d : a(m, h - 1);
      }
      default:
        throw new Error('Unknown normalization "' + l + '". Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function s(c, l, m) {
    try {
      if (c.length === 0)
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      return o(c, l, (h) => u(h, m));
    } catch (h) {
      throw $r(h, "variance");
    }
  }
}), Mb = "quantileSeq", u7 = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"], eo = /* @__PURE__ */ H(Mb, u7, (t) => {
  var {
    typed: e,
    bignumber: r,
    add: n,
    subtract: i,
    divide: a,
    multiply: o,
    partitionSelect: f,
    compare: u,
    isInteger: s,
    smaller: c,
    smallerEq: l,
    larger: m
  } = t, h = Ua({
    typed: e,
    isInteger: s
  });
  return e(Mb, {
    "Array | Matrix, number | BigNumber": (E, x) => d(E, x, !1),
    "Array | Matrix, number | BigNumber, number": (E, x, N) => g(E, x, !1, N, d),
    "Array | Matrix, number | BigNumber, boolean": d,
    "Array | Matrix, number | BigNumber, boolean, number": (E, x, N, D) => g(E, x, N, D, d),
    "Array | Matrix, Array | Matrix": (E, x) => y(E, x, !1),
    "Array | Matrix, Array | Matrix, number": (E, x, N) => g(E, x, !1, N, y),
    "Array | Matrix, Array | Matrix, boolean": y,
    "Array | Matrix, Array | Matrix, boolean, number": (E, x, N, D) => g(E, x, N, D, y)
  });
  function g(E, x, N, D, b) {
    return h(E, D, (C) => b(C, x, N));
  }
  function d(E, x, N) {
    var D, b = E.valueOf();
    if (c(x, 0))
      throw new Error("N/prob must be non-negative");
    if (l(x, 1))
      return ot(x) ? w(b, x, N) : r(w(b, x, N));
    if (m(x, 1)) {
      if (!s(x))
        throw new Error("N must be a positive integer");
      if (m(x, 4294967295))
        throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
      var C = n(x, 1);
      D = [];
      for (var A = 0; c(A, x); A++) {
        var T = a(A + 1, C);
        D.push(w(b, T, N));
      }
      return ot(x) ? D : r(D);
    }
  }
  function y(E, x, N) {
    for (var D = E.valueOf(), b = x.valueOf(), C = [], A = 0; A < b.length; ++A)
      C.push(w(D, b[A], N));
    return C;
  }
  function w(E, x, N) {
    var D = Mt(E), b = D.length;
    if (b === 0)
      throw new Error("Cannot calculate quantile of an empty sequence");
    var C = ot(x) ? x * (b - 1) : x.times(b - 1), A = ot(x) ? Math.floor(C) : C.floor().toNumber(), T = ot(x) ? C % 1 : C.minus(A);
    if (s(C))
      return N ? D[C] : f(D, ot(x) ? C : C.valueOf());
    var _, O;
    if (N)
      _ = D[A], O = D[A + 1];
    else {
      O = f(D, A + 1), _ = D[A];
      for (var I = 0; I < A; ++I)
        u(D[I], _) > 0 && (_ = D[I]);
    }
    return n(o(_, i(1, T)), o(O, T));
  }
}), Ob = "std", l7 = ["typed", "map", "sqrt", "variance"], to = /* @__PURE__ */ H(Ob, l7, (t) => {
  var {
    typed: e,
    map: r,
    sqrt: n,
    variance: i
  } = t;
  return e(Ob, {
    // std([a, b, c, d, ...])
    "Array | Matrix": a,
    // std([a, b, c, d, ...], normalization)
    "Array | Matrix, string": a,
    // std([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": a,
    // std([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": a,
    // std(a, b, c, d, ...)
    "...": function(f) {
      return a(f);
    }
  });
  function a(o, f) {
    if (o.length === 0)
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    try {
      var u = i.apply(null, arguments);
      return Yr(u) ? r(u, n) : n(u);
    } catch (s) {
      throw s instanceof TypeError && s.message.includes(" variance") ? new TypeError(s.message.replace(" variance", " std")) : s;
    }
  }
}), qb = "corr", c7 = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"], If = /* @__PURE__ */ H(qb, c7, (t) => {
  var {
    typed: e,
    matrix: r,
    sqrt: n,
    sum: i,
    add: a,
    subtract: o,
    multiply: f,
    pow: u,
    divide: s
  } = t;
  return e(qb, {
    "Array, Array": function(h, g) {
      return c(h, g);
    },
    "Matrix, Matrix": function(h, g) {
      var d = c(h.toArray(), g.toArray());
      return Array.isArray(d) ? r(d) : d;
    }
  });
  function c(m, h) {
    var g = [];
    if (Array.isArray(m[0]) && Array.isArray(h[0])) {
      if (m.length !== h.length)
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
      for (var d = 0; d < m.length; d++) {
        if (m[d].length !== h[d].length)
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
        g.push(l(m[d], h[d]));
      }
      return g;
    } else {
      if (m.length !== h.length)
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
      return l(m, h);
    }
  }
  function l(m, h) {
    var g = m.length, d = i(m), y = i(h), w = m.reduce((b, C, A) => a(b, f(C, h[A])), 0), E = i(m.map((b) => u(b, 2))), x = i(h.map((b) => u(b, 2))), N = o(f(g, w), f(d, y)), D = n(f(o(f(g, E), u(d, 2)), o(f(g, x), u(y, 2))));
    return s(N, D);
  }
}), Ib = "combinations", f7 = ["typed"], Ff = /* @__PURE__ */ H(Ib, f7, (t) => {
  var {
    typed: e
  } = t;
  return e(Ib, {
    "number, number": xw,
    "BigNumber, BigNumber": function(n, i) {
      var a = n.constructor, o, f, u = n.minus(i), s = new a(1);
      if (!Fb(n) || !Fb(i))
        throw new TypeError("Positive integer value expected in function combinations");
      if (i.gt(n))
        throw new TypeError("k must be less than n in function combinations");
      if (o = s, i.lt(u))
        for (f = s; f.lte(u); f = f.plus(s))
          o = o.times(i.plus(f)).dividedBy(f);
      else
        for (f = s; f.lte(i); f = f.plus(s))
          o = o.times(u.plus(f)).dividedBy(f);
      return o;
    }
    // TODO: implement support for collection in combinations
  });
});
function Fb(t) {
  return t.isInteger() && t.gte(0);
}
var Bb = "combinationsWithRep", p7 = ["typed"], Bf = /* @__PURE__ */ H(Bb, p7, (t) => {
  var {
    typed: e
  } = t;
  return e(Bb, {
    "number, number": function(n, i) {
      if (!Ve(n) || n < 0)
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      if (!Ve(i) || i < 0)
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      if (n < 1)
        throw new TypeError("k must be less than or equal to n + k - 1");
      if (i < n - 1) {
        var a = Zn(n, n + i - 1);
        return a / Zn(1, i);
      }
      var o = Zn(i + 1, n + i - 1);
      return o / Zn(1, n - 1);
    },
    "BigNumber, BigNumber": function(n, i) {
      var a = n.constructor, o, f, u = new a(1), s = n.minus(u);
      if (!Rb(n) || !Rb(i))
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      if (n.lt(u))
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      if (o = u, i.lt(s))
        for (f = u; f.lte(s); f = f.plus(u))
          o = o.times(i.plus(f)).dividedBy(f);
      else
        for (f = u; f.lte(i); f = f.plus(u))
          o = o.times(s.plus(f)).dividedBy(f);
      return o;
    }
  });
});
function Rb(t) {
  return t.isInteger() && t.gte(0);
}
var Pb = "gamma", m7 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"], Rf = /* @__PURE__ */ H(Pb, m7, (t) => {
  var {
    typed: e,
    config: r,
    multiplyScalar: n,
    pow: i,
    BigNumber: a,
    Complex: o
  } = t;
  function f(s) {
    if (s.im === 0)
      return tu(s.re);
    if (s.re < 0.5) {
      var c = new o(1 - s.re, -s.im), l = new o(Math.PI * s.re, Math.PI * s.im);
      return new o(Math.PI).div(l.sin()).div(f(c));
    }
    s = new o(s.re - 1, s.im);
    for (var m = new o(Aa[0], 0), h = 1; h < Aa.length; ++h) {
      var g = new o(Aa[h], 0);
      m = m.add(g.div(s.add(h)));
    }
    var d = new o(s.re + ww + 0.5, s.im), y = Math.sqrt(2 * Math.PI), w = d.pow(s.add(0.5)), E = d.neg().exp();
    return m.mul(y).mul(w).mul(E);
  }
  return e(Pb, {
    number: tu,
    Complex: f,
    BigNumber: function(c) {
      if (c.isInteger())
        return c.isNegative() || c.isZero() ? new a(1 / 0) : u(c.minus(1));
      if (!c.isFinite())
        return new a(c.isNegative() ? NaN : 1 / 0);
      throw new Error("Integer BigNumber expected");
    }
  });
  function u(s) {
    if (s < 8)
      return new a([1, 1, 2, 6, 24, 120, 720, 5040][s]);
    var c = r.precision + (Math.log(s.toNumber()) | 0), l = a.clone({
      precision: c
    });
    if (s % 2 === 1)
      return s.times(u(new a(s - 1)));
    for (var m = s, h = new l(s), g = s.toNumber(); m > 2; )
      m -= 2, g += m, h = h.times(g);
    return new a(h.toPrecision(a.precision));
  }
}), Lb = "lgamma", h7 = ["Complex", "typed"], Pf = /* @__PURE__ */ H(Lb, h7, (t) => {
  var {
    Complex: e,
    typed: r
  } = t, n = 7, i = 7, a = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return r(Lb, {
    number: ru,
    Complex: o,
    BigNumber: function() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function o(s) {
    var c = 6.283185307179586, l = 1.1447298858494002, m = 0.1;
    if (s.isNaN())
      return new e(NaN, NaN);
    if (s.im === 0)
      return new e(ru(s.re), 0);
    if (s.re >= n || Math.abs(s.im) >= i)
      return f(s);
    if (s.re <= m) {
      var h = sC(c, s.im) * Math.floor(0.5 * s.re + 0.25), g = s.mul(Math.PI).sin().log(), d = o(new e(1 - s.re, -s.im));
      return new e(l, h).sub(g).sub(d);
    } else return s.im >= 0 ? u(s) : u(s.conjugate()).conjugate();
  }
  function f(s) {
    for (var c = s.sub(0.5).mul(s.log()).sub(s).add(Nw), l = new e(1, 0).div(s), m = l.div(s), h = a[0], g = a[1], d = 2 * m.re, y = m.re * m.re + m.im * m.im, w = 2; w < 8; w++) {
      var E = g;
      g = -y * h + a[w], h = d * h + E;
    }
    var x = l.mul(m.mul(h).add(g));
    return c.add(x);
  }
  function u(s) {
    var c = 0, l = 0, m = s;
    for (s = s.add(1); s.re <= n; ) {
      m = m.mul(s);
      var h = m.im < 0 ? 1 : 0;
      h !== 0 && l === 0 && c++, l = h, s = s.add(1);
    }
    return f(s).sub(m.log()).sub(new e(0, c * 2 * Math.PI * 1));
  }
}), kb = "factorial", d7 = ["typed", "gamma"], Lf = /* @__PURE__ */ H(kb, d7, (t) => {
  var {
    typed: e,
    gamma: r
  } = t;
  return e(kb, {
    number: function(i) {
      if (i < 0)
        throw new Error("Value must be non-negative");
      return r(i + 1);
    },
    BigNumber: function(i) {
      if (i.isNegative())
        throw new Error("Value must be non-negative");
      return r(i.plus(1));
    },
    "Array | Matrix": e.referToSelf((n) => (i) => gt(i, n))
  });
}), zb = "kldivergence", g7 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"], kf = /* @__PURE__ */ H(zb, g7, (t) => {
  var {
    typed: e,
    matrix: r,
    divide: n,
    sum: i,
    multiply: a,
    map: o,
    dotDivide: f,
    log: u,
    isNumeric: s
  } = t;
  return e(zb, {
    "Array, Array": function(m, h) {
      return c(r(m), r(h));
    },
    "Matrix, Array": function(m, h) {
      return c(m, r(h));
    },
    "Array, Matrix": function(m, h) {
      return c(r(m), h);
    },
    "Matrix, Matrix": function(m, h) {
      return c(m, h);
    }
  });
  function c(l, m) {
    var h = m.size().length, g = l.size().length;
    if (h > 1)
      throw new Error("first object must be one dimensional");
    if (g > 1)
      throw new Error("second object must be one dimensional");
    if (h !== g)
      throw new Error("Length of two vectors must be equal");
    var d = i(l);
    if (d === 0)
      throw new Error("Sum of elements in first object must be non zero");
    var y = i(m);
    if (y === 0)
      throw new Error("Sum of elements in second object must be non zero");
    var w = n(l, i(l)), E = n(m, i(m)), x = i(a(w, o(f(w, E), (N) => u(N))));
    return s(x) ? x : Number.NaN;
  }
}), $b = "multinomial", v7 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"], zf = /* @__PURE__ */ H($b, v7, (t) => {
  var {
    typed: e,
    add: r,
    divide: n,
    multiply: i,
    factorial: a,
    isInteger: o,
    isPositive: f
  } = t;
  return e($b, {
    "Array | Matrix": function(s) {
      var c = 0, l = 1;
      return ei(s, function(m) {
        if (!o(m) || !f(m))
          throw new TypeError("Positive integer value expected in function multinomial");
        c = r(c, m), l = i(l, a(m));
      }), n(a(c), l);
    }
  });
}), Ub = "permutations", y7 = ["typed", "factorial"], $f = /* @__PURE__ */ H(Ub, y7, (t) => {
  var {
    typed: e,
    factorial: r
  } = t;
  return e(Ub, {
    "number | BigNumber": r,
    "number, number": function(i, a) {
      if (!Ve(i) || i < 0)
        throw new TypeError("Positive integer value expected in function permutations");
      if (!Ve(a) || a < 0)
        throw new TypeError("Positive integer value expected in function permutations");
      if (a > i)
        throw new TypeError("second argument k must be less than or equal to first argument n");
      return Zn(i - a + 1, i);
    },
    "BigNumber, BigNumber": function(i, a) {
      var o, f;
      if (!Gb(i) || !Gb(a))
        throw new TypeError("Positive integer value expected in function permutations");
      if (a.gt(i))
        throw new TypeError("second argument k must be less than or equal to first argument n");
      var u = i.mul(0).add(1);
      for (o = u, f = i.minus(a).plus(1); f.lte(i); f = f.plus(1))
        o = o.times(f);
      return o;
    }
    // TODO: implement support for collection in permutations
  });
});
function Gb(t) {
  return t.isInteger() && t.gte(0);
}
var Fd = { exports: {} };
Fd.exports;
(function(t) {
  (function(e, r, n) {
    function i(u) {
      var s = this, c = f();
      s.next = function() {
        var l = 2091639 * s.s0 + s.c * 23283064365386963e-26;
        return s.s0 = s.s1, s.s1 = s.s2, s.s2 = l - (s.c = l | 0);
      }, s.c = 1, s.s0 = c(" "), s.s1 = c(" "), s.s2 = c(" "), s.s0 -= c(u), s.s0 < 0 && (s.s0 += 1), s.s1 -= c(u), s.s1 < 0 && (s.s1 += 1), s.s2 -= c(u), s.s2 < 0 && (s.s2 += 1), c = null;
    }
    function a(u, s) {
      return s.c = u.c, s.s0 = u.s0, s.s1 = u.s1, s.s2 = u.s2, s;
    }
    function o(u, s) {
      var c = new i(u), l = s && s.state, m = c.next;
      return m.int32 = function() {
        return c.next() * 4294967296 | 0;
      }, m.double = function() {
        return m() + (m() * 2097152 | 0) * 11102230246251565e-32;
      }, m.quick = m, l && (typeof l == "object" && a(l, c), m.state = function() {
        return a(c, {});
      }), m;
    }
    function f() {
      var u = 4022871197, s = function(c) {
        c = String(c);
        for (var l = 0; l < c.length; l++) {
          u += c.charCodeAt(l);
          var m = 0.02519603282416938 * u;
          u = m >>> 0, m -= u, m *= u, u = m >>> 0, m -= u, u += m * 4294967296;
        }
        return (u >>> 0) * 23283064365386963e-26;
      };
      return s;
    }
    r && r.exports ? r.exports = o : this.alea = o;
  })(
    Ki,
    t
  );
})(Fd);
var x7 = Fd.exports, Bd = { exports: {} };
Bd.exports;
(function(t) {
  (function(e, r, n) {
    function i(f) {
      var u = this, s = "";
      u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.next = function() {
        var l = u.x ^ u.x << 11;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w ^= u.w >>> 19 ^ l ^ l >>> 8;
      }, f === (f | 0) ? u.x = f : s += f;
      for (var c = 0; c < s.length + 64; c++)
        u.x ^= s.charCodeAt(c) | 0, u.next();
    }
    function a(f, u) {
      return u.x = f.x, u.y = f.y, u.z = f.z, u.w = f.w, u;
    }
    function o(f, u) {
      var s = new i(f), c = u && u.state, l = function() {
        return (s.next() >>> 0) / 4294967296;
      };
      return l.double = function() {
        do
          var m = s.next() >>> 11, h = (s.next() >>> 0) / 4294967296, g = (m + h) / (1 << 21);
        while (g === 0);
        return g;
      }, l.int32 = s.next, l.quick = l, c && (typeof c == "object" && a(c, s), l.state = function() {
        return a(s, {});
      }), l;
    }
    r && r.exports ? r.exports = o : this.xor128 = o;
  })(
    Ki,
    t
  );
})(Bd);
var b7 = Bd.exports, Rd = { exports: {} };
Rd.exports;
(function(t) {
  (function(e, r, n) {
    function i(f) {
      var u = this, s = "";
      u.next = function() {
        var l = u.x ^ u.x >>> 2;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w = u.v, (u.d = u.d + 362437 | 0) + (u.v = u.v ^ u.v << 4 ^ (l ^ l << 1)) | 0;
      }, u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.v = 0, f === (f | 0) ? u.x = f : s += f;
      for (var c = 0; c < s.length + 64; c++)
        u.x ^= s.charCodeAt(c) | 0, c == s.length && (u.d = u.x << 10 ^ u.x >>> 4), u.next();
    }
    function a(f, u) {
      return u.x = f.x, u.y = f.y, u.z = f.z, u.w = f.w, u.v = f.v, u.d = f.d, u;
    }
    function o(f, u) {
      var s = new i(f), c = u && u.state, l = function() {
        return (s.next() >>> 0) / 4294967296;
      };
      return l.double = function() {
        do
          var m = s.next() >>> 11, h = (s.next() >>> 0) / 4294967296, g = (m + h) / (1 << 21);
        while (g === 0);
        return g;
      }, l.int32 = s.next, l.quick = l, c && (typeof c == "object" && a(c, s), l.state = function() {
        return a(s, {});
      }), l;
    }
    r && r.exports ? r.exports = o : this.xorwow = o;
  })(
    Ki,
    t
  );
})(Rd);
var w7 = Rd.exports, Pd = { exports: {} };
Pd.exports;
(function(t) {
  (function(e, r, n) {
    function i(f) {
      var u = this;
      u.next = function() {
        var c = u.x, l = u.i, m, h;
        return m = c[l], m ^= m >>> 7, h = m ^ m << 24, m = c[l + 1 & 7], h ^= m ^ m >>> 10, m = c[l + 3 & 7], h ^= m ^ m >>> 3, m = c[l + 4 & 7], h ^= m ^ m << 7, m = c[l + 7 & 7], m = m ^ m << 13, h ^= m ^ m << 9, c[l] = h, u.i = l + 1 & 7, h;
      };
      function s(c, l) {
        var m, h = [];
        if (l === (l | 0))
          h[0] = l;
        else
          for (l = "" + l, m = 0; m < l.length; ++m)
            h[m & 7] = h[m & 7] << 15 ^ l.charCodeAt(m) + h[m + 1 & 7] << 13;
        for (; h.length < 8; ) h.push(0);
        for (m = 0; m < 8 && h[m] === 0; ++m) ;
        for (m == 8 ? h[7] = -1 : h[m], c.x = h, c.i = 0, m = 256; m > 0; --m)
          c.next();
      }
      s(u, f);
    }
    function a(f, u) {
      return u.x = f.x.slice(), u.i = f.i, u;
    }
    function o(f, u) {
      f == null && (f = +/* @__PURE__ */ new Date());
      var s = new i(f), c = u && u.state, l = function() {
        return (s.next() >>> 0) / 4294967296;
      };
      return l.double = function() {
        do
          var m = s.next() >>> 11, h = (s.next() >>> 0) / 4294967296, g = (m + h) / (1 << 21);
        while (g === 0);
        return g;
      }, l.int32 = s.next, l.quick = l, c && (c.x && a(c, s), l.state = function() {
        return a(s, {});
      }), l;
    }
    r && r.exports ? r.exports = o : this.xorshift7 = o;
  })(
    Ki,
    t
  );
})(Pd);
var N7 = Pd.exports, Ld = { exports: {} };
Ld.exports;
(function(t) {
  (function(e, r, n) {
    function i(f) {
      var u = this;
      u.next = function() {
        var c = u.w, l = u.X, m = u.i, h, g;
        return u.w = c = c + 1640531527 | 0, g = l[m + 34 & 127], h = l[m = m + 1 & 127], g ^= g << 13, h ^= h << 17, g ^= g >>> 15, h ^= h >>> 12, g = l[m] = g ^ h, u.i = m, g + (c ^ c >>> 16) | 0;
      };
      function s(c, l) {
        var m, h, g, d, y, w = [], E = 128;
        for (l === (l | 0) ? (h = l, l = null) : (l = l + "\0", h = 0, E = Math.max(E, l.length)), g = 0, d = -32; d < E; ++d)
          l && (h ^= l.charCodeAt((d + 32) % l.length)), d === 0 && (y = h), h ^= h << 10, h ^= h >>> 15, h ^= h << 4, h ^= h >>> 13, d >= 0 && (y = y + 1640531527 | 0, m = w[d & 127] ^= h + y, g = m == 0 ? g + 1 : 0);
        for (g >= 128 && (w[(l && l.length || 0) & 127] = -1), g = 127, d = 4 * 128; d > 0; --d)
          h = w[g + 34 & 127], m = w[g = g + 1 & 127], h ^= h << 13, m ^= m << 17, h ^= h >>> 15, m ^= m >>> 12, w[g] = h ^ m;
        c.w = y, c.X = w, c.i = g;
      }
      s(u, f);
    }
    function a(f, u) {
      return u.i = f.i, u.w = f.w, u.X = f.X.slice(), u;
    }
    function o(f, u) {
      f == null && (f = +/* @__PURE__ */ new Date());
      var s = new i(f), c = u && u.state, l = function() {
        return (s.next() >>> 0) / 4294967296;
      };
      return l.double = function() {
        do
          var m = s.next() >>> 11, h = (s.next() >>> 0) / 4294967296, g = (m + h) / (1 << 21);
        while (g === 0);
        return g;
      }, l.int32 = s.next, l.quick = l, c && (c.X && a(c, s), l.state = function() {
        return a(s, {});
      }), l;
    }
    r && r.exports ? r.exports = o : this.xor4096 = o;
  })(
    Ki,
    // window object or global
    t
  );
})(Ld);
var D7 = Ld.exports, kd = { exports: {} };
kd.exports;
(function(t) {
  (function(e, r, n) {
    function i(f) {
      var u = this, s = "";
      u.next = function() {
        var l = u.b, m = u.c, h = u.d, g = u.a;
        return l = l << 25 ^ l >>> 7 ^ m, m = m - h | 0, h = h << 24 ^ h >>> 8 ^ g, g = g - l | 0, u.b = l = l << 20 ^ l >>> 12 ^ m, u.c = m = m - h | 0, u.d = h << 16 ^ m >>> 16 ^ g, u.a = g - l | 0;
      }, u.a = 0, u.b = 0, u.c = -1640531527, u.d = 1367130551, f === Math.floor(f) ? (u.a = f / 4294967296 | 0, u.b = f | 0) : s += f;
      for (var c = 0; c < s.length + 20; c++)
        u.b ^= s.charCodeAt(c) | 0, u.next();
    }
    function a(f, u) {
      return u.a = f.a, u.b = f.b, u.c = f.c, u.d = f.d, u;
    }
    function o(f, u) {
      var s = new i(f), c = u && u.state, l = function() {
        return (s.next() >>> 0) / 4294967296;
      };
      return l.double = function() {
        do
          var m = s.next() >>> 11, h = (s.next() >>> 0) / 4294967296, g = (m + h) / (1 << 21);
        while (g === 0);
        return g;
      }, l.int32 = s.next, l.quick = l, c && (typeof c == "object" && a(c, s), l.state = function() {
        return a(s, {});
      }), l;
    }
    r && r.exports ? r.exports = o : this.tychei = o;
  })(
    Ki,
    t
  );
})(kd);
var E7 = kd.exports, Xw = { exports: {} };
const S7 = {}, A7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: S7
}, Symbol.toStringTag, { value: "Module" })), C7 = /* @__PURE__ */ mT(A7);
(function(t) {
  (function(e, r, n) {
    var i = 256, a = 6, o = 52, f = "random", u = n.pow(i, a), s = n.pow(2, o), c = s * 2, l = i - 1, m;
    function h(N, D, b) {
      var C = [];
      D = D == !0 ? { entropy: !0 } : D || {};
      var A = w(y(
        D.entropy ? [N, x(r)] : N ?? E(),
        3
      ), C), T = new g(C), _ = function() {
        for (var O = T.g(a), I = u, B = 0; O < s; )
          O = (O + B) * i, I *= i, B = T.g(1);
        for (; O >= c; )
          O /= 2, I /= 2, B >>>= 1;
        return (O + B) / I;
      };
      return _.int32 = function() {
        return T.g(4) | 0;
      }, _.quick = function() {
        return T.g(4) / 4294967296;
      }, _.double = _, w(x(T.S), r), (D.pass || b || function(O, I, B, k) {
        return k && (k.S && d(k, T), O.state = function() {
          return d(T, {});
        }), B ? (n[f] = O, I) : O;
      })(
        _,
        A,
        "global" in D ? D.global : this == n,
        D.state
      );
    }
    function g(N) {
      var D, b = N.length, C = this, A = 0, T = C.i = C.j = 0, _ = C.S = [];
      for (b || (N = [b++]); A < i; )
        _[A] = A++;
      for (A = 0; A < i; A++)
        _[A] = _[T = l & T + N[A % b] + (D = _[A])], _[T] = D;
      (C.g = function(O) {
        for (var I, B = 0, k = C.i, L = C.j, F = C.S; O--; )
          I = F[k = l & k + 1], B = B * i + F[l & (F[k] = F[L = l & L + I]) + (F[L] = I)];
        return C.i = k, C.j = L, B;
      })(i);
    }
    function d(N, D) {
      return D.i = N.i, D.j = N.j, D.S = N.S.slice(), D;
    }
    function y(N, D) {
      var b = [], C = typeof N, A;
      if (D && C == "object")
        for (A in N)
          try {
            b.push(y(N[A], D - 1));
          } catch {
          }
      return b.length ? b : C == "string" ? N : N + "\0";
    }
    function w(N, D) {
      for (var b = N + "", C, A = 0; A < b.length; )
        D[l & A] = l & (C ^= D[l & A] * 19) + b.charCodeAt(A++);
      return x(D);
    }
    function E() {
      try {
        var N;
        return m && (N = m.randomBytes) ? N = N(i) : (N = new Uint8Array(i), (e.crypto || e.msCrypto).getRandomValues(N)), x(N);
      } catch {
        var D = e.navigator, b = D && D.plugins;
        return [+/* @__PURE__ */ new Date(), e, b, e.screen, x(r)];
      }
    }
    function x(N) {
      return String.fromCharCode.apply(0, N);
    }
    if (w(n.random(), r), t.exports) {
      t.exports = h;
      try {
        m = C7;
      } catch {
      }
    } else
      n["seed" + f] = h;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self < "u" ? self : Ki,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(Xw);
var T7 = Xw.exports, _7 = x7, M7 = b7, O7 = w7, q7 = N7, I7 = D7, F7 = E7, ta = T7;
ta.alea = _7;
ta.xor128 = M7;
ta.xorwow = O7;
ta.xorshift7 = q7;
ta.xor4096 = I7;
ta.tychei = F7;
var B7 = ta;
const Kw = /* @__PURE__ */ qs(B7);
var R7 = /* @__PURE__ */ Kw(Date.now());
function Ia(t) {
  var e;
  function r(i) {
    e = i === null ? R7 : Kw(String(i));
  }
  r(t);
  function n() {
    return e();
  }
  return n;
}
var Hb = "pickRandom", P7 = ["typed", "config", "?on"], Uf = /* @__PURE__ */ H(Hb, P7, (t) => {
  var {
    typed: e,
    config: r,
    on: n
  } = t, i = Ia(r.randomSeed);
  return n && n("config", function(o, f) {
    o.randomSeed !== f.randomSeed && (i = Ia(o.randomSeed));
  }), e(Hb, {
    "Array | Matrix": function(f) {
      return a(f, {});
    },
    "Array | Matrix, Object": function(f, u) {
      return a(f, u);
    },
    "Array | Matrix, number": function(f, u) {
      return a(f, {
        number: u
      });
    },
    "Array | Matrix, Array | Matrix": function(f, u) {
      return a(f, {
        weights: u
      });
    },
    "Array | Matrix, Array | Matrix, number": function(f, u, s) {
      return a(f, {
        number: s,
        weights: u
      });
    },
    "Array | Matrix, number, Array | Matrix": function(f, u, s) {
      return a(f, {
        number: u,
        weights: s
      });
    }
  });
  function a(o, f) {
    var {
      number: u,
      weights: s,
      elementWise: c = !0
    } = f, l = typeof u > "u";
    l && (u = 1);
    var m = Ye(o) ? o.create : Ye(s) ? s.create : null;
    o = o.valueOf(), s && (s = s.valueOf()), c === !0 && (o = Mt(o), s = Mt(s));
    var h = 0;
    if (typeof s < "u") {
      if (s.length !== o.length)
        throw new Error("Weights must have the same length as possibles");
      for (var g = 0, d = s.length; g < d; g++) {
        if (!ot(s[g]) || s[g] < 0)
          throw new Error("Weights must be an array of positive numbers");
        h += s[g];
      }
    }
    for (var y = o.length, w = [], E; w.length < u; ) {
      if (typeof s > "u")
        E = o[Math.floor(i() * y)];
      else
        for (var x = i() * h, N = 0, D = o.length; N < D; N++)
          if (x -= s[N], x < 0) {
            E = o[N];
            break;
          }
      w.push(E);
    }
    return l ? w[0] : m ? m(w) : w;
  }
});
function zd(t, e) {
  var r = [];
  if (t = t.slice(0), t.length > 1)
    for (var n = 0, i = t.shift(); n < i; n++)
      r.push(zd(t, e));
  else
    for (var a = 0, o = t.shift(); a < o; a++)
      r.push(e());
  return r;
}
var Qb = "random", L7 = ["typed", "config", "?on"], Gf = /* @__PURE__ */ H(Qb, L7, (t) => {
  var {
    typed: e,
    config: r,
    on: n
  } = t, i = Ia(r.randomSeed);
  return n && n("config", function(f, u) {
    f.randomSeed !== u.randomSeed && (i = Ia(f.randomSeed));
  }), e(Qb, {
    "": () => o(0, 1),
    number: (f) => o(0, f),
    "number, number": (f, u) => o(f, u),
    "Array | Matrix": (f) => a(f, 0, 1),
    "Array | Matrix, number": (f, u) => a(f, 0, u),
    "Array | Matrix, number, number": (f, u, s) => a(f, u, s)
  });
  function a(f, u, s) {
    var c = zd(f.valueOf(), () => o(u, s));
    return Ye(f) ? f.create(c) : c;
  }
  function o(f, u) {
    return f + i() * (u - f);
  }
}), Vb = "randomInt", k7 = ["typed", "config", "?on"], Hf = /* @__PURE__ */ H(Vb, k7, (t) => {
  var {
    typed: e,
    config: r,
    on: n
  } = t, i = Ia(r.randomSeed);
  return n && n("config", function(f, u) {
    f.randomSeed !== u.randomSeed && (i = Ia(f.randomSeed));
  }), e(Vb, {
    "": () => o(0, 1),
    number: (f) => o(0, f),
    "number, number": (f, u) => o(f, u),
    "Array | Matrix": (f) => a(f, 0, 1),
    "Array | Matrix, number": (f, u) => a(f, 0, u),
    "Array | Matrix, number, number": (f, u, s) => a(f, u, s)
  });
  function a(f, u, s) {
    var c = zd(f.valueOf(), () => o(u, s));
    return Ye(f) ? f.create(c) : c;
  }
  function o(f, u) {
    return Math.floor(f + i() * (u - f));
  }
}), Wb = "stirlingS2", z7 = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"], Qf = /* @__PURE__ */ H(Wb, z7, (t) => {
  var {
    typed: e,
    addScalar: r,
    subtractScalar: n,
    multiplyScalar: i,
    divideScalar: a,
    pow: o,
    factorial: f,
    combinations: u,
    isNegative: s,
    isInteger: c,
    number: l,
    bignumber: m,
    larger: h
  } = t, g = [], d = [];
  return e(Wb, {
    "number | BigNumber, number | BigNumber": function(w, E) {
      if (!c(w) || s(w) || !c(E) || s(E))
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      if (h(E, w))
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      var x = !(ot(w) && ot(E)), N = x ? d : g, D = x ? m : l, b = l(w), C = l(E);
      if (N[b] && N[b].length > C)
        return N[b][C];
      for (var A = 0; A <= b; ++A)
        if (N[A] || (N[A] = [D(A === 0 ? 1 : 0)]), A !== 0)
          for (var T = N[A], _ = N[A - 1], O = T.length; O <= A && O <= C; ++O)
            O === A ? T[O] = 1 : T[O] = r(i(D(O), _[O]), _[O - 1]);
      return N[b][C];
    }
  });
}), jb = "bellNumbers", $7 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"], Vf = /* @__PURE__ */ H(jb, $7, (t) => {
  var {
    typed: e,
    addScalar: r,
    isNegative: n,
    isInteger: i,
    stirlingS2: a
  } = t;
  return e(jb, {
    "number | BigNumber": function(f) {
      if (!i(f) || n(f))
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      for (var u = 0, s = 0; s <= f; s++)
        u = r(u, a(f, s));
      return u;
    }
  });
}), Yb = "catalan", U7 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"], Wf = /* @__PURE__ */ H(Yb, U7, (t) => {
  var {
    typed: e,
    addScalar: r,
    divideScalar: n,
    multiplyScalar: i,
    combinations: a,
    isNegative: o,
    isInteger: f
  } = t;
  return e(Yb, {
    "number | BigNumber": function(s) {
      if (!f(s) || o(s))
        throw new TypeError("Non-negative integer value expected in function catalan");
      return n(a(i(s, 2), s), r(s, 1));
    }
  });
}), Zb = "composition", G7 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"], jf = /* @__PURE__ */ H(Zb, G7, (t) => {
  var {
    typed: e,
    addScalar: r,
    combinations: n,
    isPositive: i,
    isNegative: a,
    isInteger: o,
    larger: f
  } = t;
  return e(Zb, {
    "number | BigNumber, number | BigNumber": function(s, c) {
      if (!o(s) || !i(s) || !o(c) || !i(c))
        throw new TypeError("Positive integer value expected in function composition");
      if (f(c, s))
        throw new TypeError("k must be less than or equal to n in function composition");
      return n(r(s, -1), r(c, -1));
    }
  });
}), Jb = "leafCount", H7 = ["parse", "typed"], Yf = /* @__PURE__ */ H(Jb, H7, (t) => {
  var {
    parse: e,
    typed: r
  } = t;
  function n(i) {
    var a = 0;
    return i.forEach((o) => {
      a += n(o);
    }), a || 1;
  }
  return r(Jb, {
    Node: function(a) {
      return n(a);
    }
  });
});
function Xb(t) {
  return wt(t) || Kt(t) && t.isUnary() && wt(t.args[0]);
}
function pu(t) {
  return !!(wt(t) || (Bn(t) || Kt(t)) && t.args.every(pu) || Cn(t) && pu(t.content));
}
function Kb(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Ph(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Kb(Object(r), !0).forEach(function(n) {
      lr(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Kb(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var Q7 = "simplifyUtil", V7 = ["FunctionNode", "OperatorNode", "SymbolNode"], $d = /* @__PURE__ */ H(Q7, V7, (t) => {
  var {
    FunctionNode: e,
    OperatorNode: r,
    SymbolNode: n
  } = t, i = !0, a = !1, o = "defaultF", f = {
    /*      */
    add: {
      trivial: i,
      total: i,
      commutative: i,
      associative: i
    },
    /**/
    unaryPlus: {
      trivial: i,
      total: i,
      commutative: i,
      associative: i
    },
    /* */
    subtract: {
      trivial: a,
      total: i,
      commutative: a,
      associative: a
    },
    /* */
    multiply: {
      trivial: i,
      total: i,
      commutative: i,
      associative: i
    },
    /*   */
    divide: {
      trivial: a,
      total: i,
      commutative: a,
      associative: a
    },
    /*    */
    paren: {
      trivial: i,
      total: i,
      commutative: i,
      associative: a
    },
    /* */
    defaultF: {
      trivial: a,
      total: i,
      commutative: a,
      associative: a
    }
  }, u = {
    divide: {
      total: a
    },
    log: {
      total: a
    }
  }, s = {
    subtract: {
      total: a
    },
    abs: {
      trivial: i
    },
    log: {
      total: i
    }
  };
  function c(x, N) {
    var D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : f, b = o;
    if (typeof x == "string" ? b = x : Kt(x) ? b = x.fn.toString() : Bn(x) ? b = x.name : Cn(x) && (b = "paren"), $e(D, b)) {
      var C = D[b];
      if ($e(C, N))
        return C[N];
      if ($e(f, b))
        return f[b][N];
    }
    if ($e(D, o)) {
      var A = D[o];
      return $e(A, N) ? A[N] : f[o][N];
    }
    if ($e(f, b)) {
      var T = f[b];
      if ($e(T, N))
        return T[N];
    }
    return f[o][N];
  }
  function l(x) {
    var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f;
    return c(x, "commutative", N);
  }
  function m(x) {
    var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f;
    return c(x, "associative", N);
  }
  function h(x, N) {
    var D = Ph({}, x);
    for (var b in N)
      $e(x, b) ? D[b] = Ph(Ph({}, N[b]), x[b]) : D[b] = N[b];
    return D;
  }
  function g(x, N) {
    if (!x.args || x.args.length === 0)
      return x;
    x.args = d(x, N);
    for (var D = 0; D < x.args.length; D++)
      g(x.args[D], N);
  }
  function d(x, N) {
    var D, b = [], C = function A(T) {
      for (var _ = 0; _ < T.args.length; _++) {
        var O = T.args[_];
        Kt(O) && D === O.op ? A(O) : b.push(O);
      }
    };
    return m(x, N) ? (D = x.op, C(x), b) : x.args;
  }
  function y(x, N) {
    if (!(!x.args || x.args.length === 0)) {
      for (var D = E(x), b = x.args.length, C = 0; C < b; C++)
        y(x.args[C], N);
      if (b > 2 && m(x, N)) {
        for (var A = x.args.pop(); x.args.length > 0; )
          A = D([x.args.pop(), A]);
        x.args = A.args;
      }
    }
  }
  function w(x, N) {
    if (!(!x.args || x.args.length === 0)) {
      for (var D = E(x), b = x.args.length, C = 0; C < b; C++)
        w(x.args[C], N);
      if (b > 2 && m(x, N)) {
        for (var A = x.args.shift(); x.args.length > 0; )
          A = D([A, x.args.shift()]);
        x.args = A.args;
      }
    }
  }
  function E(x) {
    return Kt(x) ? function(N) {
      try {
        return new r(x.op, x.fn, N, x.implicit);
      } catch (D) {
        return console.error(D), [];
      }
    } : function(N) {
      return new e(new n(x.name), N);
    };
  }
  return {
    createMakeNodeFunction: E,
    hasProperty: c,
    isCommutative: l,
    isAssociative: m,
    mergeContext: h,
    flatten: g,
    allChildren: d,
    unflattenr: y,
    unflattenl: w,
    defaultContext: f,
    realContext: u,
    positiveContext: s
  };
}), W7 = "simplify", j7 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"], Zf = /* @__PURE__ */ H(W7, j7, (t) => {
  var {
    config: e,
    typed: r,
    parse: n,
    add: i,
    subtract: a,
    multiply: o,
    divide: f,
    pow: u,
    isZero: s,
    equal: c,
    resolve: l,
    simplifyConstant: m,
    simplifyCore: h,
    fraction: g,
    bignumber: d,
    mathWithTransform: y,
    matrix: w,
    AccessorNode: E,
    ArrayNode: x,
    ConstantNode: N,
    FunctionNode: D,
    IndexNode: b,
    ObjectNode: C,
    OperatorNode: A,
    ParenthesisNode: T,
    SymbolNode: _
  } = t, {
    hasProperty: O,
    isCommutative: I,
    isAssociative: B,
    mergeContext: k,
    flatten: L,
    unflattenr: F,
    unflattenl: M,
    createMakeNodeFunction: $,
    defaultContext: R,
    realContext: Q,
    positiveContext: ee
  } = $d({
    FunctionNode: D,
    OperatorNode: A,
    SymbolNode: _
  });
  r.addConversion({
    from: "Object",
    to: "Map",
    convert: Sa
  });
  var j = r("simplify", {
    Node: se,
    "Node, Map": (K, ae) => se(K, !1, ae),
    "Node, Map, Object": (K, ae, de) => se(K, !1, ae, de),
    "Node, Array": se,
    "Node, Array, Map": se,
    "Node, Array, Map, Object": se
  });
  r.removeConversion({
    from: "Object",
    to: "Map",
    convert: Sa
  }), j.defaultContext = R, j.realContext = Q, j.positiveContext = ee;
  function U(K) {
    return K.transform(function(ae, de, xe) {
      return Cn(ae) ? U(ae.content) : ae;
    });
  }
  var pe = {
    true: !0,
    false: !0,
    e: !0,
    i: !0,
    Infinity: !0,
    LN2: !0,
    LN10: !0,
    LOG2E: !0,
    LOG10E: !0,
    NaN: !0,
    phi: !0,
    pi: !0,
    SQRT1_2: !0,
    SQRT2: !0,
    tau: !0
    // null: false,
    // undefined: false,
    // version: false,
  };
  j.rules = [
    h,
    // { l: 'n+0', r: 'n' },     // simplifyCore
    // { l: 'n^0', r: '1' },     // simplifyCore
    // { l: '0*n', r: '0' },     // simplifyCore
    // { l: 'n/n', r: '1'},      // simplifyCore
    // { l: 'n^1', r: 'n' },     // simplifyCore
    // { l: '+n1', r:'n1' },     // simplifyCore
    // { l: 'n--n1', r:'n+n1' }, // simplifyCore
    {
      l: "log(e)",
      r: "1"
    },
    // temporary rules
    // Note initially we tend constants to the right because like-term
    // collection prefers the left, and we would rather collect nonconstants
    {
      s: "n-n1 -> n+-n1",
      // temporarily replace 'subtract' so we can further flatten the 'add' operator
      assuming: {
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "n-n -> 0",
      // partial alternative when we can't always subtract
      assuming: {
        subtract: {
          total: !1
        }
      }
    },
    {
      s: "-(cl*v) -> v * (-cl)",
      // make non-constant terms positive
      assuming: {
        multiply: {
          commutative: !0
        },
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "-(cl*v) -> (-cl) * v",
      // non-commutative version, part 1
      assuming: {
        multiply: {
          commutative: !1
        },
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "-(v*cl) -> v * (-cl)",
      // non-commutative version, part 2
      assuming: {
        multiply: {
          commutative: !1
        },
        subtract: {
          total: !0
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    // finish making non-constant terms positive
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: !0
    },
    // expand negations to achieve as much sign cancellation as possible
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    // temporarily replace 'divide' so we can further flatten the 'multiply' operator
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: !0
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    // expand nested exponentiation
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: !0
        }
      }
      // 1/(1/n) = n needs 1/n to exist
    },
    // collect like factors; into a sum, only do this for nonconstants
    {
      l: " vd   * ( vd   * n1 + n2)",
      r: "vd^2       * n1 +  vd   * n2"
    },
    {
      s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
      assuming: {
        divide: {
          total: !0
        }
      }
      // v*1/v = v^(1+-1) needs 1/v
    },
    {
      s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: !0
        }
      }
    },
    {
      s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: !0
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: !0
        }
      }
      // n*1/n = n^(-1+1) needs 1/n
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: !0
        }
      }
      // ditto for n^2*1/n^2
    },
    // Unfortunately, to deal with more complicated cancellations, it
    // becomes necessary to simplify constants twice per pass. It's not
    // terribly expensive compared to matching rules, so this should not
    // pose a performance problem.
    m,
    // First: before collecting like terms
    // collect like terms
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: !0
        }
      }
      // 2 = 1 + 1 needs to exist
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "vd*n + vd",
      r: "vd*(n+1)"
    },
    // NOTE: leftmost position is special:
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    // All sub-monomials tried there.
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    // noncommutative additional cases (term collection & factoring)
    {
      s: "n*vd + vd -> (n+1)*vd",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "vd + n*vd -> (1+n)*vd",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n^n1 * n -> n^(n1+1)",
      assuming: {
        divide: {
          total: !0
        },
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      l: "n*cd + cd",
      r: "(n+1)*cd"
    },
    {
      s: "cd*n + cd -> cd*(n+1)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    {
      s: "cd + cd*n -> cd*(1+n)",
      assuming: {
        multiply: {
          commutative: !1
        }
      }
    },
    m,
    // Second: before returning expressions to "standard form"
    // make factors positive (and undo 'make non-constant terms positive')
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: !0
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      // in case * non-commutative
      assuming: {
        subtract: {
          total: !0
        },
        multiply: {
          commutative: !1
        }
      }
    },
    // final ordering of constants
    {
      s: "ce+ve -> ve+ce",
      assuming: {
        add: {
          commutative: !0
        }
      },
      imposeContext: {
        add: {
          commutative: !1
        }
      }
    },
    {
      s: "vd*cd -> cd*vd",
      assuming: {
        multiply: {
          commutative: !0
        }
      },
      imposeContext: {
        multiply: {
          commutative: !1
        }
      }
    },
    // undo temporary rules
    // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
    {
      l: "n+-n1",
      r: "n-n1"
    },
    // undo replace 'subtract'
    {
      l: "n+-(n1)",
      r: "n-(n1)"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      // undo replace 'divide'; for * commutative
      assuming: {
        multiply: {
          commutative: !0
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: !0
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: !0
        }
      }
      // o.w. / not conventional
    },
    {
      l: "n^1",
      r: "n"
    },
    // can be produced by power cancellation
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      // '*' before '/'
      assuming: {
        multiply: {
          associative: !0
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      // '-' before '+'
      assuming: {
        addition: {
          associative: !0,
          commutative: !0
        }
      }
    },
    // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
    // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
    // simplifyConstant can leave an extra factor of 1, which can always
    // be eliminated, since the identity always commutes
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: !0
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: !0
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function X(K, ae) {
    var de = {};
    if (K.s) {
      var xe = K.s.split("->");
      if (xe.length === 2)
        de.l = xe[0], de.r = xe[1];
      else
        throw SyntaxError("Could not parse rule: " + K.s);
    } else
      de.l = K.l, de.r = K.r;
    de.l = U(n(de.l)), de.r = U(n(de.r));
    for (var Ce of ["imposeContext", "repeat", "assuming"])
      Ce in K && (de[Ce] = K[Ce]);
    if (K.evaluate && (de.evaluate = n(K.evaluate)), B(de.l, ae)) {
      var G = !I(de.l, ae), Z;
      G && (Z = ce());
      var ge = $(de.l), be = ce();
      de.expanded = {}, de.expanded.l = ge([de.l, be]), L(de.expanded.l, ae), F(de.expanded.l, ae), de.expanded.r = ge([de.r, be]), G && (de.expandedNC1 = {}, de.expandedNC1.l = ge([Z, de.l]), de.expandedNC1.r = ge([Z, de.r]), de.expandedNC2 = {}, de.expandedNC2.l = ge([Z, de.expanded.l]), de.expandedNC2.r = ge([Z, de.expanded.r]));
    }
    return de;
  }
  function te(K, ae) {
    for (var de = [], xe = 0; xe < K.length; xe++) {
      var Ce = K[xe], G = void 0, Z = typeof Ce;
      switch (Z) {
        case "string":
          Ce = {
            s: Ce
          };
        case "object":
          G = X(Ce, ae);
          break;
        case "function":
          G = Ce;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + Z);
      }
      de.push(G);
    }
    return de;
  }
  var ue = 0;
  function ce() {
    return new _("_p" + ue++);
  }
  function se(K, ae) {
    var de = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ns(), xe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, Ce = xe.consoleDebug;
    ae = te(ae || j.rules, xe.context);
    var G = l(K, de);
    G = U(G);
    for (var Z = {}, ge = G.toString({
      parenthesis: "all"
    }); !Z[ge]; ) {
      Z[ge] = !0, ue = 0;
      var be = ge;
      Ce && console.log("Working on: ", ge);
      for (var Se = 0; Se < ae.length; Se++) {
        var De = "";
        if (typeof ae[Se] == "function" ? (G = ae[Se](G, xe), Ce && (De = ae[Se].name)) : (L(G, xe.context), G = le(G, ae[Se], xe.context), Ce && (De = "".concat(ae[Se].l.toString(), " -> ").concat(ae[Se].r.toString()))), Ce) {
          var Me = G.toString({
            parenthesis: "all"
          });
          Me !== be && (console.log("Applying", De, "produced", Me), be = Me);
        }
        M(G, xe.context);
      }
      ge = G.toString({
        parenthesis: "all"
      });
    }
    return G;
  }
  function he(K, ae, de) {
    var xe = K;
    if (K)
      for (var Ce = 0; Ce < K.length; ++Ce) {
        var G = le(K[Ce], ae, de);
        G !== K[Ce] && (xe === K && (xe = K.slice()), xe[Ce] = G);
      }
    return xe;
  }
  function le(K, ae, de) {
    if (ae.assuming) {
      for (var xe in ae.assuming)
        for (var Ce in ae.assuming[xe])
          if (O(xe, Ce, de) !== ae.assuming[xe][Ce])
            return K;
    }
    var G = k(ae.imposeContext, de), Z = K;
    if (Z instanceof A || Z instanceof D) {
      var ge = he(Z.args, ae, de);
      ge !== Z.args && (Z = Z.clone(), Z.args = ge);
    } else if (Z instanceof T) {
      if (Z.content) {
        var be = le(Z.content, ae, de);
        be !== Z.content && (Z = new T(be));
      }
    } else if (Z instanceof x) {
      var Se = he(Z.items, ae, de);
      Se !== Z.items && (Z = new x(Se));
    } else if (Z instanceof E) {
      var De = Z.object;
      Z.object && (De = le(Z.object, ae, de));
      var Me = Z.index;
      Z.index && (Me = le(Z.index, ae, de)), (De !== Z.object || Me !== Z.index) && (Z = new E(De, Me));
    } else if (Z instanceof b) {
      var Oe = he(Z.dimensions, ae, de);
      Oe !== Z.dimensions && (Z = new b(Oe));
    } else if (Z instanceof C) {
      var Be = !1, Ie = {};
      for (var nt in Z.properties)
        Ie[nt] = le(Z.properties[nt], ae, de), Ie[nt] !== Z.properties[nt] && (Be = !0);
      Be && (Z = new C(Ie));
    }
    var We = ae.r, Qe = J(ae.l, Z, G)[0];
    if (!Qe && ae.expanded && (We = ae.expanded.r, Qe = J(ae.expanded.l, Z, G)[0]), !Qe && ae.expandedNC1 && (We = ae.expandedNC1.r, Qe = J(ae.expandedNC1.l, Z, G)[0], Qe || (We = ae.expandedNC2.r, Qe = J(ae.expandedNC2.l, Z, G)[0])), Qe) {
      var Gt = Z.implicit;
      Z = We.clone(), Gt && "implicit" in We && (Z.implicit = !0), Z = Z.transform(function(P) {
        return P.isSymbolNode && $e(Qe.placeholders, P.name) ? Qe.placeholders[P.name].clone() : P;
      });
    }
    return ae.repeat && Z !== K && (Z = le(Z, ae, de)), Z;
  }
  function ve(K, ae) {
    var de = [], xe, Ce, G = $(K);
    if (I(K, ae))
      for (var Z = 0; Z < K.args.length; Z++)
        Ce = K.args.slice(0), Ce.splice(Z, 1), xe = Ce.length === 1 ? Ce[0] : G(Ce), de.push(G([K.args[Z], xe]));
    else
      for (var ge = 1; ge < K.args.length; ge++) {
        var be = K.args[0];
        ge > 1 && (be = G(K.args.slice(0, ge))), Ce = K.args.slice(ge), xe = Ce.length === 1 ? Ce[0] : G(Ce), de.push(G([be, xe]));
      }
    return de;
  }
  function Ee(K, ae) {
    var de = {
      placeholders: {}
    };
    if (!K.placeholders && !ae.placeholders)
      return de;
    if (K.placeholders) {
      if (!ae.placeholders)
        return K;
    } else return ae;
    for (var xe in K.placeholders)
      if ($e(K.placeholders, xe) && (de.placeholders[xe] = K.placeholders[xe], $e(ae.placeholders, xe) && !ye(K.placeholders[xe], ae.placeholders[xe])))
        return null;
    for (var Ce in ae.placeholders)
      $e(ae.placeholders, Ce) && (de.placeholders[Ce] = ae.placeholders[Ce]);
    return de;
  }
  function _e(K, ae) {
    var de = [];
    if (K.length === 0 || ae.length === 0)
      return de;
    for (var xe, Ce = 0; Ce < K.length; Ce++)
      for (var G = 0; G < ae.length; G++)
        xe = Ee(K[Ce], ae[G]), xe && de.push(xe);
    return de;
  }
  function V(K) {
    if (K.length === 0)
      return K;
    for (var ae = K.reduce(_e), de = [], xe = {}, Ce = 0; Ce < ae.length; Ce++) {
      var G = JSON.stringify(ae[Ce]);
      xe[G] || (xe[G] = !0, de.push(ae[Ce]));
    }
    return de;
  }
  function J(K, ae, de, xe) {
    var Ce = [{
      placeholders: {}
    }];
    if (K instanceof A && ae instanceof A || K instanceof D && ae instanceof D) {
      if (K instanceof A) {
        if (K.op !== ae.op || K.fn !== ae.fn)
          return [];
      } else if (K instanceof D && K.name !== ae.name)
        return [];
      if (ae.args.length === 1 && K.args.length === 1 || !B(ae, de) && ae.args.length === K.args.length || xe) {
        for (var G = [], Z = 0; Z < K.args.length; Z++) {
          var ge = J(K.args[Z], ae.args[Z], de);
          if (ge.length === 0)
            break;
          G.push(ge);
        }
        if (G.length !== K.args.length) {
          if (!I(ae, de) || // exact match in order needed
          K.args.length === 1)
            return [];
          if (K.args.length > 2)
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          var be = J(K.args[0], ae.args[1], de);
          if (be.length === 0)
            return [];
          var Se = J(K.args[1], ae.args[0], de);
          if (Se.length === 0)
            return [];
          G = [be, Se];
        }
        Ce = V(G);
      } else if (ae.args.length >= 2 && K.args.length === 2) {
        for (var De = ve(ae, de), Me = [], Oe = 0; Oe < De.length; Oe++) {
          var Be = J(K, De[Oe], de, !0);
          Me = Me.concat(Be);
        }
        return Me;
      } else {
        if (K.args.length > 2)
          throw Error("Unexpected non-binary associative function: " + K.toString());
        return [];
      }
    } else if (K instanceof _) {
      if (K.name.length === 0)
        throw new Error("Symbol in rule has 0 length...!?");
      if (pe[K.name]) {
        if (K.name !== ae.name)
          return [];
      } else
        switch (K.name[1] >= "a" && K.name[1] <= "z" ? K.name.substring(0, 2) : K.name[0]) {
          case "n":
          case "_p":
            Ce[0].placeholders[K.name] = ae;
            break;
          case "c":
          case "cl":
            if (wt(ae))
              Ce[0].placeholders[K.name] = ae;
            else
              return [];
            break;
          case "v":
            if (!wt(ae))
              Ce[0].placeholders[K.name] = ae;
            else
              return [];
            break;
          case "vl":
            if (ir(ae))
              Ce[0].placeholders[K.name] = ae;
            else
              return [];
            break;
          case "cd":
            if (Xb(ae))
              Ce[0].placeholders[K.name] = ae;
            else
              return [];
            break;
          case "vd":
            if (!Xb(ae))
              Ce[0].placeholders[K.name] = ae;
            else
              return [];
            break;
          case "ce":
            if (pu(ae))
              Ce[0].placeholders[K.name] = ae;
            else
              return [];
            break;
          case "ve":
            if (!pu(ae))
              Ce[0].placeholders[K.name] = ae;
            else
              return [];
            break;
          default:
            throw new Error("Invalid symbol in rule: " + K.name);
        }
    } else if (K instanceof N) {
      if (!c(K.value, ae.value))
        return [];
    } else
      return [];
    return Ce;
  }
  function ye(K, ae) {
    if (K instanceof N && ae instanceof N) {
      if (!c(K.value, ae.value))
        return !1;
    } else if (K instanceof _ && ae instanceof _) {
      if (K.name !== ae.name)
        return !1;
    } else if (K instanceof A && ae instanceof A || K instanceof D && ae instanceof D) {
      if (K instanceof A) {
        if (K.op !== ae.op || K.fn !== ae.fn)
          return !1;
      } else if (K instanceof D && K.name !== ae.name)
        return !1;
      if (K.args.length !== ae.args.length)
        return !1;
      for (var de = 0; de < K.args.length; de++)
        if (!ye(K.args[de], ae.args[de]))
          return !1;
    } else
      return !1;
    return !0;
  }
  return j;
}), Y7 = "simplifyConstant", Z7 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"], Jf = /* @__PURE__ */ H(Y7, Z7, (t) => {
  var {
    typed: e,
    config: r,
    mathWithTransform: n,
    matrix: i,
    fraction: a,
    bignumber: o,
    AccessorNode: f,
    ArrayNode: u,
    ConstantNode: s,
    FunctionNode: c,
    IndexNode: l,
    ObjectNode: m,
    OperatorNode: h,
    SymbolNode: g
  } = t, {
    isCommutative: d,
    isAssociative: y,
    allChildren: w,
    createMakeNodeFunction: E
  } = $d({
    FunctionNode: c,
    OperatorNode: h,
    SymbolNode: g
  }), x = e("simplifyConstant", {
    Node: (L) => C(k(L, {})),
    "Node, Object": function(F, M) {
      return C(k(F, M));
    }
  });
  function N(L) {
    return xi(L) ? L.valueOf() : L instanceof Array ? L.map(N) : Ye(L) ? i(N(L.valueOf())) : L;
  }
  function D(L, F, M) {
    try {
      return n[L].apply(null, F);
    } catch {
      return F = F.map(N), T(n[L].apply(null, F), M);
    }
  }
  var b = e({
    Fraction: O,
    number: function(F) {
      return F < 0 ? _(new s(-F)) : new s(F);
    },
    BigNumber: function(F) {
      return F < 0 ? _(new s(-F)) : new s(F);
    },
    bigint: function(F) {
      return F < 0n ? _(new s(-F)) : new s(F);
    },
    Complex: function(F) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function(F) {
      return new s(F);
    },
    Matrix: function(F) {
      return new u(F.valueOf().map((M) => b(M)));
    }
  });
  function C(L) {
    return Bt(L) ? L : b(L);
  }
  function A(L, F) {
    var M = F && F.exactFractions !== !1;
    if (M && isFinite(L) && a) {
      var $ = a(L), R = F && typeof F.fractionsLimit == "number" ? F.fractionsLimit : 1 / 0;
      if ($.valueOf() === L && $.n < R && $.d < R)
        return $;
    }
    return L;
  }
  var T = e({
    "string, Object": function(F, M) {
      var $ = wi(F, r);
      if ($ === "BigNumber")
        return o === void 0 && Md(), o(F);
      if ($ === "bigint")
        return BigInt(F);
      if ($ === "Fraction")
        return a === void 0 && Gw(), a(F);
      var R = parseFloat(F);
      return A(R, M);
    },
    "Fraction, Object": function(F, M) {
      return F;
    },
    // we don't need options here
    "BigNumber, Object": function(F, M) {
      return F;
    },
    // we don't need options here
    "number, Object": function(F, M) {
      return A(F, M);
    },
    "bigint, Object": function(F, M) {
      return F;
    },
    "Complex, Object": function(F, M) {
      return F.im !== 0 ? F : A(F.re, M);
    },
    "Matrix, Object": function(F, M) {
      return i(A(F.valueOf()));
    },
    "Array, Object": function(F, M) {
      return F.map(A);
    }
  });
  function _(L) {
    return new h("-", "unaryMinus", [L]);
  }
  function O(L) {
    var F, M = L.s * L.n;
    return M < 0 ? F = new h("-", "unaryMinus", [new s(-M)]) : F = new s(M), L.d === 1 ? F : new h("/", "divide", [F, new s(L.d)]);
  }
  function I(L, F, M) {
    if (!bi(F))
      return new f(C(L), C(F));
    if (Wr(L) || Ye(L)) {
      for (var $ = Array.from(F.dimensions); $.length > 0; )
        if (wt($[0]) && typeof $[0].value != "string") {
          var R = T($.shift().value, M);
          Wr(L) ? L = L.items[R - 1] : (L = L.valueOf()[R - 1], L instanceof Array && (L = i(L)));
        } else if ($.length > 1 && wt($[1]) && typeof $[1].value != "string") {
          var Q = T($[1].value, M), ee = [], j = Wr(L) ? L.items : L.valueOf();
          for (var U of j)
            if (Wr(U))
              ee.push(U.items[Q - 1]);
            else if (Ye(L))
              ee.push(U[Q - 1]);
            else
              break;
          if (ee.length === j.length)
            Wr(L) ? L = new u(ee) : L = i(ee), $.splice(1, 1);
          else
            break;
        } else
          break;
      return $.length === F.dimensions.length ? new f(C(L), F) : $.length > 0 ? (F = new l($), new f(C(L), F)) : L;
    }
    if (Pa(L) && F.dimensions.length === 1 && wt(F.dimensions[0])) {
      var pe = F.dimensions[0].value;
      return pe in L.properties ? L.properties[pe] : new s();
    }
    return new f(C(L), F);
  }
  function B(L, F, M, $) {
    var R = F.shift(), Q = F.reduce((ee, j) => {
      if (!Bt(j)) {
        var U = ee.pop();
        if (Bt(U))
          return [U, j];
        try {
          return ee.push(D(L, [U, j], $)), ee;
        } catch {
          ee.push(U);
        }
      }
      ee.push(C(ee.pop()));
      var pe = ee.length === 1 ? ee[0] : M(ee);
      return [M([pe, C(j)])];
    }, [R]);
    return Q.length === 1 ? Q[0] : M([Q[0], b(Q[1])]);
  }
  function k(L, F) {
    switch (L.type) {
      case "SymbolNode":
        return L;
      case "ConstantNode":
        switch (typeof L.value) {
          case "number":
            return T(L.value, F);
          case "bigint":
            return T(L.value, F);
          case "string":
            return L.value;
          default:
            if (!isNaN(L.value)) return T(L.value, F);
        }
        return L;
      case "FunctionNode":
        if (n[L.name] && n[L.name].rawArgs)
          return L;
        {
          var M = ["add", "multiply"];
          if (!M.includes(L.name)) {
            var $ = L.args.map((le) => k(le, F));
            if (!$.some(Bt))
              try {
                return D(L.name, $, F);
              } catch {
              }
            if (L.name === "size" && $.length === 1 && Wr($[0])) {
              for (var R = [], Q = $[0]; Wr(Q); )
                R.push(Q.items.length), Q = Q.items[0];
              return i(R);
            }
            return new c(L.name, $.map(C));
          }
        }
      case "OperatorNode": {
        var ee = L.fn.toString(), j, U, pe = E(L);
        if (Kt(L) && L.isUnary())
          j = [k(L.args[0], F)], Bt(j[0]) ? U = pe(j) : U = D(ee, j, F);
        else if (y(L, F.context))
          if (j = w(L, F.context), j = j.map((le) => k(le, F)), d(ee, F.context)) {
            for (var X = [], te = [], ue = 0; ue < j.length; ue++)
              Bt(j[ue]) ? te.push(j[ue]) : X.push(j[ue]);
            X.length > 1 ? (U = B(ee, X, pe, F), te.unshift(U), U = B(ee, te, pe, F)) : U = B(ee, j, pe, F);
          } else
            U = B(ee, j, pe, F);
        else
          j = L.args.map((le) => k(le, F)), U = B(ee, j, pe, F);
        return U;
      }
      case "ParenthesisNode":
        return k(L.content, F);
      case "AccessorNode":
        return I(k(L.object, F), k(L.index, F), F);
      case "ArrayNode": {
        var ce = L.items.map((le) => k(le, F));
        return ce.some(Bt) ? new u(ce.map(C)) : i(ce);
      }
      case "IndexNode":
        return new l(L.dimensions.map((le) => x(le, F)));
      case "ObjectNode": {
        var se = {};
        for (var he in L.properties)
          se[he] = x(L.properties[he], F);
        return new m(se);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(L.type));
    }
  }
  return x;
}), e2 = "simplifyCore", J7 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"], Xf = /* @__PURE__ */ H(e2, J7, (t) => {
  var {
    typed: e,
    parse: r,
    equal: n,
    isZero: i,
    add: a,
    subtract: o,
    multiply: f,
    divide: u,
    pow: s,
    AccessorNode: c,
    ArrayNode: l,
    ConstantNode: m,
    FunctionNode: h,
    IndexNode: g,
    ObjectNode: d,
    OperatorNode: y,
    ParenthesisNode: w,
    SymbolNode: E
  } = t, x = new m(0), N = new m(1), D = new m(!0), b = new m(!1);
  function C(O) {
    return Kt(O) && ["and", "not", "or"].includes(O.op);
  }
  var {
    hasProperty: A,
    isCommutative: T
  } = $d({
    FunctionNode: h,
    OperatorNode: y,
    SymbolNode: E
  });
  function _(O) {
    var I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, B = I ? I.context : void 0;
    if (A(O, "trivial", B)) {
      if (Bn(O) && O.args.length === 1)
        return _(O.args[0], I);
      var k = !1, L = 0;
      if (O.forEach((te) => {
        ++L, L === 1 && (k = _(te, I));
      }), L === 1)
        return k;
    }
    var F = O;
    if (Bn(F)) {
      var M = oI(F.name);
      if (M) {
        if (F.args.length > 2 && A(F, "associative", B))
          for (; F.args.length > 2; ) {
            var $ = F.args.pop(), R = F.args.pop();
            F.args.push(new y(M, F.name, [$, R]));
          }
        F = new y(M, F.name, F.args);
      } else
        return new h(_(F.fn), F.args.map((te) => _(te, I)));
    }
    if (Kt(F) && F.isUnary()) {
      var Q = _(F.args[0], I);
      if (F.op === "~" && Kt(Q) && Q.isUnary() && Q.op === "~" || F.op === "not" && Kt(Q) && Q.isUnary() && Q.op === "not" && C(Q.args[0]))
        return Q.args[0];
      var ee = !0;
      if (F.op === "-" && Kt(Q) && (Q.isBinary() && Q.fn === "subtract" && (F = new y("-", "subtract", [Q.args[1], Q.args[0]]), ee = !1), Q.isUnary() && Q.op === "-"))
        return Q.args[0];
      if (ee) return new y(F.op, F.fn, [Q]);
    }
    if (Kt(F) && F.isBinary()) {
      var j = _(F.args[0], I), U = _(F.args[1], I);
      if (F.op === "+") {
        if (wt(j) && i(j.value))
          return U;
        if (wt(U) && i(U.value))
          return j;
        Kt(U) && U.isUnary() && U.op === "-" && (U = U.args[0], F = new y("-", "subtract", [j, U]));
      }
      if (F.op === "-")
        return Kt(U) && U.isUnary() && U.op === "-" ? _(new y("+", "add", [j, U.args[0]]), I) : wt(j) && i(j.value) ? _(new y("-", "unaryMinus", [U])) : wt(U) && i(U.value) ? j : new y(F.op, F.fn, [j, U]);
      if (F.op === "*") {
        if (wt(j)) {
          if (i(j.value))
            return x;
          if (n(j.value, 1))
            return U;
        }
        if (wt(U)) {
          if (i(U.value))
            return x;
          if (n(U.value, 1))
            return j;
          if (T(F, B))
            return new y(F.op, F.fn, [U, j], F.implicit);
        }
        return new y(F.op, F.fn, [j, U], F.implicit);
      }
      if (F.op === "/")
        return wt(j) && i(j.value) ? x : wt(U) && n(U.value, 1) ? j : new y(F.op, F.fn, [j, U]);
      if (F.op === "^" && wt(U)) {
        if (i(U.value))
          return N;
        if (n(U.value, 1))
          return j;
      }
      if (F.op === "and") {
        if (wt(j))
          if (j.value) {
            if (C(U)) return U;
            if (wt(U))
              return U.value ? D : b;
          } else
            return b;
        if (wt(U))
          if (U.value) {
            if (C(j)) return j;
          } else
            return b;
      }
      if (F.op === "or") {
        if (wt(j)) {
          if (j.value)
            return D;
          if (C(U)) return U;
        }
        if (wt(U)) {
          if (U.value)
            return D;
          if (C(j)) return j;
        }
      }
      return new y(F.op, F.fn, [j, U]);
    }
    if (Kt(F))
      return new y(F.op, F.fn, F.args.map((te) => _(te, I)));
    if (Wr(F))
      return new l(F.items.map((te) => _(te, I)));
    if (Kn(F))
      return new c(_(F.object, I), _(F.index, I));
    if (bi(F))
      return new g(F.dimensions.map((te) => _(te, I)));
    if (Pa(F)) {
      var pe = {};
      for (var X in F.properties)
        pe[X] = _(F.properties[X], I);
      return new d(pe);
    }
    return F;
  }
  return e(e2, {
    Node: _,
    "Node,Object": _
  });
}), X7 = "resolve", K7 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"], Kf = /* @__PURE__ */ H(X7, K7, (t) => {
  var {
    typed: e,
    parse: r,
    ConstantNode: n,
    FunctionNode: i,
    OperatorNode: a,
    ParenthesisNode: o
  } = t;
  function f(u, s) {
    var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
    if (!s)
      return u;
    if (ir(u)) {
      if (c.has(u.name)) {
        var l = Array.from(c).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(l, "}"));
      }
      var m = s.get(u.name);
      if (Bt(m)) {
        var h = new Set(c);
        return h.add(u.name), f(m, s, h);
      } else return typeof m == "number" ? r(String(m)) : m !== void 0 ? new n(m) : u;
    } else if (Kt(u)) {
      var g = u.args.map(function(y) {
        return f(y, s, c);
      });
      return new a(u.op, u.fn, g, u.implicit);
    } else {
      if (Cn(u))
        return new o(f(u.content, s, c));
      if (Bn(u)) {
        var d = u.args.map(function(y) {
          return f(y, s, c);
        });
        return new i(u.name, d);
      }
    }
    return u.map((y) => f(y, s, c));
  }
  return e("resolve", {
    Node: f,
    "Node, Map | null | undefined": f,
    "Node, Object": (u, s) => f(u, Sa(s)),
    // For arrays and matrices, we map `self` rather than `_resolve`
    // because resolve is fairly expensive anyway, and this way
    // we get nice error messages if one entry in the array has wrong type.
    "Array | Matrix": e.referToSelf((u) => (s) => s.map((c) => u(c))),
    "Array | Matrix, null | undefined": e.referToSelf((u) => (s) => s.map((c) => u(c))),
    "Array, Object": e.referTo("Array,Map", (u) => (s, c) => u(s, Sa(c))),
    "Matrix, Object": e.referTo("Matrix,Map", (u) => (s, c) => u(s, Sa(c))),
    "Array | Matrix, Map": e.referToSelf((u) => (s, c) => s.map((l) => u(l, c)))
  });
}), t2 = "symbolicEqual", eR = ["parse", "simplify", "typed", "OperatorNode"], ep = /* @__PURE__ */ H(t2, eR, (t) => {
  var {
    parse: e,
    simplify: r,
    typed: n,
    OperatorNode: i
  } = t;
  function a(o, f) {
    var u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = new i("-", "subtract", [o, f]), c = r(s, {}, u);
    return wt(c) && !c.value;
  }
  return n(t2, {
    "Node, Node": a,
    "Node, Node, Object": a
  });
}), r2 = "derivative", tR = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"], tp = /* @__PURE__ */ H(r2, tR, (t) => {
  var {
    typed: e,
    config: r,
    parse: n,
    simplify: i,
    equal: a,
    isZero: o,
    numeric: f,
    ConstantNode: u,
    FunctionNode: s,
    OperatorNode: c,
    ParenthesisNode: l,
    SymbolNode: m
  } = t;
  function h(x, N) {
    var D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      simplify: !0
    }, b = {};
    y(b, x, N.name);
    var C = w(x, b);
    return D.simplify ? i(C) : C;
  }
  e.addConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: n
  });
  var g = e(r2, {
    "Node, SymbolNode": h,
    "Node, SymbolNode, Object": h
    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
      let res = expr
      for (let i = 0; i < order; i++) {
        let constNodes = {}
        constTag(constNodes, expr, variable.name)
        res = _derivative(res, constNodes)
      }
      return res
    }
    */
  });
  e.removeConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: n
  }), g._simplify = !0, g.toTex = function(x) {
    return d.apply(null, x.args);
  };
  var d = e("_derivTex", {
    "Node, SymbolNode": function(N, D) {
      return wt(N) && kt(N.value) === "string" ? d(n(N.value).toString(), D.toString(), 1) : d(N.toTex(), D.toString(), 1);
    },
    "Node, ConstantNode": function(N, D) {
      if (kt(D.value) === "string")
        return d(N, n(D.value));
      throw new Error("The second parameter to 'derivative' is a non-string constant");
    },
    "Node, SymbolNode, ConstantNode": function(N, D, b) {
      return d(N.toString(), D.name, b.value);
    },
    "string, string, number": function(N, D, b) {
      var C;
      return b === 1 ? C = "{d\\over d" + D + "}" : C = "{d^{" + b + "}\\over d" + D + "^{" + b + "}}", C + "\\left[".concat(N, "\\right]");
    }
  }), y = e("constTag", {
    "Object, ConstantNode, string": function(N, D) {
      return N[D] = !0, !0;
    },
    "Object, SymbolNode, string": function(N, D, b) {
      return D.name !== b ? (N[D] = !0, !0) : !1;
    },
    "Object, ParenthesisNode, string": function(N, D, b) {
      return y(N, D.content, b);
    },
    "Object, FunctionAssignmentNode, string": function(N, D, b) {
      return D.params.includes(b) ? y(N, D.expr, b) : (N[D] = !0, !0);
    },
    "Object, FunctionNode | OperatorNode, string": function(N, D, b) {
      if (D.args.length > 0) {
        for (var C = y(N, D.args[0], b), A = 1; A < D.args.length; ++A)
          C = y(N, D.args[A], b) && C;
        if (C)
          return N[D] = !0, !0;
      }
      return !1;
    }
  }), w = e("_derivative", {
    "ConstantNode, Object": function(N) {
      return E(0);
    },
    "SymbolNode, Object": function(N, D) {
      return D[N] !== void 0 ? E(0) : E(1);
    },
    "ParenthesisNode, Object": function(N, D) {
      return new l(w(N.content, D));
    },
    "FunctionAssignmentNode, Object": function(N, D) {
      return D[N] !== void 0 ? E(0) : w(N.expr, D);
    },
    "FunctionNode, Object": function(N, D) {
      if (D[N] !== void 0)
        return E(0);
      var b = N.args[0], C, A = !1, T = !1, _;
      switch (N.name) {
        case "cbrt":
          A = !0, _ = new c("*", "multiply", [E(3), new c("^", "pow", [b, new c("/", "divide", [E(2), E(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (N.args.length === 1)
            A = !0, _ = new c("*", "multiply", [E(2), new s("sqrt", [b])]);
          else if (N.args.length === 2)
            return C = new c("/", "divide", [E(1), N.args[1]]), D[C] = D[N.args[1]], w(new c("^", "pow", [b, C]), D);
          break;
        case "log10":
          C = E(10);
        case "log":
          if (!C && N.args.length === 1)
            _ = b.clone(), A = !0;
          else if (N.args.length === 1 && C || N.args.length === 2 && D[N.args[1]] !== void 0)
            _ = new c("*", "multiply", [b.clone(), new s("log", [C || N.args[1]])]), A = !0;
          else if (N.args.length === 2)
            return w(new c("/", "divide", [new s("log", [b]), new s("log", [N.args[1]])]), D);
          break;
        case "pow":
          if (N.args.length === 2)
            return D[C] = D[N.args[1]], w(new c("^", "pow", [b, N.args[1]]), D);
          break;
        case "exp":
          _ = new s("exp", [b.clone()]);
          break;
        case "sin":
          _ = new s("cos", [b.clone()]);
          break;
        case "cos":
          _ = new c("-", "unaryMinus", [new s("sin", [b.clone()])]);
          break;
        case "tan":
          _ = new c("^", "pow", [new s("sec", [b.clone()]), E(2)]);
          break;
        case "sec":
          _ = new c("*", "multiply", [N, new s("tan", [b.clone()])]);
          break;
        case "csc":
          T = !0, _ = new c("*", "multiply", [N, new s("cot", [b.clone()])]);
          break;
        case "cot":
          T = !0, _ = new c("^", "pow", [new s("csc", [b.clone()]), E(2)]);
          break;
        case "asin":
          A = !0, _ = new s("sqrt", [new c("-", "subtract", [E(1), new c("^", "pow", [b.clone(), E(2)])])]);
          break;
        case "acos":
          A = !0, T = !0, _ = new s("sqrt", [new c("-", "subtract", [E(1), new c("^", "pow", [b.clone(), E(2)])])]);
          break;
        case "atan":
          A = !0, _ = new c("+", "add", [new c("^", "pow", [b.clone(), E(2)]), E(1)]);
          break;
        case "asec":
          A = !0, _ = new c("*", "multiply", [new s("abs", [b.clone()]), new s("sqrt", [new c("-", "subtract", [new c("^", "pow", [b.clone(), E(2)]), E(1)])])]);
          break;
        case "acsc":
          A = !0, T = !0, _ = new c("*", "multiply", [new s("abs", [b.clone()]), new s("sqrt", [new c("-", "subtract", [new c("^", "pow", [b.clone(), E(2)]), E(1)])])]);
          break;
        case "acot":
          A = !0, T = !0, _ = new c("+", "add", [new c("^", "pow", [b.clone(), E(2)]), E(1)]);
          break;
        case "sinh":
          _ = new s("cosh", [b.clone()]);
          break;
        case "cosh":
          _ = new s("sinh", [b.clone()]);
          break;
        case "tanh":
          _ = new c("^", "pow", [new s("sech", [b.clone()]), E(2)]);
          break;
        case "sech":
          T = !0, _ = new c("*", "multiply", [N, new s("tanh", [b.clone()])]);
          break;
        case "csch":
          T = !0, _ = new c("*", "multiply", [N, new s("coth", [b.clone()])]);
          break;
        case "coth":
          T = !0, _ = new c("^", "pow", [new s("csch", [b.clone()]), E(2)]);
          break;
        case "asinh":
          A = !0, _ = new s("sqrt", [new c("+", "add", [new c("^", "pow", [b.clone(), E(2)]), E(1)])]);
          break;
        case "acosh":
          A = !0, _ = new s("sqrt", [new c("-", "subtract", [new c("^", "pow", [b.clone(), E(2)]), E(1)])]);
          break;
        case "atanh":
          A = !0, _ = new c("-", "subtract", [E(1), new c("^", "pow", [b.clone(), E(2)])]);
          break;
        case "asech":
          A = !0, T = !0, _ = new c("*", "multiply", [b.clone(), new s("sqrt", [new c("-", "subtract", [E(1), new c("^", "pow", [b.clone(), E(2)])])])]);
          break;
        case "acsch":
          A = !0, T = !0, _ = new c("*", "multiply", [new s("abs", [b.clone()]), new s("sqrt", [new c("+", "add", [new c("^", "pow", [b.clone(), E(2)]), E(1)])])]);
          break;
        case "acoth":
          A = !0, T = !0, _ = new c("-", "subtract", [E(1), new c("^", "pow", [b.clone(), E(2)])]);
          break;
        case "abs":
          _ = new c("/", "divide", [new s(new m("abs"), [b.clone()]), b.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Cannot process function "' + N.name + '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported');
      }
      var O, I;
      A ? (O = "/", I = "divide") : (O = "*", I = "multiply");
      var B = w(b, D);
      return T && (B = new c("-", "unaryMinus", [B])), new c(O, I, [B, _]);
    },
    "OperatorNode, Object": function(N, D) {
      if (D[N] !== void 0)
        return E(0);
      if (N.op === "+")
        return new c(N.op, N.fn, N.args.map(function(L) {
          return w(L, D);
        }));
      if (N.op === "-") {
        if (N.isUnary())
          return new c(N.op, N.fn, [w(N.args[0], D)]);
        if (N.isBinary())
          return new c(N.op, N.fn, [w(N.args[0], D), w(N.args[1], D)]);
      }
      if (N.op === "*") {
        var b = N.args.filter(function(L) {
          return D[L] !== void 0;
        });
        if (b.length > 0) {
          var C = N.args.filter(function(L) {
            return D[L] === void 0;
          }), A = C.length === 1 ? C[0] : new c("*", "multiply", C), T = b.concat(w(A, D));
          return new c("*", "multiply", T);
        }
        return new c("+", "add", N.args.map(function(L) {
          return new c("*", "multiply", N.args.map(function(F) {
            return F === L ? w(F, D) : F.clone();
          }));
        }));
      }
      if (N.op === "/" && N.isBinary()) {
        var _ = N.args[0], O = N.args[1];
        return D[O] !== void 0 ? new c("/", "divide", [w(_, D), O]) : D[_] !== void 0 ? new c("*", "multiply", [new c("-", "unaryMinus", [_]), new c("/", "divide", [w(O, D), new c("^", "pow", [O.clone(), E(2)])])]) : new c("/", "divide", [new c("-", "subtract", [new c("*", "multiply", [w(_, D), O.clone()]), new c("*", "multiply", [_.clone(), w(O, D)])]), new c("^", "pow", [O.clone(), E(2)])]);
      }
      if (N.op === "^" && N.isBinary()) {
        var I = N.args[0], B = N.args[1];
        if (D[I] !== void 0)
          return wt(I) && (o(I.value) || a(I.value, 1)) ? E(0) : new c("*", "multiply", [N, new c("*", "multiply", [new s("log", [I.clone()]), w(B.clone(), D)])]);
        if (D[B] !== void 0) {
          if (wt(B)) {
            if (o(B.value))
              return E(0);
            if (a(B.value, 1))
              return w(I, D);
          }
          var k = new c("^", "pow", [I.clone(), new c("-", "subtract", [B, E(1)])]);
          return new c("*", "multiply", [B.clone(), new c("*", "multiply", [w(I, D), k])]);
        }
        return new c("*", "multiply", [new c("^", "pow", [I.clone(), B.clone()]), new c("+", "add", [new c("*", "multiply", [w(I, D), new c("/", "divide", [B.clone(), I.clone()])]), new c("*", "multiply", [w(B, D), new s("log", [I.clone()])])])]);
      }
      throw new Error('Cannot process operator "' + N.op + '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported');
    }
  });
  function E(x, N) {
    return new u(f(x, wi(String(x), r)));
  }
  return g;
}), n2 = "rationalize", rR = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"], rp = /* @__PURE__ */ H(n2, rR, (t) => {
  var {
    config: e,
    typed: r,
    equal: n,
    isZero: i,
    add: a,
    subtract: o,
    multiply: f,
    divide: u,
    pow: s,
    parse: c,
    simplifyConstant: l,
    simplifyCore: m,
    simplify: h,
    fraction: g,
    bignumber: d,
    mathWithTransform: y,
    matrix: w,
    AccessorNode: E,
    ArrayNode: x,
    ConstantNode: N,
    FunctionNode: D,
    IndexNode: b,
    ObjectNode: C,
    OperatorNode: A,
    SymbolNode: T,
    ParenthesisNode: _
  } = t;
  function O(F) {
    var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, R = B(), Q = I(F, M, !0, R.firstRules), ee = Q.variables.length, j = {
      exactFractions: !1
    }, U = {
      exactFractions: !0
    };
    if (F = Q.expression, ee >= 1) {
      F = k(F);
      var pe, X, te = !0, ue = !1;
      F = h(F, R.firstRules, {}, j);
      for (var ce; X = te ? R.distrDivRules : R.sucDivRules, F = h(F, X, {}, U), te = !te, ce = F.toString(), ce !== pe; )
        ue = !0, pe = ce;
      ue && (F = h(F, R.firstRulesAgain, {}, j)), F = h(F, R.finalRules, {}, j);
    }
    var se = [], he = {};
    return F.type === "OperatorNode" && F.isBinary() && F.op === "/" ? (ee === 1 && (F.args[0] = L(F.args[0], se), F.args[1] = L(F.args[1])), $ && (he.numerator = F.args[0], he.denominator = F.args[1])) : (ee === 1 && (F = L(F, se)), $ && (he.numerator = F, he.denominator = null)), $ ? (he.coefficients = se, he.variables = Q.variables, he.expression = F, he) : F;
  }
  return r(n2, {
    Node: O,
    "Node, boolean": (F, M) => O(F, {}, M),
    "Node, Object": O,
    "Node, Object, boolean": O
  });
  function I(F, M, $, R) {
    var Q = [], ee = h(F, R, M, {
      exactFractions: !1
    });
    $ = !!$;
    var j = "+-*" + ($ ? "/" : "");
    pe(ee);
    var U = {};
    return U.expression = ee, U.variables = Q, U;
    function pe(X) {
      var te = X.type;
      if (te === "FunctionNode")
        throw new Error("There is an unsolved function call");
      if (te === "OperatorNode")
        if (X.op === "^") {
          if (X.args[1].type !== "ConstantNode" || !Ve(parseFloat(X.args[1].value)))
            throw new Error("There is a non-integer exponent");
          pe(X.args[0]);
        } else {
          if (!j.includes(X.op))
            throw new Error("Operator " + X.op + " invalid in polynomial expression");
          for (var ue = 0; ue < X.args.length; ue++)
            pe(X.args[ue]);
        }
      else if (te === "SymbolNode") {
        var ce = X.name, se = Q.indexOf(ce);
        se === -1 && Q.push(ce);
      } else if (te === "ParenthesisNode")
        pe(X.content);
      else if (te !== "ConstantNode")
        throw new Error("type " + te + " is not allowed in polynomial expression");
    }
  }
  function B() {
    var F = [
      m,
      // sCore
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      l,
      // sConstant
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ], M = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      // Unary division
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      // Unary multiplication
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      // '--' elimination
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      // Subtraction turn into add with un�ry minus
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      // Distributive 1
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      // Distributive 2
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      // Joining constants
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      // Joining constants
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      // Joining constants
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      // Joining constants
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "-v*-c",
        r: "c*v"
      },
      // Inversion constant and variable 1
      {
        l: "-v*c",
        r: "-c*v"
      },
      // Inversion constant and variable 2
      {
        l: "v*-c",
        r: "-c*v"
      },
      // Inversion constant and variable 3
      {
        l: "v*c",
        r: "c*v"
      },
      // Inversion constant and variable 4
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      // Unary propagation
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      // Unary propagation
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      // Unary propagation
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      // Unary propagation
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      // Power to Power
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      // Division and Unary
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ], $ = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      // Sum of fractions
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      // Sum fraction with number 1
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ], R = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      // Division simplification
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ], Q = {};
    return Q.firstRules = F.concat(M, R), Q.distrDivRules = $, Q.sucDivRules = R, Q.firstRulesAgain = F.concat(M), Q.finalRules = [
      m,
      // simplify.rules[0]
      {
        l: "n*-n",
        r: "-n^2"
      },
      // Joining multiply with power 1
      {
        l: "n*n",
        r: "n^2"
      },
      // Joining multiply with power 2
      l,
      // simplify.rules[14] old 3rd index in oldRules
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 3
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 4
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      // Joining multiply with power 5
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      // Joining multiply with power 6
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 7
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      // Joining division with power 1
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      // Joining division with power 2
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      // Joining division with power 3
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 4
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 5
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      // Solving useless parenthesis 1
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      // Solving useless unary 2
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      // Solving +- together (new!)
      {
        l: "v*c",
        r: "c*v"
      },
      // inversion constant with variable
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
      // Power to Power
    ], Q;
  }
  function k(F, M, $) {
    var R = F.type, Q = arguments.length > 1;
    if (R === "OperatorNode" && F.isBinary()) {
      var ee = !1, j;
      if (F.op === "^" && (F.args[0].type === "ParenthesisNode" || F.args[0].type === "OperatorNode") && F.args[1].type === "ConstantNode" && (j = parseFloat(F.args[1].value), ee = j >= 2 && Ve(j)), ee) {
        if (j > 2) {
          var U = F.args[0], pe = new A("^", "pow", [F.args[0].cloneDeep(), new N(j - 1)]);
          F = new A("*", "multiply", [U, pe]);
        } else
          F = new A("*", "multiply", [F.args[0], F.args[0].cloneDeep()]);
        Q && ($ === "content" ? M.content = F : M.args[$] = F);
      }
    }
    if (R === "ParenthesisNode")
      k(F.content, F, "content");
    else if (R !== "ConstantNode" && R !== "SymbolNode")
      for (var X = 0; X < F.args.length; X++)
        k(F.args[X], F, X);
    if (!Q)
      return F;
  }
  function L(F, M) {
    M === void 0 && (M = []), M[0] = 0;
    var $ = {};
    $.cte = 1, $.oper = "+", $.fire = "";
    var R = 0, Q = "";
    ce(F, null, $), R = M.length - 1;
    for (var ee = !0, j, U = R; U >= 0; U--)
      if (M[U] !== 0) {
        var pe = new N(ee ? M[U] : Math.abs(M[U])), X = M[U] < 0 ? "-" : "+";
        if (U > 0) {
          var te = new T(Q);
          if (U > 1) {
            var ue = new N(U);
            te = new A("^", "pow", [te, ue]);
          }
          M[U] === -1 && ee ? pe = new A("-", "unaryMinus", [te]) : Math.abs(M[U]) === 1 ? pe = te : pe = new A("*", "multiply", [pe, te]);
        }
        ee ? j = pe : X === "+" ? j = new A("+", "add", [j, pe]) : j = new A("-", "subtract", [j, pe]), ee = !1;
      }
    if (ee)
      return new N(0);
    return j;
    function ce(se, he, le) {
      var ve = se.type;
      if (ve === "FunctionNode")
        throw new Error("There is an unsolved function call");
      if (ve === "OperatorNode") {
        if (!"+-*^".includes(se.op)) throw new Error("Operator " + se.op + " invalid");
        if (he !== null) {
          if ((se.fn === "unaryMinus" || se.fn === "pow") && he.fn !== "add" && he.fn !== "subtract" && he.fn !== "multiply")
            throw new Error("Invalid " + se.op + " placing");
          if ((se.fn === "subtract" || se.fn === "add" || se.fn === "multiply") && he.fn !== "add" && he.fn !== "subtract")
            throw new Error("Invalid " + se.op + " placing");
          if ((se.fn === "subtract" || se.fn === "add" || se.fn === "unaryMinus") && le.noFil !== 0)
            throw new Error("Invalid " + se.op + " placing");
        }
        (se.op === "^" || se.op === "*") && (le.fire = se.op);
        for (var Ee = 0; Ee < se.args.length; Ee++)
          se.fn === "unaryMinus" && (le.oper = "-"), (se.op === "+" || se.fn === "subtract") && (le.fire = "", le.cte = 1, le.oper = Ee === 0 ? "+" : se.op), le.noFil = Ee, ce(se.args[Ee], se, le);
      } else if (ve === "SymbolNode") {
        if (se.name !== Q && Q !== "")
          throw new Error("There is more than one variable");
        if (Q = se.name, he === null) {
          M[1] = 1;
          return;
        }
        if (he.op === "^" && le.noFil !== 0)
          throw new Error("In power the variable should be the first parameter");
        if (he.op === "*" && le.noFil !== 1)
          throw new Error("In multiply the variable should be the second parameter");
        (le.fire === "" || le.fire === "*") && (R < 1 && (M[1] = 0), M[1] += le.cte * (le.oper === "+" ? 1 : -1), R = Math.max(1, R));
      } else if (ve === "ConstantNode") {
        var _e = parseFloat(se.value);
        if (he === null) {
          M[0] = _e;
          return;
        }
        if (he.op === "^") {
          if (le.noFil !== 1) throw new Error("Constant cannot be powered");
          if (!Ve(_e) || _e <= 0)
            throw new Error("Non-integer exponent is not allowed");
          for (var V = R + 1; V < _e; V++) M[V] = 0;
          _e > R && (M[_e] = 0), M[_e] += le.cte * (le.oper === "+" ? 1 : -1), R = Math.max(_e, R);
          return;
        }
        le.cte = _e, le.fire === "" && (M[0] += le.cte * (le.oper === "+" ? 1 : -1));
      } else
        throw new Error("Type " + ve + " is not allowed");
    }
  }
}), i2 = "zpk2tf", nR = ["typed", "add", "multiply", "Complex", "number"], np = /* @__PURE__ */ H(i2, nR, (t) => {
  var {
    typed: e,
    add: r,
    multiply: n,
    Complex: i,
    number: a
  } = t;
  return e(i2, {
    "Array,Array,number": function(s, c, l) {
      return o(s, c, l);
    },
    "Array,Array": function(s, c) {
      return o(s, c, 1);
    },
    "Matrix,Matrix,number": function(s, c, l) {
      return o(s.valueOf(), c.valueOf(), l);
    },
    "Matrix,Matrix": function(s, c) {
      return o(s.valueOf(), c.valueOf(), 1);
    }
  });
  function o(u, s, c) {
    u.some((E) => E.type === "BigNumber") && (u = u.map((E) => a(E))), s.some((E) => E.type === "BigNumber") && (s = s.map((E) => a(E)));
    for (var l = [i(1, 0)], m = [i(1, 0)], h = 0; h < u.length; h++) {
      var g = u[h];
      typeof g == "number" && (g = i(g, 0)), l = f(l, [i(1, 0), i(-g.re, -g.im)]);
    }
    for (var d = 0; d < s.length; d++) {
      var y = s[d];
      typeof y == "number" && (y = i(y, 0)), m = f(m, [i(1, 0), i(-y.re, -y.im)]);
    }
    for (var w = 0; w < l.length; w++)
      l[w] = n(l[w], c);
    return [l, m];
  }
  function f(u, s) {
    for (var c = [], l = 0; l < u.length + s.length - 1; l++) {
      c[l] = i(0, 0);
      for (var m = 0; m < u.length; m++)
        l - m >= 0 && l - m < s.length && (c[l] = r(c[l], n(u[m], s[l - m])));
    }
    return c;
  }
}), a2 = "freqz", iR = ["typed", "add", "multiply", "Complex", "divide", "matrix"], ip = /* @__PURE__ */ H(a2, iR, (t) => {
  var {
    typed: e,
    add: r,
    multiply: n,
    Complex: i,
    divide: a,
    matrix: o
  } = t;
  return e(a2, {
    "Array, Array": function(c, l) {
      var m = u(512);
      return f(c, l, m);
    },
    "Array, Array, Array": function(c, l, m) {
      return f(c, l, m);
    },
    "Array, Array, number": function(c, l, m) {
      if (m < 0)
        throw new Error("w must be a positive number");
      var h = u(m);
      return f(c, l, h);
    },
    "Matrix, Matrix": function(c, l) {
      var m = u(512), {
        w: h,
        h: g
      } = f(c.valueOf(), l.valueOf(), m);
      return {
        w: o(h),
        h: o(g)
      };
    },
    "Matrix, Matrix, Matrix": function(c, l, m) {
      var {
        h
      } = f(c.valueOf(), l.valueOf(), m.valueOf());
      return {
        h: o(h),
        w: o(m)
      };
    },
    "Matrix, Matrix, number": function(c, l, m) {
      if (m < 0)
        throw new Error("w must be a positive number");
      var h = u(m), {
        h: g
      } = f(c.valueOf(), l.valueOf(), h);
      return {
        h: o(g),
        w: o(h)
      };
    }
  });
  function f(s, c, l) {
    for (var m = [], h = [], g = 0; g < l.length; g++) {
      for (var d = i(0, 0), y = i(0, 0), w = 0; w < s.length; w++)
        d = r(d, n(s[w], i(Math.cos(-w * l[g]), Math.sin(-w * l[g]))));
      for (var E = 0; E < c.length; E++)
        y = r(y, n(c[E], i(Math.cos(-E * l[g]), Math.sin(-E * l[g]))));
      m.push(d), h.push(y);
    }
    for (var x = [], N = 0; N < m.length; N++)
      x.push(a(m[N], h[N]));
    return {
      h: x,
      w: l
    };
  }
  function u(s) {
    for (var c = [], l = 0; l < s; l++)
      c.push(l / s * Math.PI);
    return c;
  }
}), aR = "reviver", sR = ["classes"], ap = /* @__PURE__ */ H(aR, sR, (t) => {
  var {
    classes: e
  } = t;
  return function(n, i) {
    var a = e[i && i.mathjs];
    return a && typeof a.fromJSON == "function" ? a.fromJSON(i) : i;
  };
}), oR = "replacer", uR = [], sp = /* @__PURE__ */ H(oR, uR, () => function(e, r) {
  return typeof r == "number" && (!isFinite(r) || isNaN(r)) ? {
    mathjs: "number",
    value: String(r)
  } : typeof r == "bigint" ? {
    mathjs: "bigint",
    value: String(r)
  } : r;
}), lR = "13.0.0", op = /* @__PURE__ */ H("true", [], () => !0), up = /* @__PURE__ */ H("false", [], () => !1), lp = /* @__PURE__ */ H("null", [], () => null), cp = /* @__PURE__ */ an("Infinity", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(1 / 0) : 1 / 0;
}), fp = /* @__PURE__ */ an("NaN", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(NaN) : NaN;
}), pp = /* @__PURE__ */ an("pi", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? Id(r) : QT;
}), mp = /* @__PURE__ */ an("tau", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? aq(r) : VT;
}), hp = /* @__PURE__ */ an("e", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? nq(r) : WT;
}), dp = /* @__PURE__ */ an("phi", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? iq(r) : jT;
}), gp = /* @__PURE__ */ an("LN2", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(2).ln() : Math.LN2;
}), vp = /* @__PURE__ */ an("LN10", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(10).ln() : Math.LN10;
}), yp = /* @__PURE__ */ an("LOG2E", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(1).div(new r(2).ln()) : Math.LOG2E;
}), xp = /* @__PURE__ */ an("LOG10E", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(1).div(new r(10).ln()) : Math.LOG10E;
}), bp = /* @__PURE__ */ an(
  // eslint-disable-line camelcase
  "SQRT1_2",
  ["config", "?BigNumber"],
  (t) => {
    var {
      config: e,
      BigNumber: r
    } = t;
    return e.number === "BigNumber" ? new r("0.5").sqrt() : Math.SQRT1_2;
  }
), wp = /* @__PURE__ */ an("SQRT2", ["config", "?BigNumber"], (t) => {
  var {
    config: e,
    BigNumber: r
  } = t;
  return e.number === "BigNumber" ? new r(2).sqrt() : Math.SQRT2;
}), Np = /* @__PURE__ */ an("i", ["Complex"], (t) => {
  var {
    Complex: e
  } = t;
  return e.I;
}), Ud = /* @__PURE__ */ H("PI", ["pi"], (t) => {
  var {
    pi: e
  } = t;
  return e;
}), Gd = /* @__PURE__ */ H("E", ["e"], (t) => {
  var {
    e
  } = t;
  return e;
}), Dp = /* @__PURE__ */ H("version", [], () => lR);
function an(t, e, r) {
  return H(t, e, r, {
    recreateOnConfigChange: !0
  });
}
var Ep = /* @__PURE__ */ lt("speedOfLight", "299792458", "m s^-1"), Sp = /* @__PURE__ */ lt("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2"), Ap = /* @__PURE__ */ lt("planckConstant", "6.62607015e-34", "J s"), Cp = /* @__PURE__ */ lt("reducedPlanckConstant", "1.0545718176461565e-34", "J s"), Tp = /* @__PURE__ */ lt("magneticConstant", "1.25663706212e-6", "N A^-2"), _p = /* @__PURE__ */ lt("electricConstant", "8.8541878128e-12", "F m^-1"), Mp = /* @__PURE__ */ lt("vacuumImpedance", "376.730313667", "ohm"), Op = /* @__PURE__ */ lt("coulomb", "8.987551792261171e9", "N m^2 C^-2"), qp = /* @__PURE__ */ lt("elementaryCharge", "1.602176634e-19", "C"), Ip = /* @__PURE__ */ lt("bohrMagneton", "9.2740100783e-24", "J T^-1"), Fp = /* @__PURE__ */ lt("conductanceQuantum", "7.748091729863649e-5", "S"), Bp = /* @__PURE__ */ lt("inverseConductanceQuantum", "12906.403729652257", "ohm"), Rp = /* @__PURE__ */ lt("magneticFluxQuantum", "2.0678338484619295e-15", "Wb"), Pp = /* @__PURE__ */ lt("nuclearMagneton", "5.0507837461e-27", "J T^-1"), Lp = /* @__PURE__ */ lt("klitzing", "25812.807459304513", "ohm"), kp = /* @__PURE__ */ lt("bohrRadius", "5.29177210903e-11", "m"), zp = /* @__PURE__ */ lt("classicalElectronRadius", "2.8179403262e-15", "m"), $p = /* @__PURE__ */ lt("electronMass", "9.1093837015e-31", "kg"), Up = /* @__PURE__ */ lt("fermiCoupling", "1.1663787e-5", "GeV^-2"), Gp = bm("fineStructure", 0.0072973525693), Hp = /* @__PURE__ */ lt("hartreeEnergy", "4.3597447222071e-18", "J"), Qp = /* @__PURE__ */ lt("protonMass", "1.67262192369e-27", "kg"), Vp = /* @__PURE__ */ lt("deuteronMass", "3.3435830926e-27", "kg"), Wp = /* @__PURE__ */ lt("neutronMass", "1.6749271613e-27", "kg"), jp = /* @__PURE__ */ lt("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1"), Yp = /* @__PURE__ */ lt("rydberg", "10973731.568160", "m^-1"), Zp = /* @__PURE__ */ lt("thomsonCrossSection", "6.6524587321e-29", "m^2"), Jp = bm("weakMixingAngle", 0.2229), Xp = bm("efimovFactor", 22.7), Kp = /* @__PURE__ */ lt("atomicMass", "1.66053906660e-27", "kg"), em = /* @__PURE__ */ lt("avogadro", "6.02214076e23", "mol^-1"), tm = /* @__PURE__ */ lt("boltzmann", "1.380649e-23", "J K^-1"), rm = /* @__PURE__ */ lt("faraday", "96485.33212331001", "C mol^-1"), nm = /* @__PURE__ */ lt("firstRadiation", "3.7417718521927573e-16", "W m^2"), im = /* @__PURE__ */ lt("loschmidt", "2.686780111798444e25", "m^-3"), am = /* @__PURE__ */ lt("gasConstant", "8.31446261815324", "J K^-1 mol^-1"), sm = /* @__PURE__ */ lt("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1"), om = /* @__PURE__ */ lt("molarVolume", "0.022413969545014137", "m^3 mol^-1"), um = bm("sackurTetrode", -1.16487052358), lm = /* @__PURE__ */ lt("secondRadiation", "0.014387768775039337", "m K"), cm = /* @__PURE__ */ lt("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4"), fm = /* @__PURE__ */ lt("wienDisplacement", "2.897771955e-3", "m K"), pm = /* @__PURE__ */ lt("molarMass", "0.99999999965e-3", "kg mol^-1"), mm = /* @__PURE__ */ lt("molarMassC12", "11.9999999958e-3", "kg mol^-1"), hm = /* @__PURE__ */ lt("gravity", "9.80665", "m s^-2"), dm = /* @__PURE__ */ lt("planckLength", "1.616255e-35", "m"), gm = /* @__PURE__ */ lt("planckMass", "2.176435e-8", "kg"), vm = /* @__PURE__ */ lt("planckTime", "5.391245e-44", "s"), ym = /* @__PURE__ */ lt("planckCharge", "1.87554603778e-18", "C"), xm = /* @__PURE__ */ lt("planckTemperature", "1.416785e+32", "K");
function lt(t, e, r) {
  var n = ["config", "Unit", "BigNumber"];
  return H(t, n, (i) => {
    var {
      config: a,
      Unit: o,
      BigNumber: f
    } = i, u = a.number === "BigNumber" ? new f(e) : parseFloat(e), s = new o(u, r);
    return s.fixPrefix = !0, s;
  });
}
function bm(t, e) {
  var r = ["config", "BigNumber"];
  return H(t, r, (n) => {
    var {
      config: i,
      BigNumber: a
    } = n;
    return i.number === "BigNumber" ? new a(e) : e;
  });
}
var cR = "apply", fR = ["typed", "isInteger"], wm = /* @__PURE__ */ H(cR, fR, (t) => {
  var {
    typed: e,
    isInteger: r
  } = t, n = Ua({
    typed: e,
    isInteger: r
  });
  return e("apply", {
    "...any": function(a) {
      var o = a[1];
      ot(o) ? a[1] = o - 1 : at(o) && (a[1] = o.minus(1));
      try {
        return n.apply(null, a);
      } catch (f) {
        throw Gr(f);
      }
    }
  });
}, {
  isTransformFunction: !0
}), pR = "column", mR = ["typed", "Index", "matrix", "range"], Nm = /* @__PURE__ */ H(pR, mR, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: i
  } = t, a = zs({
    typed: e,
    Index: r,
    matrix: n,
    range: i
  });
  return e("column", {
    "...any": function(f) {
      var u = f.length - 1, s = f[u];
      ot(s) && (f[u] = s - 1);
      try {
        return a.apply(null, f);
      } catch (c) {
        throw Gr(c);
      }
    }
  });
}, {
  isTransformFunction: !0
});
function Hd(t, e, r) {
  var n = t.filter(function(u) {
    return ir(u) && !(u.name in e) && !r.has(u.name);
  })[0];
  if (!n)
    throw new Error('No undefined variable found in inline expression "' + t + '"');
  var i = n.name, a = /* @__PURE__ */ new Map(), o = new E2(r, a, /* @__PURE__ */ new Set([i])), f = t.compile();
  return function(s) {
    return a.set(i, s), f.evaluate(o);
  };
}
var hR = "filter", dR = ["typed"], Dm = /* @__PURE__ */ H(hR, dR, (t) => {
  var {
    typed: e
  } = t;
  function r(i, a, o) {
    var f, u;
    return i[0] && (f = i[0].compile().evaluate(o)), i[1] && (ir(i[1]) || Xi(i[1]) ? u = i[1].compile().evaluate(o) : u = Hd(i[1], a, o)), n(f, u);
  }
  r.rawArgs = !0;
  var n = e("filter", {
    "Array, function": s2,
    "Matrix, function": function(a, o) {
      return a.create(s2(a.toArray(), o));
    },
    "Array, RegExp": Jo,
    "Matrix, RegExp": function(a, o) {
      return a.create(Jo(a.toArray(), o));
    }
  });
  return r;
}, {
  isTransformFunction: !0
});
function s2(t, e) {
  return V2(t, function(r, n, i) {
    return Ga(e, r, [n + 1], i, "filter");
  });
}
var gR = "forEach", vR = ["typed"], Em = /* @__PURE__ */ H(gR, vR, (t) => {
  var {
    typed: e
  } = t;
  function r(i, a, o) {
    var f, u;
    return i[0] && (f = i[0].compile().evaluate(o)), i[1] && (ir(i[1]) || Xi(i[1]) ? u = i[1].compile().evaluate(o) : u = Hd(i[1], a, o)), n(f, u);
  }
  r.rawArgs = !0;
  var n = e("forEach", {
    "Array | Matrix, function": function(a, o) {
      var f = function u(s, c) {
        if (Array.isArray(s))
          Ou(s, function(l, m) {
            u(l, c.concat(m + 1));
          });
        else
          return Ga(o, s, c, a, "forEach");
      };
      f(a.valueOf(), []);
    }
  });
  return r;
}, {
  isTransformFunction: !0
}), yR = "index", xR = ["Index", "getMatrixDataType"], Sm = /* @__PURE__ */ H(yR, xR, (t) => {
  var {
    Index: e,
    getMatrixDataType: r
  } = t;
  return function() {
    for (var i = [], a = 0, o = arguments.length; a < o; a++) {
      var f = arguments[a];
      if (Ms(f))
        f.start--, f.end -= f.step > 0 ? 0 : 2;
      else if (f && f.isSet === !0)
        f = f.map(function(s) {
          return s - 1;
        });
      else if (_t(f) || Ye(f))
        r(f) !== "boolean" && (f = f.map(function(s) {
          return s - 1;
        }));
      else if (ot(f))
        f--;
      else if (at(f))
        f = f.toNumber() - 1;
      else if (typeof f != "string") throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      i[a] = f;
    }
    var u = new e();
    return e.apply(u, i), u;
  };
}, {
  isTransformFunction: !0
}), bR = "map", wR = ["typed"], Am = /* @__PURE__ */ H(bR, wR, (t) => {
  var {
    typed: e
  } = t;
  function r(i, a, o) {
    var f, u;
    return i[0] && (f = i[0].compile().evaluate(o)), i[1] && (ir(i[1]) || Xi(i[1]) ? u = i[1].compile().evaluate(o) : u = Hd(i[1], a, o)), n(f, u);
  }
  r.rawArgs = !0;
  var n = e("map", {
    "Array, function": function(a, o) {
      return o2(a, o, a);
    },
    "Matrix, function": function(a, o) {
      return a.create(o2(a.valueOf(), o, a));
    }
  });
  return r;
}, {
  isTransformFunction: !0
});
function o2(t, e, r) {
  function n(i, a) {
    return Array.isArray(i) ? Xn(i, function(o, f) {
      return n(o, a.concat(f + 1));
    }) : Ga(e, i, a, r, "map");
  }
  return n(t, []);
}
function Ei(t) {
  if (t.length === 2 && Yr(t[0])) {
    t = t.slice();
    var e = t[1];
    ot(e) ? t[1] = e - 1 : at(e) && (t[1] = e.minus(1));
  }
  return t;
}
var NR = "max", DR = ["typed", "config", "numeric", "larger"], Cm = /* @__PURE__ */ H(NR, DR, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    larger: i
  } = t, a = js({
    typed: e,
    config: r,
    numeric: n,
    larger: i
  });
  return e("max", {
    "...any": function(f) {
      f = Ei(f);
      try {
        return a.apply(null, f);
      } catch (u) {
        throw Gr(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), ER = "mean", SR = ["typed", "add", "divide"], Tm = /* @__PURE__ */ H(ER, SR, (t) => {
  var {
    typed: e,
    add: r,
    divide: n
  } = t, i = Xs({
    typed: e,
    add: r,
    divide: n
  });
  return e("mean", {
    "...any": function(o) {
      o = Ei(o);
      try {
        return i.apply(null, o);
      } catch (f) {
        throw Gr(f);
      }
    }
  });
}, {
  isTransformFunction: !0
}), AR = "min", CR = ["typed", "config", "numeric", "smaller"], _m = /* @__PURE__ */ H(AR, CR, (t) => {
  var {
    typed: e,
    config: r,
    numeric: n,
    smaller: i
  } = t, a = Ys({
    typed: e,
    config: r,
    numeric: n,
    smaller: i
  });
  return e("min", {
    "...any": function(f) {
      f = Ei(f);
      try {
        return a.apply(null, f);
      } catch (u) {
        throw Gr(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), TR = "range", _R = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"], Mm = /* @__PURE__ */ H(TR, _R, (t) => {
  var {
    typed: e,
    config: r,
    matrix: n,
    bignumber: i,
    smaller: a,
    smallerEq: o,
    larger: f,
    largerEq: u,
    add: s,
    isPositive: c
  } = t, l = Us({
    typed: e,
    config: r,
    matrix: n,
    bignumber: i,
    smaller: a,
    smallerEq: o,
    larger: f,
    largerEq: u,
    add: s,
    isPositive: c
  });
  return e("range", {
    "...any": function(h) {
      var g = h.length - 1, d = h[g];
      return typeof d != "boolean" && h.push(!0), l.apply(null, h);
    }
  });
}, {
  isTransformFunction: !0
}), MR = "row", OR = ["typed", "Index", "matrix", "range"], Om = /* @__PURE__ */ H(MR, OR, (t) => {
  var {
    typed: e,
    Index: r,
    matrix: n,
    range: i
  } = t, a = Gs({
    typed: e,
    Index: r,
    matrix: n,
    range: i
  });
  return e("row", {
    "...any": function(f) {
      var u = f.length - 1, s = f[u];
      ot(s) && (f[u] = s - 1);
      try {
        return a.apply(null, f);
      } catch (c) {
        throw Gr(c);
      }
    }
  });
}, {
  isTransformFunction: !0
}), qR = "subset", IR = ["typed", "matrix", "zeros", "add"], qm = /* @__PURE__ */ H(qR, IR, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    add: i
  } = t, a = Hs({
    typed: e,
    matrix: r,
    zeros: n,
    add: i
  });
  return e("subset", {
    "...any": function(f) {
      try {
        return a.apply(null, f);
      } catch (u) {
        throw Gr(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), FR = "concat", BR = ["typed", "matrix", "isInteger"], Im = /* @__PURE__ */ H(FR, BR, (t) => {
  var {
    typed: e,
    matrix: r,
    isInteger: n
  } = t, i = ks({
    typed: e,
    matrix: r,
    isInteger: n
  });
  return e("concat", {
    "...any": function(o) {
      var f = o.length - 1, u = o[f];
      ot(u) ? o[f] = u - 1 : at(u) && (o[f] = u.minus(1));
      try {
        return i.apply(null, o);
      } catch (s) {
        throw Gr(s);
      }
    }
  });
}, {
  isTransformFunction: !0
}), u2 = "diff", RR = ["typed", "matrix", "subtract", "number", "bignumber"], Fm = /* @__PURE__ */ H(u2, RR, (t) => {
  var {
    typed: e,
    matrix: r,
    subtract: n,
    number: i,
    bignumber: a
  } = t, o = $s({
    typed: e,
    matrix: r,
    subtract: n,
    number: i,
    bignumber: a
  });
  return e(u2, {
    "...any": function(u) {
      u = Ei(u);
      try {
        return o.apply(null, u);
      } catch (s) {
        throw Gr(s);
      }
    }
  });
}, {
  isTransformFunction: !0
}), PR = "std", LR = ["typed", "map", "sqrt", "variance"], Bm = /* @__PURE__ */ H(PR, LR, (t) => {
  var {
    typed: e,
    map: r,
    sqrt: n,
    variance: i
  } = t, a = to({
    typed: e,
    map: r,
    sqrt: n,
    variance: i
  });
  return e("std", {
    "...any": function(f) {
      f = Ei(f);
      try {
        return a.apply(null, f);
      } catch (u) {
        throw Gr(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), l2 = "sum", kR = ["typed", "config", "add", "numeric"], Rm = /* @__PURE__ */ H(l2, kR, (t) => {
  var {
    typed: e,
    config: r,
    add: n,
    numeric: i
  } = t, a = Zs({
    typed: e,
    config: r,
    add: n,
    numeric: i
  });
  return e(l2, {
    "...any": function(f) {
      f = Ei(f);
      try {
        return a.apply(null, f);
      } catch (u) {
        throw Gr(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), zR = "quantileSeq", $R = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"], Pm = /* @__PURE__ */ H(zR, $R, (t) => {
  var {
    typed: e,
    bignumber: r,
    add: n,
    subtract: i,
    divide: a,
    multiply: o,
    partitionSelect: f,
    compare: u,
    isInteger: s,
    smaller: c,
    smallerEq: l,
    larger: m
  } = t, h = eo({
    typed: e,
    bignumber: r,
    add: n,
    subtract: i,
    divide: a,
    multiply: o,
    partitionSelect: f,
    compare: u,
    isInteger: s,
    smaller: c,
    smallerEq: l,
    larger: m
  });
  return e("quantileSeq", {
    "Array | Matrix, number | BigNumber": h,
    "Array | Matrix, number | BigNumber, number": (d, y, w) => h(d, y, g(w)),
    "Array | Matrix, number | BigNumber, boolean": h,
    "Array | Matrix, number | BigNumber, boolean, number": (d, y, w, E) => h(d, y, w, g(E)),
    "Array | Matrix, Array | Matrix": h,
    "Array | Matrix, Array | Matrix, number": (d, y, w) => h(d, y, g(w)),
    "Array | Matrix, Array | Matrix, boolean": h,
    "Array | Matrix, Array | Matrix, boolean, number": (d, y, w, E) => h(d, y, w, g(E))
  });
  function g(d) {
    return Ei([[], d])[1];
  }
}, {
  isTransformFunction: !0
}), c2 = "cumsum", UR = ["typed", "add", "unaryPlus"], Lm = /* @__PURE__ */ H(c2, UR, (t) => {
  var {
    typed: e,
    add: r,
    unaryPlus: n
  } = t, i = Js({
    typed: e,
    add: r,
    unaryPlus: n
  });
  return e(c2, {
    "...any": function(o) {
      if (o.length === 2 && Yr(o[0])) {
        var f = o[1];
        ot(f) ? o[1] = f - 1 : at(f) && (o[1] = f.minus(1));
      }
      try {
        return i.apply(null, o);
      } catch (u) {
        throw Gr(u);
      }
    }
  });
}, {
  isTransformFunction: !0
}), f2 = "variance", GR = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"], km = /* @__PURE__ */ H(f2, GR, (t) => {
  var {
    typed: e,
    add: r,
    subtract: n,
    multiply: i,
    divide: a,
    apply: o,
    isNaN: f
  } = t, u = Ks({
    typed: e,
    add: r,
    subtract: n,
    multiply: i,
    divide: a,
    apply: o,
    isNaN: f
  });
  return e(f2, {
    "...any": function(c) {
      c = Ei(c);
      try {
        return u.apply(null, c);
      } catch (l) {
        throw Gr(l);
      }
    }
  });
}, {
  isTransformFunction: !0
}), p2 = "print", HR = ["typed", "matrix", "zeros", "add"], zm = /* @__PURE__ */ H(p2, HR, (t) => {
  var {
    typed: e,
    matrix: r,
    zeros: n,
    add: i
  } = t, a = Qs({
    typed: e,
    matrix: r,
    zeros: n,
    add: i
  });
  return e(p2, {
    "string, Object | Array": function(u, s) {
      return a(o(u), s);
    },
    "string, Object | Array, number | Object": function(u, s, c) {
      return a(o(u), s, c);
    }
  });
  function o(f) {
    return f.replace(Qw, (u) => {
      var s = u.slice(1).split("."), c = s.map(function(l) {
        return !isNaN(l) && l.length > 0 ? parseInt(l) - 1 : l;
      });
      return "$" + c.join(".");
    });
  }
}, {
  isTransformFunction: !0
}), QR = "and", VR = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"], $m = /* @__PURE__ */ H(QR, VR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    not: a,
    concat: o
  } = t, f = Ws({
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    not: a,
    concat: o
  });
  function u(s, c, l) {
    var m = s[0].compile().evaluate(l);
    if (!Yr(m) && !f(m, !0))
      return !1;
    var h = s[1].compile().evaluate(l);
    return f(m, h);
  }
  return u.rawArgs = !0, u;
}, {
  isTransformFunction: !0
}), WR = "or", jR = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Um = /* @__PURE__ */ H(WR, jR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ls({
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: i,
    concat: a
  });
  function f(u, s, c) {
    var l = u[0].compile().evaluate(c);
    if (!Yr(l) && o(l, !1))
      return !0;
    var m = u[1].compile().evaluate(c);
    return o(l, m);
  }
  return f.rawArgs = !0, f;
}, {
  isTransformFunction: !0
}), YR = "bitAnd", ZR = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"], Gm = /* @__PURE__ */ H(YR, ZR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    not: a,
    concat: o
  } = t, f = Rs({
    typed: e,
    matrix: r,
    equalScalar: n,
    zeros: i,
    not: a,
    concat: o
  });
  function u(s, c, l) {
    var m = s[0].compile().evaluate(l);
    if (!Yr(m)) {
      if (isNaN(m))
        return NaN;
      if (m === 0 || m === !1)
        return 0;
    }
    var h = s[1].compile().evaluate(l);
    return f(m, h);
  }
  return u.rawArgs = !0, u;
}, {
  isTransformFunction: !0
}), JR = "bitOr", XR = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"], Hm = /* @__PURE__ */ H(JR, XR, (t) => {
  var {
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: i,
    concat: a
  } = t, o = Ps({
    typed: e,
    matrix: r,
    equalScalar: n,
    DenseMatrix: i,
    concat: a
  });
  function f(u, s, c) {
    var l = u[0].compile().evaluate(c);
    if (!Yr(l)) {
      if (isNaN(l))
        return NaN;
      if (l === -1)
        return -1;
      if (l === !0)
        return 1;
    }
    var m = u[1].compile().evaluate(c);
    return o(l, m);
  }
  return f.rawArgs = !0, f;
}, {
  isTransformFunction: !0
});
const KR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createAbs: a0,
  createAccessorNode: Gc,
  createAcos: tc,
  createAcosh: rc,
  createAcot: nc,
  createAcoth: ic,
  createAcsc: ac,
  createAcsch: sc,
  createAdd: Rc,
  createAddScalar: s0,
  createAnd: Ws,
  createAndTransform: $m,
  createApply: Ua,
  createApplyTransform: wm,
  createArg: q0,
  createArrayNode: Hc,
  createAsec: oc,
  createAsech: uc,
  createAsin: lc,
  createAsinh: cc,
  createAssignmentNode: Qc,
  createAtan: fc,
  createAtan2: pc,
  createAtanh: mc,
  createAtomicMass: Kp,
  createAvogadro: em,
  createBellNumbers: Vf,
  createBigNumberClass: Au,
  createBigint: Vu,
  createBignumber: Yu,
  createBin: pl,
  createBitAnd: Rs,
  createBitAndTransform: Gm,
  createBitNot: M0,
  createBitOr: Ps,
  createBitOrTransform: Hm,
  createBitXor: O0,
  createBlockNode: Vc,
  createBohrMagneton: Ip,
  createBohrRadius: kp,
  createBoltzmann: tm,
  createBoolean: ju,
  createCatalan: Wf,
  createCbrt: u0,
  createCeil: l0,
  createChain: yf,
  createChainClass: gf,
  createClassicalElectronRadius: zp,
  createClone: Iu,
  createColumn: zs,
  createColumnTransform: Nm,
  createCombinations: Ff,
  createCombinationsWithRep: Bf,
  createCompare: Il,
  createCompareNatural: Fl,
  createCompareText: Bl,
  createCompile: sf,
  createComplex: Zu,
  createComplexClass: Cu,
  createComposition: jf,
  createConcat: ks,
  createConcatTransform: Im,
  createConditionalNode: Wc,
  createConductanceQuantum: Fp,
  createConj: I0,
  createConstantNode: jc,
  createCorr: If,
  createCos: hc,
  createCosh: dc,
  createCot: gc,
  createCoth: vc,
  createCoulomb: Op,
  createCount: L0,
  createCreateUnit: ec,
  createCross: k0,
  createCsc: yc,
  createCsch: xc,
  createCtranspose: rl,
  createCube: c0,
  createCumSum: Js,
  createCumSumTransform: Lm,
  createDeepEqual: Ul,
  createDenseMatrixClass: qu,
  createDerivative: tp,
  createDet: xf,
  createDeuteronMass: Vp,
  createDiag: z0,
  createDiff: $s,
  createDiffTransform: Fm,
  createDistance: _f,
  createDivide: Tf,
  createDivideScalar: yl,
  createDot: kc,
  createDotDivide: Sl,
  createDotMultiply: _0,
  createDotPow: El,
  createE: hp,
  createEfimovFactor: Xp,
  createEigs: Nf,
  createElectricConstant: _p,
  createElectronMass: $p,
  createElementaryCharge: qp,
  createEqual: Rl,
  createEqualScalar: Gu,
  createEqualText: Pl,
  createErf: ol,
  createEvaluate: of,
  createExp: f0,
  createExpm: Df,
  createExpm1: p0,
  createFactorial: Lf,
  createFalse: up,
  createFaraday: rm,
  createFermiCoupling: Up,
  createFft: il,
  createFibonacciHeapClass: jl,
  createFilter: $0,
  createFilterTransform: Dm,
  createFineStructure: Gp,
  createFirstRadiation: nm,
  createFix: m0,
  createFlatten: U0,
  createFloor: Fs,
  createForEach: G0,
  createForEachTransform: Em,
  createFormat: fl,
  createFraction: Ju,
  createFractionClass: Tu,
  createFreqz: ip,
  createFunctionAssignmentNode: Yc,
  createFunctionNode: nf,
  createGamma: Rf,
  createGasConstant: am,
  createGcd: d0,
  createGetMatrixDataType: H0,
  createGravitationConstant: Sp,
  createGravity: hm,
  createHartreeEnergy: Hp,
  createHasNumericValue: Lu,
  createHelp: vf,
  createHelpClass: df,
  createHex: hl,
  createHypot: Pc,
  createI: Np,
  createIdentity: Q0,
  createIfft: al,
  createIm: F0,
  createImmutableDenseMatrixClass: Vl,
  createIndex: $c,
  createIndexClass: Wl,
  createIndexNode: Zc,
  createIndexTransform: Sm,
  createInfinity: cp,
  createIntersect: Mf,
  createInv: bf,
  createInverseConductanceQuantum: Bp,
  createInvmod: T0,
  createIsInteger: Bu,
  createIsNaN: $u,
  createIsNegative: Ru,
  createIsNumeric: Pu,
  createIsPositive: ku,
  createIsPrime: gl,
  createIsZero: zu,
  createKldivergence: kf,
  createKlitzing: Lp,
  createKron: V0,
  createLN10: vp,
  createLN2: gp,
  createLOG10E: xp,
  createLOG2E: yp,
  createLarger: zl,
  createLargerEq: $l,
  createLcm: v0,
  createLeafCount: Yf,
  createLeftShift: Ml,
  createLgamma: Pf,
  createLog: wl,
  createLog10: y0,
  createLog1p: Nl,
  createLog2: x0,
  createLoschmidt: im,
  createLsolve: Al,
  createLsolveAll: Tl,
  createLup: cf,
  createLusolve: mf,
  createLyap: Cf,
  createMad: qf,
  createMagneticConstant: Tp,
  createMagneticFluxQuantum: Rp,
  createMap: W0,
  createMapTransform: Am,
  createMatrix: Xu,
  createMatrixClass: Mu,
  createMatrixFromColumns: t0,
  createMatrixFromFunction: Ku,
  createMatrixFromRows: e0,
  createMax: js,
  createMaxTransform: Cm,
  createMean: Xs,
  createMeanTransform: Tm,
  createMedian: Of,
  createMin: Ys,
  createMinTransform: _m,
  createMod: Bs,
  createMode: ll,
  createMolarMass: pm,
  createMolarMassC12: mm,
  createMolarPlanckConstant: sm,
  createMolarVolume: om,
  createMultinomial: zf,
  createMultiply: w0,
  createMultiplyScalar: b0,
  createNaN: fp,
  createNeutronMass: Wp,
  createNode: Uc,
  createNorm: Lc,
  createNot: R0,
  createNthRoot: N0,
  createNthRoots: Dl,
  createNuclearMagneton: Pp,
  createNull: lp,
  createNumber: Qu,
  createNumeric: vl,
  createObjectNode: Jc,
  createOct: ml,
  createOnes: j0,
  createOperatorNode: Xc,
  createOr: Ls,
  createOrTransform: Um,
  createParenthesisNode: Kc,
  createParse: af,
  createParser: lf,
  createParserClass: uf,
  createPartitionSelect: Hl,
  createPermutations: $f,
  createPhi: dp,
  createPi: pp,
  createPickRandom: Uf,
  createPinv: wf,
  createPlanckCharge: ym,
  createPlanckConstant: Ap,
  createPlanckLength: dm,
  createPlanckMass: gm,
  createPlanckTemperature: xm,
  createPlanckTime: vm,
  createPolynomialRoot: hf,
  createPow: xl,
  createPrint: Qs,
  createPrintTransform: zm,
  createProd: cl,
  createProtonMass: Qp,
  createQr: ff,
  createQuantileSeq: eo,
  createQuantileSeqTransform: Pm,
  createQuantumOfCirculation: jp,
  createRandom: Gf,
  createRandomInt: Hf,
  createRange: Us,
  createRangeClass: _u,
  createRangeNode: ef,
  createRangeTransform: Mm,
  createRationalize: rp,
  createRe: B0,
  createReducedPlanckConstant: Cp,
  createRelationalNode: tf,
  createReplacer: sp,
  createReshape: Y0,
  createResize: Z0,
  createResolve: Kf,
  createResultSet: Nu,
  createReviver: ap,
  createRightArithShift: Ol,
  createRightLogShift: ql,
  createRotate: J0,
  createRotationMatrix: X0,
  createRound: bl,
  createRow: Gs,
  createRowTransform: Om,
  createRydberg: Yp,
  createSQRT1_2: bp,
  createSQRT2: wp,
  createSackurTetrode: um,
  createSchur: Af,
  createSec: bc,
  createSech: wc,
  createSecondRadiation: lm,
  createSetCartesian: Ac,
  createSetDifference: Cc,
  createSetDistinct: Tc,
  createSetIntersect: _c,
  createSetIsSubset: Mc,
  createSetMultiplicity: Oc,
  createSetPowerset: qc,
  createSetSize: Ic,
  createSetSymDifference: Fc,
  createSetUnion: Bc,
  createSign: D0,
  createSimplify: Zf,
  createSimplifyConstant: Jf,
  createSimplifyCore: Xf,
  createSin: Nc,
  createSinh: Dc,
  createSize: K0,
  createSlu: pf,
  createSmaller: Ll,
  createSmallerEq: kl,
  createSolveODE: sl,
  createSort: Ql,
  createSpaClass: Yl,
  createSparse: Kl,
  createSparseMatrixClass: Hu,
  createSpeedOfLight: Ep,
  createSplitUnit: r0,
  createSqrt: E0,
  createSqrtm: Ef,
  createSquare: S0,
  createSqueeze: el,
  createStd: to,
  createStdTransform: Bm,
  createStefanBoltzmann: cm,
  createStirlingS2: Qf,
  createString: Wu,
  createSubset: Hs,
  createSubsetTransform: qm,
  createSubtract: A0,
  createSubtractScalar: o0,
  createSum: Zs,
  createSumTransform: Rm,
  createSylvester: Sf,
  createSymbolNode: rf,
  createSymbolicEqual: ep,
  createTan: Ec,
  createTanh: Sc,
  createTau: mp,
  createThomsonCrossSection: Zp,
  createTo: dl,
  createTrace: zc,
  createTranspose: tl,
  createTrue: op,
  createTypeOf: Uu,
  createTyped: wu,
  createUnaryMinus: n0,
  createUnaryPlus: i0,
  createUnequal: Gl,
  createUnitClass: Jl,
  createUnitFunction: Xl,
  createUppercaseE: Gd,
  createUppercasePi: Ud,
  createUsolve: Cl,
  createUsolveAll: _l,
  createVacuumImpedance: Mp,
  createVariance: Ks,
  createVarianceTransform: km,
  createVersion: Dp,
  createWeakMixingAngle: Jp,
  createWienDisplacement: fm,
  createXgcd: C0,
  createXor: P0,
  createZeros: nl,
  createZeta: ul,
  createZpk2tf: np
}, Symbol.toStringTag, { value: "Module" }));
var ke = /* @__PURE__ */ Au({
  config: Te
}), At = /* @__PURE__ */ Cu({}), sd = /* @__PURE__ */ hp({
  BigNumber: ke,
  config: Te
}), eN = /* @__PURE__ */ up({}), tN = /* @__PURE__ */ Gp({
  BigNumber: ke,
  config: Te
}), Si = /* @__PURE__ */ Tu({}), Qd = /* @__PURE__ */ Np({
  Complex: At
}), rN = /* @__PURE__ */ cp({
  BigNumber: ke,
  config: Te
}), nN = /* @__PURE__ */ vp({
  BigNumber: ke,
  config: Te
}), iN = /* @__PURE__ */ xp({
  BigNumber: ke,
  config: Te
}), Qa = /* @__PURE__ */ Mu({}), aN = /* @__PURE__ */ fp({
  BigNumber: ke,
  config: Te
}), sN = /* @__PURE__ */ lp({}), oN = /* @__PURE__ */ dp({
  BigNumber: ke,
  config: Te
}), uN = /* @__PURE__ */ _u({}), Vd = /* @__PURE__ */ Nu({}), lN = /* @__PURE__ */ bp({
  BigNumber: ke,
  config: Te
}), cN = /* @__PURE__ */ um({
  BigNumber: ke,
  config: Te
}), Wd = /* @__PURE__ */ mp({
  BigNumber: ke,
  config: Te
}), fN = /* @__PURE__ */ op({}), pN = /* @__PURE__ */ Dp({}), pt = /* @__PURE__ */ qu({
  Matrix: Qa
}), mN = /* @__PURE__ */ Xp({
  BigNumber: ke,
  config: Te
}), hN = /* @__PURE__ */ gp({
  BigNumber: ke,
  config: Te
}), yi = /* @__PURE__ */ pp({
  BigNumber: ke,
  config: Te
}), dN = /* @__PURE__ */ sp({}), gN = /* @__PURE__ */ wp({
  BigNumber: ke,
  config: Te
}), ne = /* @__PURE__ */ wu({
  BigNumber: ke,
  Complex: At,
  DenseMatrix: pt,
  Fraction: Si
}), vN = /* @__PURE__ */ Jp({
  BigNumber: ke,
  config: Te
}), It = /* @__PURE__ */ a0({
  typed: ne
}), jd = /* @__PURE__ */ tc({
  Complex: At,
  config: Te,
  typed: ne
}), yN = /* @__PURE__ */ nc({
  BigNumber: ke,
  typed: ne
}), xN = /* @__PURE__ */ ac({
  BigNumber: ke,
  Complex: At,
  config: Te,
  typed: ne
}), sr = /* @__PURE__ */ s0({
  typed: ne
}), Cs = /* @__PURE__ */ q0({
  typed: ne
}), bN = /* @__PURE__ */ uc({
  BigNumber: ke,
  Complex: At,
  config: Te,
  typed: ne
}), wN = /* @__PURE__ */ cc({
  typed: ne
}), Yd = /* @__PURE__ */ fc({
  typed: ne
}), NN = /* @__PURE__ */ mc({
  Complex: At,
  config: Te,
  typed: ne
}), DN = /* @__PURE__ */ Vu({
  typed: ne
}), EN = /* @__PURE__ */ M0({
  typed: ne
}), SN = /* @__PURE__ */ ju({
  typed: ne
}), AN = /* @__PURE__ */ Iu({
  typed: ne
}), ro = /* @__PURE__ */ Ff({
  typed: ne
}), zt = /* @__PURE__ */ Zu({
  Complex: At,
  typed: ne
}), kn = /* @__PURE__ */ I0({
  typed: ne
}), Qm = /* @__PURE__ */ hc({
  typed: ne
}), CN = /* @__PURE__ */ gc({
  BigNumber: ke,
  typed: ne
}), Zd = /* @__PURE__ */ yc({
  BigNumber: ke,
  typed: ne
}), TN = /* @__PURE__ */ c0({
  typed: ne
}), dt = /* @__PURE__ */ Gu({
  config: Te,
  typed: ne
}), _N = /* @__PURE__ */ ol({
  typed: ne
}), Jd = /* @__PURE__ */ f0({
  typed: ne
}), MN = /* @__PURE__ */ p0({
  Complex: At,
  typed: ne
}), ON = /* @__PURE__ */ $0({
  typed: ne
}), qN = /* @__PURE__ */ G0({
  typed: ne
}), Va = /* @__PURE__ */ fl({
  typed: ne
}), Vm = /* @__PURE__ */ H0({
  typed: ne
}), IN = /* @__PURE__ */ hl({
  format: Va,
  typed: ne
}), ji = /* @__PURE__ */ F0({
  typed: ne
}), zr = /* @__PURE__ */ Bu({
  typed: ne
}), ri = /* @__PURE__ */ Ru({
  config: Te,
  typed: ne
}), Ai = /* @__PURE__ */ ku({
  config: Te,
  typed: ne
}), gn = /* @__PURE__ */ zu({
  equalScalar: dt,
  typed: ne
}), FN = /* @__PURE__ */ yp({
  BigNumber: ke,
  config: Te
}), BN = /* @__PURE__ */ Pf({
  Complex: At,
  typed: ne
}), RN = /* @__PURE__ */ y0({
  Complex: At,
  config: Te,
  typed: ne
}), Ci = /* @__PURE__ */ x0({
  Complex: At,
  config: Te,
  typed: ne
}), Ti = /* @__PURE__ */ W0({
  typed: ne
}), Xt = /* @__PURE__ */ b0({
  typed: ne
}), Ts = /* @__PURE__ */ R0({
  typed: ne
}), zn = /* @__PURE__ */ Qu({
  typed: ne
}), PN = /* @__PURE__ */ ml({
  format: Va,
  typed: ne
}), LN = /* @__PURE__ */ Uf({
  config: Te,
  typed: ne
}), kN = /* @__PURE__ */ Qs({
  typed: ne
}), zN = /* @__PURE__ */ Gf({
  config: Te,
  typed: ne
}), Yi = /* @__PURE__ */ B0({
  typed: ne
}), $N = /* @__PURE__ */ bc({
  BigNumber: ke,
  typed: ne
}), Xd = /* @__PURE__ */ D0({
  BigNumber: ke,
  Fraction: Si,
  complex: zt,
  typed: ne
}), no = /* @__PURE__ */ Nc({
  typed: ne
}), $n = /* @__PURE__ */ Hu({
  Matrix: Qa,
  equalScalar: dt,
  typed: ne
}), UN = /* @__PURE__ */ r0({
  typed: ne
}), GN = /* @__PURE__ */ S0({
  typed: ne
}), HN = /* @__PURE__ */ Wu({
  typed: ne
}), sn = /* @__PURE__ */ o0({
  typed: ne
}), QN = /* @__PURE__ */ Ec({
  typed: ne
}), Kd = /* @__PURE__ */ Uu({
  typed: ne
}), VN = /* @__PURE__ */ rc({
  Complex: At,
  config: Te,
  typed: ne
}), WN = /* @__PURE__ */ sc({
  BigNumber: ke,
  typed: ne
}), Wm = /* @__PURE__ */ Ua({
  isInteger: zr,
  typed: ne
}), jN = /* @__PURE__ */ oc({
  BigNumber: ke,
  Complex: At,
  config: Te,
  typed: ne
}), jr = /* @__PURE__ */ Yu({
  BigNumber: ke,
  typed: ne
}), YN = /* @__PURE__ */ Bf({
  typed: ne
}), ZN = /* @__PURE__ */ dc({
  typed: ne
}), JN = /* @__PURE__ */ xc({
  BigNumber: ke,
  typed: ne
}), Wa = /* @__PURE__ */ $u({
  typed: ne
}), XN = /* @__PURE__ */ gl({
  typed: ne
}), KN = /* @__PURE__ */ Hf({
  config: Te,
  typed: ne
}), eD = /* @__PURE__ */ wc({
  BigNumber: ke,
  typed: ne
}), tD = /* @__PURE__ */ Dc({
  typed: ne
}), rD = /* @__PURE__ */ Kl({
  SparseMatrix: $n,
  typed: ne
}), ar = /* @__PURE__ */ E0({
  Complex: At,
  config: Te,
  typed: ne
}), nD = /* @__PURE__ */ Sc({
  typed: ne
}), On = /* @__PURE__ */ n0({
  typed: ne
}), iD = /* @__PURE__ */ ic({
  BigNumber: ke,
  Complex: At,
  config: Te,
  typed: ne
}), aD = /* @__PURE__ */ pl({
  format: Va,
  typed: ne
}), sD = /* @__PURE__ */ vc({
  BigNumber: ke,
  typed: ne
}), ra = /* @__PURE__ */ Ju({
  Fraction: Si,
  typed: ne
}), _i = /* @__PURE__ */ Pu({
  typed: ne
}), Pe = /* @__PURE__ */ Xu({
  DenseMatrix: pt,
  Matrix: Qa,
  SparseMatrix: $n,
  typed: ne
}), oD = /* @__PURE__ */ Ku({
  isZero: gn,
  matrix: Pe,
  typed: ne
}), uD = /* @__PURE__ */ ll({
  isNaN: Wa,
  isNumeric: _i,
  typed: ne
}), rn = /* @__PURE__ */ vl({
  bignumber: jr,
  fraction: ra,
  number: zn
}), eg = /* @__PURE__ */ cl({
  config: Te,
  multiplyScalar: Xt,
  numeric: rn,
  typed: ne
}), tg = /* @__PURE__ */ Y0({
  isInteger: zr,
  matrix: Pe,
  typed: ne
}), gr = /* @__PURE__ */ K0({
  matrix: Pe,
  config: Te,
  typed: ne
}), lD = /* @__PURE__ */ el({
  matrix: Pe,
  typed: ne
}), ja = /* @__PURE__ */ tl({
  matrix: Pe,
  typed: ne
}), rg = /* @__PURE__ */ C0({
  BigNumber: ke,
  config: Te,
  matrix: Pe,
  typed: ne
}), ur = /* @__PURE__ */ nl({
  BigNumber: ke,
  config: Te,
  matrix: Pe,
  typed: ne
}), cD = /* @__PURE__ */ lc({
  Complex: At,
  config: Te,
  typed: ne
}), ng = /* @__PURE__ */ u0({
  BigNumber: ke,
  Complex: At,
  Fraction: Si,
  config: Te,
  isNegative: ri,
  matrix: Pe,
  typed: ne,
  unaryMinus: On
}), Nt = /* @__PURE__ */ ks({
  isInteger: zr,
  matrix: Pe,
  typed: ne
}), fD = /* @__PURE__ */ L0({
  prod: eg,
  size: gr,
  typed: ne
}), Ya = /* @__PURE__ */ rl({
  conj: kn,
  transpose: ja,
  typed: ne
}), ig = /* @__PURE__ */ z0({
  DenseMatrix: pt,
  SparseMatrix: $n,
  matrix: Pe,
  typed: ne
}), Yt = /* @__PURE__ */ yl({
  numeric: rn,
  typed: ne
}), Za = /* @__PURE__ */ Sl({
  DenseMatrix: pt,
  concat: Nt,
  divideScalar: Yt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), on = /* @__PURE__ */ Rl({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), Ja = /* @__PURE__ */ U0({
  matrix: Pe,
  typed: ne
}), pD = /* @__PURE__ */ Lu({
  isNumeric: _i,
  typed: ne
}), ni = /* @__PURE__ */ Q0({
  BigNumber: ke,
  DenseMatrix: pt,
  SparseMatrix: $n,
  config: Te,
  matrix: Pe,
  typed: ne
}), mD = /* @__PURE__ */ V0({
  matrix: Pe,
  multiplyScalar: Xt,
  typed: ne
}), io = /* @__PURE__ */ $l({
  DenseMatrix: pt,
  concat: Nt,
  config: Te,
  matrix: Pe,
  typed: ne
}), hD = /* @__PURE__ */ Ml({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne,
  zeros: ur
}), ag = /* @__PURE__ */ Al({
  DenseMatrix: pt,
  divideScalar: Yt,
  equalScalar: dt,
  matrix: Pe,
  multiplyScalar: Xt,
  subtractScalar: sn,
  typed: ne
}), jm = /* @__PURE__ */ t0({
  flatten: Ja,
  matrix: Pe,
  size: gr,
  typed: ne
}), dD = /* @__PURE__ */ N0({
  BigNumber: ke,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), gD = /* @__PURE__ */ j0({
  BigNumber: ke,
  config: Te,
  matrix: Pe,
  typed: ne
}), Ym = /* @__PURE__ */ ff({
  addScalar: sr,
  complex: zt,
  conj: kn,
  divideScalar: Yt,
  equal: on,
  identity: ni,
  isZero: gn,
  matrix: Pe,
  multiplyScalar: Xt,
  sign: Xd,
  sqrt: ar,
  subtractScalar: sn,
  typed: ne,
  unaryMinus: On,
  zeros: ur
}), vD = /* @__PURE__ */ Z0({
  config: Te,
  matrix: Pe
}), yD = /* @__PURE__ */ Ol({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne,
  zeros: ur
}), qt = /* @__PURE__ */ bl({
  BigNumber: ke,
  DenseMatrix: pt,
  config: Te,
  equalScalar: dt,
  matrix: Pe,
  typed: ne,
  zeros: ur
}), qr = /* @__PURE__ */ Ll({
  DenseMatrix: pt,
  concat: Nt,
  config: Te,
  matrix: Pe,
  typed: ne
}), Qt = /* @__PURE__ */ A0({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  subtractScalar: sn,
  typed: ne,
  unaryMinus: On
}), xD = /* @__PURE__ */ dl({
  concat: Nt,
  matrix: Pe,
  typed: ne
}), Zm = /* @__PURE__ */ i0({
  config: Te,
  numeric: rn,
  typed: ne
}), Jm = /* @__PURE__ */ Cl({
  DenseMatrix: pt,
  divideScalar: Yt,
  equalScalar: dt,
  matrix: Pe,
  multiplyScalar: Xt,
  subtractScalar: sn,
  typed: ne
}), bD = /* @__PURE__ */ P0({
  DenseMatrix: pt,
  concat: Nt,
  matrix: Pe,
  typed: ne
}), rt = /* @__PURE__ */ Rc({
  DenseMatrix: pt,
  SparseMatrix: $n,
  addScalar: sr,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), sg = /* @__PURE__ */ pc({
  BigNumber: ke,
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), wD = /* @__PURE__ */ Rs({
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), ND = /* @__PURE__ */ Ps({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), DD = /* @__PURE__ */ O0({
  DenseMatrix: pt,
  concat: Nt,
  matrix: Pe,
  typed: ne
}), ED = /* @__PURE__ */ Wf({
  addScalar: sr,
  combinations: ro,
  divideScalar: Yt,
  isInteger: zr,
  isNegative: ri,
  multiplyScalar: Xt,
  typed: ne
}), Mi = /* @__PURE__ */ Il({
  BigNumber: ke,
  DenseMatrix: pt,
  Fraction: Si,
  concat: Nt,
  config: Te,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), og = /* @__PURE__ */ Bl({
  concat: Nt,
  matrix: Pe,
  typed: ne
}), SD = /* @__PURE__ */ Js({
  add: rt,
  typed: ne,
  unaryPlus: Zm
}), Xm = /* @__PURE__ */ Ul({
  equal: on,
  typed: ne
}), AD = /* @__PURE__ */ $s({
  matrix: Pe,
  number: zn,
  subtract: Qt,
  typed: ne
}), CD = /* @__PURE__ */ _f({
  abs: It,
  addScalar: sr,
  deepEqual: Xm,
  divideScalar: Yt,
  multiplyScalar: Xt,
  sqrt: ar,
  subtractScalar: sn,
  typed: ne
}), ao = /* @__PURE__ */ kc({
  addScalar: sr,
  conj: kn,
  multiplyScalar: Xt,
  size: gr,
  typed: ne
}), TD = /* @__PURE__ */ Pl({
  compareText: og,
  isZero: gn,
  typed: ne
}), ug = /* @__PURE__ */ Fs({
  DenseMatrix: pt,
  config: Te,
  equalScalar: dt,
  matrix: Pe,
  round: qt,
  typed: ne,
  zeros: ur
}), _D = /* @__PURE__ */ d0({
  BigNumber: ke,
  DenseMatrix: pt,
  concat: Nt,
  config: Te,
  equalScalar: dt,
  matrix: Pe,
  round: qt,
  typed: ne,
  zeros: ur
}), MD = /* @__PURE__ */ Pc({
  abs: It,
  addScalar: sr,
  divideScalar: Yt,
  isPositive: Ai,
  multiplyScalar: Xt,
  smaller: qr,
  sqrt: ar,
  typed: ne
}), lg = /* @__PURE__ */ Vl({
  DenseMatrix: pt,
  smaller: qr
}), Dr = /* @__PURE__ */ Wl({
  ImmutableDenseMatrix: lg,
  getMatrixDataType: Vm
}), Ir = /* @__PURE__ */ zl({
  DenseMatrix: pt,
  concat: Nt,
  config: Te,
  matrix: Pe,
  typed: ne
}), so = /* @__PURE__ */ wl({
  Complex: At,
  config: Te,
  divideScalar: Yt,
  typed: ne
}), OD = /* @__PURE__ */ Tl({
  DenseMatrix: pt,
  divideScalar: Yt,
  equalScalar: dt,
  matrix: Pe,
  multiplyScalar: Xt,
  subtractScalar: sn,
  typed: ne
}), qD = /* @__PURE__ */ e0({
  flatten: Ja,
  matrix: Pe,
  size: gr,
  typed: ne
}), cg = /* @__PURE__ */ Ys({
  config: Te,
  numeric: rn,
  smaller: qr,
  typed: ne
}), fg = /* @__PURE__ */ Bs({
  DenseMatrix: pt,
  concat: Nt,
  config: Te,
  equalScalar: dt,
  matrix: Pe,
  round: qt,
  typed: ne,
  zeros: ur
}), Xe = /* @__PURE__ */ w0({
  addScalar: sr,
  dot: ao,
  equalScalar: dt,
  matrix: Pe,
  multiplyScalar: Xt,
  typed: ne
}), ID = /* @__PURE__ */ Dl({
  Complex: At,
  config: Te,
  divideScalar: Yt,
  typed: ne
}), FD = /* @__PURE__ */ Ls({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), oo = /* @__PURE__ */ Hl({
  compare: Mi,
  isNaN: Wa,
  isNumeric: _i,
  typed: ne
}), BD = /* @__PURE__ */ ql({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne,
  zeros: ur
}), pg = /* @__PURE__ */ pf({
  SparseMatrix: $n,
  abs: It,
  add: rt,
  divideScalar: Yt,
  larger: Ir,
  largerEq: io,
  multiply: Xe,
  subtract: Qt,
  transpose: ja,
  typed: ne
}), Xr = /* @__PURE__ */ Hs({
  add: rt,
  matrix: Pe,
  typed: ne,
  zeros: ur
}), Km = /* @__PURE__ */ Zs({
  add: rt,
  config: Te,
  numeric: rn,
  typed: ne
}), mg = /* @__PURE__ */ zc({
  add: rt,
  matrix: Pe,
  typed: ne
}), hg = /* @__PURE__ */ _l({
  DenseMatrix: pt,
  divideScalar: Yt,
  equalScalar: dt,
  matrix: Pe,
  multiplyScalar: Xt,
  subtractScalar: sn,
  typed: ne
}), RD = /* @__PURE__ */ np({
  Complex: At,
  add: rt,
  multiply: Xe,
  number: zn,
  typed: ne
}), eh = /* @__PURE__ */ l0({
  DenseMatrix: pt,
  config: Te,
  equalScalar: dt,
  matrix: Pe,
  round: qt,
  typed: ne,
  zeros: ur
}), qn = /* @__PURE__ */ Fl({
  compare: Mi,
  typed: ne
}), PD = /* @__PURE__ */ jf({
  addScalar: sr,
  combinations: ro,
  isInteger: zr,
  isNegative: ri,
  isPositive: Ai,
  larger: Ir,
  typed: ne
}), LD = /* @__PURE__ */ k0({
  matrix: Pe,
  multiply: Xe,
  subtract: Qt,
  typed: ne
}), th = /* @__PURE__ */ xf({
  divideScalar: Yt,
  isZero: gn,
  matrix: Pe,
  multiply: Xe,
  subtractScalar: sn,
  typed: ne,
  unaryMinus: On
}), kD = /* @__PURE__ */ _0({
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  multiplyScalar: Xt,
  typed: ne
}), dg = /* @__PURE__ */ jl({
  larger: Ir,
  smaller: qr
}), gg = /* @__PURE__ */ m0({
  Complex: At,
  DenseMatrix: pt,
  ceil: eh,
  equalScalar: dt,
  floor: ug,
  matrix: Pe,
  typed: ne,
  zeros: ur
}), vg = /* @__PURE__ */ $c({
  Index: Dr,
  typed: ne
}), zD = /* @__PURE__ */ Mf({
  abs: It,
  add: rt,
  addScalar: sr,
  config: Te,
  divideScalar: Yt,
  equalScalar: dt,
  flatten: Ja,
  isNumeric: _i,
  isZero: gn,
  matrix: Pe,
  multiply: Xe,
  multiplyScalar: Xt,
  smaller: qr,
  subtract: Qt,
  typed: ne
}), $D = /* @__PURE__ */ T0({
  BigNumber: ke,
  add: rt,
  config: Te,
  equal: on,
  isInteger: zr,
  mod: fg,
  smaller: qr,
  typed: ne,
  xgcd: rg
}), UD = /* @__PURE__ */ v0({
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), GD = /* @__PURE__ */ Nl({
  Complex: At,
  config: Te,
  divideScalar: Yt,
  log: so,
  typed: ne
}), uo = /* @__PURE__ */ js({
  config: Te,
  larger: Ir,
  numeric: rn,
  typed: ne
}), HD = /* @__PURE__ */ Ac({
  DenseMatrix: pt,
  Index: Dr,
  compareNatural: qn,
  size: gr,
  subset: Xr,
  typed: ne
}), QD = /* @__PURE__ */ Tc({
  DenseMatrix: pt,
  Index: Dr,
  compareNatural: qn,
  size: gr,
  subset: Xr,
  typed: ne
}), VD = /* @__PURE__ */ Mc({
  Index: Dr,
  compareNatural: qn,
  size: gr,
  subset: Xr,
  typed: ne
}), WD = /* @__PURE__ */ qc({
  Index: Dr,
  compareNatural: qn,
  size: gr,
  subset: Xr,
  typed: ne
}), Zi = /* @__PURE__ */ kl({
  DenseMatrix: pt,
  concat: Nt,
  config: Te,
  matrix: Pe,
  typed: ne
}), jD = /* @__PURE__ */ Ql({
  compare: Mi,
  compareNatural: qn,
  matrix: Pe,
  typed: ne
}), YD = /* @__PURE__ */ Gl({
  DenseMatrix: pt,
  concat: Nt,
  config: Te,
  equalScalar: dt,
  matrix: Pe,
  typed: ne
}), ZD = /* @__PURE__ */ Ws({
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  not: Ts,
  typed: ne,
  zeros: ur
}), Ji = /* @__PURE__ */ Us({
  bignumber: jr,
  matrix: Pe,
  add: rt,
  config: Te,
  isPositive: Ai,
  larger: Ir,
  largerEq: io,
  smaller: qr,
  smallerEq: Zi,
  typed: ne
}), JD = /* @__PURE__ */ Gs({
  Index: Dr,
  matrix: Pe,
  range: Ji,
  typed: ne
}), yg = /* @__PURE__ */ Cc({
  DenseMatrix: pt,
  Index: Dr,
  compareNatural: qn,
  size: gr,
  subset: Xr,
  typed: ne
}), XD = /* @__PURE__ */ Oc({
  Index: Dr,
  compareNatural: qn,
  size: gr,
  subset: Xr,
  typed: ne
}), xg = /* @__PURE__ */ Fc({
  Index: Dr,
  concat: Nt,
  setDifference: yg,
  size: gr,
  subset: Xr,
  typed: ne
}), bg = /* @__PURE__ */ Yl({
  FibonacciHeap: dg,
  addScalar: sr,
  equalScalar: dt
}), wg = /* @__PURE__ */ zs({
  Index: Dr,
  matrix: Pe,
  range: Ji,
  typed: ne
}), Oi = /* @__PURE__ */ bf({
  abs: It,
  addScalar: sr,
  det: th,
  divideScalar: Yt,
  identity: ni,
  matrix: Pe,
  multiply: Xe,
  typed: ne,
  unaryMinus: On
}), Ng = /* @__PURE__ */ cf({
  DenseMatrix: pt,
  Spa: bg,
  SparseMatrix: $n,
  abs: It,
  addScalar: sr,
  divideScalar: Yt,
  equalScalar: dt,
  larger: Ir,
  matrix: Pe,
  multiplyScalar: Xt,
  subtractScalar: sn,
  typed: ne,
  unaryMinus: On
}), KD = /* @__PURE__ */ wf({
  Complex: At,
  add: rt,
  ctranspose: Ya,
  deepEqual: Xm,
  divideScalar: Yt,
  dot: ao,
  dotDivide: Za,
  equal: on,
  inv: Oi,
  matrix: Pe,
  multiply: Xe,
  typed: ne
}), Dt = /* @__PURE__ */ xl({
  Complex: At,
  config: Te,
  fraction: ra,
  identity: ni,
  inv: Oi,
  matrix: Pe,
  multiply: Xe,
  number: zn,
  typed: ne
}), Dg = /* @__PURE__ */ _c({
  DenseMatrix: pt,
  Index: Dr,
  compareNatural: qn,
  size: gr,
  subset: Xr,
  typed: ne
}), eE = /* @__PURE__ */ Bc({
  Index: Dr,
  concat: Nt,
  setIntersect: Dg,
  setSymDifference: xg,
  size: gr,
  subset: Xr,
  typed: ne
}), tE = /* @__PURE__ */ Ef({
  abs: It,
  add: rt,
  identity: ni,
  inv: Oi,
  map: Ti,
  max: uo,
  multiply: Xe,
  size: gr,
  sqrt: ar,
  subtract: Qt,
  typed: ne
}), et = /* @__PURE__ */ Jl({
  BigNumber: ke,
  Complex: At,
  Fraction: Si,
  abs: It,
  addScalar: sr,
  config: Te,
  divideScalar: Yt,
  equal: on,
  fix: gg,
  format: Va,
  isNumeric: _i,
  multiplyScalar: Xt,
  number: zn,
  pow: Dt,
  round: qt,
  subtractScalar: sn
}), rE = /* @__PURE__ */ Mp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), nE = /* @__PURE__ */ fm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), iE = /* @__PURE__ */ Kp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), aE = /* @__PURE__ */ Ip({
  BigNumber: ke,
  Unit: et,
  config: Te
}), sE = /* @__PURE__ */ tm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), oE = /* @__PURE__ */ Fp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), uE = /* @__PURE__ */ Op({
  BigNumber: ke,
  Unit: et,
  config: Te
}), lE = /* @__PURE__ */ Vp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), cE = /* @__PURE__ */ El({
  DenseMatrix: pt,
  concat: Nt,
  equalScalar: dt,
  matrix: Pe,
  pow: Dt,
  typed: ne
}), fE = /* @__PURE__ */ _p({
  BigNumber: ke,
  Unit: et,
  config: Te
}), pE = /* @__PURE__ */ qp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), mE = /* @__PURE__ */ Df({
  abs: It,
  add: rt,
  identity: ni,
  inv: Oi,
  multiply: Xe,
  typed: ne
}), hE = /* @__PURE__ */ rm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), Eg = /* @__PURE__ */ il({
  addScalar: sr,
  ceil: eh,
  conj: kn,
  divideScalar: Yt,
  dotDivide: Za,
  exp: Jd,
  i: Qd,
  log2: Ci,
  matrix: Pe,
  multiplyScalar: Xt,
  pow: Dt,
  tau: Wd,
  typed: ne
}), rh = /* @__PURE__ */ Rf({
  BigNumber: ke,
  Complex: At,
  config: Te,
  multiplyScalar: Xt,
  pow: Dt,
  typed: ne
}), dE = /* @__PURE__ */ Sp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), gE = /* @__PURE__ */ Hp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), vE = /* @__PURE__ */ al({
  conj: kn,
  dotDivide: Za,
  fft: Eg,
  typed: ne
}), yE = /* @__PURE__ */ Lp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), xE = /* @__PURE__ */ im({
  BigNumber: ke,
  Unit: et,
  config: Te
}), bE = /* @__PURE__ */ Tp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), wE = /* @__PURE__ */ pm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), NE = /* @__PURE__ */ sm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), DE = /* @__PURE__ */ Wp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), EE = /* @__PURE__ */ Pp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), SE = /* @__PURE__ */ ym({
  BigNumber: ke,
  Unit: et,
  config: Te
}), AE = /* @__PURE__ */ dm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), CE = /* @__PURE__ */ xm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), TE = /* @__PURE__ */ Qp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), _E = /* @__PURE__ */ jp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), ME = /* @__PURE__ */ Cp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), OE = /* @__PURE__ */ Yp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), qE = /* @__PURE__ */ lm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), IE = /* @__PURE__ */ Ep({
  BigNumber: ke,
  Unit: et,
  config: Te
}), FE = /* @__PURE__ */ cm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), BE = /* @__PURE__ */ Zp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), RE = /* @__PURE__ */ em({
  BigNumber: ke,
  Unit: et,
  config: Te
}), PE = /* @__PURE__ */ kp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), LE = /* @__PURE__ */ ec({
  Unit: et,
  typed: ne
}), er = /* @__PURE__ */ Tf({
  divideScalar: Yt,
  equalScalar: dt,
  inv: Oi,
  matrix: Pe,
  multiply: Xe,
  typed: ne
}), kE = /* @__PURE__ */ $p({
  BigNumber: ke,
  Unit: et,
  config: Te
}), Xa = /* @__PURE__ */ Lf({
  gamma: rh,
  typed: ne
}), zE = /* @__PURE__ */ nm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), $E = /* @__PURE__ */ hm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), UE = /* @__PURE__ */ Bp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), Sg = /* @__PURE__ */ mf({
  DenseMatrix: pt,
  lsolve: ag,
  lup: Ng,
  matrix: Pe,
  slu: pg,
  typed: ne,
  usolve: Jm
}), GE = /* @__PURE__ */ Rp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), HE = /* @__PURE__ */ mm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), QE = /* @__PURE__ */ zf({
  add: rt,
  divide: er,
  factorial: Xa,
  isInteger: zr,
  isPositive: Ai,
  multiply: Xe,
  typed: ne
}), VE = /* @__PURE__ */ $f({
  factorial: Xa,
  typed: ne
}), WE = /* @__PURE__ */ gm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), jE = /* @__PURE__ */ hf({
  add: rt,
  cbrt: ng,
  divide: er,
  equalScalar: dt,
  im: ji,
  isZero: gn,
  multiply: Xe,
  re: Yi,
  sqrt: ar,
  subtract: Qt,
  typeOf: Kd,
  typed: ne,
  unaryMinus: On
}), YE = /* @__PURE__ */ Ic({
  compareNatural: qn,
  typed: ne
}), ZE = /* @__PURE__ */ sl({
  abs: It,
  add: rt,
  bignumber: jr,
  divide: er,
  isNegative: ri,
  isPositive: Ai,
  larger: Ir,
  map: Ti,
  matrix: Pe,
  max: uo,
  multiply: Xe,
  smaller: qr,
  subtract: Qt,
  typed: ne,
  unaryMinus: On
}), Ag = /* @__PURE__ */ Qf({
  bignumber: jr,
  addScalar: sr,
  combinations: ro,
  divideScalar: Yt,
  factorial: Xa,
  isInteger: zr,
  isNegative: ri,
  larger: Ir,
  multiplyScalar: Xt,
  number: zn,
  pow: Dt,
  subtractScalar: sn,
  typed: ne
}), JE = /* @__PURE__ */ Xl({
  Unit: et,
  typed: ne
}), XE = /* @__PURE__ */ Vf({
  addScalar: sr,
  isInteger: zr,
  isNegative: ri,
  stirlingS2: Ag,
  typed: ne
}), Cg = /* @__PURE__ */ Nf({
  abs: It,
  add: rt,
  addScalar: sr,
  atan: Yd,
  bignumber: jr,
  column: wg,
  complex: zt,
  config: Te,
  cos: Qm,
  diag: ig,
  divideScalar: Yt,
  dot: ao,
  equal: on,
  flatten: Ja,
  im: ji,
  inv: Oi,
  larger: Ir,
  matrix: Pe,
  matrixFromColumns: jm,
  multiply: Xe,
  multiplyScalar: Xt,
  number: zn,
  qr: Ym,
  re: Yi,
  reshape: tg,
  sin: no,
  size: gr,
  smaller: qr,
  sqrt: ar,
  subtract: Qt,
  typed: ne,
  usolve: Jm,
  usolveAll: hg
}), KE = /* @__PURE__ */ Up({
  BigNumber: ke,
  Unit: et,
  config: Te
}), eS = /* @__PURE__ */ am({
  BigNumber: ke,
  Unit: et,
  config: Te
}), tS = /* @__PURE__ */ kf({
  divide: er,
  dotDivide: Za,
  isNumeric: _i,
  log: so,
  map: Ti,
  matrix: Pe,
  multiply: Xe,
  sum: Km,
  typed: ne
}), Tg = /* @__PURE__ */ Xs({
  add: rt,
  divide: er,
  typed: ne
}), rS = /* @__PURE__ */ om({
  BigNumber: ke,
  Unit: et,
  config: Te
}), nS = /* @__PURE__ */ Ap({
  BigNumber: ke,
  Unit: et,
  config: Te
}), iS = /* @__PURE__ */ eo({
  bignumber: jr,
  add: rt,
  compare: Mi,
  divide: er,
  isInteger: zr,
  larger: Ir,
  multiply: Xe,
  partitionSelect: oo,
  smaller: qr,
  smallerEq: Zi,
  subtract: Qt,
  typed: ne
}), nh = /* @__PURE__ */ Ks({
  add: rt,
  apply: Wm,
  divide: er,
  isNaN: Wa,
  multiply: Xe,
  subtract: Qt,
  typed: ne
}), aS = /* @__PURE__ */ zp({
  BigNumber: ke,
  Unit: et,
  config: Te
}), _g = /* @__PURE__ */ Of({
  add: rt,
  compare: Mi,
  divide: er,
  partitionSelect: oo,
  typed: ne
}), sS = /* @__PURE__ */ If({
  add: rt,
  divide: er,
  matrix: Pe,
  mean: Tg,
  multiply: Xe,
  pow: Dt,
  sqrt: ar,
  subtract: Qt,
  sum: Km,
  typed: ne
}), oS = /* @__PURE__ */ ip({
  Complex: At,
  add: rt,
  divide: er,
  matrix: Pe,
  multiply: Xe,
  typed: ne
}), uS = /* @__PURE__ */ qf({
  abs: It,
  map: Ti,
  median: _g,
  subtract: Qt,
  typed: ne
}), lS = /* @__PURE__ */ to({
  map: Ti,
  sqrt: ar,
  typed: ne,
  variance: nh
}), cS = /* @__PURE__ */ ul({
  BigNumber: ke,
  Complex: At,
  add: rt,
  config: Te,
  divide: er,
  equal: on,
  factorial: Xa,
  gamma: rh,
  isNegative: ri,
  multiply: Xe,
  pi: yi,
  pow: Dt,
  sin: no,
  smallerEq: Zi,
  subtract: Qt,
  typed: ne
}), ih = /* @__PURE__ */ Lc({
  abs: It,
  add: rt,
  conj: kn,
  ctranspose: Ya,
  eigs: Cg,
  equalScalar: dt,
  larger: Ir,
  matrix: Pe,
  multiply: Xe,
  pow: Dt,
  smaller: qr,
  sqrt: ar,
  typed: ne
}), Mg = /* @__PURE__ */ X0({
  BigNumber: ke,
  DenseMatrix: pt,
  SparseMatrix: $n,
  addScalar: sr,
  config: Te,
  cos: Qm,
  matrix: Pe,
  multiplyScalar: Xt,
  norm: ih,
  sin: no,
  typed: ne,
  unaryMinus: On
}), fS = /* @__PURE__ */ vm({
  BigNumber: ke,
  Unit: et,
  config: Te
}), Og = /* @__PURE__ */ Af({
  identity: ni,
  matrix: Pe,
  multiply: Xe,
  norm: ih,
  qr: Ym,
  subtract: Qt,
  typed: ne
}), pS = /* @__PURE__ */ J0({
  multiply: Xe,
  rotationMatrix: Mg,
  typed: ne
}), qg = /* @__PURE__ */ Sf({
  abs: It,
  add: rt,
  concat: Nt,
  identity: ni,
  index: vg,
  lusolve: Sg,
  matrix: Pe,
  matrixFromColumns: jm,
  multiply: Xe,
  range: Ji,
  schur: Og,
  subset: Xr,
  subtract: Qt,
  transpose: ja,
  typed: ne
}), mS = /* @__PURE__ */ Cf({
  matrix: Pe,
  multiply: Xe,
  sylvester: qg,
  transpose: ja,
  typed: ne
}), Ka = {}, es = {}, hS = {}, Ar = Uc({
  mathWithTransform: es
}), na = Jc({
  Node: Ar
}), Un = Xc({
  Node: Ar
}), qi = Kc({
  Node: Ar
}), Ig = tf({
  Node: Ar
}), ia = Hc({
  Node: Ar
}), Fg = Vc({
  Node: Ar,
  ResultSet: Vd
}), Bg = Wc({
  Node: Ar
}), ii = jc({
  Node: Ar
}), Rg = ef({
  Node: Ar
}), dS = ap({
  classes: hS
}), ah = gf({
  math: Ka,
  typed: ne
}), Pg = Yc({
  Node: Ar,
  typed: ne
}), gS = yf({
  Chain: ah,
  typed: ne
}), aa = Zc({
  Node: Ar,
  size: gr
}), sa = Gc({
  Node: Ar,
  subset: Xr
}), Lg = Qc({
  matrix: Pe,
  Node: Ar,
  subset: Xr
}), ai = rf({
  Unit: et,
  Node: Ar,
  math: Ka
}), si = nf({
  Node: Ar,
  SymbolNode: ai,
  math: Ka
}), xt = af({
  AccessorNode: sa,
  ArrayNode: ia,
  AssignmentNode: Lg,
  BlockNode: Fg,
  ConditionalNode: Bg,
  ConstantNode: ii,
  FunctionAssignmentNode: Pg,
  FunctionNode: si,
  IndexNode: aa,
  ObjectNode: na,
  OperatorNode: Un,
  ParenthesisNode: qi,
  RangeNode: Rg,
  RelationalNode: Ig,
  SymbolNode: ai,
  config: Te,
  numeric: rn,
  typed: ne
}), kg = Kf({
  ConstantNode: ii,
  FunctionNode: si,
  OperatorNode: Un,
  ParenthesisNode: qi,
  parse: xt,
  typed: ne
}), sh = Jf({
  bignumber: jr,
  fraction: ra,
  AccessorNode: sa,
  ArrayNode: ia,
  ConstantNode: ii,
  FunctionNode: si,
  IndexNode: aa,
  ObjectNode: na,
  OperatorNode: Un,
  SymbolNode: ai,
  config: Te,
  mathWithTransform: es,
  matrix: Pe,
  typed: ne
}), vS = sf({
  parse: xt,
  typed: ne
}), oh = Xf({
  AccessorNode: sa,
  ArrayNode: ia,
  ConstantNode: ii,
  FunctionNode: si,
  IndexNode: aa,
  ObjectNode: na,
  OperatorNode: Un,
  ParenthesisNode: qi,
  SymbolNode: ai,
  add: rt,
  divide: er,
  equal: on,
  isZero: gn,
  multiply: Xe,
  parse: xt,
  pow: Dt,
  subtract: Qt,
  typed: ne
}), Nr = of({
  parse: xt,
  typed: ne
}), zg = df({
  evaluate: Nr
}), $g = uf({
  evaluate: Nr
}), lo = Zf({
  bignumber: jr,
  fraction: ra,
  AccessorNode: sa,
  ArrayNode: ia,
  ConstantNode: ii,
  FunctionNode: si,
  IndexNode: aa,
  ObjectNode: na,
  OperatorNode: Un,
  ParenthesisNode: qi,
  SymbolNode: ai,
  add: rt,
  config: Te,
  divide: er,
  equal: on,
  isZero: gn,
  mathWithTransform: es,
  matrix: Pe,
  multiply: Xe,
  parse: xt,
  pow: Dt,
  resolve: kg,
  simplifyConstant: sh,
  simplifyCore: oh,
  subtract: Qt,
  typed: ne
}), yS = ep({
  OperatorNode: Un,
  parse: xt,
  simplify: lo,
  typed: ne
}), xS = Yf({
  parse: xt,
  typed: ne
}), bS = lf({
  Parser: $g,
  typed: ne
}), wS = rp({
  bignumber: jr,
  fraction: ra,
  AccessorNode: sa,
  ArrayNode: ia,
  ConstantNode: ii,
  FunctionNode: si,
  IndexNode: aa,
  ObjectNode: na,
  OperatorNode: Un,
  ParenthesisNode: qi,
  SymbolNode: ai,
  add: rt,
  config: Te,
  divide: er,
  equal: on,
  isZero: gn,
  mathWithTransform: es,
  matrix: Pe,
  multiply: Xe,
  parse: xt,
  pow: Dt,
  simplify: lo,
  simplifyConstant: sh,
  simplifyCore: oh,
  subtract: Qt,
  typed: ne
}), NS = tp({
  ConstantNode: ii,
  FunctionNode: si,
  OperatorNode: Un,
  ParenthesisNode: qi,
  SymbolNode: ai,
  config: Te,
  equal: on,
  isZero: gn,
  numeric: rn,
  parse: xt,
  simplify: lo,
  typed: ne
}), DS = vf({
  Help: zg,
  mathWithTransform: es,
  typed: ne
});
nr(Ka, {
  e: sd,
  false: eN,
  fineStructure: tN,
  i: Qd,
  Infinity: rN,
  LN10: nN,
  LOG10E: iN,
  NaN: aN,
  null: sN,
  phi: oN,
  SQRT1_2: lN,
  sackurTetrode: cN,
  tau: Wd,
  true: fN,
  E: sd,
  version: pN,
  efimovFactor: mN,
  LN2: hN,
  pi: yi,
  replacer: dN,
  reviver: dS,
  SQRT2: gN,
  typed: ne,
  PI: yi,
  weakMixingAngle: vN,
  abs: It,
  acos: jd,
  acot: yN,
  acsc: xN,
  addScalar: sr,
  arg: Cs,
  asech: bN,
  asinh: wN,
  atan: Yd,
  atanh: NN,
  bigint: DN,
  bitNot: EN,
  boolean: SN,
  clone: AN,
  combinations: ro,
  complex: zt,
  conj: kn,
  cos: Qm,
  cot: CN,
  csc: Zd,
  cube: TN,
  equalScalar: dt,
  erf: _N,
  exp: Jd,
  expm1: MN,
  filter: ON,
  forEach: qN,
  format: Va,
  getMatrixDataType: Vm,
  hex: IN,
  im: ji,
  isInteger: zr,
  isNegative: ri,
  isPositive: Ai,
  isZero: gn,
  LOG2E: FN,
  lgamma: BN,
  log10: RN,
  log2: Ci,
  map: Ti,
  multiplyScalar: Xt,
  not: Ts,
  number: zn,
  oct: PN,
  pickRandom: LN,
  print: kN,
  random: zN,
  re: Yi,
  sec: $N,
  sign: Xd,
  sin: no,
  splitUnit: UN,
  square: GN,
  string: HN,
  subtractScalar: sn,
  tan: QN,
  typeOf: Kd,
  acosh: VN,
  acsch: WN,
  apply: Wm,
  asec: jN,
  bignumber: jr,
  chain: gS,
  combinationsWithRep: YN,
  cosh: ZN,
  csch: JN,
  isNaN: Wa,
  isPrime: XN,
  randomInt: KN,
  sech: eD,
  sinh: tD,
  sparse: rD,
  sqrt: ar,
  tanh: nD,
  unaryMinus: On,
  acoth: iD,
  bin: aD,
  coth: sD,
  fraction: ra,
  isNumeric: _i,
  matrix: Pe,
  matrixFromFunction: oD,
  mode: uD,
  numeric: rn,
  prod: eg,
  reshape: tg,
  size: gr,
  squeeze: lD,
  transpose: ja,
  xgcd: rg,
  zeros: ur,
  asin: cD,
  cbrt: ng,
  concat: Nt,
  count: fD,
  ctranspose: Ya,
  diag: ig,
  divideScalar: Yt,
  dotDivide: Za,
  equal: on,
  flatten: Ja,
  hasNumericValue: pD,
  identity: ni,
  kron: mD,
  largerEq: io,
  leftShift: hD,
  lsolve: ag,
  matrixFromColumns: jm,
  nthRoot: dD,
  ones: gD,
  qr: Ym,
  resize: vD,
  rightArithShift: yD,
  round: qt,
  smaller: qr,
  subtract: Qt,
  to: xD,
  unaryPlus: Zm,
  usolve: Jm,
  xor: bD,
  add: rt,
  atan2: sg,
  bitAnd: wD,
  bitOr: ND,
  bitXor: DD,
  catalan: ED,
  compare: Mi,
  compareText: og,
  cumsum: SD,
  deepEqual: Xm,
  diff: AD,
  distance: CD,
  dot: ao,
  equalText: TD,
  floor: ug,
  gcd: _D,
  hypot: MD,
  larger: Ir,
  log: so,
  lsolveAll: OD,
  matrixFromRows: qD,
  min: cg,
  mod: fg,
  multiply: Xe,
  nthRoots: ID,
  or: FD,
  partitionSelect: oo,
  rightLogShift: BD,
  slu: pg,
  subset: Xr,
  sum: Km,
  trace: mg,
  usolveAll: hg,
  zpk2tf: RD,
  ceil: eh,
  compareNatural: qn,
  composition: PD,
  cross: LD,
  det: th,
  dotMultiply: kD,
  fix: gg,
  index: vg,
  intersect: zD,
  invmod: $D,
  lcm: UD,
  log1p: GD,
  max: uo,
  setCartesian: HD,
  setDistinct: QD,
  setIsSubset: VD,
  setPowerset: WD,
  smallerEq: Zi,
  sort: jD,
  unequal: YD,
  and: ZD,
  range: Ji,
  row: JD,
  setDifference: yg,
  setMultiplicity: XD,
  setSymDifference: xg,
  column: wg,
  inv: Oi,
  lup: Ng,
  pinv: KD,
  pow: Dt,
  setIntersect: Dg,
  setUnion: eE,
  sqrtm: tE,
  vacuumImpedance: rE,
  wienDisplacement: nE,
  atomicMass: iE,
  bohrMagneton: aE,
  boltzmann: sE,
  conductanceQuantum: oE,
  coulomb: uE,
  deuteronMass: lE,
  dotPow: cE,
  electricConstant: fE,
  elementaryCharge: pE,
  expm: mE,
  faraday: hE,
  fft: Eg,
  gamma: rh,
  gravitationConstant: dE,
  hartreeEnergy: gE,
  ifft: vE,
  klitzing: yE,
  loschmidt: xE,
  magneticConstant: bE,
  molarMass: wE,
  molarPlanckConstant: NE,
  neutronMass: DE,
  nuclearMagneton: EE,
  planckCharge: SE,
  planckLength: AE,
  planckTemperature: CE,
  protonMass: TE,
  quantumOfCirculation: _E,
  reducedPlanckConstant: ME,
  rydberg: OE,
  secondRadiation: qE,
  speedOfLight: IE,
  stefanBoltzmann: FE,
  thomsonCrossSection: BE,
  avogadro: RE,
  bohrRadius: PE,
  createUnit: LE,
  divide: er,
  electronMass: kE,
  factorial: Xa,
  firstRadiation: zE,
  gravity: $E,
  inverseConductanceQuantum: UE,
  lusolve: Sg,
  magneticFluxQuantum: GE,
  molarMassC12: HE,
  multinomial: QE,
  parse: xt,
  permutations: VE,
  planckMass: WE,
  polynomialRoot: jE,
  resolve: kg,
  setSize: YE,
  simplifyConstant: sh,
  solveODE: ZE,
  stirlingS2: Ag,
  unit: JE,
  bellNumbers: XE,
  compile: vS,
  eigs: Cg,
  fermiCoupling: KE,
  gasConstant: eS,
  kldivergence: tS,
  mean: Tg,
  molarVolume: rS,
  planckConstant: nS,
  quantileSeq: iS,
  simplifyCore: oh,
  variance: nh,
  classicalElectronRadius: aS,
  evaluate: Nr,
  median: _g,
  simplify: lo,
  symbolicEqual: yS,
  corr: sS,
  freqz: oS,
  leafCount: xS,
  mad: uS,
  parser: bS,
  rationalize: wS,
  std: lS,
  zeta: cS,
  derivative: NS,
  norm: ih,
  rotationMatrix: Mg,
  help: DS,
  planckTime: fS,
  schur: Og,
  rotate: pS,
  sylvester: qg,
  lyap: mS,
  config: Te
});
nr(es, Ka, {
  filter: Dm({
    typed: ne
  }),
  forEach: Em({
    typed: ne
  }),
  map: Am({
    typed: ne
  }),
  apply: wm({
    isInteger: zr,
    typed: ne
  }),
  or: Um({
    DenseMatrix: pt,
    concat: Nt,
    equalScalar: dt,
    matrix: Pe,
    typed: ne
  }),
  and: $m({
    add: rt,
    concat: Nt,
    equalScalar: dt,
    matrix: Pe,
    not: Ts,
    typed: ne,
    zeros: ur
  }),
  concat: Im({
    isInteger: zr,
    matrix: Pe,
    typed: ne
  }),
  max: Cm({
    config: Te,
    larger: Ir,
    numeric: rn,
    typed: ne
  }),
  print: zm({
    add: rt,
    matrix: Pe,
    typed: ne,
    zeros: ur
  }),
  bitAnd: Gm({
    add: rt,
    concat: Nt,
    equalScalar: dt,
    matrix: Pe,
    not: Ts,
    typed: ne,
    zeros: ur
  }),
  diff: Fm({
    bignumber: jr,
    matrix: Pe,
    number: zn,
    subtract: Qt,
    typed: ne
  }),
  min: _m({
    config: Te,
    numeric: rn,
    smaller: qr,
    typed: ne
  }),
  subset: qm({
    add: rt,
    matrix: Pe,
    typed: ne,
    zeros: ur
  }),
  bitOr: Hm({
    DenseMatrix: pt,
    concat: Nt,
    equalScalar: dt,
    matrix: Pe,
    typed: ne
  }),
  cumsum: Lm({
    add: rt,
    typed: ne,
    unaryPlus: Zm
  }),
  index: Sm({
    Index: Dr,
    getMatrixDataType: Vm
  }),
  sum: Rm({
    add: rt,
    config: Te,
    numeric: rn,
    typed: ne
  }),
  range: Mm({
    bignumber: jr,
    matrix: Pe,
    add: rt,
    config: Te,
    isPositive: Ai,
    larger: Ir,
    largerEq: io,
    smaller: qr,
    smallerEq: Zi,
    typed: ne
  }),
  row: Om({
    Index: Dr,
    matrix: Pe,
    range: Ji,
    typed: ne
  }),
  column: Nm({
    Index: Dr,
    matrix: Pe,
    range: Ji,
    typed: ne
  }),
  mean: Tm({
    add: rt,
    divide: er,
    typed: ne
  }),
  quantileSeq: Pm({
    add: rt,
    bignumber: jr,
    compare: Mi,
    divide: er,
    isInteger: zr,
    larger: Ir,
    multiply: Xe,
    partitionSelect: oo,
    smaller: qr,
    smallerEq: Zi,
    subtract: Qt,
    typed: ne
  }),
  variance: km({
    add: rt,
    apply: Wm,
    divide: er,
    isNaN: Wa,
    multiply: Xe,
    subtract: Qt,
    typed: ne
  }),
  std: Bm({
    map: Ti,
    sqrt: ar,
    typed: ne,
    variance: nh
  })
});
nr(hS, {
  BigNumber: ke,
  Complex: At,
  Fraction: Si,
  Matrix: Qa,
  Node: Ar,
  ObjectNode: na,
  OperatorNode: Un,
  ParenthesisNode: qi,
  Range: uN,
  RelationalNode: Ig,
  ResultSet: Vd,
  ArrayNode: ia,
  BlockNode: Fg,
  ConditionalNode: Bg,
  ConstantNode: ii,
  DenseMatrix: pt,
  RangeNode: Rg,
  Chain: ah,
  FunctionAssignmentNode: Pg,
  SparseMatrix: $n,
  IndexNode: aa,
  ImmutableDenseMatrix: lg,
  Index: Dr,
  AccessorNode: sa,
  AssignmentNode: Lg,
  FibonacciHeap: dg,
  Spa: bg,
  Unit: et,
  SymbolNode: ai,
  FunctionNode: si,
  Help: zg,
  Parser: $g
});
ah.createProxy(Ka);
var ze = {
  createBigNumberClass: Au
}, $t = {
  createComplexClass: Cu
}, uh = {
  createMatrixClass: Mu
}, ht = {
  MatrixDependencies: uh,
  createDenseMatrixClass: qu
}, oa = {
  createFractionClass: Tu
}, ie = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  DenseMatrixDependencies: ht,
  FractionDependencies: oa,
  createTyped: wu
}, Hr = {
  typedDependencies: ie,
  createAbs: a0
}, Rr = {
  createNode: Uc
}, yt = {
  typedDependencies: ie,
  createEqualScalar: Gu
}, oi = {
  MatrixDependencies: uh,
  equalScalarDependencies: yt,
  typedDependencies: ie,
  createSparseMatrixClass: Hu
}, fr = {
  typedDependencies: ie,
  createAddScalar: s0
}, Kr = {
  typedDependencies: ie,
  createIsInteger: Bu
}, Le = {
  DenseMatrixDependencies: ht,
  MatrixDependencies: uh,
  SparseMatrixDependencies: oi,
  typedDependencies: ie,
  createMatrix: Xu
}, Ct = {
  isIntegerDependencies: Kr,
  matrixDependencies: Le,
  typedDependencies: ie,
  createConcat: ks
}, bt = {
  DenseMatrixDependencies: ht,
  SparseMatrixDependencies: oi,
  addScalarDependencies: fr,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createAdd: Rc
}, Cr = {
  BigNumberDependencies: ze,
  matrixDependencies: Le,
  typedDependencies: ie,
  createZeros: nl
}, un = {
  addDependencies: bt,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createSubset: Hs
}, ts = {
  NodeDependencies: Rr,
  subsetDependencies: un,
  createAccessorNode: Gc
}, e6 = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAcos: tc
}, t6 = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAcosh: rc
}, r6 = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createAcot: nc
}, n6 = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAcoth: ic
}, i6 = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAcsc: ac
}, a6 = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createAcsch: sc
}, lh = {
  typedDependencies: ie,
  createNot: R0
}, s6 = {
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  notDependencies: lh,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createAnd: Ws
}, o6 = {
  addDependencies: bt,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  notDependencies: lh,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createAndTransform: $m
}, Ug = {
  isIntegerDependencies: Kr,
  typedDependencies: ie,
  createApply: Ua
}, u6 = {
  isIntegerDependencies: Kr,
  typedDependencies: ie,
  createApplyTransform: wm
}, l6 = {
  typedDependencies: ie,
  createArg: q0
}, rs = {
  NodeDependencies: Rr,
  createArrayNode: Hc
}, c6 = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAsec: oc
}, f6 = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAsech: uc
}, p6 = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAsin: lc
}, m6 = {
  typedDependencies: ie,
  createAsinh: cc
}, ES = {
  matrixDependencies: Le,
  NodeDependencies: Rr,
  subsetDependencies: un,
  createAssignmentNode: Qc
}, SS = {
  typedDependencies: ie,
  createAtan: fc
}, h6 = {
  BigNumberDependencies: ze,
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createAtan2: pc
}, d6 = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createAtanh: mc
}, ln = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createBignumber: Yu
}, ns = {
  FractionDependencies: oa,
  typedDependencies: ie,
  createFraction: Ju
}, ui = {
  typedDependencies: ie,
  createNumber: Qu
}, vn = {
  bignumberDependencies: ln,
  fractionDependencies: ns,
  numberDependencies: ui,
  createNumeric: vl
}, Zt = {
  numericDependencies: vn,
  typedDependencies: ie,
  createDivideScalar: yl
}, yn = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createEqual: Rl
}, is = {
  BigNumberDependencies: ze,
  DenseMatrixDependencies: ht,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createRound: bl
}, Gg = {
  DenseMatrixDependencies: ht,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  roundDependencies: is,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createCeil: l0
}, AS = {
  DenseMatrixDependencies: ht,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  roundDependencies: is,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createFloor: Fs
}, CS = {
  ComplexDependencies: $t,
  DenseMatrixDependencies: ht,
  ceilDependencies: Gg,
  equalScalarDependencies: yt,
  floorDependencies: AS,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createFix: m0
}, co = {
  typedDependencies: ie,
  createFormat: fl
}, ua = {
  typedDependencies: ie,
  createIsNumeric: Pu
}, tr = {
  typedDependencies: ie,
  createMultiplyScalar: b0
}, Ii = {
  BigNumberDependencies: ze,
  DenseMatrixDependencies: ht,
  SparseMatrixDependencies: oi,
  matrixDependencies: Le,
  typedDependencies: ie,
  createIdentity: Q0
}, In = {
  equalScalarDependencies: yt,
  typedDependencies: ie,
  createIsZero: zu
}, la = {
  typedDependencies: ie,
  createConj: I0
}, Tr = {
  matrixDependencies: Le,
  typedDependencies: ie,
  createSize: K0
}, ch = {
  addScalarDependencies: fr,
  conjDependencies: la,
  multiplyScalarDependencies: tr,
  sizeDependencies: Tr,
  typedDependencies: ie,
  createDot: kc
}, Rt = {
  addScalarDependencies: fr,
  dotDependencies: ch,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  typedDependencies: ie,
  createMultiply: w0
}, xn = {
  typedDependencies: ie,
  createSubtractScalar: o0
}, Gn = {
  typedDependencies: ie,
  createUnaryMinus: n0
}, TS = {
  divideScalarDependencies: Zt,
  isZeroDependencies: In,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createDet: xf
}, ca = {
  absDependencies: Hr,
  addScalarDependencies: fr,
  detDependencies: TS,
  divideScalarDependencies: Zt,
  identityDependencies: Ii,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createInv: bf
}, bn = {
  ComplexDependencies: $t,
  fractionDependencies: ns,
  identityDependencies: Ii,
  invDependencies: ca,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  numberDependencies: ui,
  typedDependencies: ie,
  createPow: xl
}, tt = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  FractionDependencies: oa,
  absDependencies: Hr,
  addScalarDependencies: fr,
  divideScalarDependencies: Zt,
  equalDependencies: yn,
  fixDependencies: CS,
  formatDependencies: co,
  isNumericDependencies: ua,
  multiplyScalarDependencies: tr,
  numberDependencies: ui,
  powDependencies: bn,
  roundDependencies: is,
  subtractScalarDependencies: xn,
  createUnitClass: Jl
}, g6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createAtomicMass: Kp
}, v6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createAvogadro: em
}, Fi = {
  typedDependencies: ie,
  createIsNegative: Ru
}, fh = {
  typedDependencies: ie,
  createCombinations: Ff
}, Hg = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  multiplyScalarDependencies: tr,
  powDependencies: bn,
  typedDependencies: ie,
  createGamma: Rf
}, fo = {
  gammaDependencies: Hg,
  typedDependencies: ie,
  createFactorial: Lf
}, Qr = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createLarger: zl
}, _S = {
  bignumberDependencies: ln,
  addScalarDependencies: fr,
  combinationsDependencies: fh,
  divideScalarDependencies: Zt,
  factorialDependencies: fo,
  isIntegerDependencies: Kr,
  isNegativeDependencies: Fi,
  largerDependencies: Qr,
  multiplyScalarDependencies: tr,
  numberDependencies: ui,
  powDependencies: bn,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  createStirlingS2: Qf
}, y6 = {
  addScalarDependencies: fr,
  isIntegerDependencies: Kr,
  isNegativeDependencies: Fi,
  stirlingS2Dependencies: _S,
  typedDependencies: ie,
  createBellNumbers: Vf
}, x6 = {
  typedDependencies: ie,
  createBigint: Vu
}, b6 = {
  formatDependencies: co,
  typedDependencies: ie,
  createBin: pl
}, w6 = {
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createBitAnd: Rs
}, N6 = {
  addDependencies: bt,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  notDependencies: lh,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createBitAndTransform: Gm
}, D6 = {
  typedDependencies: ie,
  createBitNot: M0
}, E6 = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createBitOr: Ps
}, S6 = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createBitOrTransform: Hm
}, A6 = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createBitXor: O0
}, MS = {
  createResultSet: Nu
}, OS = {
  NodeDependencies: Rr,
  ResultSetDependencies: MS,
  createBlockNode: Vc
}, C6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createBohrMagneton: Ip
}, T6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createBohrRadius: kp
}, _6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createBoltzmann: tm
}, M6 = {
  typedDependencies: ie,
  createBoolean: ju
}, O6 = {
  addScalarDependencies: fr,
  combinationsDependencies: fh,
  divideScalarDependencies: Zt,
  isIntegerDependencies: Kr,
  isNegativeDependencies: Fi,
  multiplyScalarDependencies: tr,
  typedDependencies: ie,
  createCatalan: Wf
}, qS = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  FractionDependencies: oa,
  isNegativeDependencies: Fi,
  matrixDependencies: Le,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createCbrt: u0
}, IS = {
  typedDependencies: ie,
  createChainClass: gf
}, q6 = {
  ChainDependencies: IS,
  typedDependencies: ie,
  createChain: yf
}, I6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createClassicalElectronRadius: zp
}, F6 = {
  typedDependencies: ie,
  createClone: Iu
}, Vr = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createSmaller: Ll
}, FS = {
  DenseMatrixDependencies: ht,
  smallerDependencies: Vr,
  createImmutableDenseMatrixClass: Vl
}, Qg = {
  typedDependencies: ie,
  createGetMatrixDataType: H0
}, Pr = {
  ImmutableDenseMatrixDependencies: FS,
  getMatrixDataTypeDependencies: Qg,
  createIndexClass: Wl
}, fa = {
  typedDependencies: ie,
  createIsPositive: ku
}, ph = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createLargerEq: $l
}, as = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createSmallerEq: kl
}, ss = {
  bignumberDependencies: ln,
  matrixDependencies: Le,
  addDependencies: bt,
  isPositiveDependencies: fa,
  largerDependencies: Qr,
  largerEqDependencies: ph,
  smallerDependencies: Vr,
  smallerEqDependencies: as,
  typedDependencies: ie,
  createRange: Us
}, BS = {
  IndexDependencies: Pr,
  matrixDependencies: Le,
  rangeDependencies: ss,
  typedDependencies: ie,
  createColumn: zs
}, B6 = {
  IndexDependencies: Pr,
  matrixDependencies: Le,
  rangeDependencies: ss,
  typedDependencies: ie,
  createColumnTransform: Nm
}, R6 = {
  typedDependencies: ie,
  createCombinationsWithRep: Bf
}, pa = {
  BigNumberDependencies: ze,
  DenseMatrixDependencies: ht,
  FractionDependencies: oa,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createCompare: Il
}, Hn = {
  compareDependencies: pa,
  typedDependencies: ie,
  createCompareNatural: Fl
}, RS = {
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createCompareText: Bl
}, PS = {
  NodeDependencies: Rr,
  createConditionalNode: Wc
}, Bi = {
  NodeDependencies: Rr,
  createConstantNode: jc
}, LS = {
  NodeDependencies: Rr,
  typedDependencies: ie,
  createFunctionAssignmentNode: Yc
}, Ri = {
  UnitDependencies: tt,
  NodeDependencies: Rr,
  createSymbolNode: rf
}, Pi = {
  NodeDependencies: Rr,
  SymbolNodeDependencies: Ri,
  createFunctionNode: nf
}, os = {
  NodeDependencies: Rr,
  sizeDependencies: Tr,
  createIndexNode: Zc
}, us = {
  NodeDependencies: Rr,
  createObjectNode: Jc
}, li = {
  NodeDependencies: Rr,
  createOperatorNode: Xc
}, ma = {
  NodeDependencies: Rr,
  createParenthesisNode: Kc
}, kS = {
  NodeDependencies: Rr,
  createRangeNode: ef
}, zS = {
  NodeDependencies: Rr,
  createRelationalNode: tf
}, Qn = {
  AccessorNodeDependencies: ts,
  ArrayNodeDependencies: rs,
  AssignmentNodeDependencies: ES,
  BlockNodeDependencies: OS,
  ConditionalNodeDependencies: PS,
  ConstantNodeDependencies: Bi,
  FunctionAssignmentNodeDependencies: LS,
  FunctionNodeDependencies: Pi,
  IndexNodeDependencies: os,
  ObjectNodeDependencies: us,
  OperatorNodeDependencies: li,
  ParenthesisNodeDependencies: ma,
  RangeNodeDependencies: kS,
  RelationalNodeDependencies: zS,
  SymbolNodeDependencies: Ri,
  numericDependencies: vn,
  typedDependencies: ie,
  createParse: af
}, P6 = {
  parseDependencies: Qn,
  typedDependencies: ie,
  createCompile: sf
}, mh = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createComplex: Zu
}, L6 = {
  addScalarDependencies: fr,
  combinationsDependencies: fh,
  isIntegerDependencies: Kr,
  isNegativeDependencies: Fi,
  isPositiveDependencies: fa,
  largerDependencies: Qr,
  typedDependencies: ie,
  createComposition: jf
}, k6 = {
  isIntegerDependencies: Kr,
  matrixDependencies: Le,
  typedDependencies: ie,
  createConcatTransform: Im
}, z6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createConductanceQuantum: Fp
}, vr = {
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  invDependencies: ca,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  typedDependencies: ie,
  createDivide: Tf
}, $S = {
  addDependencies: bt,
  divideDependencies: vr,
  typedDependencies: ie,
  createMean: Xs
}, Fn = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createSqrt: E0
}, rr = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createSubtract: A0
}, Vg = {
  addDependencies: bt,
  numericDependencies: vn,
  typedDependencies: ie,
  createSum: Zs
}, $6 = {
  addDependencies: bt,
  divideDependencies: vr,
  matrixDependencies: Le,
  meanDependencies: $S,
  multiplyDependencies: Rt,
  powDependencies: bn,
  sqrtDependencies: Fn,
  subtractDependencies: rr,
  sumDependencies: Vg,
  typedDependencies: ie,
  createCorr: If
}, Wg = {
  typedDependencies: ie,
  createCos: hc
}, U6 = {
  typedDependencies: ie,
  createCosh: dc
}, G6 = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createCot: gc
}, H6 = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createCoth: vc
}, Q6 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createCoulomb: Op
}, US = {
  multiplyScalarDependencies: tr,
  numericDependencies: vn,
  typedDependencies: ie,
  createProd: cl
}, V6 = {
  prodDependencies: US,
  sizeDependencies: Tr,
  typedDependencies: ie,
  createCount: L0
}, W6 = {
  UnitDependencies: tt,
  typedDependencies: ie,
  createCreateUnit: ec
}, j6 = {
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  subtractDependencies: rr,
  typedDependencies: ie,
  createCross: k0
}, Y6 = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createCsc: yc
}, Z6 = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createCsch: xc
}, po = {
  matrixDependencies: Le,
  typedDependencies: ie,
  createTranspose: tl
}, jg = {
  conjDependencies: la,
  transposeDependencies: po,
  typedDependencies: ie,
  createCtranspose: rl
}, J6 = {
  typedDependencies: ie,
  createCube: c0
}, Yg = {
  numericDependencies: vn,
  typedDependencies: ie,
  createUnaryPlus: i0
}, X6 = {
  addDependencies: bt,
  typedDependencies: ie,
  unaryPlusDependencies: Yg,
  createCumSum: Js
}, K6 = {
  addDependencies: bt,
  typedDependencies: ie,
  unaryPlusDependencies: Yg,
  createCumSumTransform: Lm
}, Zg = {
  equalDependencies: yn,
  typedDependencies: ie,
  createDeepEqual: Ul
}, GS = {
  ConstantNodeDependencies: Bi,
  FunctionNodeDependencies: Pi,
  OperatorNodeDependencies: li,
  ParenthesisNodeDependencies: ma,
  parseDependencies: Qn,
  typedDependencies: ie,
  createResolve: Kf
}, Jg = {
  bignumberDependencies: ln,
  fractionDependencies: ns,
  AccessorNodeDependencies: ts,
  ArrayNodeDependencies: rs,
  ConstantNodeDependencies: Bi,
  FunctionNodeDependencies: Pi,
  IndexNodeDependencies: os,
  ObjectNodeDependencies: us,
  OperatorNodeDependencies: li,
  SymbolNodeDependencies: Ri,
  matrixDependencies: Le,
  typedDependencies: ie,
  createSimplifyConstant: Jf
}, Xg = {
  AccessorNodeDependencies: ts,
  ArrayNodeDependencies: rs,
  ConstantNodeDependencies: Bi,
  FunctionNodeDependencies: Pi,
  IndexNodeDependencies: os,
  ObjectNodeDependencies: us,
  OperatorNodeDependencies: li,
  ParenthesisNodeDependencies: ma,
  SymbolNodeDependencies: Ri,
  addDependencies: bt,
  divideDependencies: vr,
  equalDependencies: yn,
  isZeroDependencies: In,
  multiplyDependencies: Rt,
  parseDependencies: Qn,
  powDependencies: bn,
  subtractDependencies: rr,
  typedDependencies: ie,
  createSimplifyCore: Xf
}, hh = {
  bignumberDependencies: ln,
  fractionDependencies: ns,
  AccessorNodeDependencies: ts,
  ArrayNodeDependencies: rs,
  ConstantNodeDependencies: Bi,
  FunctionNodeDependencies: Pi,
  IndexNodeDependencies: os,
  ObjectNodeDependencies: us,
  OperatorNodeDependencies: li,
  ParenthesisNodeDependencies: ma,
  SymbolNodeDependencies: Ri,
  addDependencies: bt,
  divideDependencies: vr,
  equalDependencies: yn,
  isZeroDependencies: In,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  parseDependencies: Qn,
  powDependencies: bn,
  resolveDependencies: GS,
  simplifyConstantDependencies: Jg,
  simplifyCoreDependencies: Xg,
  subtractDependencies: rr,
  typedDependencies: ie,
  createSimplify: Zf
}, eP = {
  ConstantNodeDependencies: Bi,
  FunctionNodeDependencies: Pi,
  OperatorNodeDependencies: li,
  ParenthesisNodeDependencies: ma,
  SymbolNodeDependencies: Ri,
  equalDependencies: yn,
  isZeroDependencies: In,
  numericDependencies: vn,
  parseDependencies: Qn,
  simplifyDependencies: hh,
  typedDependencies: ie,
  createDerivative: tp
}, tP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createDeuteronMass: Vp
}, HS = {
  DenseMatrixDependencies: ht,
  SparseMatrixDependencies: oi,
  matrixDependencies: Le,
  typedDependencies: ie,
  createDiag: z0
}, rP = {
  matrixDependencies: Le,
  numberDependencies: ui,
  subtractDependencies: rr,
  typedDependencies: ie,
  createDiff: $s
}, nP = {
  bignumberDependencies: ln,
  matrixDependencies: Le,
  numberDependencies: ui,
  subtractDependencies: rr,
  typedDependencies: ie,
  createDiffTransform: Fm
}, iP = {
  absDependencies: Hr,
  addScalarDependencies: fr,
  deepEqualDependencies: Zg,
  divideScalarDependencies: Zt,
  multiplyScalarDependencies: tr,
  sqrtDependencies: Fn,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  createDistance: _f
}, mo = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createDotDivide: Sl
}, aP = {
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  typedDependencies: ie,
  createDotMultiply: _0
}, sP = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  powDependencies: bn,
  typedDependencies: ie,
  createDotPow: El
}, QS = {
  BigNumberDependencies: ze,
  createE: hp
}, oP = {
  BigNumberDependencies: ze,
  createEfimovFactor: Xp
}, ho = {
  matrixDependencies: Le,
  typedDependencies: ie,
  createFlatten: U0
}, Kg = {
  typedDependencies: ie,
  createIm: F0
}, ev = {
  flattenDependencies: ho,
  matrixDependencies: Le,
  sizeDependencies: Tr,
  typedDependencies: ie,
  createMatrixFromColumns: t0
}, VS = {
  BigNumberDependencies: ze,
  FractionDependencies: oa,
  complexDependencies: mh,
  typedDependencies: ie,
  createSign: D0
}, tv = {
  addScalarDependencies: fr,
  complexDependencies: mh,
  conjDependencies: la,
  divideScalarDependencies: Zt,
  equalDependencies: yn,
  identityDependencies: Ii,
  isZeroDependencies: In,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  signDependencies: VS,
  sqrtDependencies: Fn,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  zerosDependencies: Cr,
  createQr: ff
}, rv = {
  typedDependencies: ie,
  createRe: B0
}, WS = {
  isIntegerDependencies: Kr,
  matrixDependencies: Le,
  typedDependencies: ie,
  createReshape: Y0
}, dh = {
  typedDependencies: ie,
  createSin: Nc
}, nv = {
  DenseMatrixDependencies: ht,
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  createUsolve: Cl
}, jS = {
  DenseMatrixDependencies: ht,
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  createUsolveAll: _l
}, YS = {
  absDependencies: Hr,
  addDependencies: bt,
  addScalarDependencies: fr,
  atanDependencies: SS,
  bignumberDependencies: ln,
  columnDependencies: BS,
  complexDependencies: mh,
  cosDependencies: Wg,
  diagDependencies: HS,
  divideScalarDependencies: Zt,
  dotDependencies: ch,
  equalDependencies: yn,
  flattenDependencies: ho,
  imDependencies: Kg,
  invDependencies: ca,
  largerDependencies: Qr,
  matrixDependencies: Le,
  matrixFromColumnsDependencies: ev,
  multiplyDependencies: Rt,
  multiplyScalarDependencies: tr,
  numberDependencies: ui,
  qrDependencies: tv,
  reDependencies: rv,
  reshapeDependencies: WS,
  sinDependencies: dh,
  sizeDependencies: Tr,
  smallerDependencies: Vr,
  sqrtDependencies: Fn,
  subtractDependencies: rr,
  typedDependencies: ie,
  usolveDependencies: nv,
  usolveAllDependencies: jS,
  createEigs: Nf
}, uP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createElectricConstant: _p
}, lP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createElectronMass: $p
}, cP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createElementaryCharge: qp
}, fP = {
  compareTextDependencies: RS,
  isZeroDependencies: In,
  typedDependencies: ie,
  createEqualText: Pl
}, pP = {
  typedDependencies: ie,
  createErf: ol
}, iv = {
  parseDependencies: Qn,
  typedDependencies: ie,
  createEvaluate: of
}, ZS = {
  typedDependencies: ie,
  createExp: f0
}, mP = {
  absDependencies: Hr,
  addDependencies: bt,
  identityDependencies: Ii,
  invDependencies: ca,
  multiplyDependencies: Rt,
  typedDependencies: ie,
  createExpm: Df
}, hP = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createExpm1: p0
}, dP = {
  createFalse: up
}, gP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createFaraday: rm
}, vP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createFermiCoupling: Up
}, JS = {
  ComplexDependencies: $t,
  createI: Np
}, XS = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createLog2: x0
}, KS = {
  BigNumberDependencies: ze,
  createTau: mp
}, eA = {
  addScalarDependencies: fr,
  ceilDependencies: Gg,
  conjDependencies: la,
  divideScalarDependencies: Zt,
  dotDivideDependencies: mo,
  expDependencies: ZS,
  iDependencies: JS,
  log2Dependencies: XS,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  powDependencies: bn,
  tauDependencies: KS,
  typedDependencies: ie,
  createFft: il
}, tA = {
  largerDependencies: Qr,
  smallerDependencies: Vr,
  createFibonacciHeapClass: jl
}, yP = {
  typedDependencies: ie,
  createFilter: $0
}, xP = {
  typedDependencies: ie,
  createFilterTransform: Dm
}, bP = {
  BigNumberDependencies: ze,
  createFineStructure: Gp
}, wP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createFirstRadiation: nm
}, NP = {
  typedDependencies: ie,
  createForEach: G0
}, DP = {
  typedDependencies: ie,
  createForEachTransform: Em
}, EP = {
  ComplexDependencies: $t,
  addDependencies: bt,
  divideDependencies: vr,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  typedDependencies: ie,
  createFreqz: ip
}, SP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createGasConstant: am
}, AP = {
  BigNumberDependencies: ze,
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  roundDependencies: is,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createGcd: d0
}, CP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createGravitationConstant: Sp
}, TP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createGravity: hm
}, _P = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createHartreeEnergy: Hp
}, MP = {
  isNumericDependencies: ua,
  typedDependencies: ie,
  createHasNumericValue: Lu
}, rA = {
  evaluateDependencies: iv,
  createHelpClass: df
}, OP = {
  HelpDependencies: rA,
  typedDependencies: ie,
  createHelp: vf
}, qP = {
  formatDependencies: co,
  typedDependencies: ie,
  createHex: hl
}, IP = {
  absDependencies: Hr,
  addScalarDependencies: fr,
  divideScalarDependencies: Zt,
  isPositiveDependencies: fa,
  multiplyScalarDependencies: tr,
  smallerDependencies: Vr,
  sqrtDependencies: Fn,
  typedDependencies: ie,
  createHypot: Pc
}, FP = {
  conjDependencies: la,
  dotDivideDependencies: mo,
  fftDependencies: eA,
  typedDependencies: ie,
  createIfft: al
}, nA = {
  IndexDependencies: Pr,
  typedDependencies: ie,
  createIndex: $c
}, BP = {
  IndexDependencies: Pr,
  getMatrixDataTypeDependencies: Qg,
  createIndexTransform: Sm
}, RP = {
  BigNumberDependencies: ze,
  createInfinity: cp
}, PP = {
  absDependencies: Hr,
  addDependencies: bt,
  addScalarDependencies: fr,
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  flattenDependencies: ho,
  isNumericDependencies: ua,
  isZeroDependencies: In,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  multiplyScalarDependencies: tr,
  smallerDependencies: Vr,
  subtractDependencies: rr,
  typedDependencies: ie,
  createIntersect: Mf
}, LP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createInverseConductanceQuantum: Bp
}, iA = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  roundDependencies: is,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createMod: Bs
}, aA = {
  BigNumberDependencies: ze,
  matrixDependencies: Le,
  typedDependencies: ie,
  createXgcd: C0
}, kP = {
  BigNumberDependencies: ze,
  addDependencies: bt,
  equalDependencies: yn,
  isIntegerDependencies: Kr,
  modDependencies: iA,
  smallerDependencies: Vr,
  typedDependencies: ie,
  xgcdDependencies: aA,
  createInvmod: T0
}, go = {
  typedDependencies: ie,
  createIsNaN: $u
}, zP = {
  typedDependencies: ie,
  createIsPrime: gl
}, av = {
  ComplexDependencies: $t,
  divideScalarDependencies: Zt,
  typedDependencies: ie,
  createLog: wl
}, ha = {
  typedDependencies: ie,
  createMap: W0
}, $P = {
  divideDependencies: vr,
  dotDivideDependencies: mo,
  isNumericDependencies: ua,
  logDependencies: av,
  mapDependencies: ha,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  sumDependencies: Vg,
  typedDependencies: ie,
  createKldivergence: kf
}, UP = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createKlitzing: Lp
}, GP = {
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  typedDependencies: ie,
  createKron: V0
}, HP = {
  BigNumberDependencies: ze,
  createLN10: vp
}, QP = {
  BigNumberDependencies: ze,
  createLN2: gp
}, VP = {
  BigNumberDependencies: ze,
  createLOG10E: xp
}, WP = {
  BigNumberDependencies: ze,
  createLOG2E: yp
}, jP = {
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createLcm: v0
}, YP = {
  parseDependencies: Qn,
  typedDependencies: ie,
  createLeafCount: Yf
}, ZP = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createLeftShift: Ml
}, JP = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createLgamma: Pf
}, XP = {
  ComplexDependencies: $t,
  typedDependencies: ie,
  createLog10: y0
}, KP = {
  ComplexDependencies: $t,
  divideScalarDependencies: Zt,
  logDependencies: av,
  typedDependencies: ie,
  createLog1p: Nl
}, e9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createLoschmidt: im
}, sA = {
  DenseMatrixDependencies: ht,
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  createLsolve: Al
}, t9 = {
  DenseMatrixDependencies: ht,
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  createLsolveAll: Tl
}, oA = {
  FibonacciHeapDependencies: tA,
  addScalarDependencies: fr,
  equalScalarDependencies: yt,
  createSpaClass: Yl
}, uA = {
  DenseMatrixDependencies: ht,
  SpaDependencies: oA,
  SparseMatrixDependencies: oi,
  absDependencies: Hr,
  addScalarDependencies: fr,
  divideScalarDependencies: Zt,
  equalScalarDependencies: yt,
  largerDependencies: Qr,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  subtractScalarDependencies: xn,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createLup: cf
}, lA = {
  SparseMatrixDependencies: oi,
  absDependencies: Hr,
  addDependencies: bt,
  divideScalarDependencies: Zt,
  largerDependencies: Qr,
  largerEqDependencies: ph,
  multiplyDependencies: Rt,
  subtractDependencies: rr,
  transposeDependencies: po,
  typedDependencies: ie,
  createSlu: pf
}, cA = {
  DenseMatrixDependencies: ht,
  lsolveDependencies: sA,
  lupDependencies: uA,
  matrixDependencies: Le,
  sluDependencies: lA,
  typedDependencies: ie,
  usolveDependencies: nv,
  createLusolve: mf
}, sv = {
  absDependencies: Hr,
  addDependencies: bt,
  conjDependencies: la,
  ctransposeDependencies: jg,
  eigsDependencies: YS,
  equalScalarDependencies: yt,
  largerDependencies: Qr,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  powDependencies: bn,
  smallerDependencies: Vr,
  sqrtDependencies: Fn,
  typedDependencies: ie,
  createNorm: Lc
}, fA = {
  identityDependencies: Ii,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  normDependencies: sv,
  qrDependencies: tv,
  subtractDependencies: rr,
  typedDependencies: ie,
  createSchur: Af
}, pA = {
  absDependencies: Hr,
  addDependencies: bt,
  concatDependencies: Ct,
  identityDependencies: Ii,
  indexDependencies: nA,
  lusolveDependencies: cA,
  matrixDependencies: Le,
  matrixFromColumnsDependencies: ev,
  multiplyDependencies: Rt,
  rangeDependencies: ss,
  schurDependencies: fA,
  subsetDependencies: un,
  subtractDependencies: rr,
  transposeDependencies: po,
  typedDependencies: ie,
  createSylvester: Sf
}, r9 = {
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  sylvesterDependencies: pA,
  transposeDependencies: po,
  typedDependencies: ie,
  createLyap: Cf
}, gh = {
  compareDependencies: pa,
  isNaNDependencies: go,
  isNumericDependencies: ua,
  typedDependencies: ie,
  createPartitionSelect: Hl
}, mA = {
  addDependencies: bt,
  compareDependencies: pa,
  divideDependencies: vr,
  partitionSelectDependencies: gh,
  typedDependencies: ie,
  createMedian: Of
}, n9 = {
  absDependencies: Hr,
  mapDependencies: ha,
  medianDependencies: mA,
  subtractDependencies: rr,
  typedDependencies: ie,
  createMad: qf
}, i9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createMagneticConstant: Tp
}, a9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createMagneticFluxQuantum: Rp
}, s9 = {
  typedDependencies: ie,
  createMapTransform: Am
}, o9 = {
  isZeroDependencies: In,
  matrixDependencies: Le,
  typedDependencies: ie,
  createMatrixFromFunction: Ku
}, u9 = {
  flattenDependencies: ho,
  matrixDependencies: Le,
  sizeDependencies: Tr,
  typedDependencies: ie,
  createMatrixFromRows: e0
}, ov = {
  largerDependencies: Qr,
  numericDependencies: vn,
  typedDependencies: ie,
  createMax: js
}, l9 = {
  largerDependencies: Qr,
  numericDependencies: vn,
  typedDependencies: ie,
  createMaxTransform: Cm
}, c9 = {
  addDependencies: bt,
  divideDependencies: vr,
  typedDependencies: ie,
  createMeanTransform: Tm
}, f9 = {
  numericDependencies: vn,
  smallerDependencies: Vr,
  typedDependencies: ie,
  createMin: Ys
}, p9 = {
  numericDependencies: vn,
  smallerDependencies: Vr,
  typedDependencies: ie,
  createMinTransform: _m
}, m9 = {
  isNaNDependencies: go,
  isNumericDependencies: ua,
  typedDependencies: ie,
  createMode: ll
}, h9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createMolarMass: pm
}, d9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createMolarMassC12: mm
}, g9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createMolarPlanckConstant: sm
}, v9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createMolarVolume: om
}, y9 = {
  addDependencies: bt,
  divideDependencies: vr,
  factorialDependencies: fo,
  isIntegerDependencies: Kr,
  isPositiveDependencies: fa,
  multiplyDependencies: Rt,
  typedDependencies: ie,
  createMultinomial: zf
}, x9 = {
  BigNumberDependencies: ze,
  createNaN: fp
}, b9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createNeutronMass: Wp
}, w9 = {
  BigNumberDependencies: ze,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createNthRoot: N0
}, N9 = {
  ComplexDependencies: $t,
  divideScalarDependencies: Zt,
  typedDependencies: ie,
  createNthRoots: Dl
}, D9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createNuclearMagneton: Pp
}, E9 = {
  createNull: lp
}, S9 = {
  formatDependencies: co,
  typedDependencies: ie,
  createOct: ml
}, A9 = {
  BigNumberDependencies: ze,
  matrixDependencies: Le,
  typedDependencies: ie,
  createOnes: j0
}, C9 = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createOr: Ls
}, T9 = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createOrTransform: Um
}, hA = {
  evaluateDependencies: iv,
  createParserClass: uf
}, _9 = {
  ParserDependencies: hA,
  typedDependencies: ie,
  createParser: lf
}, M9 = {
  factorialDependencies: fo,
  typedDependencies: ie,
  createPermutations: $f
}, O9 = {
  BigNumberDependencies: ze,
  createPhi: dp
}, uv = {
  BigNumberDependencies: ze,
  createPi: pp
}, q9 = {
  typedDependencies: ie,
  createPickRandom: Uf
}, I9 = {
  ComplexDependencies: $t,
  addDependencies: bt,
  ctransposeDependencies: jg,
  deepEqualDependencies: Zg,
  divideScalarDependencies: Zt,
  dotDependencies: ch,
  dotDivideDependencies: mo,
  equalDependencies: yn,
  invDependencies: ca,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  typedDependencies: ie,
  createPinv: wf
}, F9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createPlanckCharge: ym
}, B9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createPlanckConstant: Ap
}, R9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createPlanckLength: dm
}, P9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createPlanckMass: gm
}, L9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createPlanckTemperature: xm
}, k9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createPlanckTime: vm
}, dA = {
  typedDependencies: ie,
  createTypeOf: Uu
}, z9 = {
  addDependencies: bt,
  cbrtDependencies: qS,
  divideDependencies: vr,
  equalScalarDependencies: yt,
  imDependencies: Kg,
  isZeroDependencies: In,
  multiplyDependencies: Rt,
  reDependencies: rv,
  sqrtDependencies: Fn,
  subtractDependencies: rr,
  typeOfDependencies: dA,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createPolynomialRoot: hf
}, $9 = {
  typedDependencies: ie,
  createPrint: Qs
}, U9 = {
  addDependencies: bt,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createPrintTransform: zm
}, G9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createProtonMass: Qp
}, H9 = {
  bignumberDependencies: ln,
  addDependencies: bt,
  compareDependencies: pa,
  divideDependencies: vr,
  isIntegerDependencies: Kr,
  largerDependencies: Qr,
  multiplyDependencies: Rt,
  partitionSelectDependencies: gh,
  smallerDependencies: Vr,
  smallerEqDependencies: as,
  subtractDependencies: rr,
  typedDependencies: ie,
  createQuantileSeq: eo
}, Q9 = {
  addDependencies: bt,
  bignumberDependencies: ln,
  compareDependencies: pa,
  divideDependencies: vr,
  isIntegerDependencies: Kr,
  largerDependencies: Qr,
  multiplyDependencies: Rt,
  partitionSelectDependencies: gh,
  smallerDependencies: Vr,
  smallerEqDependencies: as,
  subtractDependencies: rr,
  typedDependencies: ie,
  createQuantileSeqTransform: Pm
}, V9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createQuantumOfCirculation: jp
}, W9 = {
  typedDependencies: ie,
  createRandom: Gf
}, j9 = {
  typedDependencies: ie,
  createRandomInt: Hf
}, Y9 = {
  createRangeClass: _u
}, Z9 = {
  bignumberDependencies: ln,
  matrixDependencies: Le,
  addDependencies: bt,
  isPositiveDependencies: fa,
  largerDependencies: Qr,
  largerEqDependencies: ph,
  smallerDependencies: Vr,
  smallerEqDependencies: as,
  typedDependencies: ie,
  createRangeTransform: Mm
}, J9 = {
  bignumberDependencies: ln,
  fractionDependencies: ns,
  AccessorNodeDependencies: ts,
  ArrayNodeDependencies: rs,
  ConstantNodeDependencies: Bi,
  FunctionNodeDependencies: Pi,
  IndexNodeDependencies: os,
  ObjectNodeDependencies: us,
  OperatorNodeDependencies: li,
  ParenthesisNodeDependencies: ma,
  SymbolNodeDependencies: Ri,
  addDependencies: bt,
  divideDependencies: vr,
  equalDependencies: yn,
  isZeroDependencies: In,
  matrixDependencies: Le,
  multiplyDependencies: Rt,
  parseDependencies: Qn,
  powDependencies: bn,
  simplifyDependencies: hh,
  simplifyConstantDependencies: Jg,
  simplifyCoreDependencies: Xg,
  subtractDependencies: rr,
  typedDependencies: ie,
  createRationalize: rp
}, X9 = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createReducedPlanckConstant: Cp
}, K9 = {
  createReplacer: sp
}, eL = {
  matrixDependencies: Le,
  createResize: Z0
}, tL = {
  createReviver: ap
}, rL = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createRightArithShift: Ol
}, nL = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createRightLogShift: ql
}, gA = {
  BigNumberDependencies: ze,
  DenseMatrixDependencies: ht,
  SparseMatrixDependencies: oi,
  addScalarDependencies: fr,
  cosDependencies: Wg,
  matrixDependencies: Le,
  multiplyScalarDependencies: tr,
  normDependencies: sv,
  sinDependencies: dh,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createRotationMatrix: X0
}, iL = {
  multiplyDependencies: Rt,
  rotationMatrixDependencies: gA,
  typedDependencies: ie,
  createRotate: J0
}, aL = {
  IndexDependencies: Pr,
  matrixDependencies: Le,
  rangeDependencies: ss,
  typedDependencies: ie,
  createRow: Gs
}, sL = {
  IndexDependencies: Pr,
  matrixDependencies: Le,
  rangeDependencies: ss,
  typedDependencies: ie,
  createRowTransform: Om
}, oL = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createRydberg: Yp
}, uL = {
  // eslint-disable-line camelcase
  BigNumberDependencies: ze,
  createSQRT1_2: bp
}, lL = {
  BigNumberDependencies: ze,
  createSQRT2: wp
}, cL = {
  BigNumberDependencies: ze,
  createSackurTetrode: um
}, fL = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createSec: bc
}, pL = {
  BigNumberDependencies: ze,
  typedDependencies: ie,
  createSech: wc
}, mL = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createSecondRadiation: lm
}, hL = {
  DenseMatrixDependencies: ht,
  IndexDependencies: Pr,
  compareNaturalDependencies: Hn,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetCartesian: Ac
}, vA = {
  DenseMatrixDependencies: ht,
  IndexDependencies: Pr,
  compareNaturalDependencies: Hn,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetDifference: Cc
}, dL = {
  DenseMatrixDependencies: ht,
  IndexDependencies: Pr,
  compareNaturalDependencies: Hn,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetDistinct: Tc
}, yA = {
  DenseMatrixDependencies: ht,
  IndexDependencies: Pr,
  compareNaturalDependencies: Hn,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetIntersect: _c
}, gL = {
  IndexDependencies: Pr,
  compareNaturalDependencies: Hn,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetIsSubset: Mc
}, vL = {
  IndexDependencies: Pr,
  compareNaturalDependencies: Hn,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetMultiplicity: Oc
}, yL = {
  IndexDependencies: Pr,
  compareNaturalDependencies: Hn,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetPowerset: qc
}, xL = {
  compareNaturalDependencies: Hn,
  typedDependencies: ie,
  createSetSize: Ic
}, xA = {
  IndexDependencies: Pr,
  concatDependencies: Ct,
  setDifferenceDependencies: vA,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetSymDifference: Fc
}, bL = {
  IndexDependencies: Pr,
  concatDependencies: Ct,
  setIntersectDependencies: yA,
  setSymDifferenceDependencies: xA,
  sizeDependencies: Tr,
  subsetDependencies: un,
  typedDependencies: ie,
  createSetUnion: Bc
}, wL = {
  typedDependencies: ie,
  createSinh: Dc
}, NL = {
  absDependencies: Hr,
  addDependencies: bt,
  bignumberDependencies: ln,
  divideDependencies: vr,
  isNegativeDependencies: Fi,
  isPositiveDependencies: fa,
  largerDependencies: Qr,
  mapDependencies: ha,
  matrixDependencies: Le,
  maxDependencies: ov,
  multiplyDependencies: Rt,
  smallerDependencies: Vr,
  subtractDependencies: rr,
  typedDependencies: ie,
  unaryMinusDependencies: Gn,
  createSolveODE: sl
}, DL = {
  compareDependencies: pa,
  compareNaturalDependencies: Hn,
  matrixDependencies: Le,
  typedDependencies: ie,
  createSort: Ql
}, EL = {
  SparseMatrixDependencies: oi,
  typedDependencies: ie,
  createSparse: Kl
}, SL = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createSpeedOfLight: Ep
}, AL = {
  typedDependencies: ie,
  createSplitUnit: r0
}, CL = {
  absDependencies: Hr,
  addDependencies: bt,
  identityDependencies: Ii,
  invDependencies: ca,
  mapDependencies: ha,
  maxDependencies: ov,
  multiplyDependencies: Rt,
  sizeDependencies: Tr,
  sqrtDependencies: Fn,
  subtractDependencies: rr,
  typedDependencies: ie,
  createSqrtm: Ef
}, TL = {
  typedDependencies: ie,
  createSquare: S0
}, _L = {
  matrixDependencies: Le,
  typedDependencies: ie,
  createSqueeze: el
}, lv = {
  addDependencies: bt,
  applyDependencies: Ug,
  divideDependencies: vr,
  isNaNDependencies: go,
  multiplyDependencies: Rt,
  subtractDependencies: rr,
  typedDependencies: ie,
  createVariance: Ks
}, ML = {
  mapDependencies: ha,
  sqrtDependencies: Fn,
  typedDependencies: ie,
  varianceDependencies: lv,
  createStd: to
}, OL = {
  mapDependencies: ha,
  sqrtDependencies: Fn,
  typedDependencies: ie,
  varianceDependencies: lv,
  createStdTransform: Bm
}, qL = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createStefanBoltzmann: cm
}, IL = {
  typedDependencies: ie,
  createString: Wu
}, FL = {
  addDependencies: bt,
  matrixDependencies: Le,
  typedDependencies: ie,
  zerosDependencies: Cr,
  createSubsetTransform: qm
}, BL = {
  addDependencies: bt,
  numericDependencies: vn,
  typedDependencies: ie,
  createSumTransform: Rm
}, RL = {
  OperatorNodeDependencies: li,
  parseDependencies: Qn,
  simplifyDependencies: hh,
  typedDependencies: ie,
  createSymbolicEqual: ep
}, PL = {
  typedDependencies: ie,
  createTan: Ec
}, LL = {
  typedDependencies: ie,
  createTanh: Sc
}, kL = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createThomsonCrossSection: Zp
}, zL = {
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createTo: dl
}, $L = {
  addDependencies: bt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createTrace: zc
}, UL = {
  createTrue: op
}, GL = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  equalScalarDependencies: yt,
  matrixDependencies: Le,
  typedDependencies: ie,
  createUnequal: Gl
}, HL = {
  UnitDependencies: tt,
  typedDependencies: ie,
  createUnitFunction: Xl
}, QL = {
  eDependencies: QS,
  createUppercaseE: Gd
}, VL = {
  piDependencies: uv,
  createUppercasePi: Ud
}, WL = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createVacuumImpedance: Mp
}, jL = {
  addDependencies: bt,
  applyDependencies: Ug,
  divideDependencies: vr,
  isNaNDependencies: go,
  multiplyDependencies: Rt,
  subtractDependencies: rr,
  typedDependencies: ie,
  createVarianceTransform: km
}, YL = {
  createVersion: Dp
}, ZL = {
  BigNumberDependencies: ze,
  createWeakMixingAngle: Jp
}, JL = {
  BigNumberDependencies: ze,
  UnitDependencies: tt,
  createWienDisplacement: fm
}, XL = {
  DenseMatrixDependencies: ht,
  concatDependencies: Ct,
  matrixDependencies: Le,
  typedDependencies: ie,
  createXor: P0
}, KL = {
  BigNumberDependencies: ze,
  ComplexDependencies: $t,
  addDependencies: bt,
  divideDependencies: vr,
  equalDependencies: yn,
  factorialDependencies: fo,
  gammaDependencies: Hg,
  isNegativeDependencies: Fi,
  multiplyDependencies: Rt,
  piDependencies: uv,
  powDependencies: bn,
  sinDependencies: dh,
  smallerEqDependencies: as,
  subtractDependencies: rr,
  typedDependencies: ie,
  createZeta: ul
}, ek = {
  ComplexDependencies: $t,
  addDependencies: bt,
  multiplyDependencies: Rt,
  numberDependencies: ui,
  typedDependencies: ie,
  createZpk2tf: np
}, tk = KR, cv = { exports: {} };
function fv() {
}
fv.prototype = {
  on: function(t, e, r) {
    var n = this.e || (this.e = {});
    return (n[t] || (n[t] = [])).push({
      fn: e,
      ctx: r
    }), this;
  },
  once: function(t, e, r) {
    var n = this;
    function i() {
      n.off(t, i), e.apply(r, arguments);
    }
    return i._ = e, this.on(t, i, r);
  },
  emit: function(t) {
    var e = [].slice.call(arguments, 1), r = ((this.e || (this.e = {}))[t] || []).slice(), n = 0, i = r.length;
    for (n; n < i; n++)
      r[n].fn.apply(r[n].ctx, e);
    return this;
  },
  off: function(t, e) {
    var r = this.e || (this.e = {}), n = r[t], i = [];
    if (n && e)
      for (var a = 0, o = n.length; a < o; a++)
        n[a].fn !== e && n[a].fn._ !== e && i.push(n[a]);
    return i.length ? r[t] = i : delete r[t], this;
  }
};
cv.exports = fv;
cv.exports.TinyEmitter = fv;
var rk = cv.exports;
const nk = /* @__PURE__ */ qs(rk);
function ik(t) {
  var e = new nk();
  return t.on = e.on.bind(e), t.off = e.off.bind(e), t.once = e.once.bind(e), t.emit = e.emit.bind(e), t;
}
function ak(t, e, r, n) {
  function i(y, w) {
    var E = arguments.length;
    if (E !== 1 && E !== 2)
      throw new Pn("import", E, 1, 2);
    w || (w = {});
    function x(C, A, T) {
      if (Array.isArray(A))
        A.forEach((I) => x(C, I));
      else if (typeof A == "object")
        for (var _ in A)
          $e(A, _) && x(C, A[_], _);
      else if (ws(A) || T !== void 0) {
        var O = ws(A) ? g(A) ? A.fn + ".transform" : A.fn : T;
        if ($e(C, O) && C[O] !== A && !w.silent)
          throw new Error('Cannot import "' + O + '" twice');
        C[O] = A;
      } else if (!w.silent)
        throw new TypeError("Factory, Object, or Array expected");
    }
    var N = {};
    x(N, y);
    for (var D in N)
      if ($e(N, D)) {
        var b = N[D];
        if (ws(b))
          s(b, w);
        else if (c(b))
          a(D, b, w);
        else if (!w.silent)
          throw new TypeError("Factory, Object, or Array expected");
      }
  }
  function a(y, w, E) {
    if (E.wrap && typeof w == "function" && (w = u(w)), l(w) && (w = t(y, {
      [w.signature]: w
    })), t.isTypedFunction(r[y]) && t.isTypedFunction(w)) {
      E.override ? w = t(y, w.signatures) : w = t(r[y], w), r[y] = w, delete n[y], o(y, w), r.emit("import", y, function() {
        return w;
      });
      return;
    }
    if (r[y] === void 0 || E.override) {
      r[y] = w, delete n[y], o(y, w), r.emit("import", y, function() {
        return w;
      });
      return;
    }
    if (!E.silent)
      throw new Error('Cannot import "' + y + '": already exists');
  }
  function o(y, w) {
    w && typeof w.transform == "function" ? (r.expression.transform[y] = w.transform, m(y) && (r.expression.mathWithTransform[y] = w.transform)) : (delete r.expression.transform[y], m(y) && (r.expression.mathWithTransform[y] = w));
  }
  function f(y) {
    delete r.expression.transform[y], m(y) ? r.expression.mathWithTransform[y] = r[y] : delete r.expression.mathWithTransform[y];
  }
  function u(y) {
    var w = function() {
      for (var x = [], N = 0, D = arguments.length; N < D; N++) {
        var b = arguments[N];
        x[N] = b && b.valueOf();
      }
      return y.apply(r, x);
    };
    return y.transform && (w.transform = y.transform), w;
  }
  function s(y, w) {
    var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : y.fn;
    if (E.includes("."))
      throw new Error("Factory name should not contain a nested path. Name: " + JSON.stringify(E));
    var x = g(y) ? r.expression.transform : r, N = E in r.expression.transform, D = $e(x, E) ? x[E] : void 0, b = function() {
      var A = {};
      y.dependencies.map(w2).forEach((_) => {
        if (_.includes("."))
          throw new Error("Factory dependency should not contain a nested path. Name: " + JSON.stringify(_));
        _ === "math" ? A.math = r : _ === "mathWithTransform" ? A.mathWithTransform = r.expression.mathWithTransform : _ === "classes" ? A.classes = r : A[_] = r[_];
      });
      var T = /* @__PURE__ */ y(A);
      if (T && typeof T.transform == "function")
        throw new Error('Transforms cannot be attached to factory functions. Please create a separate function for it with export const path = "expression.transform"');
      if (D === void 0 || w.override)
        return T;
      if (t.isTypedFunction(D) && t.isTypedFunction(T))
        return t(D, T);
      if (w.silent)
        return D;
      throw new Error('Cannot import "' + E + '": already exists');
    };
    !y.meta || y.meta.lazy !== !1 ? (Go(x, E, b), D && N ? f(E) : (g(y) || h(y)) && Go(r.expression.mathWithTransform, E, () => x[E])) : (x[E] = b(), D && N ? f(E) : (g(y) || h(y)) && Go(r.expression.mathWithTransform, E, () => x[E])), n[E] = y, r.emit("import", E, b);
  }
  function c(y) {
    return typeof y == "function" || typeof y == "number" || typeof y == "string" || typeof y == "boolean" || y === null || Lr(y) || dn(y) || at(y) || xi(y) || Ye(y) || Array.isArray(y);
  }
  function l(y) {
    return typeof y == "function" && typeof y.signature == "string";
  }
  function m(y) {
    return !$e(d, y);
  }
  function h(y) {
    return !y.fn.includes(".") && // FIXME: make checking on path redundant, check on meta data instead
    !$e(d, y.fn) && (!y.meta || !y.meta.isClass);
  }
  function g(y) {
    return y !== void 0 && y.meta !== void 0 && y.meta.isTransformFunction === !0 || !1;
  }
  var d = {
    expression: !0,
    type: !0,
    docs: !0,
    error: !0,
    json: !0,
    chain: !0
    // chain method not supported. Note that there is a unit chain too.
  };
  return i;
}
function bA(t, e) {
  var r = nr({}, gu, e);
  if (typeof Object.create != "function")
    throw new Error("ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility.");
  var n = ik({
    // only here for backward compatibility for legacy factory functions
    isNumber: ot,
    isComplex: dn,
    isBigNumber: at,
    isBigInt: ud,
    isFraction: xi,
    isUnit: Lr,
    isString: hr,
    isArray: _t,
    isMatrix: Ye,
    isCollection: Yr,
    isDenseMatrix: Ca,
    isSparseMatrix: jn,
    isRange: Ms,
    isIndex: Ba,
    isBoolean: ld,
    isResultSet: cd,
    isHelp: vu,
    isFunction: fd,
    isDate: pd,
    isRegExp: md,
    isObject: Ra,
    isNull: hd,
    isUndefined: dd,
    isAccessorNode: Kn,
    isArrayNode: Wr,
    isAssignmentNode: gd,
    isBlockNode: vd,
    isConditionalNode: yd,
    isConstantNode: wt,
    isFunctionAssignmentNode: Xi,
    isFunctionNode: Bn,
    isIndexNode: bi,
    isNode: Bt,
    isObjectNode: Pa,
    isOperatorNode: Kt,
    isParenthesisNode: Cn,
    isRangeNode: xd,
    isRelationalNode: bd,
    isSymbolNode: ir,
    isChain: yu
  });
  n.config = HA(r, n.emit), n.expression = {
    transform: {},
    mathWithTransform: {
      config: n.config
    }
  };
  var i = [], a = [];
  function o(c) {
    if (ws(c))
      return c(n);
    var l = c[Object.keys(c)[0]];
    if (ws(l))
      return l(n);
    if (!UA(c))
      throw console.warn("Factory object with properties `type`, `name`, and `factory` expected", c), new Error("Factory object with properties `type`, `name`, and `factory` expected");
    var m = i.indexOf(c), h;
    return m === -1 ? (c.math === !0 ? h = c.factory(n.type, r, o, n.typed, n) : h = c.factory(n.type, r, o, n.typed), i.push(c), a.push(h)) : h = a[m], h;
  }
  var f = {};
  function u() {
    for (var c = arguments.length, l = new Array(c), m = 0; m < c; m++)
      l[m] = arguments[m];
    return n.typed.apply(n.typed, l);
  }
  u.isTypedFunction = Gi.isTypedFunction;
  var s = ak(u, o, n, f);
  return n.import = s, n.on("config", () => {
    Object.values(f).forEach((c) => {
      c && c.meta && c.meta.recreateOnConfigChange && s(c, {
        override: !0
      });
    });
  }), n.create = bA.bind(null, t), n.factory = H, n.import(Object.values($A(t))), n.ArgumentsError = Pn, n.DimensionError = mt, n.IndexError = nn, n;
}
const wA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AccessorNode: sa,
  AccessorNodeDependencies: ts,
  ArgumentsError: Pn,
  ArrayNode: ia,
  ArrayNodeDependencies: rs,
  AssignmentNode: Lg,
  AssignmentNodeDependencies: ES,
  BigNumber: ke,
  BigNumberDependencies: ze,
  BlockNode: Fg,
  BlockNodeDependencies: OS,
  Chain: ah,
  ChainDependencies: IS,
  Complex: At,
  ComplexDependencies: $t,
  ConditionalNode: Bg,
  ConditionalNodeDependencies: PS,
  ConstantNode: ii,
  ConstantNodeDependencies: Bi,
  DenseMatrix: pt,
  DenseMatrixDependencies: ht,
  DimensionError: mt,
  EDependencies: QL,
  FibonacciHeap: dg,
  FibonacciHeapDependencies: tA,
  Fraction: Si,
  FractionDependencies: oa,
  FunctionAssignmentNode: Pg,
  FunctionAssignmentNodeDependencies: LS,
  FunctionNode: si,
  FunctionNodeDependencies: Pi,
  Help: zg,
  HelpDependencies: rA,
  ImmutableDenseMatrix: lg,
  ImmutableDenseMatrixDependencies: FS,
  Index: Dr,
  IndexDependencies: Pr,
  IndexError: nn,
  IndexNode: aa,
  IndexNodeDependencies: os,
  InfinityDependencies: RP,
  LN10: nN,
  LN10Dependencies: HP,
  LN2: hN,
  LN2Dependencies: QP,
  LOG10E: iN,
  LOG10EDependencies: VP,
  LOG2E: FN,
  LOG2EDependencies: WP,
  Matrix: Qa,
  MatrixDependencies: uh,
  NaNDependencies: x9,
  Node: Ar,
  NodeDependencies: Rr,
  ObjectNode: na,
  ObjectNodeDependencies: us,
  OperatorNode: Un,
  OperatorNodeDependencies: li,
  PIDependencies: VL,
  ParenthesisNode: qi,
  ParenthesisNodeDependencies: ma,
  Parser: $g,
  ParserDependencies: hA,
  Range: uN,
  RangeDependencies: Y9,
  RangeNode: Rg,
  RangeNodeDependencies: kS,
  RelationalNode: Ig,
  RelationalNodeDependencies: zS,
  ResultSet: Vd,
  ResultSetDependencies: MS,
  SQRT1_2: lN,
  SQRT1_2Dependencies: uL,
  SQRT2: gN,
  SQRT2Dependencies: lL,
  Spa: bg,
  SpaDependencies: oA,
  SparseMatrix: $n,
  SparseMatrixDependencies: oi,
  SymbolNode: ai,
  SymbolNodeDependencies: Ri,
  Unit: et,
  UnitDependencies: tt,
  _Infinity: rN,
  _NaN: aN,
  _false: eN,
  _null: sN,
  _true: fN,
  abs: It,
  absDependencies: Hr,
  acos: jd,
  acosDependencies: e6,
  acosh: VN,
  acoshDependencies: t6,
  acot: yN,
  acotDependencies: r6,
  acoth: iD,
  acothDependencies: n6,
  acsc: xN,
  acscDependencies: i6,
  acsch: WN,
  acschDependencies: a6,
  add: rt,
  addDependencies: bt,
  addScalar: sr,
  addScalarDependencies: fr,
  all: tk,
  and: ZD,
  andDependencies: s6,
  andTransformDependencies: o6,
  apply: Wm,
  applyDependencies: Ug,
  applyTransformDependencies: u6,
  arg: Cs,
  argDependencies: l6,
  asec: jN,
  asecDependencies: c6,
  asech: bN,
  asechDependencies: f6,
  asin: cD,
  asinDependencies: p6,
  asinh: wN,
  asinhDependencies: m6,
  atan: Yd,
  atan2: sg,
  atan2Dependencies: h6,
  atanDependencies: SS,
  atanh: NN,
  atanhDependencies: d6,
  atomicMass: iE,
  atomicMassDependencies: g6,
  avogadro: RE,
  avogadroDependencies: v6,
  bellNumbers: XE,
  bellNumbersDependencies: y6,
  bigint: DN,
  bigintDependencies: x6,
  bignumber: jr,
  bignumberDependencies: ln,
  bin: aD,
  binDependencies: b6,
  bitAnd: wD,
  bitAndDependencies: w6,
  bitAndTransformDependencies: N6,
  bitNot: EN,
  bitNotDependencies: D6,
  bitOr: ND,
  bitOrDependencies: E6,
  bitOrTransformDependencies: S6,
  bitXor: DD,
  bitXorDependencies: A6,
  bohrMagneton: aE,
  bohrMagnetonDependencies: C6,
  bohrRadius: PE,
  bohrRadiusDependencies: T6,
  boltzmann: sE,
  boltzmannDependencies: _6,
  boolean: SN,
  booleanDependencies: M6,
  catalan: ED,
  catalanDependencies: O6,
  cbrt: ng,
  cbrtDependencies: qS,
  ceil: eh,
  ceilDependencies: Gg,
  chain: gS,
  chainDependencies: q6,
  classicalElectronRadius: aS,
  classicalElectronRadiusDependencies: I6,
  clone: AN,
  cloneDependencies: F6,
  column: wg,
  columnDependencies: BS,
  columnTransformDependencies: B6,
  combinations: ro,
  combinationsDependencies: fh,
  combinationsWithRep: YN,
  combinationsWithRepDependencies: R6,
  compare: Mi,
  compareDependencies: pa,
  compareNatural: qn,
  compareNaturalDependencies: Hn,
  compareText: og,
  compareTextDependencies: RS,
  compile: vS,
  compileDependencies: P6,
  complex: zt,
  complexDependencies: mh,
  composition: PD,
  compositionDependencies: L6,
  concat: Nt,
  concatDependencies: Ct,
  concatTransformDependencies: k6,
  conductanceQuantum: oE,
  conductanceQuantumDependencies: z6,
  config: Te,
  conj: kn,
  conjDependencies: la,
  corr: sS,
  corrDependencies: $6,
  cos: Qm,
  cosDependencies: Wg,
  cosh: ZN,
  coshDependencies: U6,
  cot: CN,
  cotDependencies: G6,
  coth: sD,
  cothDependencies: H6,
  coulomb: uE,
  coulombDependencies: Q6,
  count: fD,
  countDependencies: V6,
  create: bA,
  createAbs: a0,
  createAccessorNode: Gc,
  createAcos: tc,
  createAcosh: rc,
  createAcot: nc,
  createAcoth: ic,
  createAcsc: ac,
  createAcsch: sc,
  createAdd: Rc,
  createAddScalar: s0,
  createAnd: Ws,
  createAndTransform: $m,
  createApply: Ua,
  createApplyTransform: wm,
  createArg: q0,
  createArrayNode: Hc,
  createAsec: oc,
  createAsech: uc,
  createAsin: lc,
  createAsinh: cc,
  createAssignmentNode: Qc,
  createAtan: fc,
  createAtan2: pc,
  createAtanh: mc,
  createAtomicMass: Kp,
  createAvogadro: em,
  createBellNumbers: Vf,
  createBigNumberClass: Au,
  createBigint: Vu,
  createBignumber: Yu,
  createBin: pl,
  createBitAnd: Rs,
  createBitAndTransform: Gm,
  createBitNot: M0,
  createBitOr: Ps,
  createBitOrTransform: Hm,
  createBitXor: O0,
  createBlockNode: Vc,
  createBohrMagneton: Ip,
  createBohrRadius: kp,
  createBoltzmann: tm,
  createBoolean: ju,
  createCatalan: Wf,
  createCbrt: u0,
  createCeil: l0,
  createChain: yf,
  createChainClass: gf,
  createClassicalElectronRadius: zp,
  createClone: Iu,
  createColumn: zs,
  createColumnTransform: Nm,
  createCombinations: Ff,
  createCombinationsWithRep: Bf,
  createCompare: Il,
  createCompareNatural: Fl,
  createCompareText: Bl,
  createCompile: sf,
  createComplex: Zu,
  createComplexClass: Cu,
  createComposition: jf,
  createConcat: ks,
  createConcatTransform: Im,
  createConditionalNode: Wc,
  createConductanceQuantum: Fp,
  createConj: I0,
  createConstantNode: jc,
  createCorr: If,
  createCos: hc,
  createCosh: dc,
  createCot: gc,
  createCoth: vc,
  createCoulomb: Op,
  createCount: L0,
  createCreateUnit: ec,
  createCross: k0,
  createCsc: yc,
  createCsch: xc,
  createCtranspose: rl,
  createCube: c0,
  createCumSum: Js,
  createCumSumTransform: Lm,
  createDeepEqual: Ul,
  createDenseMatrixClass: qu,
  createDerivative: tp,
  createDet: xf,
  createDeuteronMass: Vp,
  createDiag: z0,
  createDiff: $s,
  createDiffTransform: Fm,
  createDistance: _f,
  createDivide: Tf,
  createDivideScalar: yl,
  createDot: kc,
  createDotDivide: Sl,
  createDotMultiply: _0,
  createDotPow: El,
  createE: hp,
  createEfimovFactor: Xp,
  createEigs: Nf,
  createElectricConstant: _p,
  createElectronMass: $p,
  createElementaryCharge: qp,
  createEqual: Rl,
  createEqualScalar: Gu,
  createEqualText: Pl,
  createErf: ol,
  createEvaluate: of,
  createExp: f0,
  createExpm: Df,
  createExpm1: p0,
  createFactorial: Lf,
  createFalse: up,
  createFaraday: rm,
  createFermiCoupling: Up,
  createFft: il,
  createFibonacciHeapClass: jl,
  createFilter: $0,
  createFilterTransform: Dm,
  createFineStructure: Gp,
  createFirstRadiation: nm,
  createFix: m0,
  createFlatten: U0,
  createFloor: Fs,
  createForEach: G0,
  createForEachTransform: Em,
  createFormat: fl,
  createFraction: Ju,
  createFractionClass: Tu,
  createFreqz: ip,
  createFunctionAssignmentNode: Yc,
  createFunctionNode: nf,
  createGamma: Rf,
  createGasConstant: am,
  createGcd: d0,
  createGetMatrixDataType: H0,
  createGravitationConstant: Sp,
  createGravity: hm,
  createHartreeEnergy: Hp,
  createHasNumericValue: Lu,
  createHelp: vf,
  createHelpClass: df,
  createHex: hl,
  createHypot: Pc,
  createI: Np,
  createIdentity: Q0,
  createIfft: al,
  createIm: F0,
  createImmutableDenseMatrixClass: Vl,
  createIndex: $c,
  createIndexClass: Wl,
  createIndexNode: Zc,
  createIndexTransform: Sm,
  createInfinity: cp,
  createIntersect: Mf,
  createInv: bf,
  createInverseConductanceQuantum: Bp,
  createInvmod: T0,
  createIsInteger: Bu,
  createIsNaN: $u,
  createIsNegative: Ru,
  createIsNumeric: Pu,
  createIsPositive: ku,
  createIsPrime: gl,
  createIsZero: zu,
  createKldivergence: kf,
  createKlitzing: Lp,
  createKron: V0,
  createLN10: vp,
  createLN2: gp,
  createLOG10E: xp,
  createLOG2E: yp,
  createLarger: zl,
  createLargerEq: $l,
  createLcm: v0,
  createLeafCount: Yf,
  createLeftShift: Ml,
  createLgamma: Pf,
  createLog: wl,
  createLog10: y0,
  createLog1p: Nl,
  createLog2: x0,
  createLoschmidt: im,
  createLsolve: Al,
  createLsolveAll: Tl,
  createLup: cf,
  createLusolve: mf,
  createLyap: Cf,
  createMad: qf,
  createMagneticConstant: Tp,
  createMagneticFluxQuantum: Rp,
  createMap: W0,
  createMapTransform: Am,
  createMatrix: Xu,
  createMatrixClass: Mu,
  createMatrixFromColumns: t0,
  createMatrixFromFunction: Ku,
  createMatrixFromRows: e0,
  createMax: js,
  createMaxTransform: Cm,
  createMean: Xs,
  createMeanTransform: Tm,
  createMedian: Of,
  createMin: Ys,
  createMinTransform: _m,
  createMod: Bs,
  createMode: ll,
  createMolarMass: pm,
  createMolarMassC12: mm,
  createMolarPlanckConstant: sm,
  createMolarVolume: om,
  createMultinomial: zf,
  createMultiply: w0,
  createMultiplyScalar: b0,
  createNaN: fp,
  createNeutronMass: Wp,
  createNode: Uc,
  createNorm: Lc,
  createNot: R0,
  createNthRoot: N0,
  createNthRoots: Dl,
  createNuclearMagneton: Pp,
  createNull: lp,
  createNumber: Qu,
  createNumeric: vl,
  createObjectNode: Jc,
  createOct: ml,
  createOnes: j0,
  createOperatorNode: Xc,
  createOr: Ls,
  createOrTransform: Um,
  createParenthesisNode: Kc,
  createParse: af,
  createParser: lf,
  createParserClass: uf,
  createPartitionSelect: Hl,
  createPermutations: $f,
  createPhi: dp,
  createPi: pp,
  createPickRandom: Uf,
  createPinv: wf,
  createPlanckCharge: ym,
  createPlanckConstant: Ap,
  createPlanckLength: dm,
  createPlanckMass: gm,
  createPlanckTemperature: xm,
  createPlanckTime: vm,
  createPolynomialRoot: hf,
  createPow: xl,
  createPrint: Qs,
  createPrintTransform: zm,
  createProd: cl,
  createProtonMass: Qp,
  createQr: ff,
  createQuantileSeq: eo,
  createQuantileSeqTransform: Pm,
  createQuantumOfCirculation: jp,
  createRandom: Gf,
  createRandomInt: Hf,
  createRange: Us,
  createRangeClass: _u,
  createRangeNode: ef,
  createRangeTransform: Mm,
  createRationalize: rp,
  createRe: B0,
  createReducedPlanckConstant: Cp,
  createRelationalNode: tf,
  createReplacer: sp,
  createReshape: Y0,
  createResize: Z0,
  createResolve: Kf,
  createResultSet: Nu,
  createReviver: ap,
  createRightArithShift: Ol,
  createRightLogShift: ql,
  createRotate: J0,
  createRotationMatrix: X0,
  createRound: bl,
  createRow: Gs,
  createRowTransform: Om,
  createRydberg: Yp,
  createSQRT1_2: bp,
  createSQRT2: wp,
  createSackurTetrode: um,
  createSchur: Af,
  createSec: bc,
  createSech: wc,
  createSecondRadiation: lm,
  createSetCartesian: Ac,
  createSetDifference: Cc,
  createSetDistinct: Tc,
  createSetIntersect: _c,
  createSetIsSubset: Mc,
  createSetMultiplicity: Oc,
  createSetPowerset: qc,
  createSetSize: Ic,
  createSetSymDifference: Fc,
  createSetUnion: Bc,
  createSign: D0,
  createSimplify: Zf,
  createSimplifyConstant: Jf,
  createSimplifyCore: Xf,
  createSin: Nc,
  createSinh: Dc,
  createSize: K0,
  createSlu: pf,
  createSmaller: Ll,
  createSmallerEq: kl,
  createSolveODE: sl,
  createSort: Ql,
  createSpaClass: Yl,
  createSparse: Kl,
  createSparseMatrixClass: Hu,
  createSpeedOfLight: Ep,
  createSplitUnit: r0,
  createSqrt: E0,
  createSqrtm: Ef,
  createSquare: S0,
  createSqueeze: el,
  createStd: to,
  createStdTransform: Bm,
  createStefanBoltzmann: cm,
  createStirlingS2: Qf,
  createString: Wu,
  createSubset: Hs,
  createSubsetTransform: qm,
  createSubtract: A0,
  createSubtractScalar: o0,
  createSum: Zs,
  createSumTransform: Rm,
  createSylvester: Sf,
  createSymbolNode: rf,
  createSymbolicEqual: ep,
  createTan: Ec,
  createTanh: Sc,
  createTau: mp,
  createThomsonCrossSection: Zp,
  createTo: dl,
  createTrace: zc,
  createTranspose: tl,
  createTrue: op,
  createTypeOf: Uu,
  createTyped: wu,
  createUnaryMinus: n0,
  createUnaryPlus: i0,
  createUnequal: Gl,
  createUnit: LE,
  createUnitClass: Jl,
  createUnitDependencies: W6,
  createUnitFunction: Xl,
  createUppercaseE: Gd,
  createUppercasePi: Ud,
  createUsolve: Cl,
  createUsolveAll: _l,
  createVacuumImpedance: Mp,
  createVariance: Ks,
  createVarianceTransform: km,
  createVersion: Dp,
  createWeakMixingAngle: Jp,
  createWienDisplacement: fm,
  createXgcd: C0,
  createXor: P0,
  createZeros: nl,
  createZeta: ul,
  createZpk2tf: np,
  cross: LD,
  crossDependencies: j6,
  csc: Zd,
  cscDependencies: Y6,
  csch: JN,
  cschDependencies: Z6,
  ctranspose: Ya,
  ctransposeDependencies: jg,
  cube: TN,
  cubeDependencies: J6,
  cumsum: SD,
  cumsumDependencies: X6,
  cumsumTransformDependencies: K6,
  deepEqual: Xm,
  deepEqualDependencies: Zg,
  derivative: NS,
  derivativeDependencies: eP,
  det: th,
  detDependencies: TS,
  deuteronMass: lE,
  deuteronMassDependencies: tP,
  diag: ig,
  diagDependencies: HS,
  diff: AD,
  diffDependencies: rP,
  diffTransformDependencies: nP,
  distance: CD,
  distanceDependencies: iP,
  divide: er,
  divideDependencies: vr,
  divideScalar: Yt,
  divideScalarDependencies: Zt,
  docs: Jw,
  dot: ao,
  dotDependencies: ch,
  dotDivide: Za,
  dotDivideDependencies: mo,
  dotMultiply: kD,
  dotMultiplyDependencies: aP,
  dotPow: cE,
  dotPowDependencies: sP,
  e: sd,
  eDependencies: QS,
  efimovFactor: mN,
  efimovFactorDependencies: oP,
  eigs: Cg,
  eigsDependencies: YS,
  electricConstant: fE,
  electricConstantDependencies: uP,
  electronMass: kE,
  electronMassDependencies: lP,
  elementaryCharge: pE,
  elementaryChargeDependencies: cP,
  equal: on,
  equalDependencies: yn,
  equalScalar: dt,
  equalScalarDependencies: yt,
  equalText: TD,
  equalTextDependencies: fP,
  erf: _N,
  erfDependencies: pP,
  evaluate: Nr,
  evaluateDependencies: iv,
  exp: Jd,
  expDependencies: ZS,
  expm: mE,
  expm1: MN,
  expm1Dependencies: hP,
  expmDependencies: mP,
  factorial: Xa,
  factorialDependencies: fo,
  factory: H,
  falseDependencies: dP,
  faraday: hE,
  faradayDependencies: gP,
  fermiCoupling: KE,
  fermiCouplingDependencies: vP,
  fft: Eg,
  fftDependencies: eA,
  filter: ON,
  filterDependencies: yP,
  filterTransformDependencies: xP,
  fineStructure: tN,
  fineStructureDependencies: bP,
  firstRadiation: zE,
  firstRadiationDependencies: wP,
  fix: gg,
  fixDependencies: CS,
  flatten: Ja,
  flattenDependencies: ho,
  floor: ug,
  floorDependencies: AS,
  forEach: qN,
  forEachDependencies: NP,
  forEachTransformDependencies: DP,
  format: Va,
  formatDependencies: co,
  fraction: ra,
  fractionDependencies: ns,
  freqz: oS,
  freqzDependencies: EP,
  gamma: rh,
  gammaDependencies: Hg,
  gasConstant: eS,
  gasConstantDependencies: SP,
  gcd: _D,
  gcdDependencies: AP,
  getMatrixDataType: Vm,
  getMatrixDataTypeDependencies: Qg,
  gravitationConstant: dE,
  gravitationConstantDependencies: CP,
  gravity: $E,
  gravityDependencies: TP,
  hartreeEnergy: gE,
  hartreeEnergyDependencies: _P,
  hasNumericValue: pD,
  hasNumericValueDependencies: MP,
  help: DS,
  helpDependencies: OP,
  hex: IN,
  hexDependencies: qP,
  hypot: MD,
  hypotDependencies: IP,
  i: Qd,
  iDependencies: JS,
  identity: ni,
  identityDependencies: Ii,
  ifft: vE,
  ifftDependencies: FP,
  im: ji,
  imDependencies: Kg,
  index: vg,
  indexDependencies: nA,
  indexTransformDependencies: BP,
  intersect: zD,
  intersectDependencies: PP,
  inv: Oi,
  invDependencies: ca,
  inverseConductanceQuantum: UE,
  inverseConductanceQuantumDependencies: LP,
  invmod: $D,
  invmodDependencies: kP,
  isAccessorNode: Kn,
  isArray: _t,
  isArrayNode: Wr,
  isAssignmentNode: gd,
  isBigInt: ud,
  isBigNumber: at,
  isBlockNode: vd,
  isBoolean: ld,
  isChain: yu,
  isCollection: Yr,
  isComplex: dn,
  isConditionalNode: yd,
  isConstantNode: wt,
  isDate: pd,
  isDenseMatrix: Ca,
  isFraction: xi,
  isFunction: fd,
  isFunctionAssignmentNode: Xi,
  isFunctionNode: Bn,
  isHelp: vu,
  isIndex: Ba,
  isIndexNode: bi,
  isInteger: zr,
  isIntegerDependencies: Kr,
  isMatrix: Ye,
  isNaN: Wa,
  isNaNDependencies: go,
  isNegative: ri,
  isNegativeDependencies: Fi,
  isNode: Bt,
  isNull: hd,
  isNumber: ot,
  isNumeric: _i,
  isNumericDependencies: ua,
  isObject: Ra,
  isObjectNode: Pa,
  isOperatorNode: Kt,
  isParenthesisNode: Cn,
  isPositive: Ai,
  isPositiveDependencies: fa,
  isPrime: XN,
  isPrimeDependencies: zP,
  isRange: Ms,
  isRangeNode: xd,
  isRegExp: md,
  isRelationalNode: bd,
  isResultSet: cd,
  isSparseMatrix: jn,
  isString: hr,
  isSymbolNode: ir,
  isUndefined: dd,
  isUnit: Lr,
  isZero: gn,
  isZeroDependencies: In,
  kldivergence: tS,
  kldivergenceDependencies: $P,
  klitzing: yE,
  klitzingDependencies: UP,
  kron: mD,
  kronDependencies: GP,
  larger: Ir,
  largerDependencies: Qr,
  largerEq: io,
  largerEqDependencies: ph,
  lcm: UD,
  lcmDependencies: jP,
  leafCount: xS,
  leafCountDependencies: YP,
  leftShift: hD,
  leftShiftDependencies: ZP,
  lgamma: BN,
  lgammaDependencies: JP,
  log: so,
  log10: RN,
  log10Dependencies: XP,
  log1p: GD,
  log1pDependencies: KP,
  log2: Ci,
  log2Dependencies: XS,
  logDependencies: av,
  loschmidt: xE,
  loschmidtDependencies: e9,
  lsolve: ag,
  lsolveAll: OD,
  lsolveAllDependencies: t9,
  lsolveDependencies: sA,
  lup: Ng,
  lupDependencies: uA,
  lusolve: Sg,
  lusolveDependencies: cA,
  lyap: mS,
  lyapDependencies: r9,
  mad: uS,
  madDependencies: n9,
  magneticConstant: bE,
  magneticConstantDependencies: i9,
  magneticFluxQuantum: GE,
  magneticFluxQuantumDependencies: a9,
  map: Ti,
  mapDependencies: ha,
  mapTransformDependencies: s9,
  matrix: Pe,
  matrixDependencies: Le,
  matrixFromColumns: jm,
  matrixFromColumnsDependencies: ev,
  matrixFromFunction: oD,
  matrixFromFunctionDependencies: o9,
  matrixFromRows: qD,
  matrixFromRowsDependencies: u9,
  max: uo,
  maxDependencies: ov,
  maxTransformDependencies: l9,
  mean: Tg,
  meanDependencies: $S,
  meanTransformDependencies: c9,
  median: _g,
  medianDependencies: mA,
  min: cg,
  minDependencies: f9,
  minTransformDependencies: p9,
  mod: fg,
  modDependencies: iA,
  mode: uD,
  modeDependencies: m9,
  molarMass: wE,
  molarMassC12: HE,
  molarMassC12Dependencies: d9,
  molarMassDependencies: h9,
  molarPlanckConstant: NE,
  molarPlanckConstantDependencies: g9,
  molarVolume: rS,
  molarVolumeDependencies: v9,
  multinomial: QE,
  multinomialDependencies: y9,
  multiply: Xe,
  multiplyDependencies: Rt,
  multiplyScalar: Xt,
  multiplyScalarDependencies: tr,
  neutronMass: DE,
  neutronMassDependencies: b9,
  norm: ih,
  normDependencies: sv,
  not: Ts,
  notDependencies: lh,
  nthRoot: dD,
  nthRootDependencies: w9,
  nthRoots: ID,
  nthRootsDependencies: N9,
  nuclearMagneton: EE,
  nuclearMagnetonDependencies: D9,
  nullDependencies: E9,
  number: zn,
  numberDependencies: ui,
  numeric: rn,
  numericDependencies: vn,
  oct: PN,
  octDependencies: S9,
  ones: gD,
  onesDependencies: A9,
  or: FD,
  orDependencies: C9,
  orTransformDependencies: T9,
  parse: xt,
  parseDependencies: Qn,
  parser: bS,
  parserDependencies: _9,
  partitionSelect: oo,
  partitionSelectDependencies: gh,
  permutations: VE,
  permutationsDependencies: M9,
  phi: oN,
  phiDependencies: O9,
  pi: yi,
  piDependencies: uv,
  pickRandom: LN,
  pickRandomDependencies: q9,
  pinv: KD,
  pinvDependencies: I9,
  planckCharge: SE,
  planckChargeDependencies: F9,
  planckConstant: nS,
  planckConstantDependencies: B9,
  planckLength: AE,
  planckLengthDependencies: R9,
  planckMass: WE,
  planckMassDependencies: P9,
  planckTemperature: CE,
  planckTemperatureDependencies: L9,
  planckTime: fS,
  planckTimeDependencies: k9,
  polynomialRoot: jE,
  polynomialRootDependencies: z9,
  pow: Dt,
  powDependencies: bn,
  print: kN,
  printDependencies: $9,
  printTransformDependencies: U9,
  prod: eg,
  prodDependencies: US,
  protonMass: TE,
  protonMassDependencies: G9,
  qr: Ym,
  qrDependencies: tv,
  quantileSeq: iS,
  quantileSeqDependencies: H9,
  quantileSeqTransformDependencies: Q9,
  quantumOfCirculation: _E,
  quantumOfCirculationDependencies: V9,
  random: zN,
  randomDependencies: W9,
  randomInt: KN,
  randomIntDependencies: j9,
  range: Ji,
  rangeDependencies: ss,
  rangeTransformDependencies: Z9,
  rationalize: wS,
  rationalizeDependencies: J9,
  re: Yi,
  reDependencies: rv,
  reducedPlanckConstant: ME,
  reducedPlanckConstantDependencies: X9,
  replacer: dN,
  replacerDependencies: K9,
  reshape: tg,
  reshapeDependencies: WS,
  resize: vD,
  resizeDependencies: eL,
  resolve: kg,
  resolveDependencies: GS,
  reviver: dS,
  reviverDependencies: tL,
  rightArithShift: yD,
  rightArithShiftDependencies: rL,
  rightLogShift: BD,
  rightLogShiftDependencies: nL,
  rotate: pS,
  rotateDependencies: iL,
  rotationMatrix: Mg,
  rotationMatrixDependencies: gA,
  round: qt,
  roundDependencies: is,
  row: JD,
  rowDependencies: aL,
  rowTransformDependencies: sL,
  rydberg: OE,
  rydbergDependencies: oL,
  sackurTetrode: cN,
  sackurTetrodeDependencies: cL,
  schur: Og,
  schurDependencies: fA,
  sec: $N,
  secDependencies: fL,
  sech: eD,
  sechDependencies: pL,
  secondRadiation: qE,
  secondRadiationDependencies: mL,
  setCartesian: HD,
  setCartesianDependencies: hL,
  setDifference: yg,
  setDifferenceDependencies: vA,
  setDistinct: QD,
  setDistinctDependencies: dL,
  setIntersect: Dg,
  setIntersectDependencies: yA,
  setIsSubset: VD,
  setIsSubsetDependencies: gL,
  setMultiplicity: XD,
  setMultiplicityDependencies: vL,
  setPowerset: WD,
  setPowersetDependencies: yL,
  setSize: YE,
  setSizeDependencies: xL,
  setSymDifference: xg,
  setSymDifferenceDependencies: xA,
  setUnion: eE,
  setUnionDependencies: bL,
  sign: Xd,
  signDependencies: VS,
  simplify: lo,
  simplifyConstant: sh,
  simplifyConstantDependencies: Jg,
  simplifyCore: oh,
  simplifyCoreDependencies: Xg,
  simplifyDependencies: hh,
  sin: no,
  sinDependencies: dh,
  sinh: tD,
  sinhDependencies: wL,
  size: gr,
  sizeDependencies: Tr,
  slu: pg,
  sluDependencies: lA,
  smaller: qr,
  smallerDependencies: Vr,
  smallerEq: Zi,
  smallerEqDependencies: as,
  solveODE: ZE,
  solveODEDependencies: NL,
  sort: jD,
  sortDependencies: DL,
  sparse: rD,
  sparseDependencies: EL,
  speedOfLight: IE,
  speedOfLightDependencies: SL,
  splitUnit: UN,
  splitUnitDependencies: AL,
  sqrt: ar,
  sqrtDependencies: Fn,
  sqrtm: tE,
  sqrtmDependencies: CL,
  square: GN,
  squareDependencies: TL,
  squeeze: lD,
  squeezeDependencies: _L,
  std: lS,
  stdDependencies: ML,
  stdTransformDependencies: OL,
  stefanBoltzmann: FE,
  stefanBoltzmannDependencies: qL,
  stirlingS2: Ag,
  stirlingS2Dependencies: _S,
  string: HN,
  stringDependencies: IL,
  subset: Xr,
  subsetDependencies: un,
  subsetTransformDependencies: FL,
  subtract: Qt,
  subtractDependencies: rr,
  subtractScalar: sn,
  subtractScalarDependencies: xn,
  sum: Km,
  sumDependencies: Vg,
  sumTransformDependencies: BL,
  sylvester: qg,
  sylvesterDependencies: pA,
  symbolicEqual: yS,
  symbolicEqualDependencies: RL,
  tan: QN,
  tanDependencies: PL,
  tanh: nD,
  tanhDependencies: LL,
  tau: Wd,
  tauDependencies: KS,
  thomsonCrossSection: BE,
  thomsonCrossSectionDependencies: kL,
  to: xD,
  toDependencies: zL,
  trace: mg,
  traceDependencies: $L,
  transpose: ja,
  transposeDependencies: po,
  trueDependencies: UL,
  typeOf: Kd,
  typeOfDependencies: dA,
  typed: ne,
  typedDependencies: ie,
  unaryMinus: On,
  unaryMinusDependencies: Gn,
  unaryPlus: Zm,
  unaryPlusDependencies: Yg,
  unequal: YD,
  unequalDependencies: GL,
  unit: JE,
  unitDependencies: HL,
  usolve: Jm,
  usolveAll: hg,
  usolveAllDependencies: jS,
  usolveDependencies: nv,
  vacuumImpedance: rE,
  vacuumImpedanceDependencies: WL,
  variance: nh,
  varianceDependencies: lv,
  varianceTransformDependencies: jL,
  version: pN,
  versionDependencies: YL,
  weakMixingAngle: vN,
  weakMixingAngleDependencies: ZL,
  wienDisplacement: nE,
  wienDisplacementDependencies: JL,
  xgcd: rg,
  xgcdDependencies: aA,
  xor: bD,
  xorDependencies: XL,
  zeros: ur,
  zerosDependencies: Cr,
  zeta: cS,
  zetaDependencies: KL,
  zpk2tf: RD,
  zpk2tfDependencies: ek
}, Symbol.toStringTag, { value: "Module" }));
var sk = { 92: () => {
} }, m2 = {};
function Hi(t) {
  var e = m2[t];
  if (e !== void 0) return e.exports;
  var r = m2[t] = { exports: {} };
  return sk[t](r, r.exports, Hi), r.exports;
}
Hi.d = (t, e) => {
  for (var r in e) Hi.o(e, r) && !Hi.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: e[r] });
}, Hi.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var Ft = {};
(() => {
  Hi.d(Ft, { dx: () => le, q2: () => Li, FO: () => Mv, xf: () => ds, Gy: () => Fv, s4: () => wn, c7: () => Rv, _7: () => Cv, gp: () => _v, cK: () => ki, zs: () => Sh, AV: () => ds, Xp: () => w, VS: () => E, ul: () => he, hW: () => Vt, x1: () => Wt, z5: () => Ot, oN: () => Eh, TB: () => Tv, u1: () => wo, _b: () => Th, $F: () => bo, _T: () => _h, db: () => $i, Zx: () => jt, _x: () => Nn, r8: () => R, JI: () => k, TP: () => L, WU: () => t, Nj: () => u, ZP: () => kA });
  class t {
    constructor() {
      this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
    }
    getTokenSource() {
      return this.source[0];
    }
    getInputStream() {
      return this.source[1];
    }
    get text() {
      return this._text;
    }
    set text(p) {
      this._text = p;
    }
  }
  function e(re, p) {
    if (!Array.isArray(re) || !Array.isArray(p)) return !1;
    if (re === p) return !0;
    if (re.length !== p.length) return !1;
    for (let v = 0; v < re.length; v++) if (!(re[v] === p[v] || re[v].equals && re[v].equals(p[v]))) return !1;
    return !0;
  }
  t.INVALID_TYPE = 0, t.EPSILON = -2, t.MIN_USER_TOKEN_TYPE = 1, t.EOF = -1, t.DEFAULT_CHANNEL = 0, t.HIDDEN_CHANNEL = 1;
  const r = Math.round(Math.random() * Math.pow(2, 32));
  function n(re) {
    if (!re) return 0;
    const p = typeof re, v = p === "string" ? re : !(p !== "object" || !re.toString) && re.toString();
    if (!v) return 0;
    let S, q;
    const z = 3 & v.length, W = v.length - z;
    let oe = r;
    const we = 3432918353, Ae = 461845907;
    let Re = 0;
    for (; Re < W; ) q = 255 & v.charCodeAt(Re) | (255 & v.charCodeAt(++Re)) << 8 | (255 & v.charCodeAt(++Re)) << 16 | (255 & v.charCodeAt(++Re)) << 24, ++Re, q = (65535 & q) * we + (((q >>> 16) * we & 65535) << 16) & 4294967295, q = q << 15 | q >>> 17, q = (65535 & q) * Ae + (((q >>> 16) * Ae & 65535) << 16) & 4294967295, oe ^= q, oe = oe << 13 | oe >>> 19, S = 5 * (65535 & oe) + ((5 * (oe >>> 16) & 65535) << 16) & 4294967295, oe = 27492 + (65535 & S) + ((58964 + (S >>> 16) & 65535) << 16);
    switch (q = 0, z) {
      case 3:
        q ^= (255 & v.charCodeAt(Re + 2)) << 16;
      case 2:
        q ^= (255 & v.charCodeAt(Re + 1)) << 8;
      case 1:
        q ^= 255 & v.charCodeAt(Re), q = (65535 & q) * we + (((q >>> 16) * we & 65535) << 16) & 4294967295, q = q << 15 | q >>> 17, q = (65535 & q) * Ae + (((q >>> 16) * Ae & 65535) << 16) & 4294967295, oe ^= q;
    }
    return oe ^= v.length, oe ^= oe >>> 16, oe = 2246822507 * (65535 & oe) + ((2246822507 * (oe >>> 16) & 65535) << 16) & 4294967295, oe ^= oe >>> 13, oe = 3266489909 * (65535 & oe) + ((3266489909 * (oe >>> 16) & 65535) << 16) & 4294967295, oe ^= oe >>> 16, oe >>> 0;
  }
  class i {
    constructor() {
      this.count = 0, this.hash = 0;
    }
    update() {
      for (let p = 0; p < arguments.length; p++) {
        const v = arguments[p];
        if (v != null) if (Array.isArray(v)) this.update.apply(this, v);
        else {
          let S = 0;
          switch (typeof v) {
            case "undefined":
            case "function":
              continue;
            case "number":
            case "boolean":
              S = v;
              break;
            case "string":
              S = n(v);
              break;
            default:
              v.updateHashCode ? v.updateHashCode(this) : console.log("No updateHashCode for " + v.toString());
              continue;
          }
          S *= 3432918353, S = S << 15 | S >>> 17, S *= 461845907, this.count = this.count + 1;
          let q = this.hash ^ S;
          q = q << 13 | q >>> 19, q = 5 * q + 3864292196, this.hash = q;
        }
      }
    }
    finish() {
      let p = this.hash ^ 4 * this.count;
      return p ^= p >>> 16, p *= 2246822507, p ^= p >>> 13, p *= 3266489909, p ^= p >>> 16, p;
    }
    static hashStuff() {
      const p = new i();
      return p.update.apply(p, arguments), p.finish();
    }
  }
  function a(re) {
    return re ? typeof re == "string" ? n(re) : re.hashCode() : -1;
  }
  function o(re, p) {
    return re ? re.equals(p) : re === p;
  }
  function f(re) {
    return re === null ? "null" : re;
  }
  function u(re) {
    return Array.isArray(re) ? "[" + re.map(f).join(", ") + "]" : "null";
  }
  const s = "h-";
  class c {
    constructor(p, v) {
      this.data = {}, this.hashFunction = p || a, this.equalsFunction = v || o;
    }
    add(p) {
      const v = s + this.hashFunction(p);
      if (v in this.data) {
        const S = this.data[v];
        for (let q = 0; q < S.length; q++) if (this.equalsFunction(p, S[q])) return S[q];
        return S.push(p), p;
      }
      return this.data[v] = [p], p;
    }
    has(p) {
      return this.get(p) != null;
    }
    get(p) {
      const v = s + this.hashFunction(p);
      if (v in this.data) {
        const S = this.data[v];
        for (let q = 0; q < S.length; q++) if (this.equalsFunction(p, S[q])) return S[q];
      }
      return null;
    }
    values() {
      return Object.keys(this.data).filter((p) => p.startsWith(s)).flatMap((p) => this.data[p], this);
    }
    toString() {
      return u(this.values());
    }
    get length() {
      return Object.keys(this.data).filter((p) => p.startsWith(s)).map((p) => this.data[p].length, this).reduce((p, v) => p + v, 0);
    }
  }
  class l {
    hashCode() {
      const p = new i();
      return this.updateHashCode(p), p.finish();
    }
    evaluate(p, v) {
    }
    evalPrecedence(p, v) {
      return this;
    }
    static andContext(p, v) {
      if (p === null || p === l.NONE) return v;
      if (v === null || v === l.NONE) return p;
      const S = new m(p, v);
      return S.opnds.length === 1 ? S.opnds[0] : S;
    }
    static orContext(p, v) {
      if (p === null) return v;
      if (v === null) return p;
      if (p === l.NONE || v === l.NONE) return l.NONE;
      const S = new h(p, v);
      return S.opnds.length === 1 ? S.opnds[0] : S;
    }
  }
  class m extends l {
    constructor(p, v) {
      super();
      const S = new c();
      p instanceof m ? p.opnds.map(function(z) {
        S.add(z);
      }) : S.add(p), v instanceof m ? v.opnds.map(function(z) {
        S.add(z);
      }) : S.add(v);
      const q = g(S);
      if (q.length > 0) {
        let z = null;
        q.map(function(W) {
          (z === null || W.precedence < z.precedence) && (z = W);
        }), S.add(z);
      }
      this.opnds = Array.from(S.values());
    }
    equals(p) {
      return this === p || p instanceof m && e(this.opnds, p.opnds);
    }
    updateHashCode(p) {
      p.update(this.opnds, "AND");
    }
    evaluate(p, v) {
      for (let S = 0; S < this.opnds.length; S++) if (!this.opnds[S].evaluate(p, v)) return !1;
      return !0;
    }
    evalPrecedence(p, v) {
      let S = !1;
      const q = [];
      for (let W = 0; W < this.opnds.length; W++) {
        const oe = this.opnds[W], we = oe.evalPrecedence(p, v);
        if (S |= we !== oe, we === null) return null;
        we !== l.NONE && q.push(we);
      }
      if (!S) return this;
      if (q.length === 0) return l.NONE;
      let z = null;
      return q.map(function(W) {
        z = z === null ? W : l.andContext(z, W);
      }), z;
    }
    toString() {
      const p = this.opnds.map((v) => v.toString());
      return (p.length > 3 ? p.slice(3) : p).join("&&");
    }
  }
  class h extends l {
    constructor(p, v) {
      super();
      const S = new c();
      p instanceof h ? p.opnds.map(function(z) {
        S.add(z);
      }) : S.add(p), v instanceof h ? v.opnds.map(function(z) {
        S.add(z);
      }) : S.add(v);
      const q = g(S);
      if (q.length > 0) {
        const z = q.sort(function(oe, we) {
          return oe.compareTo(we);
        }), W = z[z.length - 1];
        S.add(W);
      }
      this.opnds = Array.from(S.values());
    }
    equals(p) {
      return this === p || p instanceof h && e(this.opnds, p.opnds);
    }
    updateHashCode(p) {
      p.update(this.opnds, "OR");
    }
    evaluate(p, v) {
      for (let S = 0; S < this.opnds.length; S++) if (this.opnds[S].evaluate(p, v)) return !0;
      return !1;
    }
    evalPrecedence(p, v) {
      let S = !1;
      const q = [];
      for (let z = 0; z < this.opnds.length; z++) {
        const W = this.opnds[z], oe = W.evalPrecedence(p, v);
        if (S |= oe !== W, oe === l.NONE) return l.NONE;
        oe !== null && q.push(oe);
      }
      return S ? (q.length === 0, null) : this;
    }
    toString() {
      const p = this.opnds.map((v) => v.toString());
      return (p.length > 3 ? p.slice(3) : p).join("||");
    }
  }
  function g(re) {
    const p = [];
    return re.values().map(function(v) {
      v instanceof l.PrecedencePredicate && p.push(v);
    }), p;
  }
  function d(re, p) {
    if (re === null) {
      const v = { state: null, alt: null, context: null, semanticContext: null };
      return p && (v.reachesIntoOuterContext = 0), v;
    }
    {
      const v = {};
      return v.state = re.state || null, v.alt = re.alt === void 0 ? null : re.alt, v.context = re.context || null, v.semanticContext = re.semanticContext || null, p && (v.reachesIntoOuterContext = re.reachesIntoOuterContext || 0, v.precedenceFilterSuppressed = re.precedenceFilterSuppressed || !1), v;
    }
  }
  class y {
    constructor(p, v) {
      this.checkContext(p, v), p = d(p), v = d(v, !0), this.state = p.state !== null ? p.state : v.state, this.alt = p.alt !== null ? p.alt : v.alt, this.context = p.context !== null ? p.context : v.context, this.semanticContext = p.semanticContext !== null ? p.semanticContext : v.semanticContext !== null ? v.semanticContext : l.NONE, this.reachesIntoOuterContext = v.reachesIntoOuterContext, this.precedenceFilterSuppressed = v.precedenceFilterSuppressed;
    }
    checkContext(p, v) {
      p.context !== null && p.context !== void 0 || v !== null && v.context !== null && v.context !== void 0 || (this.context = null);
    }
    hashCode() {
      const p = new i();
      return this.updateHashCode(p), p.finish();
    }
    updateHashCode(p) {
      p.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
    }
    equals(p) {
      return this === p || p instanceof y && this.state.stateNumber === p.state.stateNumber && this.alt === p.alt && (this.context === null ? p.context === null : this.context.equals(p.context)) && this.semanticContext.equals(p.semanticContext) && this.precedenceFilterSuppressed === p.precedenceFilterSuppressed;
    }
    hashCodeForConfigSet() {
      const p = new i();
      return p.update(this.state.stateNumber, this.alt, this.semanticContext), p.finish();
    }
    equalsForConfigSet(p) {
      return this === p || p instanceof y && this.state.stateNumber === p.state.stateNumber && this.alt === p.alt && this.semanticContext.equals(p.semanticContext);
    }
    toString() {
      return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== l.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
    }
  }
  class w {
    constructor(p, v) {
      this.start = p, this.stop = v;
    }
    clone() {
      return new w(this.start, this.stop);
    }
    contains(p) {
      return p >= this.start && p < this.stop;
    }
    toString() {
      return this.start === this.stop - 1 ? this.start.toString() : this.start.toString() + ".." + (this.stop - 1).toString();
    }
    get length() {
      return this.stop - this.start;
    }
  }
  w.INVALID_INTERVAL = new w(-1, -2);
  class E {
    constructor() {
      this.intervals = null, this.readOnly = !1;
    }
    first(p) {
      return this.intervals === null || this.intervals.length === 0 ? t.INVALID_TYPE : this.intervals[0].start;
    }
    addOne(p) {
      this.addInterval(new w(p, p + 1));
    }
    addRange(p, v) {
      this.addInterval(new w(p, v + 1));
    }
    addInterval(p) {
      if (this.intervals === null) this.intervals = [], this.intervals.push(p.clone());
      else {
        for (let v = 0; v < this.intervals.length; v++) {
          const S = this.intervals[v];
          if (p.stop < S.start) return void this.intervals.splice(v, 0, p);
          if (p.stop === S.start) return void (this.intervals[v] = new w(p.start, S.stop));
          if (p.start <= S.stop) return this.intervals[v] = new w(Math.min(S.start, p.start), Math.max(S.stop, p.stop)), void this.reduce(v);
        }
        this.intervals.push(p.clone());
      }
    }
    addSet(p) {
      return p.intervals !== null && p.intervals.forEach((v) => this.addInterval(v), this), this;
    }
    reduce(p) {
      if (p < this.intervals.length - 1) {
        const v = this.intervals[p], S = this.intervals[p + 1];
        v.stop >= S.stop ? (this.intervals.splice(p + 1, 1), this.reduce(p)) : v.stop >= S.start && (this.intervals[p] = new w(v.start, S.stop), this.intervals.splice(p + 1, 1));
      }
    }
    complement(p, v) {
      const S = new E();
      return S.addInterval(new w(p, v + 1)), this.intervals !== null && this.intervals.forEach((q) => S.removeRange(q)), S;
    }
    contains(p) {
      if (this.intervals === null) return !1;
      for (let v = 0; v < this.intervals.length; v++) if (this.intervals[v].contains(p)) return !0;
      return !1;
    }
    removeRange(p) {
      if (p.start === p.stop - 1) this.removeOne(p.start);
      else if (this.intervals !== null) {
        let v = 0;
        for (let S = 0; S < this.intervals.length; S++) {
          const q = this.intervals[v];
          if (p.stop <= q.start) return;
          if (p.start > q.start && p.stop < q.stop) {
            this.intervals[v] = new w(q.start, p.start);
            const z = new w(p.stop, q.stop);
            return void this.intervals.splice(v, 0, z);
          }
          p.start <= q.start && p.stop >= q.stop ? (this.intervals.splice(v, 1), v -= 1) : p.start < q.stop ? this.intervals[v] = new w(q.start, p.start) : p.stop < q.stop && (this.intervals[v] = new w(p.stop, q.stop)), v += 1;
        }
      }
    }
    removeOne(p) {
      if (this.intervals !== null) for (let v = 0; v < this.intervals.length; v++) {
        const S = this.intervals[v];
        if (p < S.start) return;
        if (p === S.start && p === S.stop - 1) return void this.intervals.splice(v, 1);
        if (p === S.start) return void (this.intervals[v] = new w(S.start + 1, S.stop));
        if (p === S.stop - 1) return void (this.intervals[v] = new w(S.start, S.stop - 1));
        if (p < S.stop - 1) {
          const q = new w(S.start, p);
          return S.start = p + 1, void this.intervals.splice(v, 0, q);
        }
      }
    }
    toString(p, v, S) {
      return p = p || null, v = v || null, S = S || !1, this.intervals === null ? "{}" : p !== null || v !== null ? this.toTokenString(p, v) : S ? this.toCharString() : this.toIndexString();
    }
    toCharString() {
      const p = [];
      for (let v = 0; v < this.intervals.length; v++) {
        const S = this.intervals[v];
        S.stop === S.start + 1 ? S.start === t.EOF ? p.push("<EOF>") : p.push("'" + String.fromCharCode(S.start) + "'") : p.push("'" + String.fromCharCode(S.start) + "'..'" + String.fromCharCode(S.stop - 1) + "'");
      }
      return p.length > 1 ? "{" + p.join(", ") + "}" : p[0];
    }
    toIndexString() {
      const p = [];
      for (let v = 0; v < this.intervals.length; v++) {
        const S = this.intervals[v];
        S.stop === S.start + 1 ? S.start === t.EOF ? p.push("<EOF>") : p.push(S.start.toString()) : p.push(S.start.toString() + ".." + (S.stop - 1).toString());
      }
      return p.length > 1 ? "{" + p.join(", ") + "}" : p[0];
    }
    toTokenString(p, v) {
      const S = [];
      for (let q = 0; q < this.intervals.length; q++) {
        const z = this.intervals[q];
        for (let W = z.start; W < z.stop; W++) S.push(this.elementName(p, v, W));
      }
      return S.length > 1 ? "{" + S.join(", ") + "}" : S[0];
    }
    elementName(p, v, S) {
      return S === t.EOF ? "<EOF>" : S === t.EPSILON ? "<EPSILON>" : p[S] || v[S];
    }
    get length() {
      return this.intervals.map((p) => p.length).reduce((p, v) => p + v);
    }
  }
  class x {
    constructor() {
      this.atn = null, this.stateNumber = x.INVALID_STATE_NUMBER, this.stateType = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = !1, this.transitions = [], this.nextTokenWithinRule = null;
    }
    toString() {
      return this.stateNumber;
    }
    equals(p) {
      return p instanceof x && this.stateNumber === p.stateNumber;
    }
    isNonGreedyExitState() {
      return !1;
    }
    addTransition(p, v) {
      v === void 0 && (v = -1), this.transitions.length === 0 ? this.epsilonOnlyTransitions = p.isEpsilon : this.epsilonOnlyTransitions !== p.isEpsilon && (this.epsilonOnlyTransitions = !1), v === -1 ? this.transitions.push(p) : this.transitions.splice(v, 1, p);
    }
  }
  x.INVALID_TYPE = 0, x.BASIC = 1, x.RULE_START = 2, x.BLOCK_START = 3, x.PLUS_BLOCK_START = 4, x.STAR_BLOCK_START = 5, x.TOKEN_START = 6, x.RULE_STOP = 7, x.BLOCK_END = 8, x.STAR_LOOP_BACK = 9, x.STAR_LOOP_ENTRY = 10, x.PLUS_LOOP_BACK = 11, x.LOOP_END = 12, x.serializationNames = ["INVALID", "BASIC", "RULE_START", "BLOCK_START", "PLUS_BLOCK_START", "STAR_BLOCK_START", "TOKEN_START", "RULE_STOP", "BLOCK_END", "STAR_LOOP_BACK", "STAR_LOOP_ENTRY", "PLUS_LOOP_BACK", "LOOP_END"], x.INVALID_STATE_NUMBER = -1;
  class N extends x {
    constructor() {
      return super(), this.stateType = x.RULE_STOP, this;
    }
  }
  class D {
    constructor(p) {
      if (p == null) throw "target cannot be null.";
      this.target = p, this.isEpsilon = !1, this.label = null;
    }
  }
  D.EPSILON = 1, D.RANGE = 2, D.RULE = 3, D.PREDICATE = 4, D.ATOM = 5, D.ACTION = 6, D.SET = 7, D.NOT_SET = 8, D.WILDCARD = 9, D.PRECEDENCE = 10, D.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"], D.serializationTypes = { EpsilonTransition: D.EPSILON, RangeTransition: D.RANGE, RuleTransition: D.RULE, PredicateTransition: D.PREDICATE, AtomTransition: D.ATOM, ActionTransition: D.ACTION, SetTransition: D.SET, NotSetTransition: D.NOT_SET, WildcardTransition: D.WILDCARD, PrecedencePredicateTransition: D.PRECEDENCE };
  class b extends D {
    constructor(p, v, S, q) {
      super(p), this.ruleIndex = v, this.precedence = S, this.followState = q, this.serializationType = D.RULE, this.isEpsilon = !0;
    }
    matches(p, v, S) {
      return !1;
    }
  }
  class C extends D {
    constructor(p, v) {
      super(p), this.serializationType = D.SET, v != null ? this.label = v : (this.label = new E(), this.label.addOne(t.INVALID_TYPE));
    }
    matches(p, v, S) {
      return this.label.contains(p);
    }
    toString() {
      return this.label.toString();
    }
  }
  class A extends C {
    constructor(p, v) {
      super(p, v), this.serializationType = D.NOT_SET;
    }
    matches(p, v, S) {
      return p >= v && p <= S && !super.matches(p, v, S);
    }
    toString() {
      return "~" + super.toString();
    }
  }
  class T extends D {
    constructor(p) {
      super(p), this.serializationType = D.WILDCARD;
    }
    matches(p, v, S) {
      return p >= v && p <= S;
    }
    toString() {
      return ".";
    }
  }
  class _ extends D {
    constructor(p) {
      super(p);
    }
  }
  class O {
  }
  class I extends O {
  }
  class B extends I {
  }
  class k extends B {
    get ruleContext() {
      throw new Error("missing interface implementation");
    }
  }
  class L extends B {
  }
  class F extends L {
  }
  const M = { toStringTree: function(re, p, v) {
    p = p || null, (v = v || null) !== null && (p = v.ruleNames);
    let S = M.getNodeText(re, p);
    S = function(W, oe) {
      return W = W.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
    }(S);
    const q = re.getChildCount();
    if (q === 0) return S;
    let z = "(" + S + " ";
    q > 0 && (S = M.toStringTree(re.getChild(0), p), z = z.concat(S));
    for (let W = 1; W < q; W++) S = M.toStringTree(re.getChild(W), p), z = z.concat(" " + S);
    return z = z.concat(")"), z;
  }, getNodeText: function(re, p, v) {
    if (p = p || null, (v = v || null) !== null && (p = v.ruleNames), p !== null) {
      if (re instanceof k) {
        const q = re.ruleContext.getAltNumber();
        return q != 0 ? p[re.ruleIndex] + ":" + q : p[re.ruleIndex];
      }
      if (re instanceof F) return re.toString();
      if (re instanceof L && re.symbol !== null) return re.symbol.text;
    }
    const S = re.getPayload();
    return S instanceof t ? S.text : re.getPayload().toString();
  }, getChildren: function(re) {
    const p = [];
    for (let v = 0; v < re.getChildCount(); v++) p.push(re.getChild(v));
    return p;
  }, getAncestors: function(re) {
    let p = [];
    for (re = re.getParent(); re !== null; ) p = [re].concat(p), re = re.getParent();
    return p;
  }, findAllTokenNodes: function(re, p) {
    return M.findAllNodes(re, p, !0);
  }, findAllRuleNodes: function(re, p) {
    return M.findAllNodes(re, p, !1);
  }, findAllNodes: function(re, p, v) {
    const S = [];
    return M._findAllNodes(re, p, v, S), S;
  }, _findAllNodes: function(re, p, v, S) {
    v && re instanceof L ? re.symbol.type === p && S.push(re) : !v && re instanceof k && re.ruleIndex === p && S.push(re);
    for (let q = 0; q < re.getChildCount(); q++) M._findAllNodes(re.getChild(q), p, v, S);
  }, descendants: function(re) {
    let p = [re];
    for (let v = 0; v < re.getChildCount(); v++) p = p.concat(M.descendants(re.getChild(v)));
    return p;
  } }, $ = M;
  class R extends k {
    constructor(p, v) {
      super(), this.parentCtx = p || null, this.invokingState = v || -1;
    }
    depth() {
      let p = 0, v = this;
      for (; v !== null; ) v = v.parentCtx, p += 1;
      return p;
    }
    isEmpty() {
      return this.invokingState === -1;
    }
    getSourceInterval() {
      return w.INVALID_INTERVAL;
    }
    get ruleContext() {
      return this;
    }
    getPayload() {
      return this;
    }
    getText() {
      return this.getChildCount() === 0 ? "" : this.children.map(function(p) {
        return p.getText();
      }).join("");
    }
    getAltNumber() {
      return 0;
    }
    setAltNumber(p) {
    }
    getChild(p) {
      return null;
    }
    getChildCount() {
      return 0;
    }
    accept(p) {
      return p.visitChildren(this);
    }
    toStringTree(p, v) {
      return $.toStringTree(this, p, v);
    }
    toString(p, v) {
      p = p || null, v = v || null;
      let S = this, q = "[";
      for (; S !== null && S !== v; ) {
        if (p === null) S.isEmpty() || (q += S.invokingState);
        else {
          const z = S.ruleIndex;
          q += z >= 0 && z < p.length ? p[z] : "" + z;
        }
        S.parentCtx === null || p === null && S.parentCtx.isEmpty() || (q += " "), S = S.parentCtx;
      }
      return q += "]", q;
    }
  }
  class Q {
    constructor(p) {
      this.cachedHashCode = p;
    }
    isEmpty() {
      return this === Q.EMPTY;
    }
    hasEmptyPath() {
      return this.getReturnState(this.length - 1) === Q.EMPTY_RETURN_STATE;
    }
    hashCode() {
      return this.cachedHashCode;
    }
    updateHashCode(p) {
      p.update(this.cachedHashCode);
    }
  }
  Q.EMPTY = null, Q.EMPTY_RETURN_STATE = 2147483647, Q.globalNodeCount = 1, Q.id = Q.globalNodeCount, Q.trace_atn_sim = !1;
  class ee extends Q {
    constructor(p, v) {
      const S = new i();
      return S.update(p, v), super(S.finish()), this.parents = p, this.returnStates = v, this;
    }
    isEmpty() {
      return this.returnStates[0] === Q.EMPTY_RETURN_STATE;
    }
    getParent(p) {
      return this.parents[p];
    }
    getReturnState(p) {
      return this.returnStates[p];
    }
    equals(p) {
      return this === p || p instanceof ee && this.hashCode() === p.hashCode() && e(this.returnStates, p.returnStates) && e(this.parents, p.parents);
    }
    toString() {
      if (this.isEmpty()) return "[]";
      {
        let p = "[";
        for (let v = 0; v < this.returnStates.length; v++) v > 0 && (p += ", "), this.returnStates[v] !== Q.EMPTY_RETURN_STATE ? (p += this.returnStates[v], this.parents[v] !== null ? p = p + " " + this.parents[v] : p += "null") : p += "$";
        return p + "]";
      }
    }
    get length() {
      return this.returnStates.length;
    }
  }
  class j extends Q {
    constructor(p, v) {
      let S = 0;
      const q = new i();
      p !== null ? q.update(p, v) : q.update(1), S = q.finish(), super(S), this.parentCtx = p, this.returnState = v;
    }
    getParent(p) {
      return this.parentCtx;
    }
    getReturnState(p) {
      return this.returnState;
    }
    equals(p) {
      return this === p || p instanceof j && this.hashCode() === p.hashCode() && this.returnState === p.returnState && (this.parentCtx == null ? p.parentCtx == null : this.parentCtx.equals(p.parentCtx));
    }
    toString() {
      const p = this.parentCtx === null ? "" : this.parentCtx.toString();
      return p.length === 0 ? this.returnState === Q.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : this.returnState + " " + p;
    }
    get length() {
      return 1;
    }
    static create(p, v) {
      return v === Q.EMPTY_RETURN_STATE && p === null ? Q.EMPTY : new j(p, v);
    }
  }
  class U extends j {
    constructor() {
      super(null, Q.EMPTY_RETURN_STATE);
    }
    isEmpty() {
      return !0;
    }
    getParent(p) {
      return null;
    }
    getReturnState(p) {
      return this.returnState;
    }
    equals(p) {
      return this === p;
    }
    toString() {
      return "$";
    }
  }
  Q.EMPTY = new U();
  const pe = "h-";
  class X {
    constructor(p, v) {
      this.data = {}, this.hashFunction = p || a, this.equalsFunction = v || o;
    }
    set(p, v) {
      const S = pe + this.hashFunction(p);
      if (S in this.data) {
        const q = this.data[S];
        for (let z = 0; z < q.length; z++) {
          const W = q[z];
          if (this.equalsFunction(p, W.key)) {
            const oe = W.value;
            return W.value = v, oe;
          }
        }
        return q.push({ key: p, value: v }), v;
      }
      return this.data[S] = [{ key: p, value: v }], v;
    }
    containsKey(p) {
      const v = pe + this.hashFunction(p);
      if (v in this.data) {
        const S = this.data[v];
        for (let q = 0; q < S.length; q++) {
          const z = S[q];
          if (this.equalsFunction(p, z.key)) return !0;
        }
      }
      return !1;
    }
    get(p) {
      const v = pe + this.hashFunction(p);
      if (v in this.data) {
        const S = this.data[v];
        for (let q = 0; q < S.length; q++) {
          const z = S[q];
          if (this.equalsFunction(p, z.key)) return z.value;
        }
      }
      return null;
    }
    entries() {
      return Object.keys(this.data).filter((p) => p.startsWith(pe)).flatMap((p) => this.data[p], this);
    }
    getKeys() {
      return this.entries().map((p) => p.key);
    }
    getValues() {
      return this.entries().map((p) => p.value);
    }
    toString() {
      return "[" + this.entries().map((p) => "{" + p.key + ":" + p.value + "}").join(", ") + "]";
    }
    get length() {
      return Object.keys(this.data).filter((p) => p.startsWith(pe)).map((p) => this.data[p].length, this).reduce((p, v) => p + v, 0);
    }
  }
  function te(re, p) {
    if (p == null && (p = R.EMPTY), p.parentCtx === null || p === R.EMPTY) return Q.EMPTY;
    const v = te(re, p.parentCtx), S = re.states[p.invokingState].transitions[0];
    return j.create(v, S.followState.stateNumber);
  }
  function ue(re, p, v) {
    if (re.isEmpty()) return re;
    let S = v.get(re) || null;
    if (S !== null) return S;
    if (S = p.get(re), S !== null) return v.set(re, S), S;
    let q = !1, z = [];
    for (let oe = 0; oe < z.length; oe++) {
      const we = ue(re.getParent(oe), p, v);
      if (q || we !== re.getParent(oe)) {
        if (!q) {
          z = [];
          for (let Ae = 0; Ae < re.length; Ae++) z[Ae] = re.getParent(Ae);
          q = !0;
        }
        z[oe] = we;
      }
    }
    if (!q) return p.add(re), v.set(re, re), re;
    let W = null;
    return W = z.length === 0 ? Q.EMPTY : z.length === 1 ? j.create(z[0], re.getReturnState(0)) : new ee(z, re.returnStates), p.add(W), v.set(W, W), v.set(re, W), W;
  }
  function ce(re, p, v, S) {
    if (re === p) return re;
    if (re instanceof j && p instanceof j) return function(q, z, W, oe) {
      if (oe !== null) {
        let Ae = oe.get(q, z);
        if (Ae !== null || (Ae = oe.get(z, q), Ae !== null)) return Ae;
      }
      const we = function(Ae, Re, Ue) {
        if (Ue) {
          if (Ae === Q.EMPTY || Re === Q.EMPTY) return Q.EMPTY;
        } else {
          if (Ae === Q.EMPTY && Re === Q.EMPTY) return Q.EMPTY;
          if (Ae === Q.EMPTY) {
            const Ge = [Re.returnState, Q.EMPTY_RETURN_STATE], St = [Re.parentCtx, null];
            return new ee(St, Ge);
          }
          if (Re === Q.EMPTY) {
            const Ge = [Ae.returnState, Q.EMPTY_RETURN_STATE], St = [Ae.parentCtx, null];
            return new ee(St, Ge);
          }
        }
        return null;
      }(q, z, W);
      if (we !== null) return oe !== null && oe.set(q, z, we), we;
      if (q.returnState === z.returnState) {
        const Ae = ce(q.parentCtx, z.parentCtx, W, oe);
        if (Ae === q.parentCtx) return q;
        if (Ae === z.parentCtx) return z;
        const Re = j.create(Ae, q.returnState);
        return oe !== null && oe.set(q, z, Re), Re;
      }
      {
        let Ae = null;
        if ((q === z || q.parentCtx !== null && q.parentCtx === z.parentCtx) && (Ae = q.parentCtx), Ae !== null) {
          const St = [q.returnState, z.returnState];
          q.returnState > z.returnState && (St[0] = z.returnState, St[1] = q.returnState);
          const st = new ee([Ae, Ae], St);
          return oe !== null && oe.set(q, z, st), st;
        }
        const Re = [q.returnState, z.returnState];
        let Ue = [q.parentCtx, z.parentCtx];
        q.returnState > z.returnState && (Re[0] = z.returnState, Re[1] = q.returnState, Ue = [z.parentCtx, q.parentCtx]);
        const Ge = new ee(Ue, Re);
        return oe !== null && oe.set(q, z, Ge), Ge;
      }
    }(re, p, v, S);
    if (v) {
      if (re instanceof U) return re;
      if (p instanceof U) return p;
    }
    return re instanceof j && (re = new ee([re.getParent()], [re.returnState])), p instanceof j && (p = new ee([p.getParent()], [p.returnState])), function(q, z, W, oe) {
      if (oe !== null) {
        let st = oe.get(q, z);
        if (st !== null || (st = oe.get(z, q), st !== null)) return Q.trace_atn_sim && console.log("mergeArrays a=" + q + ",b=" + z + " -> previous"), st;
      }
      let we = 0, Ae = 0, Re = 0, Ue = new Array(q.returnStates.length + z.returnStates.length).fill(0), Ge = new Array(q.returnStates.length + z.returnStates.length).fill(null);
      for (; we < q.returnStates.length && Ae < z.returnStates.length; ) {
        const st = q.parents[we], en = z.parents[Ae];
        if (q.returnStates[we] === z.returnStates[Ae]) {
          const pn = q.returnStates[we];
          pn === Q.EMPTY_RETURN_STATE && st === null && en === null || st !== null && en !== null && st === en ? (Ge[Re] = st, Ue[Re] = pn) : (Ge[Re] = ce(st, en, W, oe), Ue[Re] = pn), we += 1, Ae += 1;
        } else q.returnStates[we] < z.returnStates[Ae] ? (Ge[Re] = st, Ue[Re] = q.returnStates[we], we += 1) : (Ge[Re] = en, Ue[Re] = z.returnStates[Ae], Ae += 1);
        Re += 1;
      }
      if (we < q.returnStates.length) for (let st = we; st < q.returnStates.length; st++) Ge[Re] = q.parents[st], Ue[Re] = q.returnStates[st], Re += 1;
      else for (let st = Ae; st < z.returnStates.length; st++) Ge[Re] = z.parents[st], Ue[Re] = z.returnStates[st], Re += 1;
      if (Re < Ge.length) {
        if (Re === 1) {
          const st = j.create(Ge[0], Ue[0]);
          return oe !== null && oe.set(q, z, st), st;
        }
        Ge = Ge.slice(0, Re), Ue = Ue.slice(0, Re);
      }
      const St = new ee(Ge, Ue);
      return St.equals(q) ? (oe !== null && oe.set(q, z, q), Q.trace_atn_sim && console.log("mergeArrays a=" + q + ",b=" + z + " -> a"), q) : St.equals(z) ? (oe !== null && oe.set(q, z, z), Q.trace_atn_sim && console.log("mergeArrays a=" + q + ",b=" + z + " -> b"), z) : (function(st) {
        const en = new X();
        for (let pn = 0; pn < st.length; pn++) {
          const Mh = st[pn];
          en.containsKey(Mh) || en.set(Mh, Mh);
        }
        for (let pn = 0; pn < st.length; pn++) st[pn] = en.get(st[pn]);
      }(Ge), oe !== null && oe.set(q, z, St), Q.trace_atn_sim && console.log("mergeArrays a=" + q + ",b=" + z + " -> " + St), St);
    }(re, p, v, S);
  }
  class se {
    constructor() {
      this.data = [];
    }
    add(p) {
      this.data[p] = !0;
    }
    or(p) {
      Object.keys(p.data).map((v) => this.add(v), this);
    }
    remove(p) {
      delete this.data[p];
    }
    has(p) {
      return this.data[p] === !0;
    }
    values() {
      return Object.keys(this.data);
    }
    minValue() {
      return Math.min.apply(null, this.values());
    }
    hashCode() {
      return i.hashStuff(this.values());
    }
    equals(p) {
      return p instanceof se && e(this.data, p.data);
    }
    toString() {
      return "{" + this.values().join(", ") + "}";
    }
    get length() {
      return this.values().length;
    }
  }
  class he {
    constructor(p) {
      this.atn = p;
    }
    getDecisionLookahead(p) {
      if (p === null) return null;
      const v = p.transitions.length, S = [];
      for (let q = 0; q < v; q++) {
        S[q] = new E();
        const z = new c();
        this._LOOK(p.transition(q).target, null, Q.EMPTY, S[q], z, new se(), !1, !1), (S[q].length === 0 || S[q].contains(he.HIT_PRED)) && (S[q] = null);
      }
      return S;
    }
    LOOK(p, v, S) {
      const q = new E(), z = (S = S || null) !== null ? te(p.atn, S) : null;
      return this._LOOK(p, v, z, q, new c(), new se(), !0, !0), q;
    }
    _LOOK(p, v, S, q, z, W, oe, we) {
      const Ae = new y({ state: p, alt: 0, context: S }, null);
      if (!z.has(Ae)) {
        if (z.add(Ae), p === v) {
          if (S === null) return void q.addOne(t.EPSILON);
          if (S.isEmpty() && we) return void q.addOne(t.EOF);
        }
        if (p instanceof N) {
          if (S === null) return void q.addOne(t.EPSILON);
          if (S.isEmpty() && we) return void q.addOne(t.EOF);
          if (S !== Q.EMPTY) {
            const Re = W.has(p.ruleIndex);
            try {
              W.remove(p.ruleIndex);
              for (let Ue = 0; Ue < S.length; Ue++) {
                const Ge = this.atn.states[S.getReturnState(Ue)];
                this._LOOK(Ge, v, S.getParent(Ue), q, z, W, oe, we);
              }
            } finally {
              Re && W.add(p.ruleIndex);
            }
            return;
          }
        }
        for (let Re = 0; Re < p.transitions.length; Re++) {
          const Ue = p.transitions[Re];
          if (Ue.constructor === b) {
            if (W.has(Ue.target.ruleIndex)) continue;
            const Ge = j.create(S, Ue.followState.stateNumber);
            try {
              W.add(Ue.target.ruleIndex), this._LOOK(Ue.target, v, Ge, q, z, W, oe, we);
            } finally {
              W.remove(Ue.target.ruleIndex);
            }
          } else if (Ue instanceof _) oe ? this._LOOK(Ue.target, v, S, q, z, W, oe, we) : q.addOne(he.HIT_PRED);
          else if (Ue.isEpsilon) this._LOOK(Ue.target, v, S, q, z, W, oe, we);
          else if (Ue.constructor === T) q.addRange(t.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          else {
            let Ge = Ue.label;
            Ge !== null && (Ue instanceof A && (Ge = Ge.complement(t.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), q.addSet(Ge));
          }
        }
      }
    }
  }
  he.HIT_PRED = t.INVALID_TYPE;
  class le {
    constructor(p, v) {
      this.grammarType = p, this.maxTokenType = v, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = null, this.modeNameToStartState = {}, this.ruleToTokenType = null, this.lexerActions = null, this.modeToStartState = [];
    }
    nextTokensInContext(p, v) {
      return new he(this).LOOK(p, null, v);
    }
    nextTokensNoContext(p) {
      return p.nextTokenWithinRule !== null || (p.nextTokenWithinRule = this.nextTokensInContext(p, null), p.nextTokenWithinRule.readOnly = !0), p.nextTokenWithinRule;
    }
    nextTokens(p, v) {
      return v === void 0 ? this.nextTokensNoContext(p) : this.nextTokensInContext(p, v);
    }
    addState(p) {
      p !== null && (p.atn = this, p.stateNumber = this.states.length), this.states.push(p);
    }
    removeState(p) {
      this.states[p.stateNumber] = null;
    }
    defineDecisionState(p) {
      return this.decisionToState.push(p), p.decision = this.decisionToState.length - 1, p.decision;
    }
    getDecisionState(p) {
      return this.decisionToState.length === 0 ? null : this.decisionToState[p];
    }
    getExpectedTokens(p, v) {
      if (p < 0 || p >= this.states.length) throw "Invalid state number.";
      const S = this.states[p];
      let q = this.nextTokens(S);
      if (!q.contains(t.EPSILON)) return q;
      const z = new E();
      for (z.addSet(q), z.removeOne(t.EPSILON); v !== null && v.invokingState >= 0 && q.contains(t.EPSILON); ) {
        const W = this.states[v.invokingState].transitions[0];
        q = this.nextTokens(W.followState), z.addSet(q), z.removeOne(t.EPSILON), v = v.parentCtx;
      }
      return q.contains(t.EPSILON) && z.addOne(t.EOF), z;
    }
  }
  le.INVALID_ALT_NUMBER = 0;
  class ve extends x {
    constructor() {
      super(), this.stateType = x.BASIC;
    }
  }
  class Ee extends x {
    constructor() {
      return super(), this.decision = -1, this.nonGreedy = !1, this;
    }
  }
  class _e extends Ee {
    constructor() {
      return super(), this.endState = null, this;
    }
  }
  class V extends x {
    constructor() {
      return super(), this.stateType = x.BLOCK_END, this.startState = null, this;
    }
  }
  class J extends x {
    constructor() {
      return super(), this.stateType = x.LOOP_END, this.loopBackState = null, this;
    }
  }
  class ye extends x {
    constructor() {
      return super(), this.stateType = x.RULE_START, this.stopState = null, this.isPrecedenceRule = !1, this;
    }
  }
  class K extends Ee {
    constructor() {
      return super(), this.stateType = x.TOKEN_START, this;
    }
  }
  class ae extends Ee {
    constructor() {
      return super(), this.stateType = x.PLUS_LOOP_BACK, this;
    }
  }
  class de extends x {
    constructor() {
      return super(), this.stateType = x.STAR_LOOP_BACK, this;
    }
  }
  class xe extends Ee {
    constructor() {
      return super(), this.stateType = x.STAR_LOOP_ENTRY, this.loopBackState = null, this.isPrecedenceDecision = null, this;
    }
  }
  class Ce extends _e {
    constructor() {
      return super(), this.stateType = x.PLUS_BLOCK_START, this.loopBackState = null, this;
    }
  }
  class G extends _e {
    constructor() {
      return super(), this.stateType = x.STAR_BLOCK_START, this;
    }
  }
  class Z extends _e {
    constructor() {
      return super(), this.stateType = x.BLOCK_START, this;
    }
  }
  class ge extends D {
    constructor(p, v) {
      super(p), this.label_ = v, this.label = this.makeLabel(), this.serializationType = D.ATOM;
    }
    makeLabel() {
      const p = new E();
      return p.addOne(this.label_), p;
    }
    matches(p, v, S) {
      return this.label_ === p;
    }
    toString() {
      return this.label_;
    }
  }
  class be extends D {
    constructor(p, v, S) {
      super(p), this.serializationType = D.RANGE, this.start = v, this.stop = S, this.label = this.makeLabel();
    }
    makeLabel() {
      const p = new E();
      return p.addRange(this.start, this.stop), p;
    }
    matches(p, v, S) {
      return p >= this.start && p <= this.stop;
    }
    toString() {
      return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
    }
  }
  class Se extends D {
    constructor(p, v, S, q) {
      super(p), this.serializationType = D.ACTION, this.ruleIndex = v, this.actionIndex = S === void 0 ? -1 : S, this.isCtxDependent = q !== void 0 && q, this.isEpsilon = !0;
    }
    matches(p, v, S) {
      return !1;
    }
    toString() {
      return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
  }
  class De extends D {
    constructor(p, v) {
      super(p), this.serializationType = D.EPSILON, this.isEpsilon = !0, this.outermostPrecedenceReturn = v;
    }
    matches(p, v, S) {
      return !1;
    }
    toString() {
      return "epsilon";
    }
  }
  class Me extends l {
    constructor(p, v, S) {
      super(), this.ruleIndex = p === void 0 ? -1 : p, this.predIndex = v === void 0 ? -1 : v, this.isCtxDependent = S !== void 0 && S;
    }
    evaluate(p, v) {
      const S = this.isCtxDependent ? v : null;
      return p.sempred(S, this.ruleIndex, this.predIndex);
    }
    updateHashCode(p) {
      p.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    equals(p) {
      return this === p || p instanceof Me && this.ruleIndex === p.ruleIndex && this.predIndex === p.predIndex && this.isCtxDependent === p.isCtxDependent;
    }
    toString() {
      return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
    }
  }
  l.NONE = new Me();
  class Oe extends _ {
    constructor(p, v, S, q) {
      super(p), this.serializationType = D.PREDICATE, this.ruleIndex = v, this.predIndex = S, this.isCtxDependent = q, this.isEpsilon = !0;
    }
    matches(p, v, S) {
      return !1;
    }
    getPredicate() {
      return new Me(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    toString() {
      return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
  }
  class Be extends l {
    constructor(p) {
      super(), this.precedence = p === void 0 ? 0 : p;
    }
    evaluate(p, v) {
      return p.precpred(v, this.precedence);
    }
    evalPrecedence(p, v) {
      return p.precpred(v, this.precedence) ? l.NONE : null;
    }
    compareTo(p) {
      return this.precedence - p.precedence;
    }
    updateHashCode(p) {
      p.update(this.precedence);
    }
    equals(p) {
      return this === p || p instanceof Be && this.precedence === p.precedence;
    }
    toString() {
      return "{" + this.precedence + ">=prec}?";
    }
  }
  l.PrecedencePredicate = Be;
  class Ie extends _ {
    constructor(p, v) {
      super(p), this.serializationType = D.PRECEDENCE, this.precedence = v, this.isEpsilon = !0;
    }
    matches(p, v, S) {
      return !1;
    }
    getPredicate() {
      return new Be(this.precedence);
    }
    toString() {
      return this.precedence + " >= _p";
    }
  }
  class nt {
    constructor(p) {
      p === void 0 && (p = null), this.readOnly = !1, this.verifyATN = p === null || p.verifyATN, this.generateRuleBypassTransitions = p !== null && p.generateRuleBypassTransitions;
    }
  }
  nt.defaultOptions = new nt(), nt.defaultOptions.readOnly = !0;
  class We {
    constructor(p) {
      this.actionType = p, this.isPositionDependent = !1;
    }
    hashCode() {
      const p = new i();
      return this.updateHashCode(p), p.finish();
    }
    updateHashCode(p) {
      p.update(this.actionType);
    }
    equals(p) {
      return this === p;
    }
  }
  class Qe extends We {
    constructor() {
      super(6);
    }
    execute(p) {
      p.skip();
    }
    toString() {
      return "skip";
    }
  }
  Qe.INSTANCE = new Qe();
  class Gt extends We {
    constructor(p) {
      super(0), this.channel = p;
    }
    execute(p) {
      p._channel = this.channel;
    }
    updateHashCode(p) {
      p.update(this.actionType, this.channel);
    }
    equals(p) {
      return this === p || p instanceof Gt && this.channel === p.channel;
    }
    toString() {
      return "channel(" + this.channel + ")";
    }
  }
  class P extends We {
    constructor(p, v) {
      super(1), this.ruleIndex = p, this.actionIndex = v, this.isPositionDependent = !0;
    }
    execute(p) {
      p.action(null, this.ruleIndex, this.actionIndex);
    }
    updateHashCode(p) {
      p.update(this.actionType, this.ruleIndex, this.actionIndex);
    }
    equals(p) {
      return this === p || p instanceof P && this.ruleIndex === p.ruleIndex && this.actionIndex === p.actionIndex;
    }
  }
  class fe extends We {
    constructor() {
      super(3);
    }
    execute(p) {
      p.more();
    }
    toString() {
      return "more";
    }
  }
  fe.INSTANCE = new fe();
  class Ne extends We {
    constructor(p) {
      super(7), this.type = p;
    }
    execute(p) {
      p.type = this.type;
    }
    updateHashCode(p) {
      p.update(this.actionType, this.type);
    }
    equals(p) {
      return this === p || p instanceof Ne && this.type === p.type;
    }
    toString() {
      return "type(" + this.type + ")";
    }
  }
  class Fe extends We {
    constructor(p) {
      super(5), this.mode = p;
    }
    execute(p) {
      p.pushMode(this.mode);
    }
    updateHashCode(p) {
      p.update(this.actionType, this.mode);
    }
    equals(p) {
      return this === p || p instanceof Fe && this.mode === p.mode;
    }
    toString() {
      return "pushMode(" + this.mode + ")";
    }
  }
  class Ze extends We {
    constructor() {
      super(4);
    }
    execute(p) {
      p.popMode();
    }
    toString() {
      return "popMode";
    }
  }
  Ze.INSTANCE = new Ze();
  class it extends We {
    constructor(p) {
      super(2), this.mode = p;
    }
    execute(p) {
      p.mode(this.mode);
    }
    updateHashCode(p) {
      p.update(this.actionType, this.mode);
    }
    equals(p) {
      return this === p || p instanceof it && this.mode === p.mode;
    }
    toString() {
      return "mode(" + this.mode + ")";
    }
  }
  function pr(re, p) {
    const v = [];
    return v[re - 1] = p, v.map(function(S) {
      return p;
    });
  }
  class Li {
    constructor(p) {
      p == null && (p = nt.defaultOptions), this.deserializationOptions = p, this.stateFactories = null, this.actionFactories = null;
    }
    deserialize(p) {
      const v = this.reset(p);
      this.checkVersion(v), v && this.skipUUID();
      const S = this.readATN();
      this.readStates(S, v), this.readRules(S, v), this.readModes(S);
      const q = [];
      return this.readSets(S, q, this.readInt.bind(this)), v && this.readSets(S, q, this.readInt32.bind(this)), this.readEdges(S, q), this.readDecisions(S), this.readLexerActions(S, v), this.markPrecedenceDecisions(S), this.verifyATN(S), this.deserializationOptions.generateRuleBypassTransitions && S.grammarType === 1 && (this.generateRuleBypassTransitions(S), this.verifyATN(S)), S;
    }
    reset(p) {
      if ((p.charCodeAt ? p.charCodeAt(0) : p[0]) === 3) {
        const v = function(q) {
          const z = q.charCodeAt(0);
          return z > 1 ? z - 2 : z + 65534;
        }, S = p.split("").map(v);
        return S[0] = p.charCodeAt(0), this.data = S, this.pos = 0, !0;
      }
      return this.data = p, this.pos = 0, !1;
    }
    skipUUID() {
      let p = 0;
      for (; p++ < 8; ) this.readInt();
    }
    checkVersion(p) {
      const v = this.readInt();
      if (!p && v !== 4) throw "Could not deserialize ATN with version " + v + " (expected 4).";
    }
    readATN() {
      const p = this.readInt(), v = this.readInt();
      return new le(p, v);
    }
    readStates(p, v) {
      let S, q, z;
      const W = [], oe = [], we = this.readInt();
      for (let Ue = 0; Ue < we; Ue++) {
        const Ge = this.readInt();
        if (Ge === x.INVALID_TYPE) {
          p.addState(null);
          continue;
        }
        let St = this.readInt();
        v && St === 65535 && (St = -1);
        const st = this.stateFactory(Ge, St);
        if (Ge === x.LOOP_END) {
          const en = this.readInt();
          W.push([st, en]);
        } else if (st instanceof _e) {
          const en = this.readInt();
          oe.push([st, en]);
        }
        p.addState(st);
      }
      for (S = 0; S < W.length; S++) q = W[S], q[0].loopBackState = p.states[q[1]];
      for (S = 0; S < oe.length; S++) q = oe[S], q[0].endState = p.states[q[1]];
      let Ae = this.readInt();
      for (S = 0; S < Ae; S++) z = this.readInt(), p.states[z].nonGreedy = !0;
      let Re = this.readInt();
      for (S = 0; S < Re; S++) z = this.readInt(), p.states[z].isPrecedenceRule = !0;
    }
    readRules(p, v) {
      let S;
      const q = this.readInt();
      for (p.grammarType === 0 && (p.ruleToTokenType = pr(q, 0)), p.ruleToStartState = pr(q, 0), S = 0; S < q; S++) {
        const z = this.readInt();
        if (p.ruleToStartState[S] = p.states[z], p.grammarType === 0) {
          let W = this.readInt();
          v && W === 65535 && (W = t.EOF), p.ruleToTokenType[S] = W;
        }
      }
      for (p.ruleToStopState = pr(q, 0), S = 0; S < p.states.length; S++) {
        const z = p.states[S];
        z instanceof N && (p.ruleToStopState[z.ruleIndex] = z, p.ruleToStartState[z.ruleIndex].stopState = z);
      }
    }
    readModes(p) {
      const v = this.readInt();
      for (let S = 0; S < v; S++) {
        let q = this.readInt();
        p.modeToStartState.push(p.states[q]);
      }
    }
    readSets(p, v, S) {
      const q = this.readInt();
      for (let z = 0; z < q; z++) {
        const W = new E();
        v.push(W);
        const oe = this.readInt();
        this.readInt() !== 0 && W.addOne(-1);
        for (let we = 0; we < oe; we++) {
          const Ae = S(), Re = S();
          W.addRange(Ae, Re);
        }
      }
    }
    readEdges(p, v) {
      let S, q, z, W, oe;
      const we = this.readInt();
      for (S = 0; S < we; S++) {
        const Ae = this.readInt(), Re = this.readInt(), Ue = this.readInt(), Ge = this.readInt(), St = this.readInt(), st = this.readInt();
        W = this.edgeFactory(p, Ue, Ae, Re, Ge, St, st, v), p.states[Ae].addTransition(W);
      }
      for (S = 0; S < p.states.length; S++) for (z = p.states[S], q = 0; q < z.transitions.length; q++) {
        const Ae = z.transitions[q];
        if (!(Ae instanceof b)) continue;
        let Re = -1;
        p.ruleToStartState[Ae.target.ruleIndex].isPrecedenceRule && Ae.precedence === 0 && (Re = Ae.target.ruleIndex), W = new De(Ae.followState, Re), p.ruleToStopState[Ae.target.ruleIndex].addTransition(W);
      }
      for (S = 0; S < p.states.length; S++) {
        if (z = p.states[S], z instanceof _e) {
          if (z.endState === null || z.endState.startState !== null) throw "IllegalState";
          z.endState.startState = z;
        }
        if (z instanceof ae) for (q = 0; q < z.transitions.length; q++) oe = z.transitions[q].target, oe instanceof Ce && (oe.loopBackState = z);
        else if (z instanceof de) for (q = 0; q < z.transitions.length; q++) oe = z.transitions[q].target, oe instanceof xe && (oe.loopBackState = z);
      }
    }
    readDecisions(p) {
      const v = this.readInt();
      for (let S = 0; S < v; S++) {
        const q = this.readInt(), z = p.states[q];
        p.decisionToState.push(z), z.decision = S;
      }
    }
    readLexerActions(p, v) {
      if (p.grammarType === 0) {
        const S = this.readInt();
        p.lexerActions = pr(S, null);
        for (let q = 0; q < S; q++) {
          const z = this.readInt();
          let W = this.readInt();
          v && W === 65535 && (W = -1);
          let oe = this.readInt();
          v && oe === 65535 && (oe = -1), p.lexerActions[q] = this.lexerActionFactory(z, W, oe);
        }
      }
    }
    generateRuleBypassTransitions(p) {
      let v;
      const S = p.ruleToStartState.length;
      for (v = 0; v < S; v++) p.ruleToTokenType[v] = p.maxTokenType + v + 1;
      for (v = 0; v < S; v++) this.generateRuleBypassTransition(p, v);
    }
    generateRuleBypassTransition(p, v) {
      let S, q;
      const z = new Z();
      z.ruleIndex = v, p.addState(z);
      const W = new V();
      W.ruleIndex = v, p.addState(W), z.endState = W, p.defineDecisionState(z), W.startState = z;
      let oe = null, we = null;
      if (p.ruleToStartState[v].isPrecedenceRule) {
        for (we = null, S = 0; S < p.states.length; S++) if (q = p.states[S], this.stateIsEndStateFor(q, v)) {
          we = q, oe = q.loopBackState.transitions[0];
          break;
        }
        if (oe === null) throw "Couldn't identify final state of the precedence rule prefix section.";
      } else we = p.ruleToStopState[v];
      for (S = 0; S < p.states.length; S++) {
        q = p.states[S];
        for (let Ge = 0; Ge < q.transitions.length; Ge++) {
          const St = q.transitions[Ge];
          St !== oe && St.target === we && (St.target = W);
        }
      }
      const Ae = p.ruleToStartState[v], Re = Ae.transitions.length;
      for (; Re > 0; ) z.addTransition(Ae.transitions[Re - 1]), Ae.transitions = Ae.transitions.slice(-1);
      p.ruleToStartState[v].addTransition(new De(z)), W.addTransition(new De(we));
      const Ue = new ve();
      p.addState(Ue), Ue.addTransition(new ge(W, p.ruleToTokenType[v])), z.addTransition(new De(Ue));
    }
    stateIsEndStateFor(p, v) {
      if (p.ruleIndex !== v || !(p instanceof xe)) return null;
      const S = p.transitions[p.transitions.length - 1].target;
      return S instanceof J && S.epsilonOnlyTransitions && S.transitions[0].target instanceof N ? p : null;
    }
    markPrecedenceDecisions(p) {
      for (let v = 0; v < p.states.length; v++) {
        const S = p.states[v];
        if (S instanceof xe && p.ruleToStartState[S.ruleIndex].isPrecedenceRule) {
          const q = S.transitions[S.transitions.length - 1].target;
          q instanceof J && q.epsilonOnlyTransitions && q.transitions[0].target instanceof N && (S.isPrecedenceDecision = !0);
        }
      }
    }
    verifyATN(p) {
      if (this.deserializationOptions.verifyATN) for (let v = 0; v < p.states.length; v++) {
        const S = p.states[v];
        if (S !== null) if (this.checkCondition(S.epsilonOnlyTransitions || S.transitions.length <= 1), S instanceof Ce) this.checkCondition(S.loopBackState !== null);
        else if (S instanceof xe) if (this.checkCondition(S.loopBackState !== null), this.checkCondition(S.transitions.length === 2), S.transitions[0].target instanceof G) this.checkCondition(S.transitions[1].target instanceof J), this.checkCondition(!S.nonGreedy);
        else {
          if (!(S.transitions[0].target instanceof J)) throw "IllegalState";
          this.checkCondition(S.transitions[1].target instanceof G), this.checkCondition(S.nonGreedy);
        }
        else S instanceof de ? (this.checkCondition(S.transitions.length === 1), this.checkCondition(S.transitions[0].target instanceof xe)) : S instanceof J ? this.checkCondition(S.loopBackState !== null) : S instanceof ye ? this.checkCondition(S.stopState !== null) : S instanceof _e ? this.checkCondition(S.endState !== null) : S instanceof V ? this.checkCondition(S.startState !== null) : S instanceof Ee ? this.checkCondition(S.transitions.length <= 1 || S.decision >= 0) : this.checkCondition(S.transitions.length <= 1 || S instanceof N);
      }
    }
    checkCondition(p, v) {
      if (!p) throw v == null && (v = "IllegalState"), v;
    }
    readInt() {
      return this.data[this.pos++];
    }
    readInt32() {
      return this.readInt() | this.readInt() << 16;
    }
    edgeFactory(p, v, S, q, z, W, oe, we) {
      const Ae = p.states[q];
      switch (v) {
        case D.EPSILON:
          return new De(Ae);
        case D.RANGE:
          return new be(Ae, oe !== 0 ? t.EOF : z, W);
        case D.RULE:
          return new b(p.states[z], W, oe, Ae);
        case D.PREDICATE:
          return new Oe(Ae, z, W, oe !== 0);
        case D.PRECEDENCE:
          return new Ie(Ae, z);
        case D.ATOM:
          return new ge(Ae, oe !== 0 ? t.EOF : z);
        case D.ACTION:
          return new Se(Ae, z, W, oe !== 0);
        case D.SET:
          return new C(Ae, we[z]);
        case D.NOT_SET:
          return new A(Ae, we[z]);
        case D.WILDCARD:
          return new T(Ae);
        default:
          throw "The specified transition type: " + v + " is not valid.";
      }
    }
    stateFactory(p, v) {
      if (this.stateFactories === null) {
        const S = [];
        S[x.INVALID_TYPE] = null, S[x.BASIC] = () => new ve(), S[x.RULE_START] = () => new ye(), S[x.BLOCK_START] = () => new Z(), S[x.PLUS_BLOCK_START] = () => new Ce(), S[x.STAR_BLOCK_START] = () => new G(), S[x.TOKEN_START] = () => new K(), S[x.RULE_STOP] = () => new N(), S[x.BLOCK_END] = () => new V(), S[x.STAR_LOOP_BACK] = () => new de(), S[x.STAR_LOOP_ENTRY] = () => new xe(), S[x.PLUS_LOOP_BACK] = () => new ae(), S[x.LOOP_END] = () => new J(), this.stateFactories = S;
      }
      if (p > this.stateFactories.length || this.stateFactories[p] === null) throw "The specified state type " + p + " is not valid.";
      {
        const S = this.stateFactories[p]();
        if (S !== null) return S.ruleIndex = v, S;
      }
    }
    lexerActionFactory(p, v, S) {
      if (this.actionFactories === null) {
        const q = [];
        q[0] = (z, W) => new Gt(z), q[1] = (z, W) => new P(z, W), q[2] = (z, W) => new it(z), q[3] = (z, W) => fe.INSTANCE, q[4] = (z, W) => Ze.INSTANCE, q[5] = (z, W) => new Fe(z), q[6] = (z, W) => Qe.INSTANCE, q[7] = (z, W) => new Ne(z), this.actionFactories = q;
      }
      if (p > this.actionFactories.length || this.actionFactories[p] === null) throw "The specified lexer action type " + p + " is not valid.";
      return this.actionFactories[p](v, S);
    }
  }
  class ki {
    syntaxError(p, v, S, q, z, W) {
    }
    reportAmbiguity(p, v, S, q, z, W, oe) {
    }
    reportAttemptingFullContext(p, v, S, q, z, W) {
    }
    reportContextSensitivity(p, v, S, q, z, W) {
    }
  }
  class ls extends ki {
    constructor() {
      super();
    }
    syntaxError(p, v, S, q, z, W) {
      console.error("line " + S + ":" + q + " " + z);
    }
  }
  ls.INSTANCE = new ls();
  class yh extends ki {
    constructor(p) {
      if (super(), p === null) throw "delegates";
      return this.delegates = p, this;
    }
    syntaxError(p, v, S, q, z, W) {
      this.delegates.map((oe) => oe.syntaxError(p, v, S, q, z, W));
    }
    reportAmbiguity(p, v, S, q, z, W, oe) {
      this.delegates.map((we) => we.reportAmbiguity(p, v, S, q, z, W, oe));
    }
    reportAttemptingFullContext(p, v, S, q, z, W) {
      this.delegates.map((oe) => oe.reportAttemptingFullContext(p, v, S, q, z, W));
    }
    reportContextSensitivity(p, v, S, q, z, W) {
      this.delegates.map((oe) => oe.reportContextSensitivity(p, v, S, q, z, W));
    }
  }
  class da {
    constructor() {
      this._listeners = [ls.INSTANCE], this._interp = null, this._stateNumber = -1;
    }
    checkVersion(p) {
      const v = "4.13.1";
      v !== p && console.log("ANTLR runtime and generated code versions disagree: " + v + "!=" + p);
    }
    addErrorListener(p) {
      this._listeners.push(p);
    }
    removeErrorListeners() {
      this._listeners = [];
    }
    getLiteralNames() {
      return Object.getPrototypeOf(this).constructor.literalNames || [];
    }
    getSymbolicNames() {
      return Object.getPrototypeOf(this).constructor.symbolicNames || [];
    }
    getTokenNames() {
      if (!this.tokenNames) {
        const p = this.getLiteralNames(), v = this.getSymbolicNames(), S = p.length > v.length ? p.length : v.length;
        this.tokenNames = [];
        for (let q = 0; q < S; q++) this.tokenNames[q] = p[q] || v[q] || "<INVALID";
      }
      return this.tokenNames;
    }
    getTokenTypeMap() {
      const p = this.getTokenNames();
      if (p === null) throw "The current recognizer does not provide a list of token names.";
      let v = this.tokenTypeMapCache[p];
      return v === void 0 && (v = p.reduce(function(S, q, z) {
        S[q] = z;
      }), v.EOF = t.EOF, this.tokenTypeMapCache[p] = v), v;
    }
    getRuleIndexMap() {
      const p = this.ruleNames;
      if (p === null) throw "The current recognizer does not provide a list of rule names.";
      let v = this.ruleIndexMapCache[p];
      return v === void 0 && (v = p.reduce(function(S, q, z) {
        S[q] = z;
      }), this.ruleIndexMapCache[p] = v), v;
    }
    getTokenType(p) {
      const v = this.getTokenTypeMap()[p];
      return v !== void 0 ? v : t.INVALID_TYPE;
    }
    getErrorHeader(p) {
      return "line " + p.getOffendingToken().line + ":" + p.getOffendingToken().column;
    }
    getTokenErrorDisplay(p) {
      if (p === null) return "<no token>";
      let v = p.text;
      return v === null && (v = p.type === t.EOF ? "<EOF>" : "<" + p.type + ">"), v = v.replace(`
`, "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + v + "'";
    }
    getErrorListenerDispatch() {
      return new yh(this._listeners);
    }
    sempred(p, v, S) {
      return !0;
    }
    precpred(p, v) {
      return !0;
    }
    get atn() {
      return this._interp.atn;
    }
    get state() {
      return this._stateNumber;
    }
    set state(p) {
      this._stateNumber = p;
    }
  }
  da.tokenTypeMapCache = {}, da.ruleIndexMapCache = {};
  class wn extends t {
    constructor(p, v, S, q, z) {
      super(), this.source = p !== void 0 ? p : wn.EMPTY_SOURCE, this.type = v !== void 0 ? v : null, this.channel = S !== void 0 ? S : t.DEFAULT_CHANNEL, this.start = q !== void 0 ? q : -1, this.stop = z !== void 0 ? z : -1, this.tokenIndex = -1, this.source[0] !== null ? (this.line = p[0].line, this.column = p[0].column) : this.column = -1;
    }
    clone() {
      const p = new wn(this.source, this.type, this.channel, this.start, this.stop);
      return p.tokenIndex = this.tokenIndex, p.line = this.line, p.column = this.column, p.text = this.text, p;
    }
    cloneWithType(p) {
      const v = new wn(this.source, p, this.channel, this.start, this.stop);
      return v.tokenIndex = this.tokenIndex, v.line = this.line, v.column = this.column, p === t.EOF && (v.text = ""), v;
    }
    toString() {
      let p = this.text;
      return p = p !== null ? p.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t") : "<no text>", "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + p + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
    }
    get text() {
      if (this._text !== null) return this._text;
      const p = this.getInputStream();
      if (p === null) return null;
      const v = p.size;
      return this.start < v && this.stop < v ? p.getText(this.start, this.stop) : "<EOF>";
    }
    set text(p) {
      this._text = p;
    }
  }
  wn.EMPTY_SOURCE = [null, null];
  class xh {
  }
  class cs extends xh {
    constructor(p) {
      super(), this.copyText = p !== void 0 && p;
    }
    create(p, v, S, q, z, W, oe, we) {
      const Ae = new wn(p, v, q, z, W);
      return Ae.line = oe, Ae.column = we, S !== null ? Ae.text = S : this.copyText && p[1] !== null && (Ae.text = p[1].getText(z, W)), Ae;
    }
    createThin(p, v) {
      const S = new wn(null, p);
      return S.text = v, S;
    }
  }
  cs.DEFAULT = new cs();
  class Nn extends Error {
    constructor(p) {
      super(p.message), Error.captureStackTrace && Error.captureStackTrace(this, Nn), this.message = p.message, this.recognizer = p.recognizer, this.input = p.input, this.ctx = p.ctx, this.offendingToken = null, this.offendingState = -1, this.recognizer !== null && (this.offendingState = this.recognizer.state);
    }
    getExpectedTokens() {
      return this.recognizer !== null ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
    }
    toString() {
      return this.message;
    }
  }
  class fs extends Nn {
    constructor(p, v, S, q) {
      super({ message: "", recognizer: p, input: v, ctx: null }), this.startIndex = S, this.deadEndConfigs = q;
    }
    toString() {
      let p = "";
      return this.startIndex >= 0 && this.startIndex < this.input.size && (p = this.input.getText(new w(this.startIndex, this.startIndex))), "LexerNoViableAltException" + p;
    }
  }
  class Vt extends da {
    constructor(p) {
      super(), this._input = p, this._factory = cs.DEFAULT, this._tokenFactorySourcePair = [this, p], this._interp = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = !1, this._channel = t.DEFAULT_CHANNEL, this._type = t.INVALID_TYPE, this._modeStack = [], this._mode = Vt.DEFAULT_MODE, this._text = null;
    }
    reset() {
      this._input !== null && this._input.seek(0), this._token = null, this._type = t.INVALID_TYPE, this._channel = t.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = !1, this._mode = Vt.DEFAULT_MODE, this._modeStack = [], this._interp.reset();
    }
    nextToken() {
      if (this._input === null) throw "nextToken requires a non-null input stream.";
      const p = this._input.mark();
      try {
        for (; ; ) {
          if (this._hitEOF) return this.emitEOF(), this._token;
          this._token = null, this._channel = t.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this._interp.column, this._tokenStartLine = this._interp.line, this._text = null;
          let v = !1;
          for (; ; ) {
            this._type = t.INVALID_TYPE;
            let S = Vt.SKIP;
            try {
              S = this._interp.match(this._input, this._mode);
            } catch (q) {
              if (!(q instanceof Nn)) throw console.log(q.stack), q;
              this.notifyListeners(q), this.recover(q);
            }
            if (this._input.LA(1) === t.EOF && (this._hitEOF = !0), this._type === t.INVALID_TYPE && (this._type = S), this._type === Vt.SKIP) {
              v = !0;
              break;
            }
            if (this._type !== Vt.MORE) break;
          }
          if (!v) return this._token === null && this.emit(), this._token;
        }
      } finally {
        this._input.release(p);
      }
    }
    skip() {
      this._type = Vt.SKIP;
    }
    more() {
      this._type = Vt.MORE;
    }
    mode(p) {
      this._mode = p;
    }
    pushMode(p) {
      this._interp.debug && console.log("pushMode " + p), this._modeStack.push(this._mode), this.mode(p);
    }
    popMode() {
      if (this._modeStack.length === 0) throw "Empty Stack";
      return this._interp.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.mode(this._modeStack.pop()), this._mode;
    }
    emitToken(p) {
      this._token = p;
    }
    emit() {
      const p = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
      return this.emitToken(p), p;
    }
    emitEOF() {
      const p = this.column, v = this.line, S = this._factory.create(this._tokenFactorySourcePair, t.EOF, null, t.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, v, p);
      return this.emitToken(S), S;
    }
    getCharIndex() {
      return this._input.index;
    }
    getAllTokens() {
      const p = [];
      let v = this.nextToken();
      for (; v.type !== t.EOF; ) p.push(v), v = this.nextToken();
      return p;
    }
    notifyListeners(p) {
      const v = this._tokenStartCharIndex, S = this._input.index, q = this._input.getText(v, S), z = "token recognition error at: '" + this.getErrorDisplay(q) + "'";
      this.getErrorListenerDispatch().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, z, p);
    }
    getErrorDisplay(p) {
      const v = [];
      for (let S = 0; S < p.length; S++) v.push(p[S]);
      return v.join("");
    }
    getErrorDisplayForChar(p) {
      return p.charCodeAt(0) === t.EOF ? "<EOF>" : p === `
` ? "\\n" : p === "	" ? "\\t" : p === "\r" ? "\\r" : p;
    }
    getCharErrorDisplay(p) {
      return "'" + this.getErrorDisplayForChar(p) + "'";
    }
    recover(p) {
      this._input.LA(1) !== t.EOF && (p instanceof fs ? this._interp.consume(this._input) : this._input.consume());
    }
    get inputStream() {
      return this._input;
    }
    set inputStream(p) {
      this._input = null, this._tokenFactorySourcePair = [this, this._input], this.reset(), this._input = p, this._tokenFactorySourcePair = [this, this._input];
    }
    get sourceName() {
      return this._input.sourceName;
    }
    get type() {
      return this._type;
    }
    set type(p) {
      this._type = p;
    }
    get line() {
      return this._interp.line;
    }
    set line(p) {
      this._interp.line = p;
    }
    get column() {
      return this._interp.column;
    }
    set column(p) {
      this._interp.column = p;
    }
    get text() {
      return this._text !== null ? this._text : this._interp.getText(this._input);
    }
    set text(p) {
      this._text = p;
    }
  }
  function bh(re) {
    return re.hashCodeForConfigSet();
  }
  function wh(re, p) {
    return re === p || re !== null && p !== null && re.equalsForConfigSet(p);
  }
  Vt.DEFAULT_MODE = 0, Vt.MORE = -2, Vt.SKIP = -3, Vt.DEFAULT_TOKEN_CHANNEL = t.DEFAULT_CHANNEL, Vt.HIDDEN = t.HIDDEN_CHANNEL, Vt.MIN_CHAR_VALUE = 0, Vt.MAX_CHAR_VALUE = 1114111;
  class xr {
    constructor(p) {
      this.configLookup = new c(bh, wh), this.fullCtx = p === void 0 || p, this.readOnly = !1, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = !1, this.dipsIntoOuterContext = !1, this.cachedHashCode = -1;
    }
    add(p, v) {
      if (v === void 0 && (v = null), this.readOnly) throw "This set is readonly";
      p.semanticContext !== l.NONE && (this.hasSemanticContext = !0), p.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = !0);
      const S = this.configLookup.add(p);
      if (S === p) return this.cachedHashCode = -1, this.configs.push(p), !0;
      const q = !this.fullCtx, z = ce(S.context, p.context, q, v);
      return S.reachesIntoOuterContext = Math.max(S.reachesIntoOuterContext, p.reachesIntoOuterContext), p.precedenceFilterSuppressed && (S.precedenceFilterSuppressed = !0), S.context = z, !0;
    }
    getStates() {
      const p = new c();
      for (let v = 0; v < this.configs.length; v++) p.add(this.configs[v].state);
      return p;
    }
    getPredicates() {
      const p = [];
      for (let v = 0; v < this.configs.length; v++) {
        const S = this.configs[v].semanticContext;
        S !== l.NONE && p.push(S.semanticContext);
      }
      return p;
    }
    optimizeConfigs(p) {
      if (this.readOnly) throw "This set is readonly";
      if (this.configLookup.length !== 0) for (let v = 0; v < this.configs.length; v++) {
        const S = this.configs[v];
        S.context = p.getCachedContext(S.context);
      }
    }
    addAll(p) {
      for (let v = 0; v < p.length; v++) this.add(p[v]);
      return !1;
    }
    equals(p) {
      return this === p || p instanceof xr && e(this.configs, p.configs) && this.fullCtx === p.fullCtx && this.uniqueAlt === p.uniqueAlt && this.conflictingAlts === p.conflictingAlts && this.hasSemanticContext === p.hasSemanticContext && this.dipsIntoOuterContext === p.dipsIntoOuterContext;
    }
    hashCode() {
      const p = new i();
      return p.update(this.configs), p.finish();
    }
    updateHashCode(p) {
      this.readOnly ? (this.cachedHashCode === -1 && (this.cachedHashCode = this.hashCode()), p.update(this.cachedHashCode)) : p.update(this.hashCode());
    }
    isEmpty() {
      return this.configs.length === 0;
    }
    contains(p) {
      if (this.configLookup === null) throw "This method is not implemented for readonly sets.";
      return this.configLookup.contains(p);
    }
    containsFast(p) {
      if (this.configLookup === null) throw "This method is not implemented for readonly sets.";
      return this.configLookup.containsFast(p);
    }
    clear() {
      if (this.readOnly) throw "This set is readonly";
      this.configs = [], this.cachedHashCode = -1, this.configLookup = new c();
    }
    setReadonly(p) {
      this.readOnly = p, p && (this.configLookup = null);
    }
    toString() {
      return u(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== le.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
    }
    get items() {
      return this.configs;
    }
    get length() {
      return this.configs.length;
    }
  }
  class Dn {
    constructor(p, v) {
      return p === null && (p = -1), v === null && (v = new xr()), this.stateNumber = p, this.configs = v, this.edges = null, this.isAcceptState = !1, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = !1, this.predicates = null, this;
    }
    getAltSet() {
      const p = new c();
      if (this.configs !== null) for (let v = 0; v < this.configs.length; v++) {
        const S = this.configs[v];
        p.add(S.alt);
      }
      return p.length === 0 ? null : p;
    }
    equals(p) {
      return this === p || p instanceof Dn && this.configs.equals(p.configs);
    }
    toString() {
      let p = this.stateNumber + ":" + this.configs;
      return this.isAcceptState && (p += "=>", this.predicates !== null ? p += this.predicates : p += this.prediction), p;
    }
    hashCode() {
      const p = new i();
      return p.update(this.configs), p.finish();
    }
  }
  class cn {
    constructor(p, v) {
      return this.atn = p, this.sharedContextCache = v, this;
    }
    getCachedContext(p) {
      if (this.sharedContextCache === null) return p;
      const v = new X();
      return ue(p, this.sharedContextCache, v);
    }
  }
  cn.ERROR = new Dn(2147483647, new xr());
  class vo extends xr {
    constructor() {
      super(), this.configLookup = new c();
    }
  }
  class _r extends y {
    constructor(p, v) {
      super(p, v);
      const S = p.lexerActionExecutor || null;
      return this.lexerActionExecutor = S || (v !== null ? v.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = v !== null && this.checkNonGreedyDecision(v, this.state), this.hashCodeForConfigSet = _r.prototype.hashCode, this.equalsForConfigSet = _r.prototype.equals, this;
    }
    updateHashCode(p) {
      p.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
    }
    equals(p) {
      return this === p || p instanceof _r && this.passedThroughNonGreedyDecision === p.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(p.lexerActionExecutor) : !p.lexerActionExecutor) && super.equals(p);
    }
    checkNonGreedyDecision(p, v) {
      return p.passedThroughNonGreedyDecision || v instanceof Ee && v.nonGreedy;
    }
  }
  class zi extends We {
    constructor(p, v) {
      super(v.actionType), this.offset = p, this.action = v, this.isPositionDependent = !0;
    }
    execute(p) {
      this.action.execute(p);
    }
    updateHashCode(p) {
      p.update(this.actionType, this.offset, this.action);
    }
    equals(p) {
      return this === p || p instanceof zi && this.offset === p.offset && this.action === p.action;
    }
  }
  class ci {
    constructor(p) {
      return this.lexerActions = p === null ? [] : p, this.cachedHashCode = i.hashStuff(p), this;
    }
    fixOffsetBeforeMatch(p) {
      let v = null;
      for (let S = 0; S < this.lexerActions.length; S++) !this.lexerActions[S].isPositionDependent || this.lexerActions[S] instanceof zi || (v === null && (v = this.lexerActions.concat([])), v[S] = new zi(p, this.lexerActions[S]));
      return v === null ? this : new ci(v);
    }
    execute(p, v, S) {
      let q = !1;
      const z = v.index;
      try {
        for (let W = 0; W < this.lexerActions.length; W++) {
          let oe = this.lexerActions[W];
          if (oe instanceof zi) {
            const we = oe.offset;
            v.seek(S + we), oe = oe.action, q = S + we !== z;
          } else oe.isPositionDependent && (v.seek(z), q = !1);
          oe.execute(p);
        }
      } finally {
        q && v.seek(z);
      }
    }
    hashCode() {
      return this.cachedHashCode;
    }
    updateHashCode(p) {
      p.update(this.cachedHashCode);
    }
    equals(p) {
      if (this === p) return !0;
      if (p instanceof ci) {
        if (this.cachedHashCode != p.cachedHashCode || this.lexerActions.length != p.lexerActions.length) return !1;
        {
          const v = this.lexerActions.length;
          for (let S = 0; S < v; ++S) if (!this.lexerActions[S].equals(p.lexerActions[S])) return !1;
          return !0;
        }
      }
      return !1;
    }
    static append(p, v) {
      if (p === null) return new ci([v]);
      const S = p.lexerActions.concat([v]);
      return new ci(S);
    }
  }
  function yo(re) {
    re.index = -1, re.line = 0, re.column = -1, re.dfaState = null;
  }
  class Nh {
    constructor() {
      yo(this);
    }
    reset() {
      yo(this);
    }
  }
  class Wt extends cn {
    constructor(p, v, S, q) {
      super(v, q), this.decisionToDFA = S, this.recog = p, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Vt.DEFAULT_MODE, this.prevAccept = new Nh();
    }
    copyState(p) {
      this.column = p.column, this.line = p.line, this.mode = p.mode, this.startIndex = p.startIndex;
    }
    match(p, v) {
      this.mode = v;
      const S = p.mark();
      try {
        this.startIndex = p.index, this.prevAccept.reset();
        const q = this.decisionToDFA[v];
        return q.s0 === null ? this.matchATN(p) : this.execATN(p, q.s0);
      } finally {
        p.release(S);
      }
    }
    reset() {
      this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Vt.DEFAULT_MODE;
    }
    matchATN(p) {
      const v = this.atn.modeToStartState[this.mode];
      Wt.debug && console.log("matchATN mode " + this.mode + " start: " + v);
      const S = this.mode, q = this.computeStartState(p, v), z = q.hasSemanticContext;
      q.hasSemanticContext = !1;
      const W = this.addDFAState(q);
      z || (this.decisionToDFA[this.mode].s0 = W);
      const oe = this.execATN(p, W);
      return Wt.debug && console.log("DFA after matchATN: " + this.decisionToDFA[S].toLexerString()), oe;
    }
    execATN(p, v) {
      Wt.debug && console.log("start state closure=" + v.configs), v.isAcceptState && this.captureSimState(this.prevAccept, p, v);
      let S = p.LA(1), q = v;
      for (; ; ) {
        Wt.debug && console.log("execATN loop starting closure: " + q.configs);
        let z = this.getExistingTargetState(q, S);
        if (z === null && (z = this.computeTargetState(p, q, S)), z === cn.ERROR || (S !== t.EOF && this.consume(p), z.isAcceptState && (this.captureSimState(this.prevAccept, p, z), S === t.EOF))) break;
        S = p.LA(1), q = z;
      }
      return this.failOrAccept(this.prevAccept, p, q.configs, S);
    }
    getExistingTargetState(p, v) {
      if (p.edges === null || v < Wt.MIN_DFA_EDGE || v > Wt.MAX_DFA_EDGE) return null;
      let S = p.edges[v - Wt.MIN_DFA_EDGE];
      return S === void 0 && (S = null), Wt.debug && S !== null && console.log("reuse state " + p.stateNumber + " edge to " + S.stateNumber), S;
    }
    computeTargetState(p, v, S) {
      const q = new vo();
      return this.getReachableConfigSet(p, v.configs, q, S), q.items.length === 0 ? (q.hasSemanticContext || this.addDFAEdge(v, S, cn.ERROR), cn.ERROR) : this.addDFAEdge(v, S, null, q);
    }
    failOrAccept(p, v, S, q) {
      if (this.prevAccept.dfaState !== null) {
        const z = p.dfaState.lexerActionExecutor;
        return this.accept(v, z, this.startIndex, p.index, p.line, p.column), p.dfaState.prediction;
      }
      if (q === t.EOF && v.index === this.startIndex) return t.EOF;
      throw new fs(this.recog, v, this.startIndex, S);
    }
    getReachableConfigSet(p, v, S, q) {
      let z = le.INVALID_ALT_NUMBER;
      for (let W = 0; W < v.items.length; W++) {
        const oe = v.items[W], we = oe.alt === z;
        if (!we || !oe.passedThroughNonGreedyDecision) {
          Wt.debug && console.log(`testing %s at %s
`, this.getTokenName(q), oe.toString(this.recog, !0));
          for (let Ae = 0; Ae < oe.state.transitions.length; Ae++) {
            const Re = oe.state.transitions[Ae], Ue = this.getReachableTarget(Re, q);
            if (Ue !== null) {
              let Ge = oe.lexerActionExecutor;
              Ge !== null && (Ge = Ge.fixOffsetBeforeMatch(p.index - this.startIndex));
              const St = q === t.EOF, st = new _r({ state: Ue, lexerActionExecutor: Ge }, oe);
              this.closure(p, st, S, we, !0, St) && (z = oe.alt);
            }
          }
        }
      }
    }
    accept(p, v, S, q, z, W) {
      Wt.debug && console.log(`ACTION %s
`, v), p.seek(q), this.line = z, this.column = W, v !== null && this.recog !== null && v.execute(this.recog, p, S);
    }
    getReachableTarget(p, v) {
      return p.matches(v, 0, Vt.MAX_CHAR_VALUE) ? p.target : null;
    }
    computeStartState(p, v) {
      const S = Q.EMPTY, q = new vo();
      for (let z = 0; z < v.transitions.length; z++) {
        const W = v.transitions[z].target, oe = new _r({ state: W, alt: z + 1, context: S }, null);
        this.closure(p, oe, q, !1, !1, !1);
      }
      return q;
    }
    closure(p, v, S, q, z, W) {
      let oe = null;
      if (Wt.debug && console.log("closure(" + v.toString(this.recog, !0) + ")"), v.state instanceof N) {
        if (Wt.debug && (this.recog !== null ? console.log(`closure at %s rule stop %s
`, this.recog.ruleNames[v.state.ruleIndex], v) : console.log(`closure at rule stop %s
`, v)), v.context === null || v.context.hasEmptyPath()) {
          if (v.context === null || v.context.isEmpty()) return S.add(v), !0;
          S.add(new _r({ state: v.state, context: Q.EMPTY }, v)), q = !0;
        }
        if (v.context !== null && !v.context.isEmpty()) {
          for (let we = 0; we < v.context.length; we++) if (v.context.getReturnState(we) !== Q.EMPTY_RETURN_STATE) {
            const Ae = v.context.getParent(we), Re = this.atn.states[v.context.getReturnState(we)];
            oe = new _r({ state: Re, context: Ae }, v), q = this.closure(p, oe, S, q, z, W);
          }
        }
        return q;
      }
      v.state.epsilonOnlyTransitions || q && v.passedThroughNonGreedyDecision || S.add(v);
      for (let we = 0; we < v.state.transitions.length; we++) {
        const Ae = v.state.transitions[we];
        oe = this.getEpsilonTarget(p, v, Ae, S, z, W), oe !== null && (q = this.closure(p, oe, S, q, z, W));
      }
      return q;
    }
    getEpsilonTarget(p, v, S, q, z, W) {
      let oe = null;
      if (S.serializationType === D.RULE) {
        const we = j.create(v.context, S.followState.stateNumber);
        oe = new _r({ state: S.target, context: we }, v);
      } else {
        if (S.serializationType === D.PRECEDENCE) throw "Precedence predicates are not supported in lexers.";
        if (S.serializationType === D.PREDICATE) Wt.debug && console.log("EVAL rule " + S.ruleIndex + ":" + S.predIndex), q.hasSemanticContext = !0, this.evaluatePredicate(p, S.ruleIndex, S.predIndex, z) && (oe = new _r({ state: S.target }, v));
        else if (S.serializationType === D.ACTION) if (v.context === null || v.context.hasEmptyPath()) {
          const we = ci.append(v.lexerActionExecutor, this.atn.lexerActions[S.actionIndex]);
          oe = new _r({ state: S.target, lexerActionExecutor: we }, v);
        } else oe = new _r({ state: S.target }, v);
        else S.serializationType === D.EPSILON ? oe = new _r({ state: S.target }, v) : S.serializationType !== D.ATOM && S.serializationType !== D.RANGE && S.serializationType !== D.SET || W && S.matches(t.EOF, 0, Vt.MAX_CHAR_VALUE) && (oe = new _r({ state: S.target }, v));
      }
      return oe;
    }
    evaluatePredicate(p, v, S, q) {
      if (this.recog === null) return !0;
      if (!q) return this.recog.sempred(null, v, S);
      const z = this.column, W = this.line, oe = p.index, we = p.mark();
      try {
        return this.consume(p), this.recog.sempred(null, v, S);
      } finally {
        this.column = z, this.line = W, p.seek(oe), p.release(we);
      }
    }
    captureSimState(p, v, S) {
      p.index = v.index, p.line = this.line, p.column = this.column, p.dfaState = S;
    }
    addDFAEdge(p, v, S, q) {
      if (S === void 0 && (S = null), q === void 0 && (q = null), S === null && q !== null) {
        const z = q.hasSemanticContext;
        if (q.hasSemanticContext = !1, S = this.addDFAState(q), z) return S;
      }
      return v < Wt.MIN_DFA_EDGE || v > Wt.MAX_DFA_EDGE || (Wt.debug && console.log("EDGE " + p + " -> " + S + " upon " + v), p.edges === null && (p.edges = []), p.edges[v - Wt.MIN_DFA_EDGE] = S), S;
    }
    addDFAState(p) {
      const v = new Dn(null, p);
      let S = null;
      for (let oe = 0; oe < p.items.length; oe++) {
        const we = p.items[oe];
        if (we.state instanceof N) {
          S = we;
          break;
        }
      }
      S !== null && (v.isAcceptState = !0, v.lexerActionExecutor = S.lexerActionExecutor, v.prediction = this.atn.ruleToTokenType[S.state.ruleIndex]);
      const q = this.decisionToDFA[this.mode], z = q.states.get(v);
      if (z !== null) return z;
      const W = v;
      return W.stateNumber = q.states.length, p.setReadonly(!0), W.configs = p, q.states.add(W), W;
    }
    getDFA(p) {
      return this.decisionToDFA[p];
    }
    getText(p) {
      return p.getText(this.startIndex, p.index - 1);
    }
    consume(p) {
      p.LA(1) === 10 ? (this.line += 1, this.column = 0) : this.column += 1, p.consume();
    }
    getTokenName(p) {
      return p === -1 ? "EOF" : "'" + String.fromCharCode(p) + "'";
    }
  }
  Wt.debug = !1, Wt.dfa_debug = !1, Wt.MIN_DFA_EDGE = 0, Wt.MAX_DFA_EDGE = 127;
  class xo {
    constructor(p, v) {
      this.alt = v, this.pred = p;
    }
    toString() {
      return "(" + this.pred + ", " + this.alt + ")";
    }
  }
  class Dh {
    constructor() {
      this.data = {};
    }
    get(p) {
      return this.data["k-" + p] || null;
    }
    set(p, v) {
      this.data["k-" + p] = v;
    }
    values() {
      return Object.keys(this.data).filter((p) => p.startsWith("k-")).map((p) => this.data[p], this);
    }
  }
  const fn = { SLL: 0, LL: 1, LL_EXACT_AMBIG_DETECTION: 2, hasSLLConflictTerminatingPrediction: function(re, p) {
    if (fn.allConfigsInRuleStopStates(p)) return !0;
    if (re === fn.SLL && p.hasSemanticContext) {
      const S = new xr();
      for (let q = 0; q < p.items.length; q++) {
        let z = p.items[q];
        z = new y({ semanticContext: l.NONE }, z), S.add(z);
      }
      p = S;
    }
    const v = fn.getConflictingAltSubsets(p);
    return fn.hasConflictingAltSet(v) && !fn.hasStateAssociatedWithOneAlt(p);
  }, hasConfigInRuleStopState: function(re) {
    for (let p = 0; p < re.items.length; p++) if (re.items[p].state instanceof N) return !0;
    return !1;
  }, allConfigsInRuleStopStates: function(re) {
    for (let p = 0; p < re.items.length; p++) if (!(re.items[p].state instanceof N)) return !1;
    return !0;
  }, resolvesToJustOneViableAlt: function(re) {
    return fn.getSingleViableAlt(re);
  }, allSubsetsConflict: function(re) {
    return !fn.hasNonConflictingAltSet(re);
  }, hasNonConflictingAltSet: function(re) {
    for (let p = 0; p < re.length; p++) if (re[p].length === 1) return !0;
    return !1;
  }, hasConflictingAltSet: function(re) {
    for (let p = 0; p < re.length; p++) if (re[p].length > 1) return !0;
    return !1;
  }, allSubsetsEqual: function(re) {
    let p = null;
    for (let v = 0; v < re.length; v++) {
      const S = re[v];
      if (p === null) p = S;
      else if (S !== p) return !1;
    }
    return !0;
  }, getUniqueAlt: function(re) {
    const p = fn.getAlts(re);
    return p.length === 1 ? p.minValue() : le.INVALID_ALT_NUMBER;
  }, getAlts: function(re) {
    const p = new se();
    return re.map(function(v) {
      p.or(v);
    }), p;
  }, getConflictingAltSubsets: function(re) {
    const p = new X();
    return p.hashFunction = function(v) {
      i.hashStuff(v.state.stateNumber, v.context);
    }, p.equalsFunction = function(v, S) {
      return v.state.stateNumber === S.state.stateNumber && v.context.equals(S.context);
    }, re.items.map(function(v) {
      let S = p.get(v);
      S === null && (S = new se(), p.set(v, S)), S.add(v.alt);
    }), p.getValues();
  }, getStateToAltMap: function(re) {
    const p = new Dh();
    return re.items.map(function(v) {
      let S = p.get(v.state);
      S === null && (S = new se(), p.set(v.state, S)), S.add(v.alt);
    }), p;
  }, hasStateAssociatedWithOneAlt: function(re) {
    const p = fn.getStateToAltMap(re).values();
    for (let v = 0; v < p.length; v++) if (p[v].length === 1) return !0;
    return !1;
  }, getSingleViableAlt: function(re) {
    let p = null;
    for (let v = 0; v < re.length; v++) {
      const S = re[v].minValue();
      if (p === null) p = S;
      else if (p !== S) return le.INVALID_ALT_NUMBER;
    }
    return p;
  } }, jt = fn;
  class Ot extends Nn {
    constructor(p, v, S, q, z, W) {
      W = W || p._ctx, q = q || p.getCurrentToken(), S = S || p.getCurrentToken(), v = v || p.getInputStream(), super({ message: "", recognizer: p, input: v, ctx: W }), this.deadEndConfigs = z, this.startToken = S, this.offendingToken = q;
    }
  }
  class Mr {
    constructor(p) {
      this.defaultMapCtor = p || X, this.cacheMap = new this.defaultMapCtor();
    }
    get(p, v) {
      const S = this.cacheMap.get(p) || null;
      return S === null ? null : S.get(v) || null;
    }
    set(p, v, S) {
      let q = this.cacheMap.get(p) || null;
      q === null && (q = new this.defaultMapCtor(), this.cacheMap.set(p, q)), q.set(v, S);
    }
  }
  class bo extends cn {
    constructor(p, v, S, q) {
      super(v, q), this.parser = p, this.decisionToDFA = S, this.predictionMode = jt.LL, this._input = null, this._startIndex = 0, this._outerContext = null, this._dfa = null, this.mergeCache = null, this.debug = !1, this.debug_closure = !1, this.debug_add = !1, this.trace_atn_sim = !1, this.dfa_debug = !1, this.retry_debug = !1;
    }
    reset() {
    }
    adaptivePredict(p, v, S) {
      (this.debug || this.trace_atn_sim) && console.log("adaptivePredict decision " + v + " exec LA(1)==" + this.getLookaheadName(p) + " line " + p.LT(1).line + ":" + p.LT(1).column), this._input = p, this._startIndex = p.index, this._outerContext = S;
      const q = this.decisionToDFA[v];
      this._dfa = q;
      const z = p.mark(), W = p.index;
      try {
        let oe;
        if (oe = q.precedenceDfa ? q.getPrecedenceStartState(this.parser.getPrecedence()) : q.s0, oe === null) {
          S === null && (S = R.EMPTY), this.debug && console.log("predictATN decision " + q.decision + " exec LA(1)==" + this.getLookaheadName(p) + ", outerContext=" + S.toString(this.parser.ruleNames));
          let Re = this.computeStartState(q.atnStartState, R.EMPTY, !1);
          q.precedenceDfa ? (q.s0.configs = Re, Re = this.applyPrecedenceFilter(Re), oe = this.addDFAState(q, new Dn(null, Re)), q.setPrecedenceStartState(this.parser.getPrecedence(), oe)) : (oe = this.addDFAState(q, new Dn(null, Re)), q.s0 = oe);
        }
        const we = this.execATN(q, oe, p, W, S);
        return this.debug && console.log("DFA after predictATN: " + q.toString(this.parser.literalNames, this.parser.symbolicNames)), we;
      } finally {
        this._dfa = null, this.mergeCache = null, p.seek(W), p.release(z);
      }
    }
    execATN(p, v, S, q, z) {
      let W;
      (this.debug || this.trace_atn_sim) && console.log("execATN decision " + p.decision + ", DFA state " + v + ", LA(1)==" + this.getLookaheadName(S) + " line " + S.LT(1).line + ":" + S.LT(1).column);
      let oe = v;
      this.debug && console.log("s0 = " + v);
      let we = S.LA(1);
      for (; ; ) {
        let Ae = this.getExistingTargetState(oe, we);
        if (Ae === null && (Ae = this.computeTargetState(p, oe, we)), Ae === cn.ERROR) {
          const Re = this.noViableAlt(S, z, oe.configs, q);
          if (S.seek(q), W = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(oe.configs, z), W !== le.INVALID_ALT_NUMBER) return W;
          throw Re;
        }
        if (Ae.requiresFullContext && this.predictionMode !== jt.SLL) {
          let Re = null;
          if (Ae.predicates !== null) {
            this.debug && console.log("DFA state has preds in DFA sim LL failover");
            const St = S.index;
            if (St !== q && S.seek(q), Re = this.evalSemanticContext(Ae.predicates, z, !0), Re.length === 1) return this.debug && console.log("Full LL avoided"), Re.minValue();
            St !== q && S.seek(St);
          }
          this.dfa_debug && console.log("ctx sensitive state " + z + " in " + Ae);
          const Ue = !0, Ge = this.computeStartState(p.atnStartState, z, Ue);
          return this.reportAttemptingFullContext(p, Re, Ae.configs, q, S.index), W = this.execATNWithFullContext(p, Ae, Ge, S, q, z), W;
        }
        if (Ae.isAcceptState) {
          if (Ae.predicates === null) return Ae.prediction;
          const Re = S.index;
          S.seek(q);
          const Ue = this.evalSemanticContext(Ae.predicates, z, !0);
          if (Ue.length === 0) throw this.noViableAlt(S, z, Ae.configs, q);
          return Ue.length === 1 || this.reportAmbiguity(p, Ae, q, Re, !1, Ue, Ae.configs), Ue.minValue();
        }
        oe = Ae, we !== t.EOF && (S.consume(), we = S.LA(1));
      }
    }
    getExistingTargetState(p, v) {
      const S = p.edges;
      return S === null ? null : S[v + 1] || null;
    }
    computeTargetState(p, v, S) {
      const q = this.computeReachSet(v.configs, S, !1);
      if (q === null) return this.addDFAEdge(p, v, S, cn.ERROR), cn.ERROR;
      let z = new Dn(null, q);
      const W = this.getUniqueAlt(q);
      if (this.debug) {
        const oe = jt.getConflictingAltSubsets(q);
        console.log("SLL altSubSets=" + u(oe) + ", configs=" + q + ", predict=" + W + ", allSubsetsConflict=" + jt.allSubsetsConflict(oe) + ", conflictingAlts=" + this.getConflictingAlts(q));
      }
      return W !== le.INVALID_ALT_NUMBER ? (z.isAcceptState = !0, z.configs.uniqueAlt = W, z.prediction = W) : jt.hasSLLConflictTerminatingPrediction(this.predictionMode, q) && (z.configs.conflictingAlts = this.getConflictingAlts(q), z.requiresFullContext = !0, z.isAcceptState = !0, z.prediction = z.configs.conflictingAlts.minValue()), z.isAcceptState && z.configs.hasSemanticContext && (this.predicateDFAState(z, this.atn.getDecisionState(p.decision)), z.predicates !== null && (z.prediction = le.INVALID_ALT_NUMBER)), z = this.addDFAEdge(p, v, S, z), z;
    }
    predicateDFAState(p, v) {
      const S = v.transitions.length, q = this.getConflictingAltsOrUniqueAlt(p.configs), z = this.getPredsForAmbigAlts(q, p.configs, S);
      z !== null ? (p.predicates = this.getPredicatePredictions(q, z), p.prediction = le.INVALID_ALT_NUMBER) : p.prediction = q.minValue();
    }
    execATNWithFullContext(p, v, S, q, z, W) {
      (this.debug || this.trace_atn_sim) && console.log("execATNWithFullContext " + S);
      let oe, we = !1, Ae = S;
      q.seek(z);
      let Re = q.LA(1), Ue = -1;
      for (; ; ) {
        if (oe = this.computeReachSet(Ae, Re, !0), oe === null) {
          const St = this.noViableAlt(q, W, Ae, z);
          q.seek(z);
          const st = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(Ae, W);
          if (st !== le.INVALID_ALT_NUMBER) return st;
          throw St;
        }
        const Ge = jt.getConflictingAltSubsets(oe);
        if (this.debug && console.log("LL altSubSets=" + Ge + ", predict=" + jt.getUniqueAlt(Ge) + ", resolvesToJustOneViableAlt=" + jt.resolvesToJustOneViableAlt(Ge)), oe.uniqueAlt = this.getUniqueAlt(oe), oe.uniqueAlt !== le.INVALID_ALT_NUMBER) {
          Ue = oe.uniqueAlt;
          break;
        }
        if (this.predictionMode !== jt.LL_EXACT_AMBIG_DETECTION) {
          if (Ue = jt.resolvesToJustOneViableAlt(Ge), Ue !== le.INVALID_ALT_NUMBER) break;
        } else if (jt.allSubsetsConflict(Ge) && jt.allSubsetsEqual(Ge)) {
          we = !0, Ue = jt.getSingleViableAlt(Ge);
          break;
        }
        Ae = oe, Re !== t.EOF && (q.consume(), Re = q.LA(1));
      }
      return oe.uniqueAlt !== le.INVALID_ALT_NUMBER ? (this.reportContextSensitivity(p, Ue, oe, z, q.index), Ue) : (this.reportAmbiguity(p, v, z, q.index, we, null, oe), Ue);
    }
    computeReachSet(p, v, S) {
      this.debug && console.log("in computeReachSet, starting closure: " + p), this.mergeCache === null && (this.mergeCache = new Mr());
      const q = new xr(S);
      let z = null;
      for (let oe = 0; oe < p.items.length; oe++) {
        const we = p.items[oe];
        if (this.debug && console.log("testing " + this.getTokenName(v) + " at " + we), we.state instanceof N) (S || v === t.EOF) && (z === null && (z = []), z.push(we), this.debug_add && console.log("added " + we + " to skippedStopStates"));
        else for (let Ae = 0; Ae < we.state.transitions.length; Ae++) {
          const Re = we.state.transitions[Ae], Ue = this.getReachableTarget(Re, v);
          if (Ue !== null) {
            const Ge = new y({ state: Ue }, we);
            q.add(Ge, this.mergeCache), this.debug_add && console.log("added " + Ge + " to intermediate");
          }
        }
      }
      let W = null;
      if (z === null && v !== t.EOF && (q.items.length === 1 || this.getUniqueAlt(q) !== le.INVALID_ALT_NUMBER) && (W = q), W === null) {
        W = new xr(S);
        const oe = new c(), we = v === t.EOF;
        for (let Ae = 0; Ae < q.items.length; Ae++) this.closure(q.items[Ae], W, oe, !1, S, we);
      }
      if (v === t.EOF && (W = this.removeAllConfigsNotInRuleStopState(W, W === q)), !(z === null || S && jt.hasConfigInRuleStopState(W))) for (let oe = 0; oe < z.length; oe++) W.add(z[oe], this.mergeCache);
      return this.trace_atn_sim && console.log("computeReachSet " + p + " -> " + W), W.items.length === 0 ? null : W;
    }
    removeAllConfigsNotInRuleStopState(p, v) {
      if (jt.allConfigsInRuleStopStates(p)) return p;
      const S = new xr(p.fullCtx);
      for (let q = 0; q < p.items.length; q++) {
        const z = p.items[q];
        if (z.state instanceof N) S.add(z, this.mergeCache);
        else if (v && z.state.epsilonOnlyTransitions && this.atn.nextTokens(z.state).contains(t.EPSILON)) {
          const W = this.atn.ruleToStopState[z.state.ruleIndex];
          S.add(new y({ state: W }, z), this.mergeCache);
        }
      }
      return S;
    }
    computeStartState(p, v, S) {
      const q = te(this.atn, v), z = new xr(S);
      this.trace_atn_sim && console.log("computeStartState from ATN state " + p + " initialContext=" + q.toString(this.parser));
      for (let W = 0; W < p.transitions.length; W++) {
        const oe = p.transitions[W].target, we = new y({ state: oe, alt: W + 1, context: q }, null), Ae = new c();
        this.closure(we, z, Ae, !0, S, !1);
      }
      return z;
    }
    applyPrecedenceFilter(p) {
      let v;
      const S = [], q = new xr(p.fullCtx);
      for (let z = 0; z < p.items.length; z++) {
        if (v = p.items[z], v.alt !== 1) continue;
        const W = v.semanticContext.evalPrecedence(this.parser, this._outerContext);
        W !== null && (S[v.state.stateNumber] = v.context, W !== v.semanticContext ? q.add(new y({ semanticContext: W }, v), this.mergeCache) : q.add(v, this.mergeCache));
      }
      for (let z = 0; z < p.items.length; z++) if (v = p.items[z], v.alt !== 1) {
        if (!v.precedenceFilterSuppressed) {
          const W = S[v.state.stateNumber] || null;
          if (W !== null && W.equals(v.context)) continue;
        }
        q.add(v, this.mergeCache);
      }
      return q;
    }
    getReachableTarget(p, v) {
      return p.matches(v, 0, this.atn.maxTokenType) ? p.target : null;
    }
    getPredsForAmbigAlts(p, v, S) {
      let q = [];
      for (let W = 0; W < v.items.length; W++) {
        const oe = v.items[W];
        p.has(oe.alt) && (q[oe.alt] = l.orContext(q[oe.alt] || null, oe.semanticContext));
      }
      let z = 0;
      for (let W = 1; W < S + 1; W++) {
        const oe = q[W] || null;
        oe === null ? q[W] = l.NONE : oe !== l.NONE && (z += 1);
      }
      return z === 0 && (q = null), this.debug && console.log("getPredsForAmbigAlts result " + u(q)), q;
    }
    getPredicatePredictions(p, v) {
      const S = [];
      let q = !1;
      for (let z = 1; z < v.length; z++) {
        const W = v[z];
        p !== null && p.has(z) && S.push(new xo(W, z)), W !== l.NONE && (q = !0);
      }
      return q ? S : null;
    }
    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(p, v) {
      const S = this.splitAccordingToSemanticValidity(p, v), q = S[0], z = S[1];
      let W = this.getAltThatFinishedDecisionEntryRule(q);
      return W !== le.INVALID_ALT_NUMBER || z.items.length > 0 && (W = this.getAltThatFinishedDecisionEntryRule(z), W !== le.INVALID_ALT_NUMBER) ? W : le.INVALID_ALT_NUMBER;
    }
    getAltThatFinishedDecisionEntryRule(p) {
      const v = [];
      for (let S = 0; S < p.items.length; S++) {
        const q = p.items[S];
        (q.reachesIntoOuterContext > 0 || q.state instanceof N && q.context.hasEmptyPath()) && v.indexOf(q.alt) < 0 && v.push(q.alt);
      }
      return v.length === 0 ? le.INVALID_ALT_NUMBER : Math.min.apply(null, v);
    }
    splitAccordingToSemanticValidity(p, v) {
      const S = new xr(p.fullCtx), q = new xr(p.fullCtx);
      for (let z = 0; z < p.items.length; z++) {
        const W = p.items[z];
        W.semanticContext !== l.NONE ? W.semanticContext.evaluate(this.parser, v) ? S.add(W) : q.add(W) : S.add(W);
      }
      return [S, q];
    }
    evalSemanticContext(p, v, S) {
      const q = new se();
      for (let z = 0; z < p.length; z++) {
        const W = p[z];
        if (W.pred === l.NONE) {
          if (q.add(W.alt), !S) break;
          continue;
        }
        const oe = W.pred.evaluate(this.parser, v);
        if ((this.debug || this.dfa_debug) && console.log("eval pred " + W + "=" + oe), oe && ((this.debug || this.dfa_debug) && console.log("PREDICT " + W.alt), q.add(W.alt), !S)) break;
      }
      return q;
    }
    closure(p, v, S, q, z, W) {
      this.closureCheckingStopState(p, v, S, q, z, 0, W);
    }
    closureCheckingStopState(p, v, S, q, z, W, oe) {
      if ((this.trace_atn_sim || this.debug_closure) && console.log("closure(" + p.toString(this.parser, !0) + ")"), p.state instanceof N) {
        if (!p.context.isEmpty()) {
          for (let we = 0; we < p.context.length; we++) {
            if (p.context.getReturnState(we) === Q.EMPTY_RETURN_STATE) {
              if (z) {
                v.add(new y({ state: p.state, context: Q.EMPTY }, p), this.mergeCache);
                continue;
              }
              this.debug && console.log("FALLING off rule " + this.getRuleName(p.state.ruleIndex)), this.closure_(p, v, S, q, z, W, oe);
              continue;
            }
            const Ae = this.atn.states[p.context.getReturnState(we)], Re = p.context.getParent(we), Ue = { state: Ae, alt: p.alt, context: Re, semanticContext: p.semanticContext }, Ge = new y(Ue, null);
            Ge.reachesIntoOuterContext = p.reachesIntoOuterContext, this.closureCheckingStopState(Ge, v, S, q, z, W - 1, oe);
          }
          return;
        }
        if (z) return void v.add(p, this.mergeCache);
        this.debug && console.log("FALLING off rule " + this.getRuleName(p.state.ruleIndex));
      }
      this.closure_(p, v, S, q, z, W, oe);
    }
    closure_(p, v, S, q, z, W, oe) {
      const we = p.state;
      we.epsilonOnlyTransitions || v.add(p, this.mergeCache);
      for (let Ae = 0; Ae < we.transitions.length; Ae++) {
        if (Ae === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(p)) continue;
        const Re = we.transitions[Ae], Ue = q && !(Re instanceof Se), Ge = this.getEpsilonTarget(p, Re, Ue, W === 0, z, oe);
        if (Ge !== null) {
          let St = W;
          if (p.state instanceof N) {
            if (this._dfa !== null && this._dfa.precedenceDfa && Re.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex && (Ge.precedenceFilterSuppressed = !0), Ge.reachesIntoOuterContext += 1, S.add(Ge) !== Ge) continue;
            v.dipsIntoOuterContext = !0, St -= 1, this.debug && console.log("dips into outer ctx: " + Ge);
          } else {
            if (!Re.isEpsilon && S.add(Ge) !== Ge) continue;
            Re instanceof b && St >= 0 && (St += 1);
          }
          this.closureCheckingStopState(Ge, v, S, Ue, z, St, oe);
        }
      }
    }
    canDropLoopEntryEdgeInLeftRecursiveRule(p) {
      const v = p.state;
      if (v.stateType !== x.STAR_LOOP_ENTRY || v.stateType !== x.STAR_LOOP_ENTRY || !v.isPrecedenceDecision || p.context.isEmpty() || p.context.hasEmptyPath()) return !1;
      const S = p.context.length;
      for (let W = 0; W < S; W++) if (this.atn.states[p.context.getReturnState(W)].ruleIndex !== v.ruleIndex) return !1;
      const q = v.transitions[0].target.endState.stateNumber, z = this.atn.states[q];
      for (let W = 0; W < S; W++) {
        const oe = p.context.getReturnState(W), we = this.atn.states[oe];
        if (we.transitions.length !== 1 || !we.transitions[0].isEpsilon) return !1;
        const Ae = we.transitions[0].target;
        if (!(we.stateType === x.BLOCK_END && Ae === v || we === z || Ae === z || Ae.stateType === x.BLOCK_END && Ae.transitions.length === 1 && Ae.transitions[0].isEpsilon && Ae.transitions[0].target === v)) return !1;
      }
      return !0;
    }
    getRuleName(p) {
      return this.parser !== null && p >= 0 ? this.parser.ruleNames[p] : "<rule " + p + ">";
    }
    getEpsilonTarget(p, v, S, q, z, W) {
      switch (v.serializationType) {
        case D.RULE:
          return this.ruleTransition(p, v);
        case D.PRECEDENCE:
          return this.precedenceTransition(p, v, S, q, z);
        case D.PREDICATE:
          return this.predTransition(p, v, S, q, z);
        case D.ACTION:
          return this.actionTransition(p, v);
        case D.EPSILON:
          return new y({ state: v.target }, p);
        case D.ATOM:
        case D.RANGE:
        case D.SET:
          return W && v.matches(t.EOF, 0, 1) ? new y({ state: v.target }, p) : null;
        default:
          return null;
      }
    }
    actionTransition(p, v) {
      if (this.debug) {
        const S = v.actionIndex === -1 ? 65535 : v.actionIndex;
        console.log("ACTION edge " + v.ruleIndex + ":" + S);
      }
      return new y({ state: v.target }, p);
    }
    precedenceTransition(p, v, S, q, z) {
      this.debug && (console.log("PRED (collectPredicates=" + S + ") " + v.precedence + ">=_p, ctx dependent=true"), this.parser !== null && console.log("context surrounding pred is " + u(this.parser.getRuleInvocationStack())));
      let W = null;
      if (S && q) if (z) {
        const oe = this._input.index;
        this._input.seek(this._startIndex);
        const we = v.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(oe), we && (W = new y({ state: v.target }, p));
      } else {
        const oe = l.andContext(p.semanticContext, v.getPredicate());
        W = new y({ state: v.target, semanticContext: oe }, p);
      }
      else W = new y({ state: v.target }, p);
      return this.debug && console.log("config from pred transition=" + W), W;
    }
    predTransition(p, v, S, q, z) {
      this.debug && (console.log("PRED (collectPredicates=" + S + ") " + v.ruleIndex + ":" + v.predIndex + ", ctx dependent=" + v.isCtxDependent), this.parser !== null && console.log("context surrounding pred is " + u(this.parser.getRuleInvocationStack())));
      let W = null;
      if (S && (v.isCtxDependent && q || !v.isCtxDependent)) if (z) {
        const oe = this._input.index;
        this._input.seek(this._startIndex);
        const we = v.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(oe), we && (W = new y({ state: v.target }, p));
      } else {
        const oe = l.andContext(p.semanticContext, v.getPredicate());
        W = new y({ state: v.target, semanticContext: oe }, p);
      }
      else W = new y({ state: v.target }, p);
      return this.debug && console.log("config from pred transition=" + W), W;
    }
    ruleTransition(p, v) {
      this.debug && console.log("CALL rule " + this.getRuleName(v.target.ruleIndex) + ", ctx=" + p.context);
      const S = v.followState, q = j.create(p.context, S.stateNumber);
      return new y({ state: v.target, context: q }, p);
    }
    getConflictingAlts(p) {
      const v = jt.getConflictingAltSubsets(p);
      return jt.getAlts(v);
    }
    getConflictingAltsOrUniqueAlt(p) {
      let v = null;
      return p.uniqueAlt !== le.INVALID_ALT_NUMBER ? (v = new se(), v.add(p.uniqueAlt)) : v = p.conflictingAlts, v;
    }
    getTokenName(p) {
      if (p === t.EOF) return "EOF";
      if (this.parser !== null && this.parser.literalNames !== null) {
        if (!(p >= this.parser.literalNames.length && p >= this.parser.symbolicNames.length)) return (this.parser.literalNames[p] || this.parser.symbolicNames[p]) + "<" + p + ">";
        console.log(p + " ttype out of range: " + this.parser.literalNames), console.log("" + this.parser.getInputStream().getTokens());
      }
      return "" + p;
    }
    getLookaheadName(p) {
      return this.getTokenName(p.LA(1));
    }
    dumpDeadEndConfigs(p) {
      console.log("dead end configs: ");
      const v = p.getDeadEndConfigs();
      for (let S = 0; S < v.length; S++) {
        const q = v[S];
        let z = "no edges";
        if (q.state.transitions.length > 0) {
          const W = q.state.transitions[0];
          W instanceof ge ? z = "Atom " + this.getTokenName(W.label) : W instanceof C && (z = (W instanceof A ? "~" : "") + "Set " + W.set);
        }
        console.error(q.toString(this.parser, !0) + ":" + z);
      }
    }
    noViableAlt(p, v, S, q) {
      return new Ot(this.parser, p, p.get(q), p.LT(1), S, v);
    }
    getUniqueAlt(p) {
      let v = le.INVALID_ALT_NUMBER;
      for (let S = 0; S < p.items.length; S++) {
        const q = p.items[S];
        if (v === le.INVALID_ALT_NUMBER) v = q.alt;
        else if (q.alt !== v) return le.INVALID_ALT_NUMBER;
      }
      return v;
    }
    addDFAEdge(p, v, S, q) {
      if (this.debug && console.log("EDGE " + v + " -> " + q + " upon " + this.getTokenName(S)), q === null) return null;
      if (q = this.addDFAState(p, q), v === null || S < -1 || S > this.atn.maxTokenType) return q;
      if (v.edges === null && (v.edges = []), v.edges[S + 1] = q, this.debug) {
        const z = this.parser === null ? null : this.parser.literalNames, W = this.parser === null ? null : this.parser.symbolicNames;
        console.log(`DFA=
` + p.toString(z, W));
      }
      return q;
    }
    addDFAState(p, v) {
      if (v === cn.ERROR) return v;
      const S = p.states.get(v);
      return S !== null ? (this.trace_atn_sim && console.log("addDFAState " + v + " exists"), S) : (v.stateNumber = p.states.length, v.configs.readOnly || (v.configs.optimizeConfigs(this), v.configs.setReadonly(!0)), this.trace_atn_sim && console.log("addDFAState new " + v), p.states.add(v), this.debug && console.log("adding new DFA state: " + v), v);
    }
    reportAttemptingFullContext(p, v, S, q, z) {
      if (this.debug || this.retry_debug) {
        const W = new w(q, z + 1);
        console.log("reportAttemptingFullContext decision=" + p.decision + ":" + S + ", input=" + this.parser.getTokenStream().getText(W));
      }
      this.parser !== null && this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, p, q, z, v, S);
    }
    reportContextSensitivity(p, v, S, q, z) {
      if (this.debug || this.retry_debug) {
        const W = new w(q, z + 1);
        console.log("reportContextSensitivity decision=" + p.decision + ":" + S + ", input=" + this.parser.getTokenStream().getText(W));
      }
      this.parser !== null && this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, p, q, z, v, S);
    }
    reportAmbiguity(p, v, S, q, z, W, oe) {
      if (this.debug || this.retry_debug) {
        const we = new w(S, q + 1);
        console.log("reportAmbiguity " + W + ":" + oe + ", input=" + this.parser.getTokenStream().getText(we));
      }
      this.parser !== null && this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, p, S, q, z, W, oe);
    }
  }
  class $i {
    constructor() {
      this.cache = new X();
    }
    add(p) {
      if (p === Q.EMPTY) return Q.EMPTY;
      const v = this.cache.get(p) || null;
      return v !== null ? v : (this.cache.set(p, p), p);
    }
    get(p) {
      return this.cache.get(p) || null;
    }
    get length() {
      return this.cache.length;
    }
  }
  const Ui = { ATN: le, ATNDeserializer: Li, LexerATNSimulator: Wt, ParserATNSimulator: bo, PredictionMode: jt, PredictionContextCache: $i };
  class ps {
    constructor(p, v, S) {
      this.dfa = p, this.literalNames = v || [], this.symbolicNames = S || [];
    }
    toString() {
      if (this.dfa.s0 === null) return null;
      let p = "";
      const v = this.dfa.sortedStates();
      for (let S = 0; S < v.length; S++) {
        const q = v[S];
        if (q.edges !== null) {
          const z = q.edges.length;
          for (let W = 0; W < z; W++) {
            const oe = q.edges[W] || null;
            oe !== null && oe.stateNumber !== 2147483647 && (p = p.concat(this.getStateString(q)), p = p.concat("-"), p = p.concat(this.getEdgeLabel(W)), p = p.concat("->"), p = p.concat(this.getStateString(oe)), p = p.concat(`
`));
          }
        }
      }
      return p.length === 0 ? null : p;
    }
    getEdgeLabel(p) {
      return p === 0 ? "EOF" : this.literalNames !== null || this.symbolicNames !== null ? this.literalNames[p - 1] || this.symbolicNames[p - 1] : String.fromCharCode(p - 1);
    }
    getStateString(p) {
      const v = (p.isAcceptState ? ":" : "") + "s" + p.stateNumber + (p.requiresFullContext ? "^" : "");
      return p.isAcceptState ? p.predicates !== null ? v + "=>" + u(p.predicates) : v + "=>" + p.prediction.toString() : v;
    }
  }
  class Av extends ps {
    constructor(p) {
      super(p, null);
    }
    getEdgeLabel(p) {
      return "'" + String.fromCharCode(p) + "'";
    }
  }
  class Cv {
    constructor(p, v) {
      if (v === void 0 && (v = 0), this.atnStartState = p, this.decision = v, this._states = new c(), this.s0 = null, this.precedenceDfa = !1, p instanceof xe && p.isPrecedenceDecision) {
        this.precedenceDfa = !0;
        const S = new Dn(null, new xr());
        S.edges = [], S.isAcceptState = !1, S.requiresFullContext = !1, this.s0 = S;
      }
    }
    getPrecedenceStartState(p) {
      if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
      return p < 0 || p >= this.s0.edges.length ? null : this.s0.edges[p] || null;
    }
    setPrecedenceStartState(p, v) {
      if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
      p < 0 || (this.s0.edges[p] = v);
    }
    setPrecedenceDfa(p) {
      if (this.precedenceDfa !== p) {
        if (this._states = new c(), p) {
          const v = new Dn(null, new xr());
          v.edges = [], v.isAcceptState = !1, v.requiresFullContext = !1, this.s0 = v;
        } else this.s0 = null;
        this.precedenceDfa = p;
      }
    }
    sortedStates() {
      return this._states.values().sort(function(p, v) {
        return p.stateNumber - v.stateNumber;
      });
    }
    toString(p, v) {
      return p = p || null, v = v || null, this.s0 === null ? "" : new ps(this, p, v).toString();
    }
    toLexerString() {
      return this.s0 === null ? "" : new Av(this).toString();
    }
    get states() {
      return this._states;
    }
  }
  const _A = { DFA: Cv, DFASerializer: ps, LexerDFASerializer: Av, PredPrediction: xo }, MA = { PredictionContext: Q }, OA = { Interval: w, IntervalSet: E };
  class Eh {
    visitTerminal(p) {
    }
    visitErrorNode(p) {
    }
    enterEveryRule(p) {
    }
    exitEveryRule(p) {
    }
  }
  class Tv {
    visit(p) {
      return Array.isArray(p) ? p.map(function(v) {
        return v.accept(this);
      }, this) : p.accept(this);
    }
    visitChildren(p) {
      return p.children ? this.visit(p.children) : null;
    }
    visitTerminal(p) {
    }
    visitErrorNode(p) {
    }
  }
  class wo {
    walk(p, v) {
      if (v instanceof F || v.isErrorNode !== void 0 && v.isErrorNode()) p.visitErrorNode(v);
      else if (v instanceof L) p.visitTerminal(v);
      else {
        this.enterRule(p, v);
        for (let S = 0; S < v.getChildCount(); S++) {
          const q = v.getChild(S);
          this.walk(p, q);
        }
        this.exitRule(p, v);
      }
    }
    enterRule(p, v) {
      const S = v.ruleContext;
      p.enterEveryRule(S), S.enterRule(p);
    }
    exitRule(p, v) {
      const S = v.ruleContext;
      S.exitRule(p), p.exitEveryRule(S);
    }
  }
  wo.DEFAULT = new wo();
  const qA = { Trees: $, RuleNode: k, ErrorNode: F, TerminalNode: L, ParseTreeListener: Eh, ParseTreeVisitor: Tv, ParseTreeWalker: wo };
  class ms extends Nn {
    constructor(p) {
      super({ message: "", recognizer: p, input: p.getInputStream(), ctx: p._ctx }), this.offendingToken = p.getCurrentToken();
    }
  }
  class Sh extends Nn {
    constructor(p, v, S) {
      super({ message: IA(v, S || null), recognizer: p, input: p.getInputStream(), ctx: p._ctx });
      const q = p._interp.atn.states[p.state].transitions[0];
      q instanceof Oe ? (this.ruleIndex = q.ruleIndex, this.predicateIndex = q.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = v, this.offendingToken = p.getCurrentToken();
    }
  }
  function IA(re, p) {
    return p !== null ? p : "failed predicate: {" + re + "}?";
  }
  class _v extends ki {
    constructor(p) {
      super(), p = p || !0, this.exactOnly = p;
    }
    reportAmbiguity(p, v, S, q, z, W, oe) {
      if (this.exactOnly && !z) return;
      const we = "reportAmbiguity d=" + this.getDecisionDescription(p, v) + ": ambigAlts=" + this.getConflictingAlts(W, oe) + ", input='" + p.getTokenStream().getText(new w(S, q)) + "'";
      p.notifyErrorListeners(we);
    }
    reportAttemptingFullContext(p, v, S, q, z, W) {
      const oe = "reportAttemptingFullContext d=" + this.getDecisionDescription(p, v) + ", input='" + p.getTokenStream().getText(new w(S, q)) + "'";
      p.notifyErrorListeners(oe);
    }
    reportContextSensitivity(p, v, S, q, z, W) {
      const oe = "reportContextSensitivity d=" + this.getDecisionDescription(p, v) + ", input='" + p.getTokenStream().getText(new w(S, q)) + "'";
      p.notifyErrorListeners(oe);
    }
    getDecisionDescription(p, v) {
      const S = v.decision, q = v.atnStartState.ruleIndex, z = p.ruleNames;
      if (q < 0 || q >= z.length) return "" + S;
      const W = z[q] || null;
      return W === null || W.length === 0 ? "" + S : `${S} (${W})`;
    }
    getConflictingAlts(p, v) {
      if (p !== null) return p;
      const S = new se();
      for (let q = 0; q < v.items.length; q++) S.add(v.items[q].alt);
      return `{${S.values().join(", ")}}`;
    }
  }
  class Ah extends Error {
    constructor() {
      super(), Error.captureStackTrace(this, Ah);
    }
  }
  class FA {
    reset(p) {
    }
    recoverInline(p) {
    }
    recover(p, v) {
    }
    sync(p) {
    }
    inErrorRecoveryMode(p) {
    }
    reportError(p) {
    }
  }
  class Ch extends FA {
    constructor() {
      super(), this.errorRecoveryMode = !1, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
    }
    reset(p) {
      this.endErrorCondition(p);
    }
    beginErrorCondition(p) {
      this.errorRecoveryMode = !0;
    }
    inErrorRecoveryMode(p) {
      return this.errorRecoveryMode;
    }
    endErrorCondition(p) {
      this.errorRecoveryMode = !1, this.lastErrorStates = null, this.lastErrorIndex = -1;
    }
    reportMatch(p) {
      this.endErrorCondition(p);
    }
    reportError(p, v) {
      this.inErrorRecoveryMode(p) || (this.beginErrorCondition(p), v instanceof Ot ? this.reportNoViableAlternative(p, v) : v instanceof ms ? this.reportInputMismatch(p, v) : v instanceof Sh ? this.reportFailedPredicate(p, v) : (console.log("unknown recognition error type: " + v.constructor.name), console.log(v.stack), p.notifyErrorListeners(v.getOffendingToken(), v.getMessage(), v)));
    }
    recover(p, v) {
      this.lastErrorIndex === p.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(p.state) >= 0 && p.consume(), this.lastErrorIndex = p._input.index, this.lastErrorStates === null && (this.lastErrorStates = []), this.lastErrorStates.push(p.state);
      const S = this.getErrorRecoverySet(p);
      this.consumeUntil(p, S);
    }
    sync(p) {
      if (this.inErrorRecoveryMode(p)) return;
      const v = p._interp.atn.states[p.state], S = p.getTokenStream().LA(1), q = p.atn.nextTokens(v);
      if (q.contains(S)) return this.nextTokensContext = null, void (this.nextTokenState = x.INVALID_STATE_NUMBER);
      if (q.contains(t.EPSILON)) this.nextTokensContext === null && (this.nextTokensContext = p._ctx, this.nextTokensState = p._stateNumber);
      else switch (v.stateType) {
        case x.BLOCK_START:
        case x.STAR_BLOCK_START:
        case x.PLUS_BLOCK_START:
        case x.STAR_LOOP_ENTRY:
          if (this.singleTokenDeletion(p) !== null) return;
          throw new ms(p);
        case x.PLUS_LOOP_BACK:
        case x.STAR_LOOP_BACK: {
          this.reportUnwantedToken(p);
          const z = new E();
          z.addSet(p.getExpectedTokens());
          const W = z.addSet(this.getErrorRecoverySet(p));
          this.consumeUntil(p, W);
        }
      }
    }
    reportNoViableAlternative(p, v) {
      const S = p.getTokenStream();
      let q;
      q = S !== null ? v.startToken.type === t.EOF ? "<EOF>" : S.getText(new w(v.startToken.tokenIndex, v.offendingToken.tokenIndex)) : "<unknown input>";
      const z = "no viable alternative at input " + this.escapeWSAndQuote(q);
      p.notifyErrorListeners(z, v.offendingToken, v);
    }
    reportInputMismatch(p, v) {
      const S = "mismatched input " + this.getTokenErrorDisplay(v.offendingToken) + " expecting " + v.getExpectedTokens().toString(p.literalNames, p.symbolicNames);
      p.notifyErrorListeners(S, v.offendingToken, v);
    }
    reportFailedPredicate(p, v) {
      const S = "rule " + p.ruleNames[p._ctx.ruleIndex] + " " + v.message;
      p.notifyErrorListeners(S, v.offendingToken, v);
    }
    reportUnwantedToken(p) {
      if (this.inErrorRecoveryMode(p)) return;
      this.beginErrorCondition(p);
      const v = p.getCurrentToken(), S = "extraneous input " + this.getTokenErrorDisplay(v) + " expecting " + this.getExpectedTokens(p).toString(p.literalNames, p.symbolicNames);
      p.notifyErrorListeners(S, v, null);
    }
    reportMissingToken(p) {
      if (this.inErrorRecoveryMode(p)) return;
      this.beginErrorCondition(p);
      const v = p.getCurrentToken(), S = "missing " + this.getExpectedTokens(p).toString(p.literalNames, p.symbolicNames) + " at " + this.getTokenErrorDisplay(v);
      p.notifyErrorListeners(S, v, null);
    }
    recoverInline(p) {
      const v = this.singleTokenDeletion(p);
      if (v !== null) return p.consume(), v;
      if (this.singleTokenInsertion(p)) return this.getMissingSymbol(p);
      throw new ms(p);
    }
    singleTokenInsertion(p) {
      const v = p.getTokenStream().LA(1), S = p._interp.atn, q = S.states[p.state].transitions[0].target;
      return !!S.nextTokens(q, p._ctx).contains(v) && (this.reportMissingToken(p), !0);
    }
    singleTokenDeletion(p) {
      const v = p.getTokenStream().LA(2);
      if (this.getExpectedTokens(p).contains(v)) {
        this.reportUnwantedToken(p), p.consume();
        const S = p.getCurrentToken();
        return this.reportMatch(p), S;
      }
      return null;
    }
    getMissingSymbol(p) {
      const v = p.getCurrentToken(), S = this.getExpectedTokens(p).first();
      let q;
      q = S === t.EOF ? "<missing EOF>" : "<missing " + p.literalNames[S] + ">";
      let z = v;
      const W = p.getTokenStream().LT(-1);
      return z.type === t.EOF && W !== null && (z = W), p.getTokenFactory().create(z.source, S, q, t.DEFAULT_CHANNEL, -1, -1, z.line, z.column);
    }
    getExpectedTokens(p) {
      return p.getExpectedTokens();
    }
    getTokenErrorDisplay(p) {
      if (p === null) return "<no token>";
      let v = p.text;
      return v === null && (v = p.type === t.EOF ? "<EOF>" : "<" + p.type + ">"), this.escapeWSAndQuote(v);
    }
    escapeWSAndQuote(p) {
      return "'" + (p = (p = (p = p.replace(/\n/g, "\\n")).replace(/\r/g, "\\r")).replace(/\t/g, "\\t")) + "'";
    }
    getErrorRecoverySet(p) {
      const v = p._interp.atn;
      let S = p._ctx;
      const q = new E();
      for (; S !== null && S.invokingState >= 0; ) {
        const z = v.states[S.invokingState].transitions[0], W = v.nextTokens(z.followState);
        q.addSet(W), S = S.parentCtx;
      }
      return q.removeOne(t.EPSILON), q;
    }
    consumeUntil(p, v) {
      let S = p.getTokenStream().LA(1);
      for (; S !== t.EOF && !v.contains(S); ) p.consume(), S = p.getTokenStream().LA(1);
    }
  }
  class Mv extends Ch {
    constructor() {
      super();
    }
    recover(p, v) {
      let S = p._ctx;
      for (; S !== null; ) S.exception = v, S = S.parentCtx;
      throw new Ah(v);
    }
    recoverInline(p) {
      this.recover(p, new ms(p));
    }
    sync(p) {
    }
  }
  const BA = { RecognitionException: Nn, NoViableAltException: Ot, LexerNoViableAltException: fs, InputMismatchException: ms, FailedPredicateException: Sh, DiagnosticErrorListener: _v, BailErrorStrategy: Mv, DefaultErrorStrategy: Ch, ErrorListener: ki };
  class hs {
    constructor(p, v) {
      if (this.name = "<empty>", this.strdata = p, this.decodeToUnicodeCodePoints = v || !1, this._index = 0, this.data = [], this.decodeToUnicodeCodePoints) for (let S = 0; S < this.strdata.length; ) {
        const q = this.strdata.codePointAt(S);
        this.data.push(q), S += q <= 65535 ? 1 : 2;
      }
      else {
        this.data = new Array(this.strdata.length);
        for (let S = 0; S < this.strdata.length; S++) this.data[S] = this.strdata.charCodeAt(S);
      }
      this._size = this.data.length;
    }
    reset() {
      this._index = 0;
    }
    consume() {
      if (this._index >= this._size) throw "cannot consume EOF";
      this._index += 1;
    }
    LA(p) {
      if (p === 0) return 0;
      p < 0 && (p += 1);
      const v = this._index + p - 1;
      return v < 0 || v >= this._size ? t.EOF : this.data[v];
    }
    LT(p) {
      return this.LA(p);
    }
    mark() {
      return -1;
    }
    release(p) {
    }
    seek(p) {
      p <= this._index ? this._index = p : this._index = Math.min(p, this._size);
    }
    getText(p, v) {
      if (v >= this._size && (v = this._size - 1), p >= this._size) return "";
      if (this.decodeToUnicodeCodePoints) {
        let S = "";
        for (let q = p; q <= v; q++) S += String.fromCodePoint(this.data[q]);
        return S;
      }
      return this.strdata.slice(p, v + 1);
    }
    toString() {
      return this.strdata;
    }
    get index() {
      return this._index;
    }
    get size() {
      return this._size;
    }
  }
  class ds extends hs {
    constructor(p, v) {
      super(p, v);
    }
  }
  var Ov = Hi(92);
  const qv = typeof process < "u" && process.versions != null && process.versions.node != null;
  class Iv extends ds {
    static fromPath(p, v, S) {
      if (!qv) throw new Error("FileStream is only available when running in Node!");
      Ov.readFile(p, v, function(q, z) {
        let W = null;
        z !== null && (W = new hs(z, !0)), S(q, W);
      });
    }
    constructor(p, v, S) {
      if (!qv) throw new Error("FileStream is only available when running in Node!");
      super(Ov.readFileSync(p, v || "utf-8"), S), this.fileName = p;
    }
  }
  const Fv = { fromString: function(re) {
    return new hs(re, !0);
  }, fromBlob: function(re, p, v, S) {
    const q = new window.FileReader();
    q.onload = function(z) {
      const W = new hs(z.target.result, !0);
      v(W);
    }, q.onerror = S, q.readAsText(re, p);
  }, fromBuffer: function(re, p) {
    return new hs(re.toString(p), !0);
  }, fromPath: function(re, p, v) {
    Iv.fromPath(re, p, v);
  }, fromPathSync: function(re, p) {
    return new Iv(re, p);
  } }, RA = { arrayToString: u, stringToCharArray: function(re) {
    let p = new Uint16Array(re.length);
    for (let v = 0; v < re.length; v++) p[v] = re.charCodeAt(v);
    return p;
  } };
  class PA {
  }
  class Bv extends PA {
    constructor(p) {
      super(), this.tokenSource = p, this.tokens = [], this.index = -1, this.fetchedEOF = !1;
    }
    mark() {
      return 0;
    }
    release(p) {
    }
    reset() {
      this.seek(0);
    }
    seek(p) {
      this.lazyInit(), this.index = this.adjustSeekIndex(p);
    }
    get size() {
      return this.tokens.length;
    }
    get(p) {
      return this.lazyInit(), this.tokens[p];
    }
    consume() {
      let p = !1;
      if (p = this.index >= 0 && (this.fetchedEOF ? this.index < this.tokens.length - 1 : this.index < this.tokens.length), !p && this.LA(1) === t.EOF) throw "cannot consume EOF";
      this.sync(this.index + 1) && (this.index = this.adjustSeekIndex(this.index + 1));
    }
    sync(p) {
      const v = p - this.tokens.length + 1;
      return !(v > 0) || this.fetch(v) >= v;
    }
    fetch(p) {
      if (this.fetchedEOF) return 0;
      for (let v = 0; v < p; v++) {
        const S = this.tokenSource.nextToken();
        if (S.tokenIndex = this.tokens.length, this.tokens.push(S), S.type === t.EOF) return this.fetchedEOF = !0, v + 1;
      }
      return p;
    }
    getTokens(p, v, S) {
      if (S === void 0 && (S = null), p < 0 || v < 0) return null;
      this.lazyInit();
      const q = [];
      v >= this.tokens.length && (v = this.tokens.length - 1);
      for (let z = p; z < v; z++) {
        const W = this.tokens[z];
        if (W.type === t.EOF) break;
        (S === null || S.contains(W.type)) && q.push(W);
      }
      return q;
    }
    LA(p) {
      return this.LT(p).type;
    }
    LB(p) {
      return this.index - p < 0 ? null : this.tokens[this.index - p];
    }
    LT(p) {
      if (this.lazyInit(), p === 0) return null;
      if (p < 0) return this.LB(-p);
      const v = this.index + p - 1;
      return this.sync(v), v >= this.tokens.length ? this.tokens[this.tokens.length - 1] : this.tokens[v];
    }
    adjustSeekIndex(p) {
      return p;
    }
    lazyInit() {
      this.index === -1 && this.setup();
    }
    setup() {
      this.sync(0), this.index = this.adjustSeekIndex(0);
    }
    setTokenSource(p) {
      this.tokenSource = p, this.tokens = [], this.index = -1, this.fetchedEOF = !1;
    }
    nextTokenOnChannel(p, v) {
      if (this.sync(p), p >= this.tokens.length) return -1;
      let S = this.tokens[p];
      for (; S.channel !== this.channel; ) {
        if (S.type === t.EOF) return -1;
        p += 1, this.sync(p), S = this.tokens[p];
      }
      return p;
    }
    previousTokenOnChannel(p, v) {
      for (; p >= 0 && this.tokens[p].channel !== v; ) p -= 1;
      return p;
    }
    getHiddenTokensToRight(p, v) {
      if (v === void 0 && (v = -1), this.lazyInit(), p < 0 || p >= this.tokens.length) throw p + " not in 0.." + this.tokens.length - 1;
      const S = this.nextTokenOnChannel(p + 1, Vt.DEFAULT_TOKEN_CHANNEL), q = p + 1, z = S === -1 ? this.tokens.length - 1 : S;
      return this.filterForChannel(q, z, v);
    }
    getHiddenTokensToLeft(p, v) {
      if (v === void 0 && (v = -1), this.lazyInit(), p < 0 || p >= this.tokens.length) throw p + " not in 0.." + this.tokens.length - 1;
      const S = this.previousTokenOnChannel(p - 1, Vt.DEFAULT_TOKEN_CHANNEL);
      if (S === p - 1) return null;
      const q = S + 1, z = p - 1;
      return this.filterForChannel(q, z, v);
    }
    filterForChannel(p, v, S) {
      const q = [];
      for (let z = p; z < v + 1; z++) {
        const W = this.tokens[z];
        S === -1 ? W.channel !== Vt.DEFAULT_TOKEN_CHANNEL && q.push(W) : W.channel === S && q.push(W);
      }
      return q.length === 0 ? null : q;
    }
    getSourceName() {
      return this.tokenSource.getSourceName();
    }
    getText(p) {
      this.lazyInit(), this.fill(), p || (p = new w(0, this.tokens.length - 1));
      let v = p.start;
      v instanceof t && (v = v.tokenIndex);
      let S = p.stop;
      if (S instanceof t && (S = S.tokenIndex), v === null || S === null || v < 0 || S < 0) return "";
      S >= this.tokens.length && (S = this.tokens.length - 1);
      let q = "";
      for (let z = v; z < S + 1; z++) {
        const W = this.tokens[z];
        if (W.type === t.EOF) break;
        q += W.text;
      }
      return q;
    }
    fill() {
      for (this.lazyInit(); this.fetch(1e3) === 1e3; ) ;
    }
  }
  Object.defineProperty(Bv, "size", { get: function() {
    return this.tokens.length;
  } });
  class Rv extends Bv {
    constructor(p, v) {
      super(p), this.channel = v === void 0 ? t.DEFAULT_CHANNEL : v;
    }
    adjustSeekIndex(p) {
      return this.nextTokenOnChannel(p, this.channel);
    }
    LB(p) {
      if (p === 0 || this.index - p < 0) return null;
      let v = this.index, S = 1;
      for (; S <= p; ) v = this.previousTokenOnChannel(v - 1, this.channel), S += 1;
      return v < 0 ? null : this.tokens[v];
    }
    LT(p) {
      if (this.lazyInit(), p === 0) return null;
      if (p < 0) return this.LB(-p);
      let v = this.index, S = 1;
      for (; S < p; ) this.sync(v + 1) && (v = this.nextTokenOnChannel(v + 1, this.channel)), S += 1;
      return this.tokens[v];
    }
    getNumberOfOnChannelTokens() {
      let p = 0;
      this.fill();
      for (let v = 0; v < this.tokens.length; v++) {
        const S = this.tokens[v];
        if (S.channel === this.channel && (p += 1), S.type === t.EOF) break;
      }
      return p;
    }
  }
  class LA extends Eh {
    constructor(p) {
      super(), this.parser = p;
    }
    enterEveryRule(p) {
      console.log("enter   " + this.parser.ruleNames[p.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
    visitTerminal(p) {
      console.log("consume " + p.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
    }
    exitEveryRule(p) {
      console.log("exit    " + this.parser.ruleNames[p.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
  }
  class Th extends da {
    constructor(p) {
      super(), this._input = null, this._errHandler = new Ch(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = !0, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.setInputStream(p);
    }
    reset() {
      this._input !== null && this._input.seek(0), this._errHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(!1), this._precedenceStack = [], this._precedenceStack.push(0), this._interp !== null && this._interp.reset();
    }
    match(p) {
      let v = this.getCurrentToken();
      return v.type === p ? (this._errHandler.reportMatch(this), this.consume()) : (v = this._errHandler.recoverInline(this), this.buildParseTrees && v.tokenIndex === -1 && this._ctx.addErrorNode(v)), v;
    }
    matchWildcard() {
      let p = this.getCurrentToken();
      return p.type > 0 ? (this._errHandler.reportMatch(this), this.consume()) : (p = this._errHandler.recoverInline(this), this.buildParseTrees && p.tokenIndex === -1 && this._ctx.addErrorNode(p)), p;
    }
    getParseListeners() {
      return this._parseListeners || [];
    }
    addParseListener(p) {
      if (p === null) throw "listener";
      this._parseListeners === null && (this._parseListeners = []), this._parseListeners.push(p);
    }
    removeParseListener(p) {
      if (this._parseListeners !== null) {
        const v = this._parseListeners.indexOf(p);
        v >= 0 && this._parseListeners.splice(v, 1), this._parseListeners.length === 0 && (this._parseListeners = null);
      }
    }
    removeParseListeners() {
      this._parseListeners = null;
    }
    triggerEnterRuleEvent() {
      if (this._parseListeners !== null) {
        const p = this._ctx;
        this._parseListeners.forEach(function(v) {
          v.enterEveryRule(p), p.enterRule(v);
        });
      }
    }
    triggerExitRuleEvent() {
      if (this._parseListeners !== null) {
        const p = this._ctx;
        this._parseListeners.slice(0).reverse().forEach(function(v) {
          p.exitRule(v), v.exitEveryRule(p);
        });
      }
    }
    getTokenFactory() {
      return this._input.tokenSource._factory;
    }
    setTokenFactory(p) {
      this._input.tokenSource._factory = p;
    }
    getATNWithBypassAlts() {
      const p = this.getSerializedATN();
      if (p === null) throw "The current parser does not support an ATN with bypass alternatives.";
      let v = this.bypassAltsAtnCache[p];
      if (v === null) {
        const S = new nt();
        S.generateRuleBypassTransitions = !0, v = new Li(S).deserialize(p), this.bypassAltsAtnCache[p] = v;
      }
      return v;
    }
    getInputStream() {
      return this.getTokenStream();
    }
    setInputStream(p) {
      this.setTokenStream(p);
    }
    getTokenStream() {
      return this._input;
    }
    setTokenStream(p) {
      this._input = null, this.reset(), this._input = p;
    }
    get syntaxErrorsCount() {
      return this._syntaxErrors;
    }
    getCurrentToken() {
      return this._input.LT(1);
    }
    notifyErrorListeners(p, v, S) {
      S = S || null, (v = v || null) === null && (v = this.getCurrentToken()), this._syntaxErrors += 1;
      const q = v.line, z = v.column;
      this.getErrorListenerDispatch().syntaxError(this, v, q, z, p, S);
    }
    consume() {
      const p = this.getCurrentToken();
      p.type !== t.EOF && this.getInputStream().consume();
      const v = this._parseListeners !== null && this._parseListeners.length > 0;
      if (this.buildParseTrees || v) {
        let S;
        S = this._errHandler.inErrorRecoveryMode(this) ? this._ctx.addErrorNode(p) : this._ctx.addTokenNode(p), S.invokingState = this.state, v && this._parseListeners.forEach(function(q) {
          S instanceof F || S.isErrorNode !== void 0 && S.isErrorNode() ? q.visitErrorNode(S) : S instanceof L && q.visitTerminal(S);
        });
      }
      return p;
    }
    addContextToParseTree() {
      this._ctx.parentCtx !== null && this._ctx.parentCtx.addChild(this._ctx);
    }
    enterRule(p, v, S) {
      this.state = v, this._ctx = p, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
    }
    exitRule() {
      this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parentCtx;
    }
    enterOuterAlt(p, v) {
      p.setAltNumber(v), this.buildParseTrees && this._ctx !== p && this._ctx.parentCtx !== null && (this._ctx.parentCtx.removeLastChild(), this._ctx.parentCtx.addChild(p)), this._ctx = p;
    }
    getPrecedence() {
      return this._precedenceStack.length === 0 ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
    }
    enterRecursionRule(p, v, S, q) {
      this.state = v, this._precedenceStack.push(q), this._ctx = p, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
    }
    pushNewRecursionContext(p, v, S) {
      const q = this._ctx;
      q.parentCtx = p, q.invokingState = v, q.stop = this._input.LT(-1), this._ctx = p, this._ctx.start = q.start, this.buildParseTrees && this._ctx.addChild(q), this.triggerEnterRuleEvent();
    }
    unrollRecursionContexts(p) {
      this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
      const v = this._ctx, S = this.getParseListeners();
      if (S !== null && S.length > 0) for (; this._ctx !== p; ) this.triggerExitRuleEvent(), this._ctx = this._ctx.parentCtx;
      else this._ctx = p;
      v.parentCtx = p, this.buildParseTrees && p !== null && p.addChild(v);
    }
    getInvokingContext(p) {
      let v = this._ctx;
      for (; v !== null; ) {
        if (v.ruleIndex === p) return v;
        v = v.parentCtx;
      }
      return null;
    }
    precpred(p, v) {
      return v >= this._precedenceStack[this._precedenceStack.length - 1];
    }
    inContext(p) {
      return !1;
    }
    isExpectedToken(p) {
      const v = this._interp.atn;
      let S = this._ctx;
      const q = v.states[this.state];
      let z = v.nextTokens(q);
      if (z.contains(p)) return !0;
      if (!z.contains(t.EPSILON)) return !1;
      for (; S !== null && S.invokingState >= 0 && z.contains(t.EPSILON); ) {
        const W = v.states[S.invokingState].transitions[0];
        if (z = v.nextTokens(W.followState), z.contains(p)) return !0;
        S = S.parentCtx;
      }
      return !(!z.contains(t.EPSILON) || p !== t.EOF);
    }
    getExpectedTokens() {
      return this._interp.atn.getExpectedTokens(this.state, this._ctx);
    }
    getExpectedTokensWithinCurrentRule() {
      const p = this._interp.atn, v = p.states[this.state];
      return p.nextTokens(v);
    }
    getRuleIndex(p) {
      const v = this.getRuleIndexMap()[p];
      return v !== null ? v : -1;
    }
    getRuleInvocationStack(p) {
      (p = p || null) === null && (p = this._ctx);
      const v = [];
      for (; p !== null; ) {
        const S = p.ruleIndex;
        S < 0 ? v.push("n/a") : v.push(this.ruleNames[S]), p = p.parentCtx;
      }
      return v;
    }
    getDFAStrings() {
      return this._interp.decisionToDFA.toString();
    }
    dumpDFA() {
      let p = !1;
      for (let v = 0; v < this._interp.decisionToDFA.length; v++) {
        const S = this._interp.decisionToDFA[v];
        S.states.length > 0 && (p && console.log(), this.printer.println("Decision " + S.decision + ":"), this.printer.print(S.toString(this.literalNames, this.symbolicNames)), p = !0);
      }
    }
    getSourceName() {
      return this._input.sourceName;
    }
    setTrace(p) {
      p ? (this._tracer !== null && this.removeParseListener(this._tracer), this._tracer = new LA(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
    }
  }
  Th.bypassAltsAtnCache = {};
  class Pv extends L {
    constructor(p) {
      super(), this.parentCtx = null, this.symbol = p;
    }
    getChild(p) {
      return null;
    }
    getSymbol() {
      return this.symbol;
    }
    getParent() {
      return this.parentCtx;
    }
    getPayload() {
      return this.symbol;
    }
    getSourceInterval() {
      if (this.symbol === null) return w.INVALID_INTERVAL;
      const p = this.symbol.tokenIndex;
      return new w(p, p);
    }
    getChildCount() {
      return 0;
    }
    accept(p) {
      return p.visitTerminal(this);
    }
    getText() {
      return this.symbol.text;
    }
    toString() {
      return this.symbol.type === t.EOF ? "<EOF>" : this.symbol.text;
    }
  }
  class Lv extends Pv {
    constructor(p) {
      super(p);
    }
    isErrorNode() {
      return !0;
    }
    accept(p) {
      return p.visitErrorNode(this);
    }
  }
  class _h extends R {
    constructor(p, v) {
      super(p, v), this.children = null, this.start = null, this.stop = null, this.exception = null;
    }
    copyFrom(p) {
      this.parentCtx = p.parentCtx, this.invokingState = p.invokingState, this.children = null, this.start = p.start, this.stop = p.stop, p.children && (this.children = [], p.children.map(function(v) {
        v instanceof Lv && (this.children.push(v), v.parentCtx = this);
      }, this));
    }
    enterRule(p) {
    }
    exitRule(p) {
    }
    addChild(p) {
      return this.children === null && (this.children = []), this.children.push(p), p;
    }
    removeLastChild() {
      this.children !== null && this.children.pop();
    }
    addTokenNode(p) {
      const v = new Pv(p);
      return this.addChild(v), v.parentCtx = this, v;
    }
    addErrorNode(p) {
      const v = new Lv(p);
      return this.addChild(v), v.parentCtx = this, v;
    }
    getChild(p, v) {
      if (v = v || null, this.children === null || p < 0 || p >= this.children.length) return null;
      if (v === null) return this.children[p];
      for (let S = 0; S < this.children.length; S++) {
        const q = this.children[S];
        if (q instanceof v) {
          if (p === 0) return q;
          p -= 1;
        }
      }
      return null;
    }
    getToken(p, v) {
      if (this.children === null || v < 0 || v >= this.children.length) return null;
      for (let S = 0; S < this.children.length; S++) {
        const q = this.children[S];
        if (q instanceof L && q.symbol.type === p) {
          if (v === 0) return q;
          v -= 1;
        }
      }
      return null;
    }
    getTokens(p) {
      if (this.children === null) return [];
      {
        const v = [];
        for (let S = 0; S < this.children.length; S++) {
          const q = this.children[S];
          q instanceof L && q.symbol.type === p && v.push(q);
        }
        return v;
      }
    }
    getTypedRuleContext(p, v) {
      return this.getChild(v, p);
    }
    getTypedRuleContexts(p) {
      if (this.children === null) return [];
      {
        const v = [];
        for (let S = 0; S < this.children.length; S++) {
          const q = this.children[S];
          q instanceof p && v.push(q);
        }
        return v;
      }
    }
    getChildCount() {
      return this.children === null ? 0 : this.children.length;
    }
    getSourceInterval() {
      return this.start === null || this.stop === null ? w.INVALID_INTERVAL : new w(this.start.tokenIndex, this.stop.tokenIndex);
    }
  }
  R.EMPTY = new _h();
  class fi {
    static DEFAULT_PROGRAM_NAME = "default";
    constructor(p) {
      this.tokens = p, this.programs = /* @__PURE__ */ new Map();
    }
    getTokenStream() {
      return this.tokens;
    }
    insertAfter(p, v) {
      let S, q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fi.DEFAULT_PROGRAM_NAME;
      S = typeof p == "number" ? p : p.tokenIndex;
      let z = this.getProgram(q), W = new zv(this.tokens, S, z.length, v);
      z.push(W);
    }
    insertBefore(p, v) {
      let S, q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fi.DEFAULT_PROGRAM_NAME;
      S = typeof p == "number" ? p : p.tokenIndex;
      const z = this.getProgram(q), W = new ga(this.tokens, S, z.length, v);
      z.push(W);
    }
    replaceSingle(p, v) {
      let S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fi.DEFAULT_PROGRAM_NAME;
      this.replace(p, p, v, S);
    }
    replace(p, v, S) {
      let q = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fi.DEFAULT_PROGRAM_NAME;
      if (typeof p != "number" && (p = p.tokenIndex), typeof v != "number" && (v = v.tokenIndex), p > v || p < 0 || v < 0 || v >= this.tokens.size) throw new RangeError(`replace: range invalid: ${p}..${v}(size=${this.tokens.size})`);
      let z = this.getProgram(q), W = new No(this.tokens, p, v, z.length, S);
      z.push(W);
    }
    delete(p, v) {
      let S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fi.DEFAULT_PROGRAM_NAME;
      v === void 0 && (v = p), this.replace(p, v, null, S);
    }
    getProgram(p) {
      let v = this.programs.get(p);
      return v == null && (v = this.initializeProgram(p)), v;
    }
    initializeProgram(p) {
      const v = [];
      return this.programs.set(p, v), v;
    }
    getText(p) {
      let v, S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fi.DEFAULT_PROGRAM_NAME;
      v = p instanceof w ? p : new w(0, this.tokens.size - 1), typeof p == "string" && (S = p);
      const q = this.programs.get(S);
      let z = v.start, W = v.stop;
      if (W > this.tokens.size - 1 && (W = this.tokens.size - 1), z < 0 && (z = 0), q == null || q.length === 0) return this.tokens.getText(new w(z, W));
      let oe = [], we = this.reduceToSingleOperationPerIndex(q), Ae = z;
      for (; Ae <= W && Ae < this.tokens.size; ) {
        let Re = we.get(Ae);
        we.delete(Ae);
        let Ue = this.tokens.get(Ae);
        Re == null ? (Ue.type !== t.EOF && oe.push(String(Ue.text)), Ae++) : Ae = Re.execute(oe);
      }
      if (W === this.tokens.size - 1) for (const Re of we.values()) Re.index >= this.tokens.size - 1 && oe.push(Re.text.toString());
      return oe.join("");
    }
    reduceToSingleOperationPerIndex(p) {
      for (let S = 0; S < p.length; S++) {
        let q = p[S];
        if (q == null || !(q instanceof No)) continue;
        let z = q, W = this.getKindOfOps(p, ga, S);
        for (let we of W) we.index === z.index ? (p[we.instructionIndex] = void 0, z.text = we.text.toString() + (z.text != null ? z.text.toString() : "")) : we.index > z.index && we.index <= z.lastIndex && (p[we.instructionIndex] = void 0);
        let oe = this.getKindOfOps(p, No, S);
        for (let we of oe) {
          if (we.index >= z.index && we.lastIndex <= z.lastIndex) {
            p[we.instructionIndex] = void 0;
            continue;
          }
          let Ae = we.lastIndex < z.index || we.index > z.lastIndex;
          if (we.text != null || z.text != null || Ae) {
            if (!Ae) throw new Error(`replace op boundaries of ${z} overlap with previous ${we}`);
          } else p[we.instructionIndex] = void 0, z.index = Math.min(we.index, z.index), z.lastIndex = Math.max(we.lastIndex, z.lastIndex);
        }
      }
      for (let S = 0; S < p.length; S++) {
        let q = p[S];
        if (q == null || !(q instanceof ga)) continue;
        let z = q, W = this.getKindOfOps(p, ga, S);
        for (let we of W) we.index === z.index && (we instanceof zv ? (z.text = this.catOpText(we.text, z.text), p[we.instructionIndex] = void 0) : we instanceof ga && (z.text = this.catOpText(z.text, we.text), p[we.instructionIndex] = void 0));
        let oe = this.getKindOfOps(p, No, S);
        for (let we of oe) if (z.index !== we.index) {
          if (z.index >= we.index && z.index <= we.lastIndex) throw new Error(`insert op ${z} within boundaries of previous ${we}`);
        } else we.text = this.catOpText(z.text, we.text), p[S] = void 0;
      }
      let v = /* @__PURE__ */ new Map();
      for (let S of p) if (S != null) {
        if (v.get(S.index) != null) throw new Error("should only be one op per index");
        v.set(S.index, S);
      }
      return v;
    }
    catOpText(p, v) {
      let S = "", q = "";
      return p != null && (S = p.toString()), v != null && (q = v.toString()), S + q;
    }
    getKindOfOps(p, v, S) {
      return p.slice(0, S).filter((q) => q && q instanceof v);
    }
  }
  class kv {
    constructor(p, v, S, q) {
      this.tokens = p, this.instructionIndex = S, this.index = v, this.text = q === void 0 ? "" : q;
    }
    toString() {
      let p = this.constructor.name;
      const v = p.indexOf("$");
      return p = p.substring(v + 1, p.length), "<" + p + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
    }
  }
  class ga extends kv {
    constructor(p, v, S, q) {
      super(p, v, S, q);
    }
    execute(p) {
      return this.text && p.push(this.text.toString()), this.tokens.get(this.index).type !== t.EOF && p.push(String(this.tokens.get(this.index).text)), this.index + 1;
    }
  }
  class zv extends ga {
    constructor(p, v, S, q) {
      super(p, v + 1, S, q);
    }
  }
  class No extends kv {
    constructor(p, v, S, q, z) {
      super(p, v, q, z), this.lastIndex = S;
    }
    execute(p) {
      return this.text && p.push(this.text.toString()), this.lastIndex + 1;
    }
    toString() {
      return this.text == null ? "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">" : "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
    }
  }
  const kA = { atn: Ui, dfa: _A, context: MA, misc: OA, tree: qA, error: BA, Token: t, CommonToken: wn, CharStreams: Fv, CharStream: ds, InputStream: ds, CommonTokenStream: Rv, Lexer: Vt, Parser: Th, ParserRuleContext: _h, Interval: w, IntervalSet: E, LL1Analyzer: he, Utils: RA, TokenStreamRewriter: fi };
})();
var Qi = Ft.dx, NA = Ft.q2;
Ft.FO;
Ft.xf;
Ft.Gy;
Ft.s4;
var ok = Ft.c7, DA = Ft._7;
Ft.gp;
var pv = Ft.cK, Lh = Ft.zs, uk = Ft.AV;
Ft.Xp;
Ft.VS;
Ft.ul;
var lk = Ft.hW, ck = Ft.x1, od = Ft.z5, fk = Ft.oN;
Ft.TB;
var pk = Ft.u1, mk = Ft._b, hk = Ft.$F, yr = Ft._T, EA = Ft.db;
Ft.Zx;
var mr = Ft._x;
Ft.r8;
Ft.JI;
Ft.TP;
var SA = Ft.WU;
Ft.Nj;
Ft.ZP;
const dk = [
  "悋Ꜫ脳맭䅼㯧瞆奤",
  "-Ĥ\b		",
  "			\x07	",
  `\x07\b	\b			
	
\v	\v`,
  "\f	\f\r	\r		",
  "				",
  "			",
  "				",
  "\x1B	\x1B		",
  '		 	 !	!"	"#',
  "	#$	$%	%&	&'	'(	()	)",
  "*	*+	+,	,",
  "",
  "\x07",
  "\x07\x07\b\b\b		",
  `						


`,
  `





\v\v`,
  "\v\v\v\v\v\v",
  "\f\f\f\f\f\r\r",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\x1B\x1B",
  "",
  " ",
  '   !!!""""',
  '"###$$$$$',
  `$$$á
$%%%%æ
%\r%`,
  `%ç&&&&í
&\r&&î'`,
  `'ò
'\r''ó((\x07(ø
(\f`,
  `((û\v())þ
)\r))ÿ)`,
  `)***Ć
*\r**ć**`,
  `++++\x07+Đ
+\f++ē\v+`,
  "+++++,,,,\x07",
  `,Ğ
,\f,,ġ\v,,,đ-`,
  "\x07	\v\x07\r\b	",
  `
\v\f\r\x1B`,
  "!#%')+-/1",
  `3\x1B579;= ?!A"C#E$G%I&K'M(O)Q*S+U,W-`,
  `
2;GGgg--//c`,
  '|2;C\\aac|\v\f""\x07',
  "/02;C\\aac|\f\fĭ",
  "\x07",
  "	\v",
  "\r",
  "",
  "",
  "\x1B",
  "",
  "!#",
  "%'",
  ")+",
  "-/",
  "135",
  "79",
  ";=",
  "?A",
  "CE",
  "GIK",
  "MO",
  "QS",
  "UW",
  "Y[\x07",
  "b	d\vf",
  "\rhk",
  "nv",
  "",
  "\x1B",
  "!",
  "#%¤",
  "'§)­",
  "+¯-²",
  "/´1¶",
  "3¸5º",
  "7¼9¾;Â",
  "=Æ?Ê",
  "AÎCÑ",
  "EÖGà",
  "IâKé",
  "MñOõQý",
  "SăUċ",
  "WęYZ\x07",
  "Z[\\\x07q\\]\x07",
  "r]^\x07c^_\x07s_`\x07w",
  "`a\x07gabc\x07=",
  `c\bde\x07*e
`,
  "fg\x07+g\fh",
  "i\x07kij\x07hj",
  "kl\x07?lm\x07?m",
  "no\x07dop\x07cpq\x07t",
  "qr\x07trs\x07kst\x07gtu\x07",
  "tuvw\x07Qwx",
  "\x07Rxy\x07Gyz\x07Pz{\x07",
  "S{|\x07C|}\x07U}~\x07O",
  "~\x07k",
  "\x07p\x07e",
  "\x07n\x07w",
  "\x07f\x07g",
  "\x07s\x07",
  "t\x07g\x07i",
  "\x07]",
  "\x07_",
  "\x07e",
  "\x07t\x07g",
  "\x07i",
  "\x07i\x07c",
  "\x07v\x07g ",
  '\x07}"',
  "\x07o\x07g",
  "\x07c \x07u",
  " ¡\x07w¡¢\x07t¢",
  "£\x07g£$¤¥",
  "\x07/¥¦\x07@¦&",
  "§¨\x07t¨©\x07g",
  "©ª\x07uª«\x07g",
  "«¬\x07v¬(­",
  "®\x07W®*¯°",
  "\x07E°±\x07Z±,",
  "²³\x07.³.",
  "´µ\x07`µ0",
  "¶·\x07,·2¸",
  "¹\x071¹4º»",
  "\x07-»6¼½\x07",
  "/½8¾¿\x07u",
  "¿À\x07kÀÁ\x07p",
  "Á:ÂÃ\x07eÃ",
  "Ä\x07qÄÅ\x07uÅ<",
  "ÆÇ\x07vÇÈ\x07",
  "cÈÉ\x07pÉ>",
  "ÊË\x07gËÌ\x07z",
  "ÌÍ\x07rÍ@Î",
  "Ï\x07nÏÐ\x07pÐB",
  "ÑÒ\x07uÒÓ\x07",
  "sÓÔ\x07tÔÕ\x07v",
  "ÕDÖ×\x07r",
  "×Ø\x07kØFÙ",
  "ÚI%ÚÛK&Ûá",
  "ÜÝM'ÝÞK&Þ",
  "áßáI%àÙ",
  "àÜàß",
  "áHâã",
  "M'ãå\x070äæ	",
  "åäæç",
  "çåçè",
  "èJéê	",
  "êì	ëí	ì",
  "ëíîî",
  "ìîïï",
  "Lðò	ñð",
  "òóóñ",
  "óôôN",
  "õù	öø",
  "	÷öøû",
  "ù÷ùú",
  "úPûù",
  "üþ	\x07ýü",
  "þÿÿý",
  "ÿĀĀā",
  "āĂ\b)ĂR",
  "ăą\x07$ĄĆ	\b",
  "ąĄĆć",
  "ćąćĈ",
  "ĈĉĉĊ\x07$",
  "ĊTċČ\x071Č",
  "č\x07,čđĎ",
  "Đ\vďĎĐ",
  "ēđĒđ",
  "ďĒĔē",
  "đĔĕ\x07,ĕ",
  "Ė\x071Ėėė",
  "Ę\b+ĘVęĚ\x07",
  "1Ěě\x071ěğ",
  `ĜĞ
	ĝĜ`,
  "Ğġğĝ",
  "ğĠĠĢ",
  "ġğĢģ\b,",
  "ģX\fàçîóù",
  "ÿćđğ\b"
].join(""), mv = new NA().deserialize(dk), gk = mv.decisionToState.map(function(t, e) {
  return new DA(t, e);
});
class ct extends lk {
  constructor(e) {
    super(e), this._interp = new ck(
      this,
      mv,
      gk,
      new EA()
    );
  }
  channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
  modeNames = ["DEFAULT_MODE"];
  literalNames = [
    null,
    "'}'",
    "'opaque'",
    "';'",
    "'('",
    "')'",
    "'if'",
    "'=='",
    "'barrier'",
    "'OPENQASM'",
    "'include'",
    "'qreg'",
    "'['",
    "']'",
    "'creg'",
    "'gate'",
    "'{'",
    "'measure'",
    "'->'",
    "'reset'",
    "'U'",
    "'CX'",
    "','",
    "'^'",
    "'*'",
    "'/'",
    "'+'",
    "'-'",
    "'sin'",
    "'cos'",
    "'tan'",
    "'exp'",
    "'ln'",
    "'sqrt'",
    "'pi'"
  ];
  symbolicNames = [
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "PI",
    "REAL",
    "SUBREAL",
    "EXPREAL",
    "INT",
    "ID",
    "WS",
    "FILENAME",
    "COMMENT",
    "LINE_COMMENT"
  ];
  ruleNames = [
    "T__0",
    "T__1",
    "T__2",
    "T__3",
    "T__4",
    "T__5",
    "T__6",
    "T__7",
    "T__8",
    "T__9",
    "T__10",
    "T__11",
    "T__12",
    "T__13",
    "T__14",
    "T__15",
    "T__16",
    "T__17",
    "T__18",
    "T__19",
    "T__20",
    "T__21",
    "T__22",
    "T__23",
    "T__24",
    "T__25",
    "T__26",
    "T__27",
    "T__28",
    "T__29",
    "T__30",
    "T__31",
    "T__32",
    "PI",
    "REAL",
    "SUBREAL",
    "EXPREAL",
    "INT",
    "ID",
    "WS",
    "FILENAME",
    "COMMENT",
    "LINE_COMMENT"
  ];
  grammarFileName = "QASM.g4";
}
Object.defineProperty(ct.prototype, "atn", {
  get: function() {
    return mv;
  }
});
ct.EOF = SA.EOF;
ct.T__0 = 1;
ct.T__1 = 2;
ct.T__2 = 3;
ct.T__3 = 4;
ct.T__4 = 5;
ct.T__5 = 6;
ct.T__6 = 7;
ct.T__7 = 8;
ct.T__8 = 9;
ct.T__9 = 10;
ct.T__10 = 11;
ct.T__11 = 12;
ct.T__12 = 13;
ct.T__13 = 14;
ct.T__14 = 15;
ct.T__15 = 16;
ct.T__16 = 17;
ct.T__17 = 18;
ct.T__18 = 19;
ct.T__19 = 20;
ct.T__20 = 21;
ct.T__21 = 22;
ct.T__22 = 23;
ct.T__23 = 24;
ct.T__24 = 25;
ct.T__25 = 26;
ct.T__26 = 27;
ct.T__27 = 28;
ct.T__28 = 29;
ct.T__29 = 30;
ct.T__30 = 31;
ct.T__31 = 32;
ct.T__32 = 33;
ct.PI = 34;
ct.REAL = 35;
ct.SUBREAL = 36;
ct.EXPREAL = 37;
ct.INT = 38;
ct.ID = 39;
ct.WS = 40;
ct.FILENAME = 41;
ct.COMMENT = 42;
ct.LINE_COMMENT = 43;
class Et extends fk {
  constructor() {
    super();
  }
  enterMainprog = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mainprog.
  exitMainprog = function(e) {
  };
  // Enter a parse tree produced by QASMParser#statement.
  enterStatement = function(e) {
  };
  // Exit a parse tree produced by QASMParser#statement.
  exitStatement = function(e) {
  };
  // Enter a parse tree produced by QASMParser#version.
  enterVersion = function(e) {
  };
  // Exit a parse tree produced by QASMParser#version.
  exitVersion = function(e) {
  };
  // Enter a parse tree produced by QASMParser#include.
  enterInclude = function(e) {
  };
  // Exit a parse tree produced by QASMParser#include.
  exitInclude = function(e) {
  };
  // Enter a parse tree produced by QASMParser#filename.
  enterFilename = function(e) {
  };
  // Exit a parse tree produced by QASMParser#filename.
  exitFilename = function(e) {
  };
  // Enter a parse tree produced by QASMParser#decl.
  enterDecl = function(e) {
  };
  // Exit a parse tree produced by QASMParser#decl.
  exitDecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#gatedecl.
  enterGatedecl = function(e) {
  };
  // Exit a parse tree produced by QASMParser#gatedecl.
  exitGatedecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#goplist.
  enterGoplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#goplist.
  exitGoplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#qop.
  enterQop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#qop.
  exitQop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#uop.
  enterUop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#uop.
  exitUop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#anylist.
  enterAnylist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#anylist.
  exitAnylist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#idlist.
  enterIdlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#idlist.
  exitIdlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#mixedlist.
  enterMixedlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mixedlist.
  exitMixedlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#argument.
  enterArgument = function(e) {
  };
  // Exit a parse tree produced by QASMParser#argument.
  exitArgument = function(e) {
  };
  // Enter a parse tree produced by QASMParser#explist.
  enterExplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#explist.
  exitExplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#exp.
  enterExp = function(e) {
  };
  // Exit a parse tree produced by QASMParser#exp.
  exitExp = function(e) {
  };
  // Enter a parse tree produced by QASMParser#atom.
  enterAtom = function(e) {
  };
  // Exit a parse tree produced by QASMParser#atom.
  exitAtom = function(e) {
  };
  // Enter a parse tree produced by QASMParser#unaryop.
  enterUnaryop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#unaryop.
  exitUnaryop = function(e) {
  };
}
const vk = [
  "悋Ꜫ脳맭䅼㯧瞆奤",
  "-İ			",
  "		\x07	\x07",
  `\b	\b			
	
\v	\v\f	\f`,
  "\r	\r			",
  "			",
  `\x07)
\f,\v`,
  "",
  "",
  "",
  "",
  "",
  "",
  `W
`,
  "",
  "\x07\x07",
  "\x07\x07\x07\x07\x07\x07",
  `\x07\x07\x07\x07\x07o
\x07`,
  "\b\b\b\b\b\b\b\b",
  "\b\b\b\b\b\b\b\b\b",
  `\b\b\b\b
\b				`,
  `		
	\r		


`,
  `







`,
  `


\v\v\v\v\v`,
  "\v\v\v\v\v\v",
  "\v\v\v\v\v\v",
  "\v\v\v\v\v\v",
  "\v\v\v\v\v\v",
  `\v\v»
\v\f\f\f¿`,
  `
\f\r\r\x07\rÃ
\r\f\r\rÆ\v\r`,
  "\r\r",
  `\x07Ï
\fÒ\v`,
  "\x07",
  `Ú
\fÝ\v`,
  "\x07",
  `å
\fè\v`,
  `\x07ì
\fï\v`,
  `õ
`,
  "",
  `ü
\x07`,
  `ā
\fĄ\v`,
  `Ċ
`,
  `đ
`,
  "",
  `ę
Ĝ
`,
  "",
  `\x07ħ
\f`,
  "Ī\v",
  ` \b
\f`,
  ' "$',
  "\x1B$%()",
  "#ń&V",
  "X\b\\",
  "\n`\fn",
  "",
  "º¾",
  "Äô",
  "ûĂ",
  ' ě"ī',
  "$ĭ&*",
  "')('),",
  "*(*++",
  ",*-W\f\x07",
  "./\b/0	01\x07",
  "1W23\b34\x07",
  "4W56\x0767\x07)",
  "78\r89\x079W",
  ":;\x07;<\x07)<=",
  "\x07=>\x07\x07>?\r",
  "?@\x07@WAB\x07",
  "BC\x07)CD\x07DE",
  "\rEF\x07\x07FG\rGH\x07",
  `HWIW
JK\x07`,
  "\bKL\x07LM\x07)MN\x07",
  "	NO\x07(OP\x07\x07PW",
  `
QR\x07
RS\fST\x07`,
  "TWUW\bV-",
  "V.V2",
  "V5V:VA",
  "VIVJVQ",
  "VUW",
  "XY\x07\vYZ\x07%Z[\x07",
  "[\x07\\]\x07\f]^",
  `
^_\x07_	`,
  "`a\x07+a\vbc\x07\r",
  "cd\x07)de\x07ef\x07(",
  "fg\x07go\x07hi\x07",
  "ij\x07)jk\x07kl\x07",
  "(lm\x07mo\x07nb",
  "nho\r",
  "pq\x07qr\x07)rs",
  "\rst\x07tuv",
  "\x07vw\x07)wx\x07",
  "xy\x07\x07yz\rz{\x07",
  "{|}\x07}~\x07",
  ")~\x07",
  "\r\x07\x07",
  "\r\x07",
  "pu",
  "|",
  `\v\x07
`,
  "\r\x07",
  "",
  "",
  "",
  "\v",
  "\x07",
  "\x07",
  "\x07",
  "\x07",
  "\x07",
  "",
  "",
  "\x07\x07",
  " \x07\x07",
  " ¡¡¢\x07",
  "¢»£¤\x07",
  "¤¥¥¦\x07",
  "¦§§¨\x07",
  "¨»©ª\x07)",
  "ª«\f«¬\x07",
  "¬»­®\x07)",
  "®¯\x07¯°\x07\x07",
  "°±\f±²\x07",
  "²»³´\x07)",
  "´µ\x07µ¶",
  "¶·\x07\x07·¸\f",
  "¸¹\x07¹»",
  "ºº£",
  "º©º­",
  "º³»",
  "¼¿\r½¿",
  "¾¼¾½",
  "¿ÀÁ\x07)",
  "ÁÃ\x07ÂÀ",
  "ÃÆÄÂ",
  "ÄÅÅÇ",
  "ÆÄÇÈ\x07)",
  "ÈÉÊ\x07)",
  "ÊË\x07ËÌ\x07(",
  "ÌÍ\x07ÍÏ\x07",
  "ÎÉÏÒ",
  "ÐÎÐÑ",
  "ÑÓÒÐ",
  "Óõ\x07)ÔÕ\x07)",
  "ÕÖ\x07Ö×\x07(",
  "×Ø\x07ØÚ\x07",
  "ÙÔÚÝ",
  "ÛÙÛÜ",
  "ÜÞÝÛ",
  "Þß\x07)ßà\x07",
  "àá\x07(áõ\x07",
  "âã\x07)ãå\x07",
  "äâåè",
  "æäæç",
  "çéèæ",
  "éê\x07)êì\x07",
  "ëæìï",
  "íëíî",
  "îðïí",
  "ðñ\x07)ñò\x07",
  "òó\x07(óõ\x07",
  "ôÐôÛ",
  "ôíõ\x1B",
  "öü\x07)÷ø\x07)ø",
  "ù\x07ùú\x07(ú",
  "ü\x07ûöû",
  "÷üý",
  "þ þÿ\x07ÿ",
  "āĀýā",
  "ĄĂĀĂ",
  "ăăąĄ",
  "ĂąĆ Ć",
  "ćĉ\bĈ",
  "Ċ	ĉĈĉ",
  "ĊĊċċ",
  "Č\x07Čč č",
  "Ď\x07\x07ĎĜď",
  "đ	ĐďĐ",
  "đđĒĒ",
  "ē$ēĔ\x07Ĕ",
  "ĕ ĕĖ\x07\x07Ė",
  "Ĝėę	Ę",
  "ėĘęę",
  'ĚĚĜ"ě',
  "ćěĐě",
  "ĘĜĨĝ",
  "Ğ\f\bĞğ\x07ğħ",
  " 	Ġġ\f\x07ġĢ	",
  "Ģħ \bģĤ\f",
  "Ĥĥ	ĥħ \x07Ħ",
  "ĝĦĠĦ",
  "ģħĪĨ",
  "ĦĨĩĩ",
  "!ĪĨī",
  "Ĭ	Ĭ#ĭĮ",
  "	Į%*Vn",
  "º¾ÄÐÛæíôûĂ",
  "ĉĐĘěĦĨ"
].join(""), hv = new NA().deserialize(vk), yk = hv.decisionToState.map(function(t, e) {
  return new DA(t, e);
}), xk = new EA(), bk = [
  null,
  "'}'",
  "'opaque'",
  "';'",
  "'('",
  "')'",
  "'if'",
  "'=='",
  "'barrier'",
  "'OPENQASM'",
  "'include'",
  "'qreg'",
  "'['",
  "']'",
  "'creg'",
  "'gate'",
  "'{'",
  "'measure'",
  "'->'",
  "'reset'",
  "'U'",
  "'CX'",
  "','",
  "'^'",
  "'*'",
  "'/'",
  "'+'",
  "'-'",
  "'sin'",
  "'cos'",
  "'tan'",
  "'exp'",
  "'ln'",
  "'sqrt'",
  "'pi'"
], wk = [
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "PI",
  "REAL",
  "SUBREAL",
  "EXPREAL",
  "INT",
  "ID",
  "WS",
  "FILENAME",
  "COMMENT",
  "LINE_COMMENT"
], Nk = [
  "mainprog",
  "statement",
  "version",
  "include",
  "filename",
  "decl",
  "gatedecl",
  "goplist",
  "qop",
  "uop",
  "anylist",
  "idlist",
  "mixedlist",
  "argument",
  "explist",
  "exp",
  "atom",
  "unaryop"
];
class Y extends mk {
  constructor(e) {
    super(e), this._interp = new hk(
      this,
      hv,
      yk,
      xk
    ), this.ruleNames = Nk, this.literalNames = bk, this.symbolicNames = wk;
  }
  decl = function() {
    const e = new yv(this, this._ctx, this.state);
    this.enterRule(e, 10, Y.RULE_decl);
    try {
      switch (this.state = 108, this._errHandler.sync(this), this._input.LA(1)) {
        case Y.T__10:
          this.enterOuterAlt(e, 1), this.state = 96, this.match(Y.T__10), this.state = 97, this.match(Y.ID), this.state = 98, this.match(Y.T__11), this.state = 99, this.match(Y.INT), this.state = 100, this.match(Y.T__12), this.state = 101, this.match(Y.T__2);
          break;
        case Y.T__13:
          this.enterOuterAlt(e, 2), this.state = 102, this.match(Y.T__13), this.state = 103, this.match(Y.ID), this.state = 104, this.match(Y.T__11), this.state = 105, this.match(Y.INT), this.state = 106, this.match(Y.T__12), this.state = 107, this.match(Y.T__2);
          break;
        default:
          throw new od(this);
      }
    } catch (r) {
      if (r instanceof mr)
        e.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
      else
        throw r;
    } finally {
      this.exitRule();
    }
    return e;
  }.bind(this);
  mainprog = function() {
    const e = new AA(this, this._ctx, this.state);
    this.enterRule(e, 0, Y.RULE_mainprog);
    let r = 0;
    try {
      for (this.enterOuterAlt(e, 1), this.state = 36, this.version(), this.state = 40, this._errHandler.sync(this), r = this._input.LA(1); !(r & -32) && 1 << r & (1 << Y.T__1 | 1 << Y.T__5 | 1 << Y.T__7 | 1 << Y.T__9 | 1 << Y.T__10 | 1 << Y.T__13 | 1 << Y.T__14 | 1 << Y.T__16 | 1 << Y.T__18 | 1 << Y.T__19 | 1 << Y.T__20) || r === Y.ID; )
        this.state = 37, this.statement(), this.state = 42, this._errHandler.sync(this), r = this._input.LA(1);
    } catch (n) {
      if (n instanceof mr)
        e.exception = n, this._errHandler.reportError(this, n), this._errHandler.recover(this, n);
      else
        throw n;
    } finally {
      this.exitRule();
    }
    return e;
  }.bind(this);
  atom = function() {
    const e = new Ev(this, this._ctx, this.state);
    this.enterRule(e, 32, Y.RULE_atom);
    let r = 0;
    try {
      this.enterOuterAlt(e, 1), this.state = 297, r = this._input.LA(1), !(r - 34 & -32) && 1 << r - 34 & (1 << Y.PI - 34 | 1 << Y.REAL - 34 | 1 << Y.INT - 34 | 1 << Y.ID - 34) ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this);
    } catch (n) {
      if (n instanceof mr)
        e.exception = n, this._errHandler.reportError(this, n), this._errHandler.recover(this, n);
      else
        throw n;
    } finally {
      this.exitRule();
    }
    return e;
  }.bind(this);
  unaryop = function() {
    const e = new Sv(this, this._ctx, this.state);
    this.enterRule(e, 34, Y.RULE_unaryop);
    let r = 0;
    try {
      this.enterOuterAlt(e, 1), this.state = 299, r = this._input.LA(1), !(r - 28 & -32) && 1 << r - 28 & (1 << Y.T__27 - 28 | 1 << Y.T__28 - 28 | 1 << Y.T__29 - 28 | 1 << Y.T__30 - 28 | 1 << Y.T__31 - 28 | 1 << Y.T__32 - 28) ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this);
    } catch (n) {
      if (n instanceof mr)
        e.exception = n, this._errHandler.reportError(this, n), this._errHandler.recover(this, n);
      else
        throw n;
    } finally {
      this.exitRule();
    }
    return e;
  }.bind(this);
  sempred = function(e, r, n) {
    switch (r) {
      case 15:
        return this.exp_sempred(e, n);
      default:
        throw "No predicate with index:" + r;
    }
  }.bind(this);
  exp_sempred = function(e, r) {
    switch (r) {
      case 0:
        return this.precpred(this._ctx, 6);
      case 1:
        return this.precpred(this._ctx, 5);
      case 2:
        return this.precpred(this._ctx, 4);
      default:
        throw "No predicate with index:" + r;
    }
  }.bind(this);
  qop = function() {
    const e = new wv(this, this._ctx, this.state);
    this.enterRule(e, 16, Y.RULE_qop);
    try {
      switch (this.state = 152, this._errHandler.sync(this), this._input.LA(1)) {
        case Y.T__19:
        case Y.T__20:
        case Y.ID:
          this.enterOuterAlt(e, 1), this.state = 141, this.uop();
          break;
        case Y.T__16:
          this.enterOuterAlt(e, 2), this.state = 142, this.match(Y.T__16), this.state = 143, this.argument(), this.state = 144, this.match(Y.T__17), this.state = 145, this.argument(), this.state = 146, this.match(Y.T__2);
          break;
        case Y.T__18:
          this.enterOuterAlt(e, 3), this.state = 148, this.match(Y.T__18), this.state = 149, this.argument(), this.state = 150, this.match(Y.T__2);
          break;
        default:
          throw new od(this);
      }
    } catch (r) {
      if (r instanceof mr)
        e.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
      else
        throw r;
    } finally {
      this.exitRule();
    }
    return e;
  }.bind(this);
  exp = function(e) {
    e === void 0 && (e = 0);
    const r = this._ctx, n = this.state;
    let i = new Jn(this, this._ctx, n), a = i;
    const o = 30;
    this.enterRecursionRule(i, 30, Y.RULE_exp, e);
    let f = 0;
    try {
      switch (this.enterOuterAlt(i, 1), this.state = 281, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 20, this._ctx)) {
        case 1:
          this.state = 263, this._errHandler.sync(this), f = this._input.LA(1), (f === Y.T__25 || f === Y.T__26) && (this.state = 262, f = this._input.LA(1), f === Y.T__25 || f === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this)), this.state = 265, this.match(Y.T__3), this.state = 266, this.exp(0), this.state = 267, this.match(Y.T__4);
          break;
        case 2:
          this.state = 270, this._errHandler.sync(this), f = this._input.LA(1), (f === Y.T__25 || f === Y.T__26) && (this.state = 269, f = this._input.LA(1), f === Y.T__25 || f === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this)), this.state = 272, this.unaryop(), this.state = 273, this.match(Y.T__3), this.state = 274, this.exp(0), this.state = 275, this.match(Y.T__4);
          break;
        case 3:
          this.state = 278, this._errHandler.sync(this), f = this._input.LA(1), (f === Y.T__25 || f === Y.T__26) && (this.state = 277, f = this._input.LA(1), f === Y.T__25 || f === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this)), this.state = 280, this.atom();
          break;
      }
      this._ctx.stop = this._input.LT(-1), this.state = 294, this._errHandler.sync(this);
      let s = this._interp.adaptivePredict(this._input, 22, this._ctx);
      for (; s !== 2 && s !== Qi.INVALID_ALT_NUMBER; ) {
        if (s === 1)
          switch (this._parseListeners !== null && this.triggerExitRuleEvent(), a = i, this.state = 292, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 21, this._ctx)) {
            case 1:
              if (i = new Jn(this, r, n), this.pushNewRecursionContext(i, o, Y.RULE_exp), this.state = 283, !this.precpred(this._ctx, 6))
                throw new Lh(
                  this,
                  "this.precpred(this._ctx, 6)",
                  void 0
                );
              this.state = 284, this.match(Y.T__22), this.state = 285, this.exp(7);
              break;
            case 2:
              if (i = new Jn(this, r, n), this.pushNewRecursionContext(i, o, Y.RULE_exp), this.state = 286, !this.precpred(this._ctx, 5))
                throw new Lh(
                  this,
                  "this.precpred(this._ctx, 5)",
                  void 0
                );
              this.state = 287, f = this._input.LA(1), f === Y.T__23 || f === Y.T__24 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this), this.state = 288, this.exp(6);
              break;
            case 3:
              if (i = new Jn(this, r, n), this.pushNewRecursionContext(i, o, Y.RULE_exp), this.state = 289, !this.precpred(this._ctx, 4))
                throw new Lh(
                  this,
                  "this.precpred(this._ctx, 4)",
                  void 0
                );
              this.state = 290, f = this._input.LA(1), f === Y.T__25 || f === Y.T__26 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this), this.state = 291, this.exp(5);
              break;
          }
        this.state = 296, this._errHandler.sync(this), s = this._interp.adaptivePredict(this._input, 22, this._ctx);
      }
    } catch (u) {
      if (u instanceof mr)
        i.exception = u, this._errHandler.reportError(this, u), this._errHandler.recover(this, u);
      else
        throw u;
    } finally {
      this.unrollRecursionContexts(r);
    }
    return i;
  }.bind(this);
  statement = function() {
    const e = new mu(this, this._ctx, this.state);
    this.enterRule(e, 2, Y.RULE_statement);
    try {
      switch (this.state = 84, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 1, this._ctx)) {
        case 1:
          this.enterOuterAlt(e, 1), this.state = 43, this.decl();
          break;
        case 2:
          this.enterOuterAlt(e, 2), this.state = 44, this.gatedecl(), this.state = 45, this.goplist(), this.state = 46, this.match(Y.T__0);
          break;
        case 3:
          this.enterOuterAlt(e, 3), this.state = 48, this.gatedecl(), this.state = 49, this.match(Y.T__0);
          break;
        case 4:
          this.enterOuterAlt(e, 4), this.state = 51, this.match(Y.T__1), this.state = 52, this.match(Y.ID), this.state = 53, this.idlist(), this.state = 54, this.match(Y.T__2);
          break;
        case 5:
          this.enterOuterAlt(e, 5), this.state = 56, this.match(Y.T__1), this.state = 57, this.match(Y.ID), this.state = 58, this.match(Y.T__3), this.state = 59, this.match(Y.T__4), this.state = 60, this.idlist(), this.state = 61, this.match(Y.T__2);
          break;
        case 6:
          this.enterOuterAlt(e, 6), this.state = 63, this.match(Y.T__1), this.state = 64, this.match(Y.ID), this.state = 65, this.match(Y.T__3), this.state = 66, this.idlist(), this.state = 67, this.match(Y.T__4), this.state = 68, this.idlist(), this.state = 69, this.match(Y.T__2);
          break;
        case 7:
          this.enterOuterAlt(e, 7), this.state = 71, this.qop();
          break;
        case 8:
          this.enterOuterAlt(e, 8), this.state = 72, this.match(Y.T__5), this.state = 73, this.match(Y.T__3), this.state = 74, this.match(Y.ID), this.state = 75, this.match(Y.T__6), this.state = 76, this.match(Y.INT), this.state = 77, this.match(Y.T__4), this.state = 78, this.qop();
          break;
        case 9:
          this.enterOuterAlt(e, 9), this.state = 79, this.match(Y.T__7), this.state = 80, this.anylist(), this.state = 81, this.match(Y.T__2);
          break;
        case 10:
          this.enterOuterAlt(e, 10), this.state = 83, this.include();
          break;
      }
    } catch (r) {
      if (r instanceof mr)
        e.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
      else
        throw r;
    } finally {
      this.exitRule();
    }
    return e;
  }.bind(this);
}
Object.defineProperty(Y.prototype, "atn", {
  get: function() {
    return hv;
  }
});
Y.EOF = SA.EOF;
Y.T__0 = 1;
Y.T__1 = 2;
Y.T__2 = 3;
Y.T__3 = 4;
Y.T__4 = 5;
Y.T__5 = 6;
Y.T__6 = 7;
Y.T__7 = 8;
Y.T__8 = 9;
Y.T__9 = 10;
Y.T__10 = 11;
Y.T__11 = 12;
Y.T__12 = 13;
Y.T__13 = 14;
Y.T__14 = 15;
Y.T__15 = 16;
Y.T__16 = 17;
Y.T__17 = 18;
Y.T__18 = 19;
Y.T__19 = 20;
Y.T__20 = 21;
Y.T__21 = 22;
Y.T__22 = 23;
Y.T__23 = 24;
Y.T__24 = 25;
Y.T__25 = 26;
Y.T__26 = 27;
Y.T__27 = 28;
Y.T__28 = 29;
Y.T__29 = 30;
Y.T__30 = 31;
Y.T__31 = 32;
Y.T__32 = 33;
Y.PI = 34;
Y.REAL = 35;
Y.SUBREAL = 36;
Y.EXPREAL = 37;
Y.INT = 38;
Y.ID = 39;
Y.WS = 40;
Y.FILENAME = 41;
Y.COMMENT = 42;
Y.LINE_COMMENT = 43;
Y.RULE_mainprog = 0;
Y.RULE_statement = 1;
Y.RULE_version = 2;
Y.RULE_include = 3;
Y.RULE_filename = 4;
Y.RULE_decl = 5;
Y.RULE_gatedecl = 6;
Y.RULE_goplist = 7;
Y.RULE_qop = 8;
Y.RULE_uop = 9;
Y.RULE_anylist = 10;
Y.RULE_idlist = 11;
Y.RULE_mixedlist = 12;
Y.RULE_argument = 13;
Y.RULE_explist = 14;
Y.RULE_exp = 15;
Y.RULE_atom = 16;
Y.RULE_unaryop = 17;
class AA extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.contextType = "MainprogContext", this.parser = e, this.ruleIndex = Y.RULE_mainprog;
  }
  version = function() {
    return this.getTypedRuleContext(dv, 0);
  }.bind(this);
  statement = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(mu) : this.getTypedRuleContext(mu, e);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterMainprog(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitMainprog(this);
  }.bind(this);
}
Y.MainprogContext = AA;
class mu extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_statement;
  }
  decl = function() {
    return this.getTypedRuleContext(yv, 0);
  }.bind(this);
  gatedecl = function() {
    return this.getTypedRuleContext(xv, 0);
  }.bind(this);
  goplist = function() {
    return this.getTypedRuleContext(bv, 0);
  }.bind(this);
  ID = function() {
    return this.getToken(Y.ID, 0);
  }.bind(this);
  idlist = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(ti) : this.getTypedRuleContext(ti, e);
  }.bind(this);
  qop = function() {
    return this.getTypedRuleContext(wv, 0);
  }.bind(this);
  INT = function() {
    return this.getToken(Y.INT, 0);
  }.bind(this);
  anylist = function() {
    return this.getTypedRuleContext(vh, 0);
  }.bind(this);
  include = function() {
    return this.getTypedRuleContext(gv, 0);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterStatement(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitStatement(this);
  }.bind(this);
}
Y.StatementContext = mu;
class dv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.contextType = "VersionContext", this.parser = e, this.ruleIndex = Y.RULE_version;
  }
  REAL = function() {
    return this.getToken(Y.REAL, 0);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterVersion(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitVersion(this);
  }.bind(this);
}
Y.VersionContext = dv;
Y.prototype.version = function() {
  const t = new dv(this, this._ctx, this.state);
  this.enterRule(t, 4, Y.RULE_version);
  try {
    this.enterOuterAlt(t, 1), this.state = 86, this.match(Y.T__8), this.state = 87, this.match(Y.REAL), this.state = 88, this.match(Y.T__2);
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class gv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_include;
  }
  filename = function() {
    return this.getTypedRuleContext(vv, 0);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterInclude(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitInclude(this);
  }.bind(this);
}
Y.IncludeContext = gv;
Y.prototype.include = function() {
  const t = new gv(this, this._ctx, this.state);
  this.enterRule(t, 6, Y.RULE_include);
  try {
    this.enterOuterAlt(t, 1), this.state = 90, this.match(Y.T__9), this.state = 91, this.filename(), this.state = 92, this.match(Y.T__2);
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class vv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_filename;
  }
  FILENAME = function() {
    return this.getToken(Y.FILENAME, 0);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterFilename(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitFilename(this);
  }.bind(this);
}
Y.FilenameContext = vv;
Y.prototype.filename = function() {
  const t = new vv(this, this._ctx, this.state);
  this.enterRule(t, 8, Y.RULE_filename);
  try {
    this.enterOuterAlt(t, 1), this.state = 94, this.match(Y.FILENAME);
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class yv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_decl;
  }
  ID = function() {
    return this.getToken(Y.ID, 0);
  }.bind(this);
  INT = function() {
    return this.getToken(Y.INT, 0);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterDecl(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitDecl(this);
  }.bind(this);
}
Y.DeclContext = yv;
class xv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_gatedecl;
  }
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  idlist = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(ti) : this.getTypedRuleContext(ti, e);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterGatedecl(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitGatedecl(this);
  };
}
Y.GatedeclContext = xv;
Y.prototype.gatedecl = function() {
  const t = new xv(this, this._ctx, this.state);
  this.enterRule(t, 12, Y.RULE_gatedecl);
  try {
    switch (this.state = 130, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 3, this._ctx)) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 110, this.match(Y.T__14), this.state = 111, this.match(Y.ID), this.state = 112, this.idlist(), this.state = 113, this.match(Y.T__15);
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 115, this.match(Y.T__14), this.state = 116, this.match(Y.ID), this.state = 117, this.match(Y.T__3), this.state = 118, this.match(Y.T__4), this.state = 119, this.idlist(), this.state = 120, this.match(Y.T__15);
        break;
      case 3:
        this.enterOuterAlt(t, 3), this.state = 122, this.match(Y.T__14), this.state = 123, this.match(Y.ID), this.state = 124, this.match(Y.T__3), this.state = 125, this.idlist(), this.state = 126, this.match(Y.T__4), this.state = 127, this.idlist(), this.state = 128, this.match(Y.T__15);
        break;
    }
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class bv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_goplist;
  }
  uop = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(_s) : this.getTypedRuleContext(_s, e);
  };
  idlist = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(ti) : this.getTypedRuleContext(ti, e);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterGoplist(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitGoplist(this);
  };
}
Y.GoplistContext = bv;
Y.prototype.goplist = function() {
  const t = new bv(this, this._ctx, this.state);
  this.enterRule(t, 14, Y.RULE_goplist);
  let e = 0;
  try {
    this.enterOuterAlt(t, 1), this.state = 137, this._errHandler.sync(this), e = this._input.LA(1);
    do {
      switch (this.state = 137, this._errHandler.sync(this), this._input.LA(1)) {
        case Y.T__19:
        case Y.T__20:
        case Y.ID:
          this.state = 132, this.uop();
          break;
        case Y.T__7:
          this.state = 133, this.match(Y.T__7), this.state = 134, this.idlist(), this.state = 135, this.match(Y.T__2);
          break;
        default:
          throw new od(this);
      }
      this.state = 139, this._errHandler.sync(this), e = this._input.LA(1);
    } while (!(e - 8 & -32) && 1 << e - 8 & (1 << Y.T__7 - 8 | 1 << Y.T__19 - 8 | 1 << Y.T__20 - 8 | 1 << Y.ID - 8));
  } catch (r) {
    if (r instanceof mr)
      t.exception = r, this._errHandler.reportError(this, r), this._errHandler.recover(this, r);
    else
      throw r;
  } finally {
    this.exitRule();
  }
  return t;
};
class wv extends yr {
  constructor(e, r, n) {
    return r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_qop, this;
  }
  uop = function() {
    return this.getTypedRuleContext(_s, 0);
  }.bind(this);
  argument = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(Fa) : this.getTypedRuleContext(Fa, e);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterQop(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitQop(this);
  }.bind(this);
}
Y.QopContext = wv;
class _s extends yr {
  constructor(e, r, n) {
    return r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_uop, this;
  }
  explist = function() {
    return this.getTypedRuleContext(Dv, 0);
  }.bind(this);
  argument = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(Fa) : this.getTypedRuleContext(Fa, e);
  }.bind(this);
  ID = function() {
    return this.getToken(Y.ID, 0);
  }.bind(this);
  anylist = function() {
    return this.getTypedRuleContext(vh, 0);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterUop(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitUop(this);
  };
}
Y.UopContext = _s;
Y.prototype.uop = function() {
  const t = new _s(this, this._ctx, this.state);
  this.enterRule(t, 18, Y.RULE_uop);
  try {
    switch (this.state = 184, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 7, this._ctx)) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 154, this.match(Y.T__19), this.state = 155, this.match(Y.T__3), this.state = 156, this.explist(), this.state = 157, this.match(Y.T__4), this.state = 158, this.argument(), this.state = 159, this.match(Y.T__2);
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 161, this.match(Y.T__20), this.state = 162, this.argument(), this.state = 163, this.match(Y.T__21), this.state = 164, this.argument(), this.state = 165, this.match(Y.T__2);
        break;
      case 3:
        this.enterOuterAlt(t, 3), this.state = 167, this.match(Y.ID), this.state = 168, this.anylist(), this.state = 169, this.match(Y.T__2);
        break;
      case 4:
        this.enterOuterAlt(t, 4), this.state = 171, this.match(Y.ID), this.state = 172, this.match(Y.T__3), this.state = 173, this.match(Y.T__4), this.state = 174, this.anylist(), this.state = 175, this.match(Y.T__2);
        break;
      case 5:
        this.enterOuterAlt(t, 5), this.state = 177, this.match(Y.ID), this.state = 178, this.match(Y.T__3), this.state = 179, this.explist(), this.state = 180, this.match(Y.T__4), this.state = 181, this.anylist(), this.state = 182, this.match(Y.T__2);
        break;
    }
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class vh extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_anylist;
  }
  idlist = function() {
    return this.getTypedRuleContext(ti, 0);
  };
  mixedlist = function() {
    return this.getTypedRuleContext(Nv, 0);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterAnylist(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitAnylist(this);
  };
}
Y.AnylistContext = vh;
Y.prototype.anylist = function() {
  const t = new vh(this, this._ctx, this.state);
  this.enterRule(t, 20, Y.RULE_anylist);
  try {
    switch (this.state = 188, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 8, this._ctx)) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 186, this.idlist();
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 187, this.mixedlist();
        break;
    }
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class ti extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_idlist;
  }
  ID = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTokens(Y.ID) : this.getToken(Y.ID, e);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterIdlist(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitIdlist(this);
  };
}
Y.IdlistContext = ti;
Y.prototype.idlist = function() {
  const t = new ti(this, this._ctx, this.state);
  this.enterRule(t, 22, Y.RULE_idlist);
  try {
    this.enterOuterAlt(t, 1), this.state = 194, this._errHandler.sync(this);
    let e = this._interp.adaptivePredict(this._input, 9, this._ctx);
    for (; e !== 2 && e !== Qi.INVALID_ALT_NUMBER; )
      e === 1 && (this.state = 190, this.match(Y.ID), this.state = 191, this.match(Y.T__21)), this.state = 196, this._errHandler.sync(this), e = this._interp.adaptivePredict(this._input, 9, this._ctx);
    this.state = 197, this.match(Y.ID);
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class Nv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_mixedlist;
  }
  ID = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTokens(Y.ID) : this.getToken(Y.ID, e);
  };
  INT = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTokens(Y.INT) : this.getToken(Y.INT, e);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterMixedlist(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitMixedlist(this);
  };
}
Y.MixedlistContext = Nv;
Y.prototype.mixedlist = function() {
  const t = new Nv(this, this._ctx, this.state);
  this.enterRule(t, 24, Y.RULE_mixedlist);
  try {
    this.state = 242, this._errHandler.sync(this);
    const e = this._interp.adaptivePredict(this._input, 14, this._ctx);
    let r;
    switch (e) {
      case 1:
        for (this.enterOuterAlt(t, 1), this.state = 206, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 10, this._ctx); r !== 2 && r !== Qi.INVALID_ALT_NUMBER; )
          r === 1 && (this.state = 199, this.match(Y.ID), this.state = 200, this.match(Y.T__11), this.state = 201, this.match(Y.INT), this.state = 202, this.match(Y.T__12), this.state = 203, this.match(Y.T__21)), this.state = 208, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 10, this._ctx);
        this.state = 209, this.match(Y.ID);
        break;
      case 2:
        for (this.enterOuterAlt(t, 2), this.state = 217, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 11, this._ctx); r !== 2 && r !== Qi.INVALID_ALT_NUMBER; )
          r === 1 && (this.state = 210, this.match(Y.ID), this.state = 211, this.match(Y.T__11), this.state = 212, this.match(Y.INT), this.state = 213, this.match(Y.T__12), this.state = 214, this.match(Y.T__21)), this.state = 219, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 11, this._ctx);
        this.state = 220, this.match(Y.ID), this.state = 221, this.match(Y.T__11), this.state = 222, this.match(Y.INT), this.state = 223, this.match(Y.T__12);
        break;
      case 3:
        for (this.enterOuterAlt(t, 3), this.state = 235, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 13, this._ctx); r !== 2 && r !== Qi.INVALID_ALT_NUMBER; ) {
          if (r === 1) {
            this.state = 228, this._errHandler.sync(this);
            let n = this._interp.adaptivePredict(this._input, 12, this._ctx);
            for (; n !== 2 && n !== Qi.INVALID_ALT_NUMBER; )
              n === 1 && (this.state = 224, this.match(Y.ID), this.state = 225, this.match(Y.T__21)), this.state = 230, this._errHandler.sync(this), n = this._interp.adaptivePredict(this._input, 12, this._ctx);
            this.state = 231, this.match(Y.ID), this.state = 232, this.match(Y.T__21);
          }
          this.state = 237, this._errHandler.sync(this), r = this._interp.adaptivePredict(this._input, 13, this._ctx);
        }
        this.state = 238, this.match(Y.ID), this.state = 239, this.match(Y.T__11), this.state = 240, this.match(Y.INT), this.state = 241, this.match(Y.T__12);
        break;
    }
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class Fa extends yr {
  constructor(e, r, n) {
    return r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_argument, this;
  }
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  INT = function() {
    return this.getToken(Y.INT, 0);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterArgument(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitArgument(this);
  };
}
Y.ArgumentContext = Fa;
Y.prototype.argument = function() {
  const t = new Fa(this, this._ctx, this.state);
  this.enterRule(t, 26, Y.RULE_argument);
  try {
    switch (this.state = 249, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 15, this._ctx)) {
      case 1:
        this.enterOuterAlt(t, 1), this.state = 244, this.match(Y.ID);
        break;
      case 2:
        this.enterOuterAlt(t, 2), this.state = 245, this.match(Y.ID), this.state = 246, this.match(Y.T__11), this.state = 247, this.match(Y.INT), this.state = 248, this.match(Y.T__12);
        break;
    }
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class Dv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_explist;
  }
  exp = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(Jn) : this.getTypedRuleContext(Jn, e);
  }.bind(this);
  enterRule = function(e) {
    e instanceof Et && e.enterExplist(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitExplist(this);
  }.bind(this);
}
Y.ExplistContext = Dv;
Y.prototype.explist = function() {
  const t = new Dv(this, this._ctx, this.state);
  this.enterRule(t, 28, Y.RULE_explist);
  try {
    this.enterOuterAlt(t, 1), this.state = 256, this._errHandler.sync(this);
    let e = this._interp.adaptivePredict(this._input, 16, this._ctx);
    for (; e !== 2 && e !== Qi.INVALID_ALT_NUMBER; )
      e === 1 && (this.state = 251, this.exp(0), this.state = 252, this.match(Y.T__21)), this.state = 258, this._errHandler.sync(this), e = this._interp.adaptivePredict(this._input, 16, this._ctx);
    this.state = 259, this.exp(0);
  } catch (e) {
    if (e instanceof mr)
      t.exception = e, this._errHandler.reportError(this, e), this._errHandler.recover(this, e);
    else
      throw e;
  } finally {
    this.exitRule();
  }
  return t;
};
class Jn extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_exp;
  }
  exp = function(e) {
    return e === void 0 && (e = null), e === null ? this.getTypedRuleContexts(Jn) : this.getTypedRuleContext(Jn, e);
  };
  unaryop = function() {
    return this.getTypedRuleContext(Sv, 0);
  };
  atom = function() {
    return this.getTypedRuleContext(Ev, 0);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterExp(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitExp(this);
  };
}
class Ev extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_atom;
  }
  INT = function() {
    return this.getToken(Y.INT, 0);
  };
  REAL = function() {
    return this.getToken(Y.REAL, 0);
  };
  PI = function() {
    return this.getToken(Y.PI, 0);
  };
  ID = function() {
    return this.getToken(Y.ID, 0);
  };
  enterRule = function(e) {
    e instanceof Et && e.enterAtom(this);
  }.bind(this);
  exitRule = function(e) {
    e instanceof Et && e.exitAtom(this);
  }.bind(this);
}
Y.AtomContext = Ev;
class Sv extends yr {
  constructor(e, r, n) {
    r === void 0 && (r = null), n == null && (n = -1), super(r, n), this.parser = e, this.ruleIndex = Y.RULE_unaryop;
  }
  enterRule = function(e) {
    e instanceof Et && e.enterUnaryop(this);
  };
  exitRule = function(e) {
    e instanceof Et && e.exitUnaryop(this);
  };
}
Y.UnaryopContext = Sv;
/**
 * @license
 *
 * Copyright (c) 2016, Petar Korponaić <petar.korponaic@gmail.com>
 *
 * This source code is licensed under the MIT License, found in
 * the LICENSE.txt file in the root directory of this source tree.
 */
const hu = function(t) {
  return pv.call(this), this.errors = t, this;
};
hu.prototype = Object.create(hu.prototype);
hu.prototype.constructor = pv;
hu.prototype.syntaxError = function(t, e, r, n, i, a) {
  this.errors.push({
    line: r,
    col: n,
    msg: i
  });
};
class Dk extends Et {
  constructor(e, r) {
    super(), this.circuit = e, this.qregMap = {}, this.condition = {}, this.compatibilityMode = r;
  }
  numQbit = function() {
    let e = 0;
    for (const r in this.qregMap)
      e += this.qregMap[r];
    return e;
  };
  qregBase = function(e) {
    let r = 0;
    for (const n in this.qregMap) {
      if (n === e)
        return r;
      r += this.qregMap[n];
    }
    return r;
  };
  qregLen = function(e) {
    return this.qregMap[e] || 0;
  };
  // Enter a parse tree produced by QASMParser#mainprog.
  enterMainprog = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mainprog.
  exitMainprog = function(e) {
  };
  // Enter a parse tree produced by QASMParser#statement.
  enterStatement = function(e) {
    const r = this;
    if ((e.getChildCount() ? e.getChild(0).getText() : "") === "if" && (this.condition = {
      creg: e.ID().getText(),
      value: parseInt(e.INT().getText())
    }), e.gatedecl()) {
      const i = e.gatedecl();
      let a = [], o = [];
      const f = i.getChildCount();
      f > 2 && i.getChild(2).ID ? a = i.getChild(2).ID() : (f > 3 && i.getChild(3).ID && (o = i.getChild(3).ID()), f > 5 && i.getChild(5).ID && (a = i.getChild(5).ID()));
      const u = Object.getPrototypeOf(this.circuit), s = new u.constructor(a.length), c = i.ID().getText(), l = [];
      a.map(function(m) {
        l.push(m.getText());
      }), o.map(function(m) {
        const h = m.getText();
        s.params.push(h);
      }), e.goplist() && e.goplist().uop().map(function(h) {
        let g = h.ID() ? h.ID().getText() : "";
        if (g) {
          const d = h.anylist() ? h.anylist().idlist() : null;
          h.anylist() && h.anylist().mixedlist();
          const y = h.explist();
          switch (g) {
            case "CX":
              g = "cx";
              break;
            case "U":
              g = "u3";
              break;
          }
          if (!r.circuit.basicGates[g] && !r.circuit.customGates[g])
            for (const D in r.circuit.basicGates) {
              const b = r.circuit.basicGates[D];
              if (b.exportInfo && b.exportInfo.qasm && b.exportInfo.qasm.name && b.exportInfo.qasm.name === g) {
                g = D;
                break;
              }
              if (b.exportInfo && b.exportInfo.qiskit && b.exportInfo.qiskit.name && b.exportInfo.qiskit.name === g) {
                g = D;
                break;
              }
            }
          const w = {};
          if (y && y.exp()) {
            let D = r.circuit.basicGates[g];
            if (D || (D = r.circuit.customGates[g]), D) {
              const b = y.exp(), C = D.params || [];
              b.map(function(A, T) {
                const _ = A.getText(), O = C.length >= T ? C[T] : "";
                O && (w[O] = _);
              });
            }
          }
          const E = { params: w }, x = [];
          if (d) {
            const D = d.ID().length;
            for (let b = 0; b < D; b++)
              x.push(l.indexOf(d.ID()[b].getText()));
          }
          const N = r.circuit.customGates[g];
          N && s.registerGate(g, JSON.parse(JSON.stringify(N))), s.addGate(g, -1, x, E);
        }
      }), this.circuit.registerGate(c, s.save(!1));
    }
  };
  // Exit a parse tree produced by QASMParser#statement.
  exitStatement = function(e) {
  };
  // Enter a parse tree produced by QASMParser#version.
  enterVersion = function(e) {
  };
  // Exit a parse tree produced by QASMParser#version.
  exitVersion = function(e) {
  };
  // Enter a parse tree produced by QASMParser#decl.
  enterDecl = function(e) {
    switch (e.getChild(0).getText()) {
      case "qreg":
        this.qregMap[e.getChild(1).getText()] = parseInt(
          e.getChild(3).getText()
        );
        break;
      case "creg":
        this.circuit.createCreg(
          e.getChild(1).getText(),
          parseInt(e.getChild(3).getText())
        );
        break;
    }
  };
  // Exit a parse tree produced by QASMParser#decl.
  exitDecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#gatedecl.
  enterGatedecl = function(e) {
  };
  // Exit a parse tree produced by QASMParser#gatedecl.
  exitGatedecl = function(e) {
  };
  // Enter a parse tree produced by QASMParser#goplist.
  enterGoplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#goplist.
  exitGoplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#qop.
  enterQop = function(e) {
    const r = this, n = JSON.parse(JSON.stringify(this.condition));
    this.condition = {};
    const i = e.getChildCount() ? e.getChild(0).getText() : "";
    if (i === "reset") {
      let o = "", f = -1;
      const u = e.argument().length;
      for (let s = 0; s < u; s++) {
        const c = e.argument()[s];
        s === 0 && (o = c.ID().getText(), f = c.INT() ? parseInt(c.INT().getText()) : -1);
      }
      if (o) {
        const s = r.qregLen(o);
        if (f < 0)
          for (let c = 0; c < s; c++)
            r.circuit.addGate("reset", -1, c + r.qregBase(o), {
              condition: n || {}
            });
        else
          r.circuit.addGate("reset", -1, f + r.qregBase(o), {
            condition: n || {}
          });
      }
    }
    if (i === "measure") {
      let o = "", f = -1, u = "", s = -1;
      const c = e.argument().length;
      for (let l = 0; l < c; l++) {
        const m = e.argument()[l];
        l === 0 && (o = m.ID().getText(), f = m.INT() ? parseInt(m.INT().getText()) : -1), l === 1 && (u = m.ID().getText(), s = m.INT() ? parseInt(m.INT().getText()) : -1);
      }
      if (o && u) {
        const l = r.qregLen(o);
        if (f < 0 && s < 0)
          for (let m = 0; m < l; m++)
            r.circuit.addGate("measure", -1, m + r.qregBase(o), {
              creg: { name: u, bit: m },
              condition: n || {}
            });
        else if (f >= 0 && s >= 0)
          r.circuit.addGate("measure", -1, f + r.qregBase(o), {
            creg: { name: u, bit: s },
            condition: n || {}
          });
        else if (f >= 0 && s < 0)
          for (let m = 0; m < l; m++)
            r.circuit.addGate("measure", -1, f + r.qregBase(o), {
              creg: { name: u, bit: m },
              condition: n || {}
            });
        else
          for (let m = 0; m < l; m++)
            r.circuit.addGate("measure", -1, m + r.qregBase(o), {
              creg: { name: u, bit: s },
              condition: n || {}
            });
      }
    }
    const a = e.uop();
    if (a && a.ID()) {
      let o = a.ID().getText();
      const f = a.anylist() ? a.anylist().idlist() : null, u = a.anylist() ? a.anylist().mixedlist() : null, s = a.explist();
      switch (o) {
        case "CX":
          o = "cx";
          break;
        case "U":
          o = "u3";
          break;
      }
      if (!r.circuit.basicGates[o] && !r.circuit.customGates[o])
        for (const m in r.circuit.basicGates) {
          const h = r.circuit.basicGates[m];
          if (h.exportInfo && h.exportInfo.qasm && h.exportInfo.qasm.name && h.exportInfo.qasm.name === o) {
            o = m;
            break;
          }
          if (h.exportInfo && h.exportInfo.qiskit && h.exportInfo.qiskit.name && h.exportInfo.qiskit.name === o) {
            o = m;
            break;
          }
        }
      const c = {};
      if (s && s.exp()) {
        let m = r.circuit.basicGates[o];
        if (m || (m = r.circuit.customGates[o]), m) {
          const h = s.exp(), g = m.params || [];
          h.map(function(d, y) {
            const w = d.getText(), E = g.length >= y ? g[y] : "";
            E && (c[E] = w);
          });
        }
      }
      const l = { params: c, condition: n || {} };
      if (f) {
        const m = r.qregLen(f.ID()[0].getText());
        for (let h = 0; h < m; h++) {
          const g = [], d = f.ID().length;
          for (let w = 0; w < d; w++)
            g.push({ reg: f.ID()[w].getText(), bit: h });
          const y = [];
          g.map(function(w) {
            y.push(w.bit + r.qregBase(w.reg));
          }), r.circuit.addGate(o, -1, y, l);
        }
      }
      if (u && u.ID().length === u.INT().length) {
        const m = [], h = u.ID().length;
        for (let d = 0; d < h; d++)
          m.push({
            reg: u.ID()[d].getText(),
            bit: parseInt(u.INT()[d].getText())
          });
        const g = [];
        m.map(function(d) {
          g.push(d.bit + r.qregBase(d.reg));
        }), r.circuit.addGate(o, -1, g, l);
      }
    }
  };
  // Exit a parse tree produced by QASMParser#qop.
  exitQop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#uop.
  enterUop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#uop.
  exitUop = function(e) {
  };
  // Enter a parse tree produced by QASMParser#anylist.
  enterAnylist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#anylist.
  exitAnylist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#idlist.
  enterIdlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#idlist.
  exitIdlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#mixedlist.
  enterMixedlist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#mixedlist.
  exitMixedlist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#argument.
  enterArgument = function(e) {
  };
  // Exit a parse tree produced by QASMParser#argument.
  exitArgument = function(e) {
  };
  // Enter a parse tree produced by QASMParser#explist.
  enterExplist = function(e) {
  };
  // Exit a parse tree produced by QASMParser#explist.
  exitExplist = function(e) {
  };
  // Enter a parse tree produced by QASMParser#exp.
  enterExp = function(e) {
  };
  // Exit a parse tree produced by QASMParser#exp.
  exitExp = function(e) {
  };
  // Enter a parse tree produced by QASMParser#unaryop.
  enterUnaryop = function(e) {
  };
  // Exit a parse tree produced by QASMParser#unaryop.
  exitUnaryop = function(e) {
  };
}
const Ek = function(e, r, n, i) {
  const a = new uk(r), o = new ct(a), f = new ok(o), u = new Y(f);
  u.buildParseTrees = !0, u.removeErrorListeners();
  const s = [], c = new pv(s);
  u.addErrorListener(c);
  const l = u.mainprog(), m = new Dk(e, i);
  pk.DEFAULT.walk(m, l), n && n(s);
};
/**
 * @license
 *
 * Copyright (c) 2016, Petar Korponaić <petar.korponaic@gmail.com>
 *
 * This source code is licensed under the MIT License, found in
 * the LICENSE.txt file in the root directory of this source tree.
 */
const du = function(t, e) {
  e = e || {}, e.decimalPlaces && (t = qt(t, e.decimalPlaces));
  let r = t + "";
  e.fixedWidth && (r = t.toFixed(e.decimalPlaces || 14));
  let n = e.plusChar;
  return e.fixedWidth && !n && (n = " "), n && t >= 0 && (r = n + r), r;
}, bs = function(t, e, r) {
  r = r || {};
  const n = du(t, r), i = JSON.parse(JSON.stringify(r));
  i.plusChar = "+";
  const a = du(e, i);
  return n + a + (r.iotaChar ? r.iotaChar : "i");
}, dr = function(t, e) {
  let r = e || t + 1;
  r > 0 && (r = r - 1);
  let n = r.toString(26).length, i = t.toString(26);
  for (; i.length < n; )
    i = "0" + i;
  let a = "";
  for (let o = 0; o < i.length; o++) {
    const f = i.charCodeAt(o);
    a += String.fromCharCode(f < 97 ? f + 49 : f + 10);
  }
  return a;
}, me = function(e) {
  this.basicGates = {
    id: {
      description: "Single qubit identity gate",
      matrix: [
        [1, 0],
        [0, 1]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "ID"
      },
      exportInfo: {
        quil: {
          name: "I"
        },
        cirq: {
          name: "I",
          notTfqSupported: !0
        },
        quest: {
          name: "compactUnitary",
          params: {
            alpha: "(Complex) { .real = 1, .imag = 0 }",
            beta: "(Complex) {.real = 0, .imag = 0}"
          }
        },
        qsharp: {
          name: "I"
        },
        qiskit: {
          name: "id"
        },
        braket: {
          name: "i"
        },
        aqasm: {
          name: "I"
        }
      }
    },
    x: {
      description: 'Pauli X (PI rotation over X-axis) aka "NOT" gate',
      matrix: [
        [0, 1],
        [1, 0]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "X"
      },
      exportInfo: {
        quil: {
          name: "X"
        },
        cirq: {
          name: "X"
        },
        quest: {
          name: "pauliX"
        },
        qsharp: {
          name: "X"
        },
        quirk: {
          name: "X"
        },
        braket: {
          name: "x"
        },
        aqasm: {
          name: "X"
        },
        ionq: {
          names: ["x", "not"]
        }
      }
    },
    y: {
      description: "Pauli Y (PI rotation over Y-axis)",
      matrix: [
        [0, "-i"],
        ["i", 0]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Y"
      },
      exportInfo: {
        quil: {
          name: "Y"
        },
        cirq: {
          name: "Y"
        },
        quest: {
          name: "pauliY"
        },
        qsharp: {
          name: "Y"
        },
        quirk: {
          name: "Y"
        },
        braket: {
          name: "y"
        },
        aqasm: {
          name: "Y"
        },
        ionq: {
          name: "y"
        }
      }
    },
    z: {
      description: "Pauli Z (PI rotation over Z-axis)",
      matrix: [
        [1, 0],
        [0, -1]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z"
      },
      exportInfo: {
        quil: {
          name: "Z"
        },
        cirq: {
          name: "Z"
        },
        quest: {
          name: "pauliZ"
        },
        qsharp: {
          name: "Z"
        },
        quirk: {
          name: "Z"
        },
        braket: {
          name: "z"
        },
        aqasm: {
          name: "Z"
        },
        ionq: {
          name: "z"
        }
      }
    },
    h: {
      description: "Hadamard gate",
      matrix: [
        ["1 / sqrt(2)", "1 / sqrt(2)"],
        ["1 / sqrt(2)", "-1 / sqrt(2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "H"
      },
      exportInfo: {
        quil: {
          name: "H"
        },
        cirq: {
          name: "H"
        },
        quest: {
          name: "hadamard"
        },
        qsharp: {
          name: "H"
        },
        quirk: {
          name: "H"
        },
        braket: {
          name: "h"
        },
        aqasm: {
          name: "H"
        },
        ionq: {
          name: "h"
        }
      }
    },
    srn: {
      description: "Square root of NOT",
      matrix: [
        ["0.5+0.5i", "0.5-0.5i"],
        ["0.5-0.5i", "0.5+0.5i"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "&#x221A;X"
      },
      exportInfo: {
        quil: {
          name: "srn",
          defgate: `DEFGATE srn:
    0.5+0.5i, 0.5-0.5i
    0.5-0.5i, 0.5+0.5i`
        },
        pyquil: {
          name: "srn",
          array: "[[0.5+0.5j, 0.5-0.5j], [0.5-0.5j, 0.5+0.5j]]"
        },
        cirq: {
          name: "X**(1/2)"
        },
        quest: {
          name: "unitary",
          matrix: [
            [
              ["0.5", "0.5"],
              ["0.5", "-0.5"]
            ],
            [
              ["0.5", "-0.5"],
              ["0.5", "0.5"]
            ]
          ]
        },
        qasm: {
          name: "sx"
        },
        qiskit: {
          name: "sx"
        },
        braket: {
          name: "v"
        },
        aqasm: {
          matrix: [
            ["0.5+0.5i", "0.5-0.5i"],
            ["0.5-0.5i", "0.5+0.5i"]
          ],
          array: "[[0.5+0.5j, 0.5-0.5j], [0.5-0.5j, 0.5+0.5j]]"
        },
        ionq: {
          name: "v"
        }
      }
    },
    srndg: {
      description: "Inverse square root of NOT",
      matrix: [
        ["0.5-0.5i", "0.5+0.5i"],
        ["0.5+0.5i", "0.5-0.5i"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "&#x221A;X&#8224;"
      },
      exportInfo: {
        quil: {
          name: "srndg",
          defgate: `DEFGATE srndg:
    0.5-0.5i, 0.5+0.5i
    0.5+0.5i, 0.5-0.5i`
        },
        pyquil: {
          name: "srndg",
          array: "[[0.5-0.5j, 0.5+0.5j], [0.5+0.5j, 0.5-0.5j]]"
        },
        cirq: {
          name: "X**(-1/2)"
        },
        quest: {
          name: "unitary",
          matrix: [
            [
              ["0.5", "-0.5"],
              ["0.5", "0.5"]
            ],
            [
              ["0.5", "0.5"],
              ["0.5", "-0.5"]
            ]
          ]
        },
        qasm: {
          name: "sxdg"
        },
        qiskit: {
          name: "sxdg"
        },
        braket: {
          name: "vi"
        },
        aqasm: {
          matrix: [
            ["0.5-0.5i", "0.5+0.5i"],
            ["0.5+0.5i", "0.5-0.5i"]
          ],
          array: "[[0.5-0.5j, 0.5+0.5j], [0.5+0.5j, 0.5-0.5j]]"
        },
        ionq: {
          name: "vi"
        }
      }
    },
    r2: {
      description: 'PI/2 rotation over Z-axis aka "Phase PI/2"',
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z&#x1D6D1;/2"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "s"
          }
        },
        cirq: {
          replacement: {
            name: "s"
          }
        },
        quest: {
          name: "sGate"
        },
        qsharp: {
          replacement: {
            name: "s"
          }
        },
        qasm: {
          replacement: [{ name: "s", params: {} }]
        },
        qiskit: {
          replacement: [{ name: "s", params: {} }]
        },
        quirk: {
          name: "Z^½"
        },
        braket: {
          name: "s"
        },
        aqasm: {
          name: "S"
        }
      }
    },
    r4: {
      description: 'PI/4 rotation over Z-axis aka "Phase PI/4"',
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 4)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z&#x1D6D1;/4"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "t"
          }
        },
        cirq: {
          replacement: {
            name: "t"
          }
        },
        quest: {
          name: "tGate"
        },
        qsharp: {
          replacement: {
            name: "t"
          }
        },
        qasm: {
          replacement: [{ name: "t", params: {} }]
        },
        qiskit: {
          replacement: [{ name: "t", params: {} }]
        },
        quirk: {
          name: "Z^¼"
        },
        braket: {
          name: "t"
        },
        aqasm: {
          name: "T"
        }
      }
    },
    r8: {
      description: 'PI/8 rotation over Z-axis aka "Phase PI/8"',
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 8)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "Z&#x1D6D1;/8"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "u1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        cirq: {
          replacement: {
            name: "u1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        quest: {
          name: "phaseShift",
          params: { theta: "M_PI/8" }
        },
        qsharp: {
          replacement: {
            name: "u1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        qasm: {
          replacement: [{ name: "u1", params: { lambda: "pi/8" } }]
        },
        qiskit: {
          replacement: [{ name: "u1", params: { lambda: "pi/8" } }]
        },
        quirk: {
          name: "Z^⅛"
        },
        braket: {
          name: "phaseshift",
          params: { theta: "pi/8" }
        },
        aqasm: {
          matrix: [
            [1, 0],
            [0, "exp(i * pi / 8)"]
          ],
          array: "[[1,0],[0,np.exp(1j * np.pi / 8)]]"
        }
      }
    },
    rx: {
      description: "Rotation around the X-axis by given angle",
      matrix: [
        ["cos(theta / 2)", "-i * sin(theta / 2)"],
        ["-i * sin(theta / 2)", "cos(theta / 2)"]
      ],
      params: ["theta"],
      drawingInfo: {
        connectors: ["box"],
        label: "RX"
      },
      exportInfo: {
        quil: {
          name: "RX",
          params: ["theta"]
        },
        cirq: {
          name: "rx",
          params: ["theta"]
        },
        quest: {
          name: "rotateX",
          params: ["theta"]
        },
        qsharp: {
          name: "Rx",
          params: ["theta"]
        },
        braket: {
          name: "rx",
          params: ["theta"]
        },
        aqasm: {
          name: "RX"
        },
        ionq: {
          name: "rx",
          paramsKey: "rotation"
        }
      }
    },
    ry: {
      description: "Rotation around the Y-axis by given angle",
      matrix: [
        ["cos(theta / 2)", "-1 * sin(theta / 2)"],
        ["sin(theta / 2)", "cos(theta / 2)"]
      ],
      params: ["theta"],
      drawingInfo: {
        connectors: ["box"],
        label: "RY"
      },
      exportInfo: {
        quil: {
          name: "RY",
          params: ["theta"]
        },
        cirq: {
          name: "ry",
          params: ["theta"]
        },
        quest: {
          name: "rotateY",
          params: ["theta"]
        },
        qsharp: {
          name: "Ry",
          params: ["theta"]
        },
        braket: {
          name: "ry",
          params: ["theta"]
        },
        aqasm: {
          name: "RY"
        },
        ionq: {
          name: "ry",
          paramsKey: "rotation"
        }
      }
    },
    rz: {
      description: "Rotation around the Z-axis by given angle",
      matrix: [
        ["cos(phi / 2) - i * sin(phi / 2)", 0],
        [0, "cos(phi / 2) + i * sin(phi / 2)"]
      ],
      params: ["phi"],
      drawingInfo: {
        connectors: ["box"],
        label: "RZ"
      },
      exportInfo: {
        quil: {
          name: "RZ",
          params: ["phi"]
        },
        cirq: {
          name: "rz",
          params: ["theta"]
        },
        qsharp: {
          name: "Rz",
          params: ["theta"]
        },
        braket: {
          name: "rz",
          params: ["phi"]
        },
        aqasm: {
          name: "RZ"
        },
        ionq: {
          name: "rz",
          paramsKey: "rotation"
        }
      }
    },
    u1: {
      description: "Single-qubit rotation about the Z axis",
      matrix: [
        [1, 0],
        [0, "exp(i * lambda)"]
      ],
      params: ["lambda"],
      drawingInfo: {
        connectors: ["box"],
        label: "U1"
      },
      exportInfo: {
        quil: {
          name: "PHASE",
          params: ["lambda"]
        },
        cirq: {
          name: "u1",
          params: ["lambda"],
          array: "[[1, 0], [0, np.exp(1j*p_lambda)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "phaseShift",
          params: ["lambda"]
        },
        braket: {
          name: "phaseshift",
          params: ["lambda"]
        },
        qiskit: {
          name: "p"
        },
        aqasm: {
          name: "PH"
        }
      }
    },
    u2: {
      description: "Single-qubit rotation about the X+Z axis",
      matrix: [
        ["1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"],
        ["exp(i * phi) * 1 / sqrt(2)", "exp(i * lambda + i * phi) * 1 / sqrt(2)"]
      ],
      params: ["phi", "lambda"],
      drawingInfo: {
        connectors: ["box"],
        label: "U2"
      },
      exportInfo: {
        quil: {
          name: "u2",
          params: ["phi", "lambda"],
          defgate: `DEFGATE u2(%phi, %lambda):
    1/SQRT(2), -1*EXP(i*%lambda)*1/SQRT(2)
    EXP(i*%phi)*1/SQRT(2), EXP(i*%lambda + i*%phi)*1/SQRT(2)`
        },
        pyquil: {
          name: "u2",
          params: ["phi", "lambda"],
          array: "[[1/quil_sqrt(2),-quil_exp(1j*p_lambda)*1/quil_sqrt(2)],[quil_exp(1j*p_phi)*1/quil_sqrt(2),quil_exp(1j*p_lambda+1j*p_phi)*1/quil_sqrt(2)]]"
        },
        cirq: {
          name: "u2",
          params: ["phi", "lambda"],
          array: "[[1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)], [np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "unitary",
          params: ["phi", "lambda"],
          matrix: [
            [
              ["1/sqrt(2)", "0"],
              ["-cos(lambda)/sqrt(2)", "-sin(lambda)/sqrt(2)"]
            ],
            [
              ["cos(phi)/sqrt(2)", "sin(phi)/sqrt(2)"],
              ["cos(lambda+phi)/sqrt(2)", "sin(lambda+phi)/sqrt(2)"]
            ]
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi", "lambda"],
          array: "[[1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)], [np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]"
        },
        aqasm: {
          matrix: [
            ["1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"],
            ["exp(i * phi) * 1 / sqrt(2)", "exp(i * lambda + i * phi) * 1 / sqrt(2)"]
          ],
          array: "[[1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)], [np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          params: ["phi", "lambda"]
        },
        qiskit: {
          replacement: [
            {
              name: "u3",
              params: { theta: "pi/2", phi: "phi", lambda: "lambda" }
            }
          ]
        }
      }
    },
    u3: {
      description: "Generic single-qubit rotation gate with 3 Euler angles",
      matrix: [
        ["cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"],
        [
          "exp(i * phi) * sin(theta / 2)",
          "exp(i * lambda + i * phi) * cos(theta / 2)"
        ]
      ],
      params: ["theta", "phi", "lambda"],
      drawingInfo: {
        connectors: ["box"],
        label: "U3"
      },
      exportInfo: {
        quil: {
          name: "u3",
          params: ["theta", "phi", "lambda"],
          defgate: `DEFGATE u3(%theta, %phi, %lambda):
    COS(%theta/2), -1*EXP(i*%lambda)*SIN(%theta/2)
    EXP(i*%phi)*SIN(%theta/2), EXP(i*%lambda + i*%phi)*COS(%theta/2)`
        },
        pyquil: {
          name: "u3",
          params: ["theta", "phi", "lambda"],
          array: "[[quil_cos(p_theta/2),-quil_exp(1j*p_lambda)*quil_sin(p_theta/2)],[quil_exp(1j*p_phi)*quil_sin(p_theta/2),quil_exp(1j*p_lambda+1j*p_phi)*quil_cos(p_theta/2)]]"
        },
        cirq: {
          name: "u3",
          params: ["theta", "phi", "lambda"],
          array: "[[np.cos(p_theta/2), -np.exp(1j*p_lambda)*np.sin(p_theta/2)], [np.exp(1j*p_phi)*np.sin(p_theta/2), np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "unitary",
          params: ["theta", "phi", "lambda"],
          matrix: [
            [
              ["cos(theta/2)", "0"],
              ["-cos(lambda)*sin(theta/2)", "-sin(lambda)*sin(theta/2)"]
            ],
            [
              ["cos(phi)*sin(theta/2)", "sin(phi)*sin(theta/2)"],
              ["cos(lambda+phi)*cos(theta/2)", "sin(lambda+phi)*cos(theta/2)"]
            ]
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta", "phi", "lambda"],
          array: "[[np.cos(p_theta/2), -np.exp(1j*p_lambda)*np.sin(p_theta/2)], [np.exp(1j*p_phi)*np.sin(p_theta/2), np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]"
        },
        qiskit: {
          name: "u"
        },
        aqasm: {
          matrix: [
            ["cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"],
            [
              "exp(i * phi) * sin(theta / 2)",
              "exp(i * lambda + i * phi) * cos(theta / 2)"
            ]
          ],
          array: "[[np.cos(p_theta/2), -np.exp(1j*p_lambda)*np.sin(p_theta/2)], [np.exp(1j*p_phi)*np.sin(p_theta/2), np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          params: ["theta", "phi", "lambda"]
        }
      }
    },
    s: {
      description: "PI/2 rotation over Z-axis (synonym for `r2`)",
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "S"
      },
      exportInfo: {
        quil: {
          name: "S"
        },
        cirq: {
          name: "S"
        },
        quest: {
          name: "sGate"
        },
        qsharp: {
          name: "S"
        },
        quirk: {
          name: "Z^½"
        },
        braket: {
          name: "s"
        },
        aqasm: {
          name: "S"
        },
        ionq: {
          name: "s"
        }
      }
    },
    t: {
      description: "PI/4 rotation over Z-axis (synonym for `r4`)",
      matrix: [
        [1, 0],
        [0, "exp(i * pi / 4)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "T"
      },
      exportInfo: {
        quil: {
          name: "T"
        },
        cirq: {
          name: "T"
        },
        quest: {
          name: "tGate"
        },
        qsharp: {
          name: "T"
        },
        quirk: {
          name: "Z^¼"
        },
        braket: {
          name: "t"
        },
        aqasm: {
          name: "T"
        },
        ionq: {
          name: "t"
        }
      }
    },
    sdg: {
      description: "(-PI/2) rotation over Z-axis",
      matrix: [
        [1, 0],
        [0, "exp(-i * pi / 2)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "S&#8224;"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        quest: {
          name: "phaseShift",
          params: { theta: "-M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        quirk: {
          name: "Z^-½"
        },
        braket: {
          name: "si"
        },
        aqasm: {
          name: "S",
          dagger: !0
        },
        ionq: {
          name: "si"
        }
      }
    },
    tdg: {
      description: "(-PI/4) rotation over Z-axis",
      matrix: [
        [1, 0],
        [0, "exp(-i * pi / 4)"]
      ],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "T&#8224;"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        quest: {
          name: "phaseShift",
          params: { theta: "-M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "u1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        quirk: {
          name: "Z^-¼"
        },
        braket: {
          name: "ti"
        },
        aqasm: {
          name: "T",
          dagger: !0
        },
        ionq: {
          name: "ti"
        }
      }
    },
    gpi: {
      description: "GPi gate",
      matrix: [
        [0, "exp(-i*phi)"],
        ["exp(i*phi)", 0]
      ],
      params: ["phi"],
      drawingInfo: {
        connectors: ["box"],
        label: "GPi"
      },
      exportInfo: {
        quil: {
          name: "gpi",
          params: ["phi"],
          defgate: `DEFGATE gpi(%phi):
    0, EXP(-i * %phi)
    EXP(i * %phi), 0`
        },
        pyquil: {
          name: "gpi",
          params: ["phi"],
          array: "[ [ 0, quil_exp(-1j*p_phi) ], [ quil_exp(1j*p_phi), 0 ] ]"
        },
        cirq: {
          name: "gpi"
        },
        quest: {
          name: "gpi",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "pi", phi: "phi", lambda: "pi-phi" },
              wires: [0]
            }
          ]
        },
        qiskit: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "pi", phi: "phi", lambda: "pi-phi" },
              wires: [0]
            }
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi"],
          array: "[ [ 0, np.exp(-1j*p_phi) ], [ np.exp(1j*p_phi), 0 ] ]"
        },
        aqasm: {
          matrix: [
            [0, "exp(-i*phi)"],
            ["exp(i*phi)", 0]
          ],
          array: "[ [ 0, np.exp(-1j*p_phi) ], [ np.exp(1j*p_phi), 0 ] ]",
          params: ["phi"]
        },
        ionq: {
          name: "gpi",
          paramsKey: "phase"
        }
      }
    },
    gpi2: {
      description: "GPi2 gate",
      matrix: [
        ["1/sqrt(2)", "(-i*exp(-i*phi))/sqrt(2)"],
        ["(-i*exp(i*phi))/sqrt(2)", "1/sqrt(2)"]
      ],
      params: ["phi"],
      drawingInfo: {
        connectors: ["box"],
        label: "GPi2"
      },
      exportInfo: {
        quil: {
          name: "gpi2",
          params: ["phi"],
          defgate: `DEFGATE gpi2(%phi):
    1/SQRT(2), (-i*EXP(-i * %phi)) / SQRT(2)
    (-i*EXP(i * %phi)) / SQRT(2), 1/SQRT(2)`
        },
        pyquil: {
          name: "gpi2",
          params: ["phi"],
          array: "[ [ 1/quil_sqrt(2), (-1j*quil_exp(-1j*p_phi))/quil_sqrt(2) ], [ (-1j*quil_exp(1j*p_phi))/quil_sqrt(2), 1/quil_sqrt(2) ] ]"
        },
        cirq: {
          name: "gpi2"
        },
        quest: {
          name: "gpi2",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          equivalent: [
            {
              name: "u3",
              params: {
                theta: "pi/2",
                phi: "phi-(pi/2)",
                lambda: "(pi/2)-phi"
              },
              wires: [0]
            }
          ]
        },
        qiskit: {
          equivalent: [
            {
              name: "u3",
              params: {
                theta: "pi/2",
                phi: "phi-(pi/2)",
                lambda: "(pi/2)-phi"
              },
              wires: [0]
            }
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi"],
          array: "[ [ 1/np.sqrt(2), (-1j*np.exp(-1j*p_phi))/np.sqrt(2) ], [ (-1j*np.exp(1j*p_phi))/np.sqrt(2), 1/np.sqrt(2) ] ]"
        },
        aqasm: {
          matrix: [
            ["1/sqrt(2)", "(-i*exp(-i*phi))/sqrt(2)"],
            ["(-i*exp(i*phi))/sqrt(2)", "1/sqrt(2)"]
          ],
          array: "[ [ 1/np.sqrt(2), (-1j*np.exp(-1j*p_phi))/np.sqrt(2) ], [ (-1j*np.exp(1j*p_phi))/np.sqrt(2), 1/np.sqrt(2) ] ]",
          params: ["phi"]
        },
        ionq: {
          name: "gpi2",
          paramsKey: "phase"
        }
      }
    },
    vz: {
      description: "VirtualZ gate",
      matrix: [
        ["exp(-i*theta/2)", 0],
        [0, "exp(i*theta/2)"]
      ],
      params: ["theta"],
      drawingInfo: {
        connectors: ["box"],
        label: "VrtZ"
      },
      exportInfo: {
        quil: {
          name: "vz",
          params: ["theta"],
          defgate: `DEFGATE vz(%theta):
    EXP(-i * %theta/2), 0
    0, EXP(-i * %theta/2)`
        },
        pyquil: {
          name: "vz",
          params: ["theta"],
          array: "[ [ quil_exp(-1j*p_theta/2), 0 ], [ 0, quil_exp(1j*p_theta/2) ] ]"
        },
        cirq: {
          name: "vz"
        },
        quest: {
          name: "vz",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          equivalent: [{ name: "rz", params: { phi: "theta" }, wires: [0] }]
        },
        qiskit: {
          equivalent: [{ name: "rz", params: { phi: "theta" }, wires: [0] }]
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[ [ np.exp(-1j*p_theta/2), 0 ], [ 0, np.exp(1j*p_theta/2) ] ]"
        },
        aqasm: {
          matrix: [
            ["exp(-i*theta/2)", 0],
            [0, "exp(i*theta/2)"]
          ],
          array: "[ [ np.exp(-1j*p_theta/2), 0 ], [ 0, np.exp(1j*p_theta/2) ] ]",
          params: ["theta"]
        },
        ionq: {
          name: "vz",
          paramsKey: "phase"
        }
      }
    },
    cx: {
      description: "Controlled NOT (CNOT) gate",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 1],
        [0, 0, 1, 0]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "not"],
        label: "X",
        root: "x"
      },
      exportInfo: {
        quil: {
          name: "CNOT"
        },
        cirq: {
          name: "CNOT"
        },
        quest: {
          name: "controlledNot"
        },
        qsharp: {
          name: "CNOT"
        },
        quirk: {
          name: "X",
          controlled: !0
        },
        braket: {
          name: "cnot"
        },
        aqasm: {
          name: "CNOT"
        },
        ionq: {
          name: "cnot"
        }
      }
    },
    cy: {
      description: "Controlled Y gate (controlled rotation over Y-axis by PI)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 0, "-i"],
        [0, 0, "i", 0]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Y",
        root: "y"
      },
      exportInfo: {
        quest: {
          name: "controlledPauliY"
        },
        cirq: {
          replacement: {
            name: "y",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "cy",
          defgate: `DEFGATE cy:
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 0, -i
    0, 0, i, 0`
        },
        pyquil: {
          name: "cy",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0,-1j],[0,0,1j,0]]"
        },
        qsharp: {
          name: "Controlled Y"
        },
        quirk: {
          name: "Y",
          controlled: !0
        },
        braket: {
          name: "cy"
        },
        aqasm: {
          name: "Y",
          controlled: !0
        }
      }
    },
    cz: {
      description: "Controlled Z gate (controlled rotation over Z-axis by PI)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, -1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "dot"],
        label: "Z",
        root: "z"
      },
      exportInfo: {
        quil: {
          name: "CZ"
        },
        cirq: {
          name: "CZ"
        },
        quest: {
          name: "controlledPhaseFlip"
        },
        qsharp: {
          name: "Controlled Z"
        },
        quirk: {
          name: "Z",
          controlled: !0
        },
        braket: {
          name: "cz"
        },
        aqasm: {
          name: "CSIGN"
        }
      }
    },
    ch: {
      description: "Controlled Hadamard gate",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "1 / sqrt(2)", "1 / sqrt(2)"],
        [0, 0, "1 / sqrt(2)", "-1 / sqrt(2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "H",
        root: "h"
      },
      exportInfo: {
        quest: {
          name: "controlledUnitary",
          matrix: [
            [
              ["1/sqrt(2)", "0"],
              ["1/sqrt(2)", "0"]
            ],
            [
              ["1/sqrt(2)", "0"],
              ["-1/sqrt(2)", "0"]
            ]
          ]
        },
        cirq: {
          replacement: {
            name: "h",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "ch",
          defgate: `DEFGATE ch:
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 0.7071067811865475, 0.7071067811865475
    0, 0, 0.7071067811865475, -0.7071067811865475`
        },
        pyquil: {
          name: "ch",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,1/np.sqrt(2),1/np.sqrt(2)],[0,0,1/np.sqrt(2),-1/np.sqrt(2)]]"
        },
        qsharp: {
          name: "Controlled H"
        },
        quirk: {
          name: "H",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,1/np.sqrt(2),1/np.sqrt(2)],[0,0,1/np.sqrt(2),-1/np.sqrt(2)]]"
        },
        aqasm: {
          name: "H",
          controlled: !0
        }
      }
    },
    csrn: {
      description: "Controlled square root of NOT",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "0.5+0.5i", "0.5-0.5i"],
        [0, 0, "0.5-0.5i", "0.5+0.5i"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "&#x221A;X",
        root: "srn"
      },
      exportInfo: {
        quest: {
          name: "controlledUnitary",
          matrix: [
            [
              ["-1/sqrt(2)", "0"],
              ["-1/sqrt(2)", "0"]
            ],
            [
              ["-1/sqrt(2)", "0"],
              ["1/sqrt(2)", "0"]
            ]
          ]
        },
        cirq: {
          replacement: {
            name: "srn",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "csrn",
          defgate: `DEFGATE csrn:
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 0.5+0.5i, 0.5-0.5i
    0, 0, 0.5-0.5i, 0.5+0.5i`
        },
        qasm: {
          name: "csx"
        },
        qiskit: {
          name: "csx"
        },
        pyquil: {
          name: "csrn",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0.5+0.5j,0.5-0.5j],[0,0,0.5-0.5j,0.5+0.5j]]"
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0.5+0.5j,0.5-0.5j],[0,0,0.5-0.5j,0.5+0.5j]]"
        },
        aqasm: {
          matrix: [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, "0.5+0.5i", "0.5-0.5i"],
            [0, 0, "0.5-0.5i", "0.5+0.5i"]
          ],
          array: "[[1,0,0,0],[0,1,0,0],[0,0,0.5+0.5j,0.5-0.5j],[0,0,0.5-0.5j,0.5+0.5j]]"
        }
      }
    },
    swap: {
      description: "Swaps the state of two qubits.",
      matrix: [
        [1, 0, 0, 0],
        [0, 0, 1, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["x", "x"],
        label: "SWP"
      },
      exportInfo: {
        quil: {
          name: "SWAP"
        },
        cirq: {
          name: "SWAP"
        },
        quest: {
          name: "swap",
          func: `void swap(Qureg qubits, const int q1, const int q2) {
    controlledNot(qubits, q1, q2);
    controlledNot(qubits, q2, q1);
    controlledNot(qubits, q1, q2);
}`
        },
        qsharp: {
          name: "SWAP"
        },
        quirk: {
          name: "Swap"
        },
        braket: {
          name: "swap"
        },
        aqasm: {
          name: "SWAP"
        },
        ionq: {
          name: "swap"
        }
      }
    },
    srswap: {
      description: "Square root of swap",
      matrix: [
        [1, 0, 0, 0],
        [0, "0.5 * (1 + i)", "0.5 * (1 - i)", 0],
        [0, "0.5 * (1 - i)", "0.5 * (1 + i)", 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "&#x221A;SWP"
      },
      exportInfo: {
        quil: {
          name: "srswap",
          defgate: `DEFGATE srswap:
    1, 0, 0, 0
    0, 0.5+0.5i, 0.5-0.5i, 0
    0, 0.5-0.5i, 0.5+0.5i, 0
    0, 0, 0, 1`
        },
        cirq: {
          name: "SWAP**(1/2)"
        },
        pyquil: {
          name: "srswap",
          array: "[[1,0,0,0],[0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,1]]"
        },
        quest: {
          name: "srswap",
          func: `void srswap(Qureg qubits, const int q1, const int q2) {
    controlledNot(qubits, q2, q1);
    rotateY(qubits, q2, M_PI/2);
    rotateZ(qubits, q2, M_PI/16);
    controlledNot(qubits, q1, q2);
    rotateZ(qubits, q1, M_PI/8);
    rotateZ(qubits, q2, -M_PI/8);
    controlledNot(qubits, q1, q2);
    rotateZ(qubits, q2, M_PI/16);
    rotateY(qubits, q2, -M_PI/2);
    controlledNot(qubits, q2, q1);
}`
        },
        qasm: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "pi/2", phi: "pi/2", lambda: "-1*pi" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/4", phi: "-1*pi/2", lambda: "-1*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "7*pi/4" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/4", phi: "-1*pi", lambda: "-1*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "pi", lambda: "pi/2" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "-3*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "pi/2", lambda: "0" },
              wires: [1]
            }
          ]
        },
        qiskit: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "pi/2", phi: "pi/2", lambda: "-1*pi" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/4", phi: "-1*pi/2", lambda: "-1*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "7*pi/4" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/4", phi: "-1*pi", lambda: "-1*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "pi", lambda: "pi/2" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "-3*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "pi/2", lambda: "0" },
              wires: [1]
            }
          ]
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,1]]"
        },
        aqasm: {
          name: "SQRTSWAP"
        }
      }
    },
    iswap: {
      description: "Swaps the state of two qubits, applying a -i phase to q1 when it is in the 1 state and a -i phase to q2 when it is in the 0 state",
      matrix: [
        [1, 0, 0, 0],
        [0, 0, "0+i", 0],
        [0, "0+i", 0, 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "iSWP"
      },
      exportInfo: {
        quil: {
          name: "ISWAP"
        },
        cirq: {
          name: "ISWAP"
        },
        qasm: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "pi/2", phi: "-1*pi/2", lambda: "-1*pi" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "3*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "3*pi/2", lambda: "0" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "0" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi", phi: "pi/4", lambda: "-1*pi/4" },
              wires: [1]
            }
          ]
        },
        qiskit: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "pi/2", phi: "-1*pi/2", lambda: "-1*pi" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "-1*pi/2", lambda: "pi" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "3*pi/2" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "3*pi/2", lambda: "0" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "pi/2", phi: "0", lambda: "0" },
              wires: [0]
            },
            {
              name: "u3",
              params: { theta: "pi", phi: "pi/4", lambda: "-1*pi/4" },
              wires: [1]
            }
          ]
        },
        braket: {
          name: "iswap"
        },
        aqasm: {
          name: "ISWAP"
        }
      }
    },
    xx: {
      description: "XX gate",
      matrix: [
        ["cos(theta)", 0, 0, "-i*sin(theta)"],
        [0, "cos(theta)", "-i*sin(theta)", 0],
        [0, "-i*sin(theta)", "cos(theta)", 0],
        ["-i*sin(theta)", 0, 0, "cos(theta)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["theta"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "XX"
      },
      exportInfo: {
        quil: {
          name: "xx",
          params: ["theta"],
          defgate: `DEFGATE xx(%theta):
    COS(%theta), 0, 0, -i*SIN(%theta)
    0, COS(%theta), -i*SIN(%theta), 0
    0, -i*SIN(%theta), COS(%theta), 0
    -i*SIN(%theta), 0, 0, COS(%theta)`
        },
        pyquil: {
          name: "xx",
          params: ["theta"],
          array: "[ [quil_cos(p_theta), 0, 0, -1j*quil_sin(p_theta)], [0, quil_cos(p_theta), -1j*quil_sin(p_theta), 0], [0, -1j*quil_sin(p_theta), quil_cos(p_theta), 0], [-1j*quil_sin(p_theta), 0, 0, quil_cos(p_theta)] ]"
        },
        cirq: {
          name: "xx"
        },
        quest: {
          name: "xx",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          name: "rxx"
        },
        qiskit: {
          name: "rxx"
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[[np.cos(p_theta), 0, 0, -1j*np.sin(p_theta)], [0, np.cos(p_theta), -1j*np.sin(p_theta), 0], [0, -1j*np.sin(p_theta), np.cos(p_theta), 0], [-1j*np.sin(p_theta), 0, 0, np.cos(p_theta)] ]"
        },
        aqasm: {
          matrix: [
            ["cos(theta)", 0, 0, "-i*sin(theta)"],
            [0, "cos(theta)", "-i*sin(theta)", 0],
            [0, "-i*sin(theta)", "cos(theta)", 0],
            ["-i*sin(theta)", 0, 0, "cos(theta)"]
          ],
          array: "[[np.cos(p_theta), 0, 0, -1j*np.sin(p_theta)], [0, np.cos(p_theta), -1j*np.sin(p_theta), 0], [0, -1j*np.sin(p_theta), np.cos(p_theta), 0], [-1j*np.sin(p_theta), 0, 0, np.cos(p_theta)] ]",
          params: ["theta"]
        },
        ionq: {
          name: "xx",
          paramsKey: "phase"
        }
      }
    },
    yy: {
      description: "YY gate",
      matrix: [
        ["cos(theta)", 0, 0, "i*sin(theta)"],
        [0, "cos(theta)", "-i*sin(theta)", 0],
        [0, "-i*sin(theta)", "cos(theta)", 0],
        ["i*sin(theta)", 0, 0, "cos(theta)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["theta"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "YY"
      },
      exportInfo: {
        quil: {
          name: "yy",
          params: ["theta"],
          defgate: `DEFGATE yy(%theta):
    COS(%theta), 0, 0, i*SIN(%theta)
    0, COS(%theta), -i*SIN(%theta), 0
    0, -i*SIN(%theta), COS(%theta), 0
    i*SIN(%theta), 0, 0, COS(%theta)`
        },
        cirq: {
          name: "YY"
        },
        pyquil: {
          name: "yy",
          params: ["theta"],
          array: "[ [quil_cos(p_theta), 0, 0, 1j*quil_sin(p_theta)], [0, quil_cos(p_theta), -1j*quil_sin(p_theta), 0], [0, -1j*quil_sin(p_theta), quil_cos(p_theta), 0], [1j*quil_sin(p_theta), 0, 0, quil_cos(p_theta)] ]"
        },
        quest: {
          name: "yy",
          //@TODO add function
          func: "TODO"
        },
        braket: {
          name: "yy",
          params: ["theta"]
        },
        aqasm: {
          matrix: [
            ["cos(theta)", 0, 0, "i*sin(theta)"],
            [0, "cos(theta)", "-i*sin(theta)", 0],
            [0, "-i*sin(theta)", "cos(theta)", 0],
            ["i*sin(theta)", 0, 0, "cos(theta)"]
          ],
          array: "[[np.cos(p_theta), 0, 0, 1j*np.sin(p_theta)], [0, np.cos(p_theta), -1j*np.sin(p_theta), 0], [0, -1j*np.sin(p_theta), np.cos(p_theta), 0], [1j*np.sin(p_theta), 0, 0, np.cos(p_theta)] ]",
          params: ["theta"]
        },
        qasm: {
          name: "ryy"
        },
        qiskit: {
          name: "ryy"
        },
        ionq: {
          name: "yy",
          paramsKey: "phase"
        }
      }
    },
    zz: {
      description: "Parametric 2-qubit rotation about ZZ",
      matrix: [
        ["exp(-i * theta / 2)", 0, 0, 0],
        [0, "exp(i * theta / 2)", 0, 0],
        [0, 0, "exp(i * theta / 2)", 0],
        [0, 0, 0, "exp(-i * theta / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["theta"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "ZZ"
      },
      exportInfo: {
        quil: {
          name: "zz",
          params: ["theta"],
          defgate: `DEFGATE zz(%theta):
    EXP(-i * %theta / 2), 0, 0, 0
    0, EXP(i * %theta / 2), 0, 0
    0, 0, EXP(i * %theta / 2), 0
    0, 0, 0, EXP(-i * %theta / 2)`
        },
        pyquil: {
          name: "zz",
          params: ["theta"],
          array: "[ [ quil_exp(-1j * p_theta / 2), 0, 0, 0 ], [ 0, quil_exp(1j * p_theta / 2), 0, 0], [ 0, 0, quil_exp(1j * p_theta / 2), 0 ], [ 0, 0, 0, quil_exp(-1j * p_theta / 2) ] ]"
        },
        qasm: {
          name: "rzz"
        },
        qiskit: {
          name: "rzz"
        },
        ionq: {
          name: "zz",
          paramsKey: "phase"
        }
      }
    },
    xy: {
      description: "XY gate",
      matrix: [
        [1, 0, 0, 0],
        [0, "cos(phi / 2)", "i * sin(phi / 2)", 0],
        [0, "i * sin(phi / 2)", "cos(phi / 2)", 0],
        [0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["phi"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "XY"
      },
      exportInfo: {
        quil: {
          name: "XY",
          params: ["phi"]
        },
        qasm: {
          equivalent: [
            { name: "rz", params: { phi: "3*pi/4" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "-3*pi/4" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "phi/2" }, wires: [0] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "phi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/4" }, wires: [0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "3*pi/4" }, wires: [1] }
          ]
        },
        qiskit: {
          equivalent: [
            { name: "rz", params: { phi: "3*pi/4" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "-3*pi/4" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "phi/2" }, wires: [0] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "phi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "cz", wires: [1, 0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [0] },
            { name: "rx", params: { theta: "pi/2" }, wires: [0] },
            { name: "rz", params: { phi: "pi/4" }, wires: [0] },
            { name: "rz", params: { phi: "-1*pi/2" }, wires: [1] },
            { name: "rx", params: { theta: "-1*pi/2" }, wires: [1] },
            { name: "rz", params: { phi: "3*pi/4" }, wires: [1] }
          ]
        },
        cirq: {
          name: "xy",
          params: ["phi"],
          array: "[[1, 0, 0, 0], [0, np.cos(p_phi/2), 1j*np.sin(p_phi/2), 0], [0, 1j*np.sin(p_phi/2), np.cos(p_phi/2), 0], [0, 0, 0, 1]]",
          notTfqSupported: !0
        },
        braket: {
          name: "xy",
          params: ["phi"]
        },
        aqasm: {
          matrix: [
            [1, 0, 0, 0],
            [0, "cos(phi / 2)", "i * sin(phi / 2)", 0],
            [0, "i * sin(phi / 2)", "cos(phi / 2)", 0],
            [0, 0, 0, 1]
          ],
          array: "[[1, 0, 0, 0], [0, np.cos(p_phi/2), 1j*np.sin(p_phi/2), 0], [0, 1j*np.sin(p_phi/2), np.cos(p_phi/2), 0], [0, 0, 0, 1]]",
          params: ["phi"]
        }
      }
    },
    ms: {
      description: "Mølmer-Sørensen gate",
      matrix: [
        ["1/sqrt(2)", 0, 0, "(-i*exp(-i*(phi0+phi1)))/sqrt(2)"],
        [0, "1/sqrt(2)", "(-i*exp(-i*(phi0-phi1)))/sqrt(2)", 0],
        [0, "(-i*exp(i*(phi0-phi1)))/sqrt(2)", "1/sqrt(2)", 0],
        ["(-i*exp(i*(phi0+phi1)))/sqrt(2)", 0, 0, "1/sqrt(2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["phi0", "phi1"],
      drawingInfo: {
        connectors: ["box", "box"],
        label: "MS"
      },
      exportInfo: {
        quil: {
          name: "ms",
          params: ["phi0", "phi1"],
          defgate: `DEFGATE ms(%phi0, %phi1):
    1/SQRT(2), 0, 0, (-i*EXP(-i*(%phi0+%phi1)))/SQRT(2)
    0, 1/SQRT(2), (-i*EXP(-i*(%phi0-%phi1)))/SQRT(2), 0
    0, (-i*EXP(i*(%phi0-%phi1)))/SQRT(2), 1/SQRT(2), 0
    (-i*EXP(i*(%phi0+%phi1)))/SQRT(2), 0, 0, 1/SQRT(2)`
        },
        pyquil: {
          name: "ms",
          params: ["phi0", "phi1"],
          array: "[ [ 1/quil_sqrt(2), 0, 0, (-1j*quil_exp(-1j*(p_phi0+p_phi1)))/quil_sqrt(2) ], [ 0, 1/quil_sqrt(2), (-1j*quil_exp(-1j*(p_phi0-p_phi1)))/quil_sqrt(2), 0 ], [ 0, (-1j*quil_exp(1j*(p_phi0-p_phi1)))/quil_sqrt(2), 1/quil_sqrt(2), 0 ], [ (-1j*quil_exp(1j*(p_phi0+p_phi1)))/quil_sqrt(2), 0, 0, 1/quil_sqrt(2) ] ]"
        },
        cirq: {
          name: "ms"
        },
        quest: {
          name: "ms",
          //@TODO add function
          func: "TODO"
        },
        qasm: {
          name: "ms"
        },
        qiskit: {
          name: "ms"
        },
        braket: {
          name: "unitary",
          params: ["phi0", "phi1"],
          array: "[ [ 1/np.sqrt(2), 0, 0, (-1j*np.exp(-1j*(p_phi0+p_phi1)))/np.sqrt(2) ], [ 0, 1/np.sqrt(2), (-1j*np.exp(-1j*(p_phi0-p_phi1)))/np.sqrt(2), 0 ], [ 0, (-1j*np.exp(1j*(p_phi0-p_phi1)))/np.sqrt(2), 1/np.sqrt(2), 0 ], [ (-1j*np.exp(1j*(p_phi0+p_phi1)))/np.sqrt(2), 0, 0, 1/np.sqrt(2) ] ]"
        },
        aqasm: {
          matrix: [
            ["1/sqrt(2)", 0, 0, "(-1i*exp(-1i*(phi0+phi1)))/sqrt(2)"],
            [0, "1/sqrt(2)", "(-1i*exp(-1i*(phi0-phi1)))/sqrt(2)", 0],
            [0, "(-1i*exp(1i*(phi0-phi1)))/sqrt(2)", "1/sqrt(2)", 0],
            ["(-1i*exp(1i*(phi0+phi1)))/sqrt(2)", 0, 0, "1/sqrt(2)"]
          ],
          array: "[ [ 1/np.sqrt(2), 0, 0, (-1j*np.exp(-1j*(p_phi0+p_phi1)))/np.sqrt(2) ], [ 0, 1/np.sqrt(2), (-1j*np.exp(-1j*(p_phi0-p_phi1)))/np.sqrt(2), 0 ], [ 0, (-1j*np.exp(1j*(p_phi0-p_phi1)))/np.sqrt(2), 1/np.sqrt(2), 0 ], [ (-1j*np.exp(1j*(p_phi0+p_phi1)))/np.sqrt(2), 0, 0, 1/np.sqrt(2) ] ]",
          params: ["phi0", "phi1"]
        },
        ionq: {
          name: "ms",
          paramsKey: "phases"
        }
      }
    },
    cr2: {
      description: "Controlled PI/2 rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Z&#x1D6D1;/2",
        root: "r2"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        qasm: {
          replacement: [{ name: "cu1", params: { lambda: "pi/2" } }]
        },
        qiskit: {
          replacement: [{ name: "cu1", params: { lambda: "pi/2" } }]
        },
        quirk: {
          name: "Z^½",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 2)] ]"
        },
        aqasm: {
          name: "S",
          controlled: !0
        }
      }
    },
    cr4: {
      description: "Controlled PI/4 rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 4)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Z&#x1D6D1;/4",
        root: "r4"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        qasm: {
          replacement: [{ name: "cu1", params: { lambda: "pi/4" } }]
        },
        qiskit: {
          replacement: [{ name: "cu1", params: { lambda: "pi/4" } }]
        },
        quirk: {
          name: "Z^¼",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 4)] ]"
        },
        aqasm: {
          name: "T",
          controlled: !0
        }
      }
    },
    cr8: {
      description: "Controlled PI/8 rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 8)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "Z&#x1D6D1;/8",
        root: "r8"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/8" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/8"
            }
          }
        },
        qasm: {
          replacement: [{ name: "cu1", params: { lambda: "pi/8" } }]
        },
        qiskit: {
          replacement: [{ name: "cu1", params: { lambda: "pi/8" } }]
        },
        quirk: {
          name: "Z^⅛",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 8)] ]"
        },
        aqasm: {
          matrix: [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, "exp(i * pi / 8)"]
          ],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * np.pi / 8)] ]"
        }
      }
    },
    crx: {
      description: "Controlled rotation around the X-axis by given angle",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(theta / 2)", "-i * sin(theta / 2)"],
        [0, 0, "-i * sin(theta / 2)", "cos(theta / 2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["theta"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "RX",
        root: "rx"
      },
      exportInfo: {
        quil: {
          name: "crx",
          params: ["theta"],
          defgate: `DEFGATE crx(%theta):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%theta/2), -i*SIN(%theta/2)
    0, 0, -i*SIN(%theta/2), COS(%theta/2)`
        },
        cirq: {
          replacement: {
            name: "rx",
            params: { theta: "theta" },
            type: "controlled",
            notTfqSupported: !0
          }
        },
        pyquil: {
          name: "crx",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, quil_cos(p_theta / 2), -1j*quil_sin(p_theta / 2) ], [ 0, 0, -1j*quil_sin(p_theta / 2), quil_cos(p_theta / 2) ]]"
        },
        quest: {
          name: "controlledUnitary",
          params: ["theta"],
          matrix: [
            [
              ["cos(theta/2)", "0"],
              ["0", "-sin(theta/2)"]
            ],
            [
              ["0", "-sin(theta/2)"],
              ["cos(theta/2)", "0"]
            ]
          ]
        },
        qsharp: {
          name: "Controlled Rx",
          params: ["theta"]
        },
        qasm: {
          replacement: [
            {
              name: "cu3",
              params: { theta: "theta", phi: "-1*pi/2", lambda: "pi/2" }
            }
          ]
        },
        qiskit: {
          replacement: [
            {
              name: "cu3",
              params: { theta: "theta", phi: "-1*pi/2", lambda: "pi/2" }
            }
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, np.cos(p_theta / 2), -1j*np.sin(p_theta / 2) ], [ 0, 0, -1j*np.sin(p_theta / 2), np.cos(p_theta / 2) ]]"
        },
        aqasm: {
          name: "RX",
          controlled: !0
        }
      }
    },
    cry: {
      description: "Controlled rotation around the Y-axis by given angle",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(theta / 2)", "-1 * sin(theta / 2)"],
        [0, 0, "sin(theta / 2)", "cos(theta / 2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["theta"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "RY",
        root: "ry"
      },
      exportInfo: {
        quil: {
          name: "cry",
          params: ["theta"],
          defgate: `DEFGATE cry(%theta):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%theta/2), -1*SIN(%theta/2)
    0, 0, SIN(%theta/2), COS(%theta/2)`
        },
        cirq: {
          replacement: {
            name: "ry",
            params: { theta: "theta" },
            type: "controlled",
            notTfqSupported: !0
          }
        },
        pyquil: {
          name: "cry",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ],[ 0, 1, 0, 0 ],[ 0, 0, quil_cos(p_theta / 2), -1*quil_sin(p_theta / 2) ],[ 0, 0, quil_sin(p_theta / 2), quil_cos(p_theta / 2) ]]"
        },
        quest: {
          name: "controlledUnitary",
          params: ["theta"],
          matrix: [
            [
              ["cos(theta/2)", "0"],
              ["-sin(theta/2)", "0"]
            ],
            [
              ["sin(theta/2)", "0"],
              ["cos(theta/2)", "0"]
            ]
          ]
        },
        qsharp: {
          name: "Controlled Ry",
          params: ["theta"]
        },
        qasm: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "theta/2", phi: "0", lambda: "0" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "-1*theta / 2", phi: "0", lambda: "0" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] }
          ]
        },
        qiskit: {
          equivalent: [
            {
              name: "u3",
              params: { theta: "theta/2", phi: "0", lambda: "0" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] },
            {
              name: "u3",
              params: { theta: "-1*theta / 2", phi: "0", lambda: "0" },
              wires: [1]
            },
            { name: "cx", wires: [0, 1] }
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta"],
          array: "[[ 1, 0, 0, 0 ],[ 0, 1, 0, 0 ],[ 0, 0, np.cos(p_theta / 2), -1*np.sin(p_theta / 2) ],[ 0, 0, np.sin(p_theta / 2), np.cos(p_theta / 2) ]]"
        },
        aqasm: {
          name: "RY",
          controlled: !0
        }
      }
    },
    crz: {
      description: "Controlled rotation around the Z-axis by given angle",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(phi / 2) - i * sin(phi / 2)", 0],
        [0, 0, 0, "cos(phi / 2) + i * sin(phi / 2)"]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["phi"],
      drawingInfo: {
        connectors: ["dot", "dot"],
        label: "RZ",
        root: "rz"
      },
      exportInfo: {
        quil: {
          name: "crz",
          params: ["phi"],
          defgate: `DEFGATE crz(%phi):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%phi / 2) - i * SIN(%phi / 2), 0
    0, 0, 0, COS(%phi / 2) + i * SIN(%phi / 2)`
        },
        pyquil: {
          name: "crz",
          params: ["phi"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, quil_cos(p_phi / 2) - 1j * quil_sin(p_phi / 2), 0], [0, 0, 0, quil_cos(p_phi / 2) + 1j * quil_sin(p_phi / 2)]]"
        },
        cirq: {
          replacement: {
            name: "rz",
            params: { phi: "phi" },
            type: "controlled"
          }
        },
        quest: {
          name: "controlledRotateZ",
          params: ["theta"]
        },
        qsharp: {
          name: "Controlled Rz",
          params: ["phi"]
        },
        braket: {
          name: "unitary",
          params: ["phi"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, np.cos(p_phi / 2) - 1j * np.sin(p_phi / 2), 0], [0, 0, 0, np.cos(p_phi / 2) + 1j * np.sin(p_phi / 2)]]"
        },
        aqasm: {
          name: "RZ",
          controlled: !0
        }
      }
    },
    cu1: {
      description: "Controlled rotation about the Z axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * lambda)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: ["lambda"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "CU1",
        root: "u1"
      },
      exportInfo: {
        quil: {
          name: "CPHASE",
          params: ["lambda"]
        },
        cirq: {
          name: "cu1",
          params: ["lambda"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j*p_lambda)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "controlledPhaseShift",
          params: ["theta"]
        },
        braket: {
          name: "unitary",
          params: ["lambda"],
          array: "[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j*p_lambda)]]"
        },
        aqasm: {
          name: "PH",
          controlled: !0
        },
        qiskit: {
          name: "cp"
        }
      }
    },
    cu2: {
      description: "Controlled rotation about the X+Z axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"],
        [
          0,
          0,
          "exp(i * phi) * 1 / sqrt(2)",
          "exp(i * lambda + i * phi) * 1 / sqrt(2)"
        ]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["phi", "lambda"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "CU2",
        root: "u2"
      },
      exportInfo: {
        quil: {
          name: "cu2",
          params: ["phi", "lambda"],
          defgate: `DEFGATE cu2(%phi, %lambda):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, 1/SQRT(2), -1*EXP(i*%lambda)*1/SQRT(2)
    0, 0, EXP(i*%phi)*1/SQRT(2), EXP(i*%lambda + i*%phi)*1/SQRT(2)`
        },
        pyquil: {
          name: "cu2",
          params: ["phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/quil_sqrt(2), -quil_exp(1j*p_lambda)*1/quil_sqrt(2)],[0, 0, quil_exp(1j*p_phi)*1/quil_sqrt(2), quil_exp(1j*p_lambda+1j*p_phi)*1/quil_sqrt(2)]]"
        },
        cirq: {
          name: "cu2",
          params: ["phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)],[0, 0, np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "controlledUnitary",
          params: ["phi", "lambda"],
          matrix: [
            [
              ["1/sqrt(2)", "0"],
              ["-cos(lambda)/sqrt(2)", "-sin(lambda)/sqrt(2)"]
            ],
            [
              ["cos(phi)/sqrt(2)", "sin(phi)/sqrt(2)"],
              ["cos(lambda+phi)/sqrt(2)", "sin(lambda+phi)/sqrt(2)"]
            ]
          ]
        },
        qasm: {
          replacement: [
            {
              name: "cu3",
              params: { theta: "pi/2", phi: "phi", lambda: "lambda" }
            }
          ]
        },
        qiskit: {
          replacement: [
            {
              name: "cu3",
              params: { theta: "pi/2", phi: "phi", lambda: "lambda" }
            }
          ]
        },
        braket: {
          name: "unitary",
          params: ["phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)],[0, 0, np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]"
        },
        aqasm: {
          matrix: [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, "1 / sqrt(2)", "-exp(i * lambda) * 1 / sqrt(2)"],
            [
              0,
              0,
              "exp(i * phi) * 1 / sqrt(2)",
              "exp(i * lambda + i * phi) * 1 / sqrt(2)"
            ]
          ],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1/np.sqrt(2), -np.exp(1j*p_lambda)*1/np.sqrt(2)],[0, 0, np.exp(1j*p_phi)*1/np.sqrt(2), np.exp(1j*p_lambda+1j*p_phi)*1/np.sqrt(2)]]",
          params: ["phi", "lambda"]
        }
      }
    },
    cu3: {
      description: "Controlled rotation gate with 3 Euler angles",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, "cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"],
        [
          0,
          0,
          "exp(i * phi) * sin(theta / 2)",
          "exp(i * lambda + i * phi) * cos(theta / 2)"
        ]
      ],
      numTargetQubits: 1,
      numControlQubits: 1,
      params: ["theta", "phi", "lambda"],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "CU3",
        root: "u3"
      },
      exportInfo: {
        quil: {
          name: "cu3",
          params: ["theta", "phi", "lambda"],
          defgate: `DEFGATE cu3(%theta, %phi, %lambda):
    1, 0, 0, 0
    0, 1, 0, 0
    0, 0, COS(%theta/2), -1*EXP(i*%lambda)*SIN(%theta/2)
    0, 0, EXP(i*%phi)*SIN(%theta/2), EXP(i*%lambda + i*%phi)*COS(%theta/2)`
        },
        pyquil: {
          name: "cu3",
          params: ["theta", "phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, quil_cos(p_theta/2),-quil_exp(1j*p_lambda)*quil_sin(p_theta/2)],[0, 0, quil_exp(1j*p_phi)*quil_sin(p_theta/2),quil_exp(1j*p_lambda+1j*p_phi)*quil_cos(p_theta/2)]]"
        },
        cirq: {
          name: "cu3",
          params: ["theta", "phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, np.cos(p_theta/2),-np.exp(1j*p_lambda)*np.sin(p_theta/2)],[0, 0, np.exp(1j*p_phi)*np.sin(p_theta/2),np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          notTfqSupported: !0
        },
        quest: {
          name: "controlledUnitary",
          params: ["theta", "phi", "lambda"],
          matrix: [
            [
              ["cos(theta/2)", "0"],
              ["-cos(lambda)*sin(theta/2)", "-sin(lambda)*sin(theta/2)"]
            ],
            [
              ["cos(phi)*sin(theta/2)", "sin(phi)*sin(theta/2)"],
              ["cos(lambda+phi)*cos(theta/2)", "sin(lambda+phi)*cos(theta/2)"]
            ]
          ]
        },
        braket: {
          name: "unitary",
          params: ["theta", "phi", "lambda"],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, np.cos(p_theta/2),-np.exp(1j*p_lambda)*np.sin(p_theta/2)],[0, 0, np.exp(1j*p_phi)*np.sin(p_theta/2),np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]"
        },
        aqasm: {
          matrix: [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, "cos(theta/2)", "-exp(i * lambda) * sin(theta / 2)"],
            [
              0,
              0,
              "exp(i * phi) * sin(theta / 2)",
              "exp(i * lambda + i * phi) * cos(theta / 2)"
            ]
          ],
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, np.cos(p_theta/2),-np.exp(1j*p_lambda)*np.sin(p_theta/2)],[0, 0, np.exp(1j*p_phi)*np.sin(p_theta/2),np.exp(1j*p_lambda+1j*p_phi)*np.cos(p_theta/2)]]",
          params: ["theta", "phi", "lambda"]
        },
        qiskit: {
          name: "cu"
        }
      }
    },
    cs: {
      description: "Controlled PI/2 rotation over Z-axis (synonym for `cr2`)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "S",
        root: "s"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/2"
            }
          }
        },
        qasm: {
          replacement: [{ name: "cu1", params: { lambda: "pi/2" } }]
        },
        qiskit: {
          replacement: [{ name: "cu1", params: { lambda: "pi/2" } }]
        },
        quirk: {
          name: "Z^½",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(1j * np.pi / 2)]]"
        },
        aqasm: {
          name: "S",
          controlled: !0
        }
      }
    },
    ct: {
      description: "Controlled PI/4 rotation over Z-axis (synonym for `cr4`)",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(i * pi / 4)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "T",
        root: "t"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "pi/4"
            }
          }
        },
        qasm: {
          replacement: [{ name: "cu1", params: { lambda: "pi/4" } }]
        },
        qiskit: {
          replacement: [{ name: "cu1", params: { lambda: "pi/4" } }]
        },
        quirk: {
          name: "Z^¼",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(1j * np.pi / 4)]]"
        },
        aqasm: {
          name: "T",
          controlled: !0
        }
      }
    },
    csdg: {
      description: "Controlled (-PI/2) rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(-i * pi / 2)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "S&#8224;",
        root: "sdg"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "-M_PI/2" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/2"
            }
          }
        },
        qasm: {
          replacement: [{ name: "cu1", params: { lambda: "-1*pi/2" } }]
        },
        qiskit: {
          replacement: [{ name: "cu1", params: { lambda: "-1*pi/2" } }]
        },
        quirk: {
          name: "Z^-½",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(-1j * np.pi / 2)]]"
        },
        aqasm: {
          name: "S",
          controlled: !0,
          dagger: !0
        }
      }
    },
    ctdg: {
      description: "Controlled (-PI/4) rotation over Z-axis",
      matrix: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, "exp(-i * pi / 4)"]
      ],
      numTargetQubits: 2,
      numControlQubits: 0,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box"],
        label: "T&#8224;",
        root: "tdg"
      },
      exportInfo: {
        quil: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        cirq: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        quest: {
          name: "controlledPhaseShift",
          params: { theta: "-M_PI/4" }
        },
        qsharp: {
          replacement: {
            name: "cu1",
            params: {
              lambda: "-pi/4"
            }
          }
        },
        qasm: {
          replacement: [{ name: "cu1", params: { lambda: "-1*pi/4" } }]
        },
        qiskit: {
          replacement: [{ name: "cu1", params: { lambda: "-1*pi/4" } }]
        },
        quirk: {
          name: "Z^-¼",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0],[0,1,0,0],[0, 0, 1, 0],[0, 0, 0, np.exp(-1j * np.pi / 4)]]"
        },
        aqasm: {
          name: "T",
          controlled: !0,
          dagger: !0
        }
      }
    },
    ccx: {
      description: 'Toffoli aka "CCNOT" gate',
      matrix: [
        [1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 0, 0, 1, 0]
      ],
      numTargetQubits: 1,
      numControlQubits: 2,
      params: [],
      drawingInfo: {
        connectors: ["dot", "dot", "not"],
        label: "CCNOT",
        root: "x"
      },
      exportInfo: {
        quil: {
          name: "CCNOT"
        },
        cirq: {
          name: "CCX",
          notTfqSupported: !0
        },
        quest: {
          name: "ccx",
          func: `void ccx(Qureg qubits, const int q1, const int q2, const int q3) {
    hadamard(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q2);
    tGate(qubits, q3);
    controlledNot(qubits, q1, q2);
    hadamard(qubits, q3);
    tGate(qubits, q1);
    phaseShift(qubits, q2, -M_PI/4);
    controlledNot(qubits, q1, q2);
}`
        },
        qsharp: {
          name: "CCNOT"
        },
        quirk: {
          name: "X",
          controlled: !0
        },
        braket: {
          name: "ccnot"
        },
        aqasm: {
          name: "CCNOT"
        }
      }
    },
    cswap: {
      description: 'Controlled swap aka "Fredkin" gate',
      matrix: [
        [1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "x", "x"],
        label: "SWP",
        root: "swap"
      },
      exportInfo: {
        cirq: {
          name: "CSWAP"
        },
        quest: {
          name: "cswap",
          func: `void cswap(Qureg qubits, const int q1, const int q2, const int q3) {
    controlledNot(qubits, q3, q2);
    hadamard(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q3);
    controlledNot(qubits, q2, q3);
    phaseShift(qubits, q3, -M_PI/4);
    controlledNot(qubits, q1, q3);
    tGate(qubits, q2);
    tGate(qubits, q3);
    hadamard(qubits, q3);
    controlledNot(qubits, q1, q2);
    tGate(qubits, q1);
    phaseShift(qubits, q2, -M_PI/4);
    controlledNot(qubits, q2, q3);
    controlledNot(qubits, q3, q2);
}`
        },
        qsharp: {
          name: "Controlled SWAP"
        },
        quil: {
          name: "CSWAP"
        },
        pyquil: {
          name: "CSWAP"
        },
        quirk: {
          name: "Swap",
          controlled: !0
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0], [0,0,1,0,0,0,0,0], [0,0,0,1,0,0,0,0], [0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0], [0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1]]"
        },
        aqasm: {
          name: "SWAP",
          controlled: !0
        }
      }
    },
    csrswap: {
      description: "Controlled square root of swap",
      matrix: [
        [1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, "0.5 * (1 + i)", "0.5 * (1 - i)", 0],
        [0, 0, 0, 0, 0, "0.5 * (1 - i)", "0.5 * (1 + i)", 0],
        [0, 0, 0, 0, 0, 0, 0, 1]
      ],
      numTargetQubits: 2,
      numControlQubits: 1,
      params: [],
      drawingInfo: {
        connectors: ["dot", "box", "box"],
        label: "&#x221A;SWP",
        root: "srswap"
      },
      exportInfo: {
        quest: {
          name: "csrswap",
          //@TODO add function
          func: "TODO"
        },
        cirq: {
          replacement: {
            name: "srswap",
            type: "controlled",
            notTfqSupported: !0
          }
        },
        quil: {
          name: "csrswap",
          defgate: `DEFGATE csrswap:
    1, 0, 0, 0, 0, 0, 0, 0
    0, 1, 0, 0, 0, 0, 0, 0
    0, 0, 1, 0, 0, 0, 0, 0
    0, 0, 0, 1, 0, 0, 0, 0
    0, 0, 0, 0, 1, 0, 0, 0
    0, 0, 0, 0, 0, 0.5+0.5i, 0.5-0.5i, 0
    0, 0, 0, 0, 0, 0.5-0.5i, 0.5+0.5i, 0
    0, 0, 0, 0, 0, 0, 0, 1`
        },
        pyquil: {
          name: "csrswap",
          array: "[[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0,0,0,0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,0,0,0,0,1]]"
        },
        braket: {
          name: "unitary",
          array: "[[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0.5 * (1 + 1j),0.5 * (1 - 1j),0],[0,0,0,0,0,0.5 * (1 - 1j),0.5 * (1 + 1j),0],[0,0,0,0,0,0,0,1]]"
        },
        aqasm: {
          name: "SQRTSWAP",
          controlled: !0
        }
      }
    },
    reset: {
      description: "Resets qubit",
      matrix: [],
      params: [],
      drawingInfo: {
        connectors: ["box"],
        label: "RST"
      },
      exportInfo: {
        quil: {
          name: "RESET"
        },
        cirq: {
          name: "reset",
          notTfqSupported: !0
        },
        quest: {
          name: "reset",
          //@TODO add function
          func: "TODO"
        },
        qsharp: {
          name: "Reset"
        }
      }
    },
    measure: {
      description: "Measures qubit and stores chance (0 or 1) into classical bit",
      matrix: [],
      params: [],
      drawingInfo: {
        connectors: ["gauge"],
        label: ""
      },
      exportInfo: {
        quil: {
          name: "MEASURE"
        },
        cirq: {
          name: "measure"
        },
        quest: {
          name: "measure"
        },
        qsharp: {
          name: "M"
        }
      }
    }
  }, this.init(e);
};
me.prototype.defaultHybridOptions = function() {
  return {
    optimizer: "Powell",
    tolerance: 1e-3,
    costFunction: {
      python: "",
      javascript: ""
    }
  };
};
me.prototype.init = function(t, e) {
  e = e || {}, this.numQubits = t || 1, this.gates = [], this.partitionMap = [], this.partitionCount = 0, this.partitionInfo = {}, this.params = [], this.options = {
    params: {},
    hybrid: !1,
    hybridOptions: this.defaultHybridOptions()
  }, e.keepCustomGates || (this.customGates = {}), this.cregs = {}, this.collapsed = [], this.prob = [], this.measureResetsQubit = !1, this.reverseBitOrder = !1, this.clear();
};
me.prototype.clearGates = function() {
  this.gates = [];
  for (let t = 0; t < this.numQubits; t++)
    this.gates.push([]);
};
me.prototype.clear = function() {
  this.clearGates(), this.initState();
};
me.prototype.resetState = function() {
  this.state = {}, this.stateBits = 0, this.partitionCache = {};
  for (let t in this.cregs) {
    const e = this.cregs[t].length || 0;
    this.cregs[t] = [];
    for (let r = 0; r < e; r++)
      this.cregs[t].push(0);
  }
  this.collapsed = [], this.prob = [], this.stats = {
    duration: 0
  };
};
me.prototype.initState = function() {
  this.resetState(), this.state[0] = zt(1, 0);
};
me.prototype.formatComplex = function(t, e) {
  return bs(t.re, t.im, e);
};
me.prototype.multiplySquareMatrices = function(t, e) {
  const r = t.length;
  let n = r, i = r, a = r;
  const o = [];
  for (; n--; )
    for (o[n] = [], i = r; i--; )
      for (o[n][i] = 0, a = r; a--; )
        t[n][a] && e[a][i] && (o[n][i] ? o[n][i] = rt(o[n][i], Xe(t[n][a], e[a][i])) : o[n][i] = Xe(t[n][a], e[a][i]));
  return o;
};
me.prototype.isIdentityMatrix = function(t, e) {
  typeof e > "u" && (e = 14);
  for (let r = 0; r < t.length; r++)
    for (let n = 0; n < t.length; n++)
      if (qt(t[r][n], e) != (r === n ? 1 : 0))
        return !1;
  return !0;
};
me.prototype.isUnitaryMatrix = function(t, e) {
  return this.isIdentityMatrix(Xe(t, Ya(t)), e);
};
me.prototype.isHermitianMatrix = function(t, e) {
  return this.matrixDiff(t, Ya(t)) <= Dt(10, -1 * (e || 14));
};
me.prototype.matrixDiff = function(t, e) {
  let r = 0, n = 0;
  for (let i = 0; i < t.length; i++) {
    const a = t[i], o = e[i];
    for (let f = 0; f < a.length; f++) {
      const u = a[f], s = o[f], c = typeof u == "object" ? u : zt(u), l = typeof s == "object" ? s : zt(s), m = It(Qt(c, l));
      r += m, n++;
    }
  }
  return n ? r / n : 0;
};
me.prototype.parseMathString = function(t) {
  const e = [], r = function(a) {
    if (a.isSymbolNode) {
      if (a.name === "j")
        return "i";
      e.indexOf(a.name) < 0 && e.push(a.name);
    }
  }, n = xt(t.replace(/[\t\n\r]/gm, ""));
  return {
    expression: n.toString({ handler: r }),
    variables: e,
    node: n
  };
};
me.prototype.evalMathString = function(t, e) {
  e = e || {};
  const r = this.parseMathString(t), n = Nr(r.expression, e);
  return n instanceof Qa ? n.toArray() : n;
};
me.prototype.parseMatrix = function(t, e) {
  const r = this;
  let n;
  typeof t == "string" ? n = r.evalMathString(t, e) : n = t;
  const i = [];
  return n.map(function(a, o) {
    Array.isArray(a) ? (i.push([]), a.map(function(f) {
      typeof f == "string" ? i[o].push(r.evalMathString(f, e)) : i[o].push(f);
    })) : typeof a == "string" ? i.push(r.evalMathString(a, e)) : i.push(a);
  }), i;
};
me.prototype.matrixHasComplexElement = function(t) {
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (r instanceof Array)
      for (let n = 0; n < r.length; n++) {
        const i = r[n];
        if (i instanceof At || typeof i == "object" && (i.mathjs && i.mathjs === "Complex" || i.type && i.type === "Complex"))
          return !0;
      }
    else if (r instanceof At || typeof r == "object" && (r.mathjs && r.mathjs === "Complex" || r.type && r.type === "Complex"))
      return !0;
  }
  return !1;
};
me.prototype.matrixZeroImagToReal = function(t) {
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (r instanceof Array)
      for (let n = 0; n < r.length; n++) {
        const i = r[n];
        (i instanceof At || typeof i == "object" && (i.mathjs && i.mathjs === "Complex" || i.type && i.type === "Complex")) && ji(i) === 0 && (t[e][n] = Yi(i));
      }
    else
      (r instanceof At || typeof r == "object" && (r.mathjs && r.mathjs === "Complex" || r.type && r.type === "Complex")) && ji(r) === 0 && (t[e] = Yi(r));
  }
  return t;
};
me.prototype.stringifyMatrix = function(t, e) {
  const r = this, n = t.toArray ? t.toArray() : t;
  e = e || {};
  let i = !1;
  e.fixedWidth && (i = this.matrixHasComplexElement(n));
  let a = "";
  return a += "[", n.map(function(o, f) {
    f > 0 && (a += ","), e.minify ? a += " " : a += `
  `, o instanceof Array ? (a += "[", o.map(function(u, s) {
      s > 0 && (a += ", "), u instanceof At ? a += r.formatComplex(u, e) : typeof u == "object" && (u.mathjs && u.mathjs === "Complex" || u.type && u.type === "Complex") ? a += bs(u.re, u.im, e) : typeof u == "string" ? a += u : i ? a += bs(u, 0, e) : a += du(u, e);
    }), a += "]") : o instanceof At ? a += r.formatComplex(o, e) : typeof o == "object" && (o.mathjs && o.mathjs === "Complex" || o.type && o.type === "Complex") ? a += bs(Yi, ji, e) : typeof o == "string" ? a += o : i ? a += bs(o, 0, e) : a += du(o, e);
  }), n.length && (e.minify ? a += " " : a += `
`), a += "]", a;
};
me.prototype.matrixRe = function(t) {
  const e = [], r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (Array.isArray(i)) {
      for (let a = 0; a < i.length; a++)
        typeof i[a] == "object" ? e.push(i[a].re) : e.push(i[a]);
      r.push(e);
    } else
      typeof i == "object" ? e.push(i.re) : e.push(i);
  }
  return r;
};
me.prototype.matrixIm = function(t) {
  const e = [], r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (Array.isArray(i)) {
      for (let a = 0; a < i.length; a++)
        typeof i[a] == "object" ? e.push(i[a].im) : e.push(0);
      r.push(e);
    } else
      typeof i == "object" ? e.push(i.im) : e.push(0);
  }
  return r;
};
me.prototype.matrixAbs = function(t) {
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (Array.isArray(n)) {
      const i = [];
      for (let a = 0; a < n.length; a++)
        i.push(It(n[a]));
      e.push(i);
    } else
      e.push(It(n));
  }
  return e;
};
me.prototype.matrixArg = function(t) {
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (Array.isArray(n)) {
      const i = [];
      for (let a = 0; a < n.length; a++)
        i.push(Cs(n[a]));
      e.push(i);
    } else
      e.push(Cs(n));
  }
  return e;
};
me.prototype.setCombinedState = function(t) {
  let e, r, n;
  const i = {};
  let a = 0, o = 0;
  for (e = 0; e < t.length; e++)
    n = t[e], n.wires.map(function(s) {
      s + 1 > o && (o = s + 1);
    });
  const f = [];
  for (e = 0; e < t.length; e++) {
    n = t[e];
    const s = [];
    n.wires.map(function(c, l) {
      s.push({
        and: 1 << o - 1 - c,
        or: 1 << n.circuit.numQubits - 1 - l
      });
    }), f.push(s);
  }
  const u = 1 << o;
  for (let s = 0; s < u; s++) {
    let c = null;
    for (e = 0; e < t.length; e++) {
      const l = f[e];
      let m = 0;
      for (r = 0; r < l.length; r++)
        s & l[r].and && (m |= l[r].or);
      n = t[e];
      const h = n.circuit.state[m];
      h ? c == null ? c = h : c = Xe(h, c) : c = zt(0, 0);
    }
    c && (c.re || c.im) && (i[s] = c, a |= s);
  }
  if (this.resetState(), this.numQubits < o) {
    for (this.numQubits = o; this.gates.length < this.numQubits; )
      this.gates.push([]);
    const s = this.numCols();
    for (r = 0; r < this.gates.length; r++)
      for (; this.gates[r].length < s; )
        this.gates[r].push(null);
  }
  this.state = i, this.stateBits = a, this.stateBits === 0 && Object.keys(this.state).length === 0 && (this.state[0] = zt(1, 0));
};
me.prototype._setCombinedState = function(t, e, r) {
  let n;
  r = r || {};
  const i = t.numQubits, a = e.numQubits;
  if (!r.wireMap) {
    for (r.wireMap = {
      c1: [],
      c2: []
    }, n = 0; n < i; n++)
      r.wireMap.c1.push(n);
    for (n = 0; n < a; n++)
      r.wireMap.c2.push(n + i);
  }
  let o = 0;
  r.wireMap.c1.map(function(h) {
    h + 1 > o && (o = h + 1);
  }), r.wireMap.c2.map(function(h) {
    h + 1 > o && (o = h + 1);
  });
  const f = [];
  r.wireMap.c1.map(function(h, g) {
    f.push({ and: 1 << o - 1 - h, or: 1 << i - 1 - g });
  });
  const u = [];
  r.wireMap.c2.map(function(h, g) {
    u.push({ and: 1 << o - 1 - h, or: 1 << a - 1 - g });
  });
  let s = 0;
  for (n = 0; n < o; n++)
    r.wireMap.c1.indexOf(n) < 0 && r.wireMap.c2.indexOf(n) < 0 && (s |= 1 << o - 1 - n);
  const c = {};
  let l = 0;
  const m = 1 << o;
  for (let h = 0; h < m; h++)
    if (!(h & s)) {
      let g = 0;
      for (n = 0; n < f.length; n++)
        h & f[n].and && (g |= f[n].or);
      let d = 0;
      for (n = 0; n < u.length; n++)
        h & u[n].and && (d |= u[n].or);
      const y = t.state[g];
      if (y) {
        const w = e.state[d];
        if (w) {
          const E = Xe(y, w);
          (E.re || E.im) && (c[h] = E, l |= h);
        }
      }
    }
  if (this.resetState(), this.numQubits < o) {
    for (this.numQubits = o; this.gates.length < this.numQubits; )
      this.gates.push([]);
    const h = this.numCols();
    for (n = 0; n < this.gates.length; n++)
      for (; this.gates[n].length < h; )
        this.gates[n].push(null);
  }
  this.state = c, this.stateBits = l, this.stateBits === 0 && Object.keys(this.state).length === 0 && (this.state[0] = zt(1, 0));
};
me.prototype.appendQubits = function(t) {
  const e = new me(t);
  this._setCombinedState(this, e);
};
me.prototype.numAmplitudes = function(t) {
  if (t) {
    let e = 0;
    for (let r in this.state) {
      const n = qt(this.state[r], 14);
      (n.re || n.im) && e++;
    }
    return e;
  }
  return Dt(2, this.numQubits);
};
me.prototype.numCols = function() {
  return this.gates.length ? this.gates[0].length : 0;
};
me.prototype.numGates = function(t) {
  let e;
  t ? (e = new me(), e.load(this.save(!0))) : e = this;
  let r = 0;
  const n = e.numCols();
  for (let i = 0; i < n; i++)
    for (let a = 0; a < e.numQubits; a++) {
      const o = e.getGateAt(i, a);
      o && o.connector === 0 && r++;
    }
  return r;
};
me.prototype.isEmptyCell = function(t, e) {
  if (this.gates[e] && this.gates[e][t])
    return !1;
  for (let r = 0; r < this.numQubits; r++) {
    const n = this.getGateAt(t, r);
    if (n && (n.name === "measure" || n.options && n.options.condition && n.options.condition.creg || Math.min.apply(null, n.wires) < e && Math.max.apply(null, n.wires) > e))
      return !1;
  }
  return !0;
};
me.prototype.isEmptyPlace = function(t, e, r) {
  const n = Math.min.apply(null, e);
  let i = Math.max.apply(null, e);
  if (r) {
    const o = this.numQubits - 1;
    o > i && (i = o);
  }
  let a = !0;
  for (let o = n; o <= i; o++)
    if (!this.isEmptyCell(t, o)) {
      a = !1;
      break;
    }
  return a;
};
me.prototype.lastNonEmptyPlace = function(t, e) {
  let r = this.numCols(), n = !0;
  const i = Math.min.apply(null, t);
  let a = Math.max.apply(null, t);
  if (e) {
    const o = this.numQubits - 1;
    o > a && (a = o);
  }
  for (; n && r--; )
    for (let o = i; o <= a; o++)
      if (!this.isEmptyCell(r, o)) {
        n = !1;
        break;
      }
  return r;
};
me.prototype.insertColumn = function(t) {
  for (let e = 0; e < this.numQubits; e++)
    this.gates[e].splice(t || 0, 0, null);
};
me.prototype.randomString = function(t) {
  t = t || 17;
  let e = "", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  e += r.charAt(Math.floor(Math.random() * r.length)), r += "0123456789";
  for (let n = 0; n < t; n++)
    e += r.charAt(Math.floor(Math.random() * r.length));
  return e;
};
me.prototype.addGate = function(t, e, r, n) {
  let i;
  const a = [];
  if (Array.isArray(r))
    for (i = 0; i < r.length; i++)
      a.push(r[i]);
  else
    a.push(r);
  e < 0 && (e = this.lastNonEmptyPlace(
    a,
    t === "measure" || n && n.condition && n.condition.creg
  ) + 1);
  const o = a.length, f = this.randomString();
  for (let u = 0; u < o; u++) {
    const s = a[u];
    for (s + 1 > this.numQubits && (this.numQubits = s + 1); this.gates.length < this.numQubits; )
      this.gates.push([]);
    let c = this.numCols();
    for (e + 1 > c && (c = e + 1), i = 0; i < this.gates.length; i++)
      for (; this.gates[i].length < c; )
        this.gates[i].push(null);
    const l = {
      id: f,
      name: t,
      connector: u,
      options: {}
    };
    if (n && (l.options = n, n.creg && n.creg.name && typeof n.creg.bit < "u")) {
      let m = parseInt(n.creg.bit || 0);
      isNaN(m) && (m = 0);
      const h = this.cregs[n.creg.name] || [], g = h.length > m ? h[n.creg.bit] : 0;
      this.setCregBit(n.creg.name, m, g);
    }
    this.gates[s][e] = l;
  }
  return f;
};
me.prototype.appendGate = function(t, e, r) {
  return this.addGate(t, -1, e, r);
};
me.prototype.insertGate = function(t, e, r, n) {
  let i;
  const a = [];
  if (Array.isArray(r))
    for (i = 0; i < r.length; i++)
      a.push(r[i]);
  else
    a.push(r);
  e < 0 && (e = this.lastNonEmptyPlace(
    a,
    !!t && t === "measure" || n && n.condition && n.condition.creg
  ) + 1);
  const o = a.length;
  for (let u = 0; u < o; u++) {
    const s = a[u];
    for (s + 1 > this.numQubits && (this.numQubits = s + 1); this.gates.length < this.numQubits; )
      this.gates.push([]);
    let c = this.numCols();
    for (e + 1 > c && (c = e + 1), i = 0; i < this.gates.length; i++)
      for (; this.gates[i].length < c; )
        this.gates[i].push(null);
  }
  this.isEmptyPlace(
    e,
    a,
    !!t && t === "measure" || n && n.condition && n.condition.creg
  ) || this.insertColumn(e);
  let f = null;
  return t && (f = this.addGate(t, e, a, n)), f;
};
me.prototype.insertSpace = function(t, e) {
  return this.insertGate(null, t, e, null);
};
me.prototype.removeGateAt = function(t, e) {
  if (!this.gates[e])
    return;
  const r = this.gates[e][t];
  if (!r)
    return;
  const n = r.id, i = this.gates.length;
  for (let a = 0; a < i; a++) {
    const o = this.gates[a][t];
    o && o.id === n && (this.gates[a][t] = null);
  }
};
me.prototype.removeGate = function(t) {
  const e = this.getGatePosById(t);
  !e || e.col < 0 || !e.wires.length || this.removeGateAt(e.col, e.wires[0]);
};
me.prototype.addMeasure = function(t, e, r) {
  this.addGate("measure", -1, t, { creg: { name: e, bit: r } });
};
me.prototype.appendCircuit = function(t) {
  const e = this.numCols(), r = t.numCols();
  for (let n = 0; n < r; n++)
    for (let i = 0; i < t.numQubits; i++) {
      const a = t.getGateAt(n, i);
      a && a.connector === 0 && (!this.basicGates[a.name] && t.customGates[a.name] && this.registerGate(a.name, t.customGates[a.name]), this.addGate(a.name, n + e, a.wires, a.options));
    }
};
me.prototype.removeTrailingColumns = function() {
  const t = this.numCols();
  for (let e = t - 1; e >= 0; e--) {
    let r, n = !0;
    for (r = 0; r < this.numQubits; r++)
      if (this.gates[r][e]) {
        n = !1;
        break;
      }
    if (!n)
      return;
    for (r = 0; r < this.numQubits; r++)
      this.gates[r].pop();
  }
};
me.prototype.removeLeadingColumns = function() {
  let t = 0;
  const e = this.numCols();
  for (let r = 0; r < e; r++) {
    let n = !0;
    for (let i = 0; i < this.numQubits; i++)
      if (this.gates[i][r]) {
        n = !1;
        break;
      }
    if (!n)
      break;
    t++;
  }
  for (let r = 0; r < t; r++)
    for (let n = 0; n < this.numQubits; n++)
      this.gates[n].shift();
};
me.prototype.removeTrailingRows = function() {
  const t = this.numCols();
  for (let e = this.numQubits - 1; e >= 0; e--) {
    let r = !0;
    for (let n = 0; n < t; n++)
      if (this.gates[e][n]) {
        r = !1;
        break;
      }
    if (!r)
      return;
    this.gates.pop(), this.numQubits--;
  }
};
me.prototype.removeQubit = function(t) {
  let e;
  if (!this.gates[t])
    return;
  this.resetState();
  const r = this.numCols();
  for (e = 0; e < r; e++)
    this.removeGateAt(e, t);
  for (let n = t + 1; n < this.numQubits; n++)
    for (e = 0; e < r; e++)
      this.gates[n - 1][e] = this.gates[n][e];
  this.gates.pop(), this.numQubits--;
};
me.prototype.flipVertically = function() {
  this.resetState();
  const t = this.numCols(), e = this.numQubits - 1;
  for (let r = 0; r < this.numQubits / 2; r++)
    for (let n = 0; n < t; n++) {
      const i = this.gates[r][n];
      this.gates[r][n] = this.gates[e - r][n], this.gates[e - r][n] = i;
    }
};
me.prototype.flipHorizontally = function() {
  this.resetState();
  const t = this.numCols(), e = t - 1;
  for (let r = 0; r < this.numQubits; r++)
    for (let n = 0; n < t / 2; n++) {
      const i = this.gates[r][n];
      this.gates[r][n] = this.gates[r][e - n], this.gates[r][e - n] = i;
    }
};
me.prototype.applyTransform = function(t, e) {
  const r = {};
  let n = 0;
  if (e = e.slice(0), this.reverseBitOrder)
    for (let l = 0; l < e.length; l++)
      e[l] = this.numQubits - 1 - e[l];
  e.reverse();
  const i = [];
  for (let l = 0; l < this.numQubits; l++)
    e.indexOf(l) < 0 && i.push(l);
  const o = 1 << i.length;
  function f(l) {
    let m = 0;
    return e.map(function(h, g) {
      l & 1 << g && (m |= 1 << h);
    }), m;
  }
  function u() {
    let l = 0;
    return e.map(function(m) {
      l |= 1 << m;
    }), l + 1;
  }
  function s() {
    let l = 0;
    return i.map(function(m) {
      l |= 1 << m;
    }), l;
  }
  const c = zt(0, 0);
  for (let l = 0; l < t.length; l++) {
    const m = f(l);
    for (let h = 0; h < t[l].length; h++) {
      const g = f(h);
      if ((this.stateBits & g) === g) {
        const d = t[l][h];
        if (d) {
          let y = m, w = g, E = o;
          const x = f(0), N = u(), D = s();
          let b = x;
          for (; E--; ) {
            const C = this.state[w];
            C && (y = b | m, d === 1 ? r[y] = rt(r[y] || c, C) : r[y] = rt(
              r[y] || c,
              Xe(d, C)
            ), n |= y), b = b + N & D, w = b | g;
          }
        }
      }
    }
  }
  this.state = r, this.stateBits = n, this.stateBits === 0 && Object.keys(this.state).length === 0 && (this.state[0] = zt(1, 0));
};
me.prototype.transformMatrix = function(t, e, r, n) {
  let i;
  r = r.slice(0);
  let a;
  if (n ? a = n === "big" : a = !this.reverseBitOrder, a)
    for (i = 0; i < r.length; i++)
      r[i] = t - 1 - r[i];
  r.reverse();
  const o = [];
  for (i = 0; i < t; i++)
    r.indexOf(i) < 0 && o.push(i);
  const u = 1 << o.length;
  function s(h) {
    let g = 0;
    return r.map(function(d, y) {
      h & 1 << y && (g |= 1 << d);
    }), g;
  }
  function c() {
    let h = 0;
    return r.map(function(g) {
      h |= 1 << g;
    }), h + 1;
  }
  function l() {
    let h = 0;
    return o.map(function(g) {
      h |= 1 << g;
    }), h;
  }
  const m = ur([1 << t, 1 << t]);
  for (let h = 0; h < e.length; h++) {
    const g = s(h);
    for (let d = 0; d < e[h].length; d++) {
      const y = s(d), w = e[h][d];
      if (w) {
        let E = g, x = y, N = u;
        const D = s(0), b = c(), C = l();
        let A = D;
        for (; N--; )
          E = A | g, m[E][x] = w, A = A + b & C, x = A | y;
      }
    }
  }
  return m;
};
me.prototype.circuitMatrix = function(t) {
  const e = new me();
  if (e.load(this.save(!0)), e.gotClassicalControl())
    return [];
  let r = [];
  for (let n = e.numCols() - 1; n >= 0; n--)
    for (let i = e.numQubits - 1; i >= 0; i--) {
      const a = e.getGateAt(n, i);
      if (a && a.connector === 0) {
        const o = e.basicGates[a.name];
        if (!o)
          throw new Error('Unknown gate "' + a.name + '"');
        if (o.matrix && o.matrix.length) {
          const f = e.getRawGate(o, a.options), u = e.transformMatrix(
            e.numQubits,
            f,
            a.wires,
            t
          );
          !r || !r.length ? r = u : r = this.multiplySquareMatrices(r, u);
        }
      }
    }
  return r;
};
me.prototype.eigenvalues2x2 = function(t) {
  const e = this.parseMatrix(t), r = [0, 0], n = rt(e[0][0], e[1][1]);
  return r[0] = er(
    rt(
      n,
      ar(
        rt(
          Xe(Xe(4, e[0][1]), e[1][0]),
          Dt(Qt(e[0][0], e[1][1]), 2)
        )
      )
    ),
    2
  ), r[1] = er(
    Qt(
      n,
      ar(
        rt(
          Xe(Xe(4, e[0][1]), e[1][0]),
          Dt(Qt(e[0][0], e[1][1]), 2)
        )
      )
    ),
    2
  ), r;
};
me.prototype.getBipartiteState = function(t, e) {
  const r = {};
  let n = 0;
  function i(a, o) {
    const u = rt(a, o).arg();
    return zt({
      abs: ar(Dt(It(a), 2) + Dt(It(o), 2)),
      arg: u
    });
  }
  for (let a in this.state) {
    const o = parseInt(a);
    let f = 0;
    const u = o & 1 << t ? 1 : 0, s = o & 1 << e ? 2 : 0;
    f |= u, f |= s, typeof r[f] < "u" ? r[f] = i(
      r[f],
      this.state[a]
    ) : r[f] = this.state[a], n++;
  }
  return n || (r[0] = zt(1, 0)), r;
};
me.prototype.chanceMap = function() {
  const t = {};
  for (let e = 0; e < this.numQubits; e++)
    for (let r = 0; r < this.numQubits; r++)
      t[e] || (t[e] = {}), r === e ? t[e][r] = null : t[e][r] = {};
  for (let e = 0; e < this.numQubits; e++)
    for (let r = e + 1; r < this.numQubits; r++) {
      const n = this.getBipartiteState(e, r), i = new me(2);
      i.state = n;
      const a = It(i.angles()[0].radius), o = qt(1 - Dt(a, 2), 7);
      t[e][r].entangled = o > 0, t[e][r].concurence = o, t[e][r].concurencePercent = qt(o * 100, 2), t[r][e].entangled = o > 0, t[r][e].concurence = o, t[r][e].concurencePercent = qt(o * 100, 2);
    }
  return t;
};
function CA(t, e) {
  let r = t.toString(2);
  for (; r.length < e; )
    r = "0" + r;
  return r;
}
function TA(t, e) {
  return parseInt(CA(t, e).split("").reverse().join(""), 2);
}
me.prototype.resetQubit = function(t, e) {
  const r = [
    [0, 0],
    [0, 0]
  ];
  let n;
  this.reverseBitOrder ? n = Dt(2, this.numQubits - 1 - t) : n = Dt(2, t);
  let i = 0;
  for (let a in this.state) {
    const o = parseInt(a);
    (e ? o & n : !(o & n)) && (i += Dt(It(this.state[a]), 2));
  }
  i = qt(i, 14), i !== 1 && (e ? i === 0 ? r[1][0] = 1 : r[1][1] = ar(1 / i) : i === 0 ? r[0][1] = 1 : r[0][0] = ar(1 / i), this.collapsed = [], this.prob = [], this.applyTransform(r, [t]));
};
me.prototype.applyGate = function(t, e, r, n) {
  if (t === "measure") {
    if (!n.creg)
      throw 'Error: "measure" gate requires destination.';
    const o = this.measure(r[0], n.creg.name, n.creg.bit);
    let f = this.measureResetsQubit;
    if (!f)
      for (let u = e; u < this.numCols(); u++) {
        const s = u === e ? r[0] : 0;
        for (let c = s; c < this.numQubits; c++) {
          const l = this.gates[c][u];
          if (l && l.name !== "measure") {
            f = !0;
            break;
          }
        }
        if (f)
          break;
      }
    f && this.resetQubit(r[0], o);
    return;
  }
  if (t === "reset") {
    this.resetQubit(r[0], 0);
    return;
  }
  const i = this.basicGates[t];
  if (!i) {
    console.log('Unknown gate "' + t + '".');
    return;
  }
  const a = this.getRawGate(i, n);
  this.collapsed = [], this.prob = [], this.applyTransform(a, r);
};
me.prototype.getRawGate = function(t, e, r) {
  let n = r && r.params ? r.params : this.options && this.options.params ? this.options.params : {};
  n = JSON.parse(JSON.stringify(n));
  for (let a in n)
    n[a] = Nr(n[a]);
  const i = [];
  return t.matrix.map(function(a) {
    const o = [];
    a.map(function(f) {
      if (typeof f == "string") {
        const u = e ? e.params || {} : {}, s = {};
        t.params.map(function(l, m) {
          Array.isArray(u) ? s[l] = u.length > m ? Nr(u[m], n) : null : s[l] = Nr(String(u[l]), n);
        });
        const c = Nr(f, s);
        o.push(c);
      } else
        o.push(f);
    }), i.push(o);
  }), i;
};
me.prototype.countParameterizedGates = function() {
  let t = 0;
  const e = this.numCols();
  for (let r = 0; r < e; r++)
    for (let n = 0; n < this.numQubits; n++) {
      const i = this.getGateAt(r, n);
      if (i && i.connector === 0 && i.options && i.options.params) {
        let a = 0;
        for (let o in i.options.params)
          a++;
        a > 0 && t++;
      }
    }
  return t;
};
me.prototype.findGlobalParams = function() {
  const t = {
    globalParams: [],
    cells: []
  }, e = function(n) {
    const i = [], a = function(f) {
      f.isSymbolNode && !f.isFunctionNode && !wA[f.name] && i.push(f.name);
    };
    return xt(n).toString({ handler: a }), i;
  }, r = this.numCols();
  for (let n = 0; n < r; n++)
    for (let i = 0; i < this.numQubits; i++) {
      const a = this.getGateAt(n, i);
      if (a && a.connector === 0 && a.options && a.options.params) {
        let o = !1;
        for (let f in a.options.params) {
          const u = a.options.params[f];
          if (typeof u == "string") {
            const s = e(u);
            if (s.length) {
              for (let c = 0; c < s.length; c++)
                t.globalParams.indexOf(s[c]) < 0 && t.globalParams.push(s[c]);
              if (!o) {
                const c = Math.max.apply(null, a.wires);
                t.cells.push([n, c]), o = !0;
              }
            }
          }
        }
      }
    }
  return t;
};
me.prototype.getGlobalParams = function() {
  return this.findGlobalParams().globalParams;
};
me.prototype.gotGlobalParams = function() {
  return this.getGlobalParams().length > 0;
};
me.prototype.updateGlobalParams = function() {
  this.params = this.getGlobalParams(), this.options = this.options || {}, this.options.params = this.options.params || {};
  for (let t = 0; t < this.params.length; t++) {
    let e = this.params[t];
    typeof this.options.params[e] > "u" && (this.options.params[e] = 0);
  }
  for (let t in this.options.params)
    this.params.indexOf(t) < 0 && delete this.options.params[t];
  return this.params;
};
me.prototype.makeAllParamsGlobal = function() {
  const t = this.getGlobalParams(), e = function(n) {
    const i = [], a = function(f) {
      f.isSymbolNode && !f.isFunctionNode && !wA[f.name] && i.push(f.name);
    };
    return xt(n).toString({ handler: a }), i;
  }, r = this.numCols();
  for (let n = 0; n < r; n++)
    for (let i = 0; i < this.numQubits; i++) {
      const a = this.getGateAt(n, i);
      if (a && a.connector === 0 && a.options && a.options.params)
        for (let o in a.options.params) {
          const f = a.options.params[o];
          let u = !1;
          if (typeof f == "string" && e(f).length && (u = !0), !u) {
            let s = 0;
            for (; t.indexOf("var" + s) >= 0; )
              s++;
            const c = "var" + s;
            t.push(c);
            for (let l = 0; l < a.wires.length; l++) {
              const m = this.gates[a.wires[l]][n];
              m.options.params[o] = c;
            }
            this.params.push(c), this.options.params[c] = f;
          }
        }
    }
};
me.prototype.decompose = function(t) {
  let e;
  if (!t.gates.length)
    return t;
  this.updateGlobalParams();
  function r(n, i, a) {
    return n.slice(0, a).concat(i).concat(n.slice(a));
  }
  for (let n = 0; n < t.gates[0].length; n++)
    for (let i = 0; i < t.numQubits; i++) {
      const a = t.gates[i][n];
      if (a && a.connector === 0 && !this.basicGates[a.name]) {
        const o = new me(), f = t.customGates[a.name];
        if (f) {
          if (o.load(f), o.params.length && a.options && a.options.params) {
            const c = a.options.params;
            for (let l = 0; l < o.gates[0].length; l++)
              for (let m = 0; m < o.numQubits; m++) {
                let h = o.gates[m][l];
                if (h && h.connector === 0 && h.options && h.options.params)
                  for (let g in h.options.params) {
                    const y = xt(h.options.params[g]).transform(function(w) {
                      return w.isSymbolNode && c.hasOwnProperty(w.name) ? xt("(" + c[w.name] + ")") : w;
                    });
                    h.options.params[g] = y.toString();
                  }
              }
          }
          if (a.options && a.options.condition)
            for (let c = 0; c < o.gates[0].length; c++)
              for (let l = 0; l < o.numQubits; l++) {
                const m = o.gates[l][c];
                m && (m.options = m.options || {}, m.options.condition = a.options.condition);
              }
          const u = o.save(!0);
          if (!u.gates[0].length)
            for (e = 0; e < u.gates.length; e++)
              u.gates[e].push(null);
          const s = [];
          for (let c = 0; c < u.gates[0].length - 1; c++)
            s.push(null);
          for (let c = 0; c < t.numQubits; c++) {
            const l = t.gates[c][n];
            if (l && l.id === a.id) {
              t.gates[c].splice(n, 1);
              const m = JSON.parse(
                JSON.stringify(u.gates[l.connector])
              );
              for (e = 0; e < m.length; e++)
                m[e] && (m[e].id = m[e].id + "_" + a.id);
              t.gates[c] = r(t.gates[c], m, n);
            } else
              t.gates[c] = r(t.gates[c], s, n + 1);
          }
        }
      }
    }
  return t.customGates = {}, t;
};
me.prototype.decomposeGateAt = function(t, e) {
  let r;
  const n = this, i = this.getGateAt(t, e);
  if (!i || !this.customGates[i.name])
    return;
  const a = new me();
  for (a.load(this.save()), r = 0; r < a.gates[0].length; r++)
    for (let u = 0; u < a.numQubits; u++) {
      const s = a.gates[u][r];
      s && s.id !== i.id && a.removeGateAt(r, u);
    }
  const o = new me();
  o.load(a.save(!0)), o.removeLeadingColumns(), o.removeTrailingColumns();
  for (let u = 0; u < o.gates[0].length - 1; u++)
    this.insertSpace(t + u, i.wires);
  this.removeGate(i.id);
  let f = t;
  for (r = 0; r < o.gates[0].length; r++)
    o.getGatesAtColumn(r).map(function(s) {
      n.addGate(s.name, f, s.wires, s.options);
    }), f++;
  return o;
};
me.prototype.removeMeasurementAndClassicalControl = function() {
  const t = this.numCols();
  for (let e = 0; e < t; e++)
    for (let r = 0; r < this.numQubits; r++) {
      let n = this.gates[r][e];
      n && n.name === "measure" && (this.gates[r][e] = null, n = null), n && n.options && n.options.condition && delete this.gates[r][e].options.condition;
    }
  this.cregs = {}, this.options && (this.options.hybrid = !1, this.options.hybridOptions && delete this.options.hybridOptions);
};
me.prototype.convertToCustomGate = function(t, e, r) {
  const n = this.numCols();
  for (let a = 0; a < n; a++)
    for (let o = 0; o < this.numQubits; o++) {
      let f = this.gates[o][a];
      f && f.name === "measure" && (this.gates[o][a] = null, f = null), f && f.options && f.options.condition && delete this.gates[o][a].options.condition;
    }
  this.cregs = {};
  const i = this.save(e);
  if (i.options && (i.options.hybrid = !1, i.options.hybridOptions && delete i.options.hybridOptions), this.clear(), this.customGates[t] = i, r) {
    const a = [];
    for (let f = 0; f < this.numQubits; f++)
      a.push(f);
    const o = JSON.parse(
      JSON.stringify(this.customGates[t].options)
    );
    this.addGate(t, -1, a, o);
  } else
    this.removeTrailingRows();
};
me.prototype.validCustomGateName = function(t) {
  t = (t || "sub") + "";
  const e = [];
  if (this.customGates) {
    let i;
    if (!this.basicGates[t] && !this.customGates[t])
      return t;
    for (i in this.basicGates)
      e.push(i);
    for (i in this.customGates)
      e.push(i);
  }
  let r = 0, n = "";
  do
    r++, n = t + r;
  while (e.indexOf(n) >= 0);
  return n;
};
me.prototype.splitIntoBlocks = function(t, e) {
  let r, n, i;
  e = e || {};
  const a = [];
  let o = "{}", f = !0, u = null;
  const s = new me();
  s.load(this.save(!0));
  const c = s.numCols();
  for (let h = 0; h < c; h++)
    for (let g = 0; g < s.numQubits; g++)
      if (i = s.getGateAt(h, g), i && i.connector === 0 && !i.addedToBlock) {
        n = this.basicGates[i.name];
        const d = i.options && i.options.condition ? JSON.stringify(i.options.condition) : "{}", y = n && !!(n.matrix && n.matrix.length), w = JSON.parse(
          JSON.stringify(u ? u.wires : [])
        );
        if (i.wires.map(function(E) {
          w.indexOf(E) < 0 && w.push(E);
        }), !a.length || d !== o || !y || !f || !(w.length <= t) ? (u = {
          wires: i.wires,
          gates: [i]
        }, a.push(u), i.options && i.options.condition && (u.condition = i.options.condition)) : (u.wires = w, u.gates.push(i)), i.wires.map(function(E) {
          s.gates[E][h].addedToBlock = !0;
        }), o = d, f = y, !e.verticalOnly) {
          let E = h + 1, x = JSON.parse(JSON.stringify(u.wires));
          for (x.sort(); E < c && x.length; ) {
            let N = x[0];
            for (; x.length && N <= x[x.length - 1]; ) {
              const D = s.getGateAt(E, N);
              if (D && !D.addedToBlock) {
                const b = this.basicGates[D.name], C = D.options && D.options.condition ? JSON.stringify(D.options.condition) : "{}";
                let T = b && !!(b.matrix && b.matrix.length) && C === d;
                if (T) {
                  for (let _ = 0; _ < D.wires.length; _++)
                    if (x.indexOf(D.wires[_]) < 0) {
                      T = !1;
                      break;
                    }
                }
                if (T)
                  u.gates.push(D), D.wires.map(function(_) {
                    s.gates[_][E].addedToBlock = !0;
                  });
                else {
                  const _ = [];
                  for (let O = 0; O < x.length; O++) {
                    let I = x[O];
                    D.wires.indexOf(I) < 0 && _.push(I);
                  }
                  x = _;
                }
              }
              if (x.length) {
                let b = x[x.length - 1] + 1;
                for (let C = x.length - 1; C >= 0; C--) {
                  let A = x[C];
                  A > N && (b = A);
                }
                N = b;
              }
            }
            E++;
          }
        }
      }
  const l = new me();
  let m = 0;
  for (let h = 0; h < a.length; h++) {
    const g = a[h];
    let d = !1;
    if (g.wires.length <= t || e.flexibleBlockSize)
      for (r = 0; r < g.gates.length; r++)
        i = g.gates[r], n = this.basicGates[i.name], n.matrix && n.matrix.length && (d = !0);
    if (d) {
      m++;
      const y = new me();
      for (r = 0; r < g.gates.length; r++) {
        i = g.gates[r], i.options.condition && delete i.options.condition;
        const x = [];
        i.wires.map(function(N) {
          x.push(g.wires.indexOf(N));
        }), i.wires = x, y.appendGate(i.name, x, i.options);
      }
      const w = "block" + m;
      l.registerGate(w, y);
      const E = {};
      g.condition && (E.condition = g.condition), l.appendGate(w, g.wires, E);
    } else
      g.gates.map(function(y) {
        l.appendGate(y.name, y.wires, y.options);
      });
  }
  this.load(l.save(!1));
};
me.prototype.usedGates = function(t) {
  t = t || {};
  const e = new me();
  e.load(this.save(!0));
  const r = [];
  for (let n = 0; n < e.numQubits; n++)
    for (let i = 0; i < e.numCols(); i++) {
      const a = e.gates[n][i];
      if (a && r.indexOf(a.name) < 0) {
        let o = !1;
        if (t.unitariesOnly) {
          const f = e.basicGates[a.name];
          (!f || !f.matrix || !f.matrix.length) && (o = !0);
        }
        o || r.push(a.name);
      }
    }
  if (!t.noCustomGates)
    for (let n in this.customGates)
      r.indexOf(n) < 0 && r.push(n);
  return r;
};
me.prototype.countOps = function(t, e) {
  e = e || {}, e.shallow = e.shallow || !1, t || (t = this);
  const r = {};
  for (let n = 0; n < t.gates.length; n++)
    for (let i = 0; i < t.gates[n].length; i++) {
      const a = t.gates[n][i];
      if (a && a.connector === 0)
        if (this.basicGates[a.name])
          r[a.name] ? r[a.name]++ : r[a.name] = 1;
        else {
          const f = this.customGates[a.name];
          if (f && (r[a.name] ? r[a.name]++ : r[a.name] = 1, !e.shallow)) {
            const u = this.countOps(f, e);
            for (let s in u)
              r[s] ? r[s] += u[s] : r[s] = u[s];
          }
        }
    }
  return r;
};
me.prototype.getCouplingMap = function(t) {
  t = t || {};
  let e = "";
  const r = new me();
  r.load(this.save(!0));
  for (let n = 0; n < r.numQubits; n++)
    for (let i = 0; i < r.numCols(); i++) {
      const a = r.getGateAt(i, n);
      if (a && a.connector === 0) {
        let o = !1;
        if (t.unitariesOnly) {
          const f = r.basicGates[a.name];
          (!f || !f.matrix || !f.matrix.length) && (o = !0);
        }
        if (!o) {
          const f = JSON.stringify(a.wires);
          e.indexOf(f) < 0 && (e && (e += ","), e += f);
        }
      }
    }
  return JSON.parse("[" + e + "]");
};
me.prototype.getGateDef = function(t) {
  let e = this.basicGates[t];
  return e || (e = this.customGates[t]), e;
};
me.prototype.importRaw = function(t, e) {
  let r;
  const n = t && t.qubits || 0;
  if (this.init(n), !t)
    if (e)
      e([]);
    else
      return;
  if (t.cregs)
    for (let i = 0; i < t.cregs.length; i++) {
      const a = t.cregs[i];
      if (!a.name) {
        let o = "Classical register " + i + ` doesn't have a "name".`;
        if (e) {
          e([{ msg: o, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(o);
      }
      this.createCreg(a.name, a.len || 0);
    }
  if (t.program)
    for (let i = 0; i < t.program.length; i++) {
      const a = t.program[i];
      if (!a.name)
        if (r = "Gate " + i + ` doesn't have a "name". Name is optional and this is OK for QubitToaster but we cannot import gate from matrix. Not implemented yet.`, e) {
          e([{ msg: r, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(r);
      const o = this.basicGates[a.name];
      if (!o)
        if (r = 'Unknown gate "' + a.name + '". Name is optional and this is OK for QubitToaster but we cannot import gate from matrix. We can import only gates by name from set of known gates.', e) {
          e([{ msg: r, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(r);
      const f = JSON.parse(JSON.stringify(a.wires || [])), u = JSON.parse(JSON.stringify(a.options || {})), s = o.matrix && o.matrix.length ? Ci(o.matrix.length) : 1;
      if (f.length !== s)
        if (r = 'Gate "' + a.name + '" has ' + f.length + " wires but should have " + s + " wires.", e) {
          e([{ msg: r, line: 0, col: 0 }]);
          return;
        } else
          throw new Error(r);
      if (o.params && o.params.length) {
        if (!u.params)
          if (r = 'Missing parameters for gate "' + a.name + '". Expecting ' + o.params.length + " parameters.", e) {
            e([{ msg: r, line: 0, col: 0 }]);
            return;
          } else
            throw new Error(r);
        for (let c = 0; c < o.params.length; c++) {
          const l = o.params[c];
          if (typeof u.params[l] > "u")
            if (r = 'Missing parameter "' + l + '" for gate "' + a.name + '".', e) {
              e([{ msg: r, line: 0, col: 0 }]);
              return;
            } else
              throw new Error(r);
        }
      }
      this.appendGate(a.name, f, u);
    }
  e && e([]);
};
me.prototype.exportRaw = function() {
  let t = this.options && this.options.params ? this.options.params : {};
  t = JSON.parse(JSON.stringify(t));
  for (let a in t)
    t[a] = Nr(t[a]);
  const e = new me();
  e.load(this.save(!0));
  const r = e.numCols(), n = [];
  for (let a = 0; a < r; a++)
    for (let o = 0; o < e.numQubits; o++) {
      const f = e.getGateAt(a, o);
      if (f && f.connector === 0) {
        const u = e.basicGates[f.name];
        if (!u) {
          console.log('Unknown gate "' + f.name + '".');
          return;
        }
        const s = e.getRawGate(u, f.options), c = [];
        s.map(function(m) {
          const h = [];
          m.map(function(g) {
            g = JSON.parse(JSON.stringify(g)), typeof g == "object" && g.mathjs && typeof g.mathjs == "string" && (g.type = g.mathjs.toLowerCase(), delete g.mathjs), h.push(g);
          }), c.push(h);
        });
        let l = {};
        if (f.options && (l = JSON.parse(JSON.stringify(f.options))), l.params)
          for (let m in l.params)
            l.params[m] = Nr(
              l.params[m],
              t
            );
        n.push({
          name: f.name,
          matrix: c,
          wires: f.wires,
          options: l
        });
      }
    }
  const i = [];
  for (let a in e.cregs)
    i.push({
      name: a,
      len: e.cregs[a].length || 0
    });
  return {
    qubits: e.numQubits,
    cregs: i,
    program: n
  };
};
me.prototype.exportToGenerator = function(t) {
  t = t || {};
  const e = this.exportQASM(null, !1, null, !1, !0), r = this.usedGates({
    noCustomGates: !0,
    unitariesOnly: !0
  }), n = this.getCouplingMap({ unitariesOnly: !0 }), i = {
    source: {
      circuit: {
        qasm: e
      }
    },
    problem: [],
    type: "circuit",
    settings: {
      allowed_gates: r.join(","),
      coupling_map: n
    }
  }, a = new me();
  if (a.load(this.save(!0)), t.fromMatrix) {
    const o = a.circuitMatrix(), f = [];
    return o.map(function(u) {
      u.map(function(s) {
        typeof s == "object" ? f.push([s.re, s.im]) : f.push(s);
      });
    }), i.problem.push({
      unitary: f
    }), i;
  }
  if (!t.noVectors) {
    const o = new me(), f = t.numSamples || (this.numQubits < 3 ? 8 : this.numQubits < 5 ? (1 << this.numQubits) + 1 : this.numQubits < 9 ? this.numQubits * 4 : this.numQubits);
    for (let u = 0; u < f + 1; u++) {
      const s = { input: [], output: [] };
      let c = [];
      u > 0 ? (o.randomCircuit(this.numQubits, 20, {
        useGates: t.useGates || ["u3", "cx"],
        noClassicControl: !0,
        noMeasure: !0,
        noReset: !0
      }), o.run(), o.stateAsArray().map(function(l) {
        s.input.push([l.amplitude.re, l.amplitude.im]);
      }), c = o.state) : (a.initState(), a.stateAsArray().map(function(l) {
        s.input.push([l.amplitude.re, l.amplitude.im]);
      }), c = a.state), a.run(null, { initialState: c }), a.stateAsArray().map(function(l) {
        s.output.push([l.amplitude.re, l.amplitude.im]);
      }), i.problem.push(s);
    }
    return i;
  }
  return i;
};
me.prototype.save = function(t, e) {
  this.updateGlobalParams();
  const r = {
    numQubits: this.numQubits,
    params: JSON.parse(JSON.stringify(this.params)),
    options: JSON.parse(JSON.stringify(this.options)),
    gates: JSON.parse(JSON.stringify(this.gates)),
    customGates: JSON.parse(JSON.stringify(this.customGates)),
    cregs: JSON.parse(JSON.stringify(this.cregs))
  };
  let n;
  if (t ? n = this.decompose(r) : n = r, e && (n.gates && n.gates.map(function(i) {
    i && i.map(function(a) {
      a && a.id && delete a.id;
    });
  }), n.customGates))
    for (let i in n.customGates) {
      const a = n.customGates[i];
      a && a.gates && a.gates.map(function(o) {
        o && o.map(function(f) {
          f && f.id && delete f.id;
        });
      });
    }
  return n;
};
me.prototype.load = function(t) {
  this.numQubits = t.numQubits || 1, this.clear(), this.params = JSON.parse(JSON.stringify(t.params || [])), this.options = JSON.parse(JSON.stringify(t.options || {})), this.gates = JSON.parse(JSON.stringify(t.gates || [])), this.customGates = JSON.parse(JSON.stringify(t.customGates || {})), this.cregs = JSON.parse(JSON.stringify(t.cregs || {})), this.options.params = this.options.params || {}, this.options.hybrid = this.options.hybrid || !1, this.options.hybridOptions || (this.options.hybridOptions = this.defaultHybridOptions());
};
const Sk = function(t) {
  if (t <= 0)
    throw new Error("Cannot generate the gray code for less than 1 bit.");
  const e = [0];
  for (let n = 0; n < t; n++)
    [].concat(e).reverse().map(function(a) {
      e.push(a + Dt(2, n));
    });
  const r = [];
  return e.map(function(n) {
    r.push(CA(n, t));
  }), r;
};
me.prototype.grayCodeChain = function(t, e, r) {
  function n(l, m) {
    const h = [];
    for (let g = 0; g < l.length; g++)
      h.push(l[g] !== m[g]);
    return h;
  }
  function i(l, m) {
    const h = [];
    for (let g = 0; g < l.length; g++)
      l[g] === m && h.push(g);
    return h;
  }
  function a(l, m) {
    let h = 0;
    for (let g = 0; g < l.length; g++)
      l[g] === m && h++;
    return h;
  }
  const o = [];
  for (let l = 0; l < t; l++)
    o.push(l);
  const f = t, u = Sk(t);
  let s = null;
  const c = [];
  return u.map(function(l) {
    const m = l.indexOf("1");
    if (m >= 0) {
      s || (s = l);
      const g = n(l, s).indexOf(!0);
      if (g >= 0)
        if (g !== m)
          c.push({
            gateName: "cx",
            wires: [o[g], o[m]],
            options: null
          });
        else {
          const d = i(l, "1");
          for (let y = 1; y < d.length; y++)
            c.push({
              gateName: "cx",
              wires: [o[d[y]], o[m]],
              options: null
            });
        }
      if (a(l, "1") % 2)
        c.push({
          gateName: e,
          wires: [o[m], f],
          options: r
        });
      else {
        let d = null;
        if (r && (d = JSON.parse(JSON.stringify(r)), d.params))
          for (let y in d.params) {
            let w = d.params[y];
            typeof w == "number" ? w = 0 - w : w = "-(" + w + ")", d.params[y] = w;
          }
        c.push({
          gateName: e,
          wires: [o[m], f],
          options: d
        });
      }
      s = l;
    }
  }), c;
};
me.prototype.MCU1Circuit = function(t) {
  let e;
  const r = [];
  if (typeof t == "number")
    e = t;
  else {
    e = t.length || 0;
    for (let u = 0; u < e; u++)
      (!t[u] || typeof t[u] == "number" && t[u] < 0) && r.push(u);
  }
  if (e === 0)
    throw new Error(
      "Cannot create multi-controlled gate with zero control qubits."
    );
  function n(u, s) {
    s.map(function(c) {
      u.appendGate("x", c);
    });
  }
  const a = { params: { lambda: "lambda / " + Dt(2, e - 1) } }, o = new me();
  return e === 1 ? (n(o, r), o.appendGate("cu1", [0, 1], a), n(o, r), o) : (n(o, r), this.grayCodeChain(e, "cu1", a).map(function(u) {
    o.appendGate(u.gateName, u.wires, u.options);
  }), n(o, r), o);
};
me.prototype.MCXCircuit = function(t) {
  let e;
  const r = [];
  if (typeof t == "number")
    e = t;
  else {
    e = t.length || 0;
    for (let u = 0; u < e; u++)
      (!t[u] || typeof t[u] == "number" && t[u] < 0) && r.push(u);
  }
  const n = new me();
  if (e === 0)
    throw new Error(
      "Cannot create multi-controlled gate with zero control qubits."
    );
  function i(u, s) {
    s.map(function(c) {
      u.appendGate("x", c);
    });
  }
  if (e === 1)
    return i(n, r), n.appendGate("cx", [0, 1]), i(n, r), n;
  if (e === 2)
    return i(n, r), n.appendGate("ccx", [0, 1, 2]), i(n, r), n;
  const a = n.MCU1Circuit(e), o = "mcu1_" + e, f = [];
  for (let u = 0; u < e + 1; u++)
    f.push(u);
  return n.registerGate(o, a), i(n, r), n.appendGate("h", e), n.appendGate(o, f, { params: { lambda: "pi" } }), i(n, r), n.appendGate("h", e), n;
};
me.prototype.registerGate = function(t, e) {
  if (e instanceof me ? this.customGates[t] = e.save() : this.customGates[t] = e, this.isMultiControlledGate(t)) {
    const r = this.decodeMultiControlledGateName(t);
    if (r.numCtrlQubits !== this.customGates[t].numQubits - 1) {
      r.numCtrlQubits = this.customGates[t].numQubits - 1;
      const i = [];
      for (let a = 0; a < r.numCtrlQubits; a++)
        i.push(
          typeof r.ctrlQubits[a] > "u" ? !0 : r.ctrlQubits[a]
        );
      r.ctrlQubits = i;
    }
    const n = this.basicGates[r.rootName];
    if (n && n.drawingInfo && n.drawingInfo.connectors) {
      this.customGates[t].drawingInfo || (this.customGates[t].drawingInfo = {});
      const i = [];
      r.ctrlQubits.map(function(a) {
        a ? i.push("dot") : i.push("ndot");
      }), i.push(
        n.drawingInfo.connectors[n.drawingInfo.connectors.length - 1]
      ), this.customGates[t].drawingInfo.connectors = i, this.customGates[t].drawingInfo.root = n.drawingInfo.root;
    }
  }
};
me.prototype.registerMCXGate = function(t) {
  const e = this.multiControlledGateName("mcx", t);
  return this.registerGate(e, this.MCXCircuit(t).save(!0)), e;
};
me.prototype.registerMCU1Gate = function(t) {
  const e = this.multiControlledGateName("mcu1", t);
  return this.registerGate(e, this.MCU1Circuit(t).save(!0)), e;
};
me.prototype.registerMultiControlledGate = function(t, e) {
  switch (t) {
    case "cx":
      return this.registerMCXGate(e);
    case "cu1":
      return this.registerMCU1Gate(e);
  }
  return "";
};
me.prototype.getOrRegisterMultiControlledEquivalent = function(t, e) {
  const r = this.basicGates[t];
  if (r) {
    if (r.drawingInfo && (t === "x" || t === "u1" || r.drawingInfo.root === "x" || r.drawingInfo.root === "u1"))
      if (!this.basicGates["c" + t] || e) {
        const n = "c" + (r.drawingInfo.root || t), i = Ci(r.matrix.length), a = [];
        for (let o = 0; o < i - 1; o++)
          a.push(!0);
        return a.unshift(!e), this.registerMultiControlledGate(n, a);
      } else
        return "c" + t;
    for (let n in this.basicGates) {
      const i = this.basicGates[n];
      if (i && i.drawingInfo && i.drawingInfo.root && i.drawingInfo.root === t && !e)
        return n;
    }
    return null;
  }
  if (this.customGates[t]) {
    const n = this.decodeMultiControlledGateName(t);
    return !n || !n.numCtrlQubits ? null : n.rootName === "cx" || n.rootName === "cu1" ? (n.ctrlQubits.unshift(!e), this.registerMultiControlledGate(n.rootName, n.ctrlQubits)) : null;
  }
  return null;
};
me.prototype.removeUnusedMultiControlledGates = function() {
  const t = this.countOps(null, { shallow: !1 });
  for (let e in this.customGates)
    t[e] || this.isMultiControlledGate(e) && delete this.customGates[e];
};
me.prototype.decodeMultiControlledGateName = function(t) {
  let e;
  if (!t)
    return null;
  const r = t.split("_");
  e = parseInt(r[1]);
  const n = {};
  if (r.length > 0 && (n.name = r[0], n.rootName = n.name.substring(1), n.rootName !== "cx" && n.rootName !== "cu1"))
    return null;
  if (r.length > 1 && !isNaN(e) && e <= 20 && (n.numCtrlQubits = e), n.numCtrlQubits) {
    const i = [];
    if (r.length > 2)
      for (let a = 0; a < r[2].length; a++)
        r[2][a] === "0" && i.push(!1), r[2][a] === "1" && i.push(!0);
    if (!i.length)
      for (let a = 0; a < e; a++)
        i.push(!0);
    n.ctrlQubits = i;
  }
  return n;
};
me.prototype.multiControlledGateName = function(t, e) {
  let r = t + "_";
  if (typeof e == "number")
    r += e;
  else {
    r += e.length || 0;
    let n = "";
    e.map(function(i) {
      !i || typeof i == "number" && i < 0 ? n += "0" : n += "1";
    }), n.indexOf("0") < 0 && (n = ""), n && (r += "_" + n);
  }
  return r;
};
me.prototype.isMultiControlledGate = function(t) {
  const e = this.decodeMultiControlledGateName(t);
  return !!this.customGates[t] && !!e && !!e.numCtrlQubits;
};
me.prototype.isControllableGate = function(t) {
  let e = this.basicGates[t];
  if (e) {
    if (e.drawingInfo && (e.drawingInfo.root === "x" || e.drawingInfo.root === "u1"))
      return !0;
    for (let r in this.basicGates)
      if (e = this.basicGates[r], e && e.drawingInfo && e.drawingInfo.root && e.drawingInfo.root === t)
        return !0;
  }
  return this.isMultiControlledGate(t);
};
me.prototype.getGatePosById = function(t) {
  const e = this, r = e.numCols();
  for (let n = 0; n < r; n++)
    for (let i = 0; i < e.numQubits; i++) {
      const a = e.getGateAt(n, i);
      if (a && a.id === t)
        return {
          wires: a.wires,
          col: n
        };
    }
  return {
    wires: [],
    col: -1
  };
};
me.prototype.getGateById = function(t) {
  const e = this, r = e.numCols();
  for (let n = 0; n < r; n++)
    for (let i = 0; i < e.numQubits; i++) {
      const a = e.getGateAt(n, i);
      if (a && a.id === t)
        return a;
    }
  return null;
};
me.prototype.getGateBefore = function(t, e) {
  let r = null, n = t - 1;
  for (; n >= 0 && !r; )
    r = this.getGateAt(n, e), n--;
  return r;
};
me.prototype.getGateAt = function(t, e) {
  if (!this.gates[e] || !this.gates[e][t])
    return null;
  const r = JSON.parse(JSON.stringify(this.gates[e][t]));
  if (!r)
    return null;
  r.column = t, r.wires = [];
  const n = r.id, i = this.gates.length;
  for (let a = 0; a < i; a++) {
    const o = this.gates[a][t];
    o && o.id === n && (r.wires[o.connector] = a);
  }
  return r;
};
me.prototype.getGatesAtColumn = function(t) {
  const e = [], r = this.gates.length;
  for (let n = 0; n < r; n++) {
    const i = this.getGateAt(t, n);
    i && i.connector === 0 && e.push(i);
  }
  return e;
};
me.prototype.getControllableGatesAtColumn = function(t) {
  const e = this.getGatesAtColumn(t), r = [];
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    this.isControllableGate(i.name) && r.push(i);
  }
  return r;
};
me.prototype.exportJavaScript = function(t, e, r, n) {
  const i = this;
  let a = null;
  e ? (a = new me(), a.load(this.save(!0))) : a = this;
  let o = "";
  t && (t || "").split(`
`).map(function(m) {
    m.length >= 2 && m[0] !== "/" && m[1] !== "/" && (o += "// "), o += m, o += `
`;
  });
  let f = "", u = "";
  if (r)
    f = "    ", u = "circ", o += "const " + r + ` = function() {
`, o += f + "const " + u + " = new QuantumCircuit(" + a.numQubits + `);

`, a.params && a.params.length && (o += f + u + ".params = " + JSON.stringify(a.params) + `

`);
  else {
    f = "", u = "circuit", o += f + `const QuantumCircuit = require("quantum-circuit");

`, o += f + "const " + u + " = new QuantumCircuit(" + a.numQubits + `);

`;
    const l = a.usedGates();
    if (!e) {
      const m = [];
      l.map(function(h) {
        if (!a.basicGates[h]) {
          const d = i.customGates[h];
          if (d) {
            const y = new me();
            y.load(d), o += y.exportJavaScript("", !0, h), m.push(h);
          }
        }
      }), m.map(function(h) {
        o += f + u + '.registerGate("' + h + '", ' + h + `());
`;
      }), m.length > 0 && (o += `
`);
    }
  }
  let s = 0;
  for (let l in this.cregs)
    o += f + u + '.createCreg("' + l + '", ' + (this.cregs[l].length || 1) + `);
`, s++;
  s > 0 && (o += `
`);
  const c = a.numCols();
  for (let l = 0; l < c; l++)
    for (let m = 0; m < this.numQubits; m++) {
      const h = a.getGateAt(l, m);
      if (h && h.connector === 0)
        if (h.name === "measure" && h.options && h.options.creg)
          o += f + u + ".addMeasure(" + m + ', "' + h.options.creg.name + '", ' + h.options.creg.bit + `);
`;
        else {
          if (o += f + u + '.appendGate("' + h.name + '"', h.wires.length === 1)
            o += ", ", o += h.wires[0];
          else {
            o += ", [";
            for (let d = 0; d < h.wires.length; d++)
              d > 0 && (o += ","), o += h.wires[d];
            o += "]";
          }
          if (h.options) {
            const d = {};
            for (let y in h.options)
              if (h.options[y]) {
                const w = h.options[y];
                let E = !1;
                typeof w == "object" && Object.keys(w).length === 0 && w.constructor === Object && (E = !0), E || (d[y] = w);
              }
            o += ", " + JSON.stringify(d);
          }
          o += `);
`;
        }
    }
  return r ? (o += `
`, o += f + "return " + u + `;
`, o += `};

`) : (o += `
`, o += f + u + `.run();

`, o += f + `console.log("Probabilities:");
`, o += f + `console.log(JSON.stringify(circuit.probabilities()));

`, o += f + `console.log("Measure all:");
`, o += f + `console.log(JSON.stringify(circuit.measureAll()));

`, a.cregCount() && (o += f + `console.log("Classical registers:");
`, o += f + `console.log(circuit.cregsAsString());

`)), n ? JSON.stringify({
    metadata: {
      kernelspec: {
        display_name: "Javascript (Node.js)",
        language: "javascript",
        name: "javascript"
      },
      language_info: {
        file_extension: ".js",
        mimetype: "application/javascript",
        name: "javascript"
      }
    },
    nbformat: 4,
    nbformat_minor: 0,
    cells: [
      {
        cell_type: "code",
        source: o,
        metadata: {},
        outputs: [],
        execution_count: null
      }
    ]
  }) : o;
};
me.prototype.exportQiskit = function(t, e, r, n, i, a, o, f, u, s, c) {
  const l = {
    comment: t,
    decompose: e,
    versionStr: n,
    providerName: i,
    backendName: a,
    asJupyter: o,
    shots: f,
    hybrid: c
  };
  return this.exportToQiskit(
    l,
    r,
    u,
    s
  );
};
me.prototype.exportQuEST = function(t, e, r, n) {
  const i = {
    comment: t,
    decompose: e
  };
  return this.exportToQuEST(i, r, n);
};
me.prototype.exportQASM = function(t, e, r, n, i, a) {
  const o = {
    comment: t,
    decompose: e,
    compatibilityMode: i
  };
  return this.exportToQASM(
    o,
    r,
    n,
    a
  );
};
me.prototype.importQASM = function(t, e, r) {
  this.init(), Ek(this, t, e, r);
};
me.prototype.exportPyquil = function(t, e, r, n, i, a, o, f, u) {
  const s = {
    comment: t,
    decompose: e,
    versionStr: n,
    lattice: i,
    asQVM: a,
    asJupyter: o,
    shots: f,
    hybrid: u
  };
  return this.exportToPyquil(s, r);
};
me.prototype.exportQuil = function(t, e, r, n) {
  const i = {
    comment: t,
    decompose: e,
    versionStr: n
  };
  return this.exportToQuil(i, r);
};
me.prototype.importQuil = function(t, e, r, n, i, a) {
  let o, f, u, s, c;
  const l = this;
  r = r || {}, l.init(), i = i || {}, a = a || 0;
  function m(w) {
    if (l.customGates && l.customGates[w])
      return { name: w, customGate: l.customGates[w] };
    for (let E in l.basicGates) {
      const x = l.basicGates[E];
      if (x.exportInfo) {
        if (x.exportInfo.quil && x.exportInfo.quil.name === w)
          return { name: E, gateDef: x, quilDef: x.exportInfo.quil };
        if (x.exportInfo.pyquil && x.exportInfo.pyquil.name === w)
          return {
            name: E,
            gateDef: x,
            quilDef: x.exportInfo.pyquil
          };
      }
    }
    return null;
  }
  const h = t.split(`
`), g = [];
  let d = !1;
  h.map(function(w, E) {
    let x;
    if (w = w.split("#")[0], w.length ? w = w.trim() : d = !1, d)
      x = w.split(";"), x.map(function(N) {
        N.trim().length && g[g.length - 1].body.push(N.trim());
      });
    else if (w.length) {
      const N = w.split(";");
      x = [], N.map(function(D) {
        D.trim().length && x.push(D.trim());
      }), x.map(function(D) {
        let b = D.split(" "), C = b[b.length - 1];
        if (C.length && (C[C.length - 1] === ":" && (d = !0, C = C.substring(0, C.length - 1), b[b.length - 1] = C), b.length)) {
          let A = "GATE";
          (b[0] === "DEFGATE" || b[0] === "DEFCIRCUIT") && (A = b[0], b.splice(0, 1));
          let T = b.join(" "), _ = [];
          const O = T.indexOf("(");
          if (O >= 0) {
            const B = T.indexOf(")");
            if (B > O) {
              if (_ = T.substring(O + 1, B).split(","), _.map(function(k, L) {
                for (k = k.trim(); k.length && k[0] === "%"; )
                  k = k.slice(1);
                _[L] = k;
              }), B + 1 <= T.length) {
                const k = T.substring(B + 1, T.length).split(" ");
                b = [], k.map(function(L) {
                  L = L.trim(), L.length && b.push(L);
                });
              } else
                b = [];
              T = T.substring(0, O).trim();
            }
          } else
            T = b.splice(0, 1)[0].trim();
          const I = [];
          for (let B = 0; B < b.length; B++) {
            const k = b[B];
            if (n) {
              const L = n.indexOf(k);
              L >= 0 ? I.push(L) : I.push(k);
            } else
              I.push(k);
          }
          g.push({
            type: A,
            name: T,
            params: _,
            args: I,
            body: [],
            line: E,
            col: 0
          });
        }
      });
    }
  });
  const y = g.length;
  for (let w = 0; w < y; w++) {
    const E = g[w];
    switch (i[E.name] && (E.name = i[E.name]), E.type) {
      case "DEFGATE":
        E.name === E.name.toUpperCase() && (o = E.name.toLowerCase(), i[E.name] = o, E.name = o);
        break;
      case "DEFCIRCUIT":
        {
          E.name === E.name.toUpperCase() && (o = E.name.toLowerCase(), i[E.name] = o, E.name = o);
          const x = E.body.join(`
`), N = E.args, D = new me();
          D.importQuil(
            x,
            e,
            r,
            N,
            i,
            E.line + 1
          ), D.params = JSON.parse(JSON.stringify(E.params)), l.registerGate(E.name, D.save());
        }
        break;
      case "GATE":
        switch (E.name) {
          case "DECLARE":
            break;
          case "HALT":
            break;
          case "PRAGMA":
            break;
          default: {
            const x = m(E.name);
            if (x) {
              const N = {};
              if (x.gateDef) {
                f = x.gateDef;
                const C = x.quilDef;
                if ((C.params || []).length !== (E.params || []).length)
                  if (c = "Invalid number of params. Expected " + (C.params || []).length + " got " + (E.params || []).length + ".", e) {
                    e([
                      {
                        msg: c,
                        line: a + E.line,
                        col: E.col
                      }
                    ]);
                    return;
                  } else
                    throw new Error(c);
                else
                  for (let A = 0; A < f.params.length; A++) {
                    u = f.params[A];
                    const T = C.params.indexOf(u);
                    if (T < 0 || T >= E.params.length)
                      if (c = 'Internal error: QUIL definition for gate "' + E.name + " is invalid.", e) {
                        e([
                          {
                            msg: c,
                            line: a + E.line,
                            col: E.col
                          }
                        ]);
                        return;
                      } else
                        throw new Error(c);
                    else
                      N[u] = E.params[T];
                  }
              } else if (f = x.customGate, (f.params || []).length !== (E.params || []).length)
                if (c = "Invalid number of params. Expected " + (f.params || []).length + " got " + (E.params || []).length + ".", e) {
                  e([
                    {
                      msg: c,
                      line: a + E.line,
                      col: E.col
                    }
                  ]);
                  return;
                } else
                  throw new Error(c);
              else
                for (let C = 0; C < f.params.length; C++)
                  u = f.params[C], N[u] = E.params[C];
              if (E.name === "MEASURE") {
                if (E.args.length !== 2)
                  if (c = "Expecting 2 arguments (qubit and target register) but found " + E.args.length + ".", e) {
                    e([
                      {
                        msg: c,
                        line: a + E.line,
                        col: E.col
                      }
                    ]);
                    return;
                  } else
                    throw new Error(c);
              } else {
                let C = 1;
                if (f.numQubits ? C = f.numQubits : f.matrix && f.matrix.length && (C = Ci(f.matrix.length)), E.args.length !== C)
                  if (c = "Expecting " + C + " arguments but found " + E.args.length + ".", e) {
                    e([
                      {
                        msg: c,
                        line: a + E.line,
                        col: E.col
                      }
                    ]);
                    return;
                  } else
                    throw new Error(c);
              }
              const D = [];
              let b = {};
              for (let C = 0; C < E.args.length; C++) {
                const A = E.args[C];
                if (E.name === "MEASURE") {
                  const T = A.indexOf("[");
                  if (T >= 0) {
                    const _ = A.indexOf("]");
                    if (_ > T) {
                      const O = A.substring(T + 1, _), I = A.substring(0, T);
                      b = {
                        bit: O,
                        name: I
                      };
                    }
                  } else {
                    if (s = parseInt(A), isNaN(s))
                      if (C > 0)
                        D.push(A);
                      else if (c = 'Invalid argument "' + A + '"', e) {
                        e([
                          {
                            msg: c,
                            line: a + E.line,
                            col: E.col
                          }
                        ]);
                        return;
                      } else
                        throw new Error(c);
                    D.push(s);
                  }
                } else {
                  if (s = parseInt(A), isNaN(s))
                    if (c = 'Invalid argument "' + A + '"', e) {
                      e([
                        {
                          msg: c,
                          line: a + E.line,
                          col: E.col
                        }
                      ]);
                      return;
                    } else
                      throw new Error(c);
                  D.push(s);
                }
              }
              l.appendGate(x.name, D, {
                params: N,
                creg: b
              });
            } else if (c = 'Cannot recognize "' + E.name + '".', e) {
              e([
                {
                  msg: c,
                  line: a + E.line,
                  col: E.col
                }
              ]);
              return;
            } else
              throw new Error(c);
          }
        }
        break;
    }
  }
  e && e([]);
};
me.prototype.importIonq = function(t, e) {
  const r = this, n = t.qubits || 1;
  if (r.init(n), !t.circuit) {
    const a = "Invalid file format.";
    if (e) {
      e([{ msg: a, line: -1, col: -1 }]);
      return;
    } else
      throw new Error(a);
  }
  function i(a) {
    if (r.customGates && r.customGates[a])
      return { name: a, customGate: r.customGates[a] };
    for (let o in r.basicGates) {
      const f = r.basicGates[o];
      if (f.exportInfo && f.exportInfo.ionq && (f.exportInfo.ionq.name && f.exportInfo.ionq.name === a || f.exportInfo.ionq.names && f.exportInfo.ionq.names.indexOf(a) >= 0))
        return { name: o, gateDef: f };
    }
    return null;
  }
  t.circuit.map(function(a) {
    let o;
    const f = i(a.gate);
    if (!f)
      if (o = 'Unknown gate "' + a.gate + '"', e) {
        e([{ msg: o, line: -1, col: -1 }]);
        return;
      } else
        throw new Error(o);
    let u = [];
    typeof a.control < "u" && u.push(a.control), typeof a.controls < "u" && (u = u.concat(a.controls)), typeof a.target < "u" && u.push(a.target), typeof a.targets < "u" && (u = u.concat(a.targets));
    let s = [];
    typeof a.rotation < "u" && s.push(a.rotation), typeof a.phase < "u" && s.push(a.phase), typeof a.phases < "u" && (s = s.concat(a.phases));
    const c = f.gateDef ? f.gateDef.matrix ? Ci(f.gateDef.matrix.length) : 1 : f.customGate.numQubits || 1, l = f.gateDef ? f.gateDef.params || [] : f.customGate.params || [];
    if (u.length !== c)
      if (o = 'Gate "' + a.gate + '": invalid number of qubits. Expected ' + c + " but got " + u.length + ".", e) {
        e([{ msg: o, line: -1, col: -1 }]);
        return;
      } else
        throw new Error(o);
    if (s.length !== l.length)
      if (o = 'Gate "' + a.gate + '": invalid number of params. Expected ' + l.length + " but got " + s.length + ".", e) {
        e([{ msg: o, line: -1, col: -1 }]);
        return;
      } else
        throw new Error(o);
    const m = {};
    s.length && (m.params = {}, l.map(function(h, g) {
      m.params[h] = a.rotation ? s[g] : 2 * yi * s[g];
    })), r.appendGate(f.name, u, m);
  }), e && e([]);
};
me.prototype.exportToIonq = function() {
  let t, e = this.options && this.options.params ? this.options.params : {};
  e = JSON.parse(JSON.stringify(e));
  for (let a in e)
    e[a] = Nr(e[a]);
  const r = new me();
  r.load(this.save(!0));
  const n = {
    qubits: r.numQubits,
    circuit: []
  }, i = r.numCols();
  for (let a = 0; a < i; a++)
    for (let o = 0; o < r.numQubits; o++) {
      const f = r.getGateAt(a, o);
      if (f && f.connector === 0) {
        const u = r.getGateDef(f.name);
        u.exportInfo && u.exportInfo.ionq ? u.exportInfo.ionq.name || u.exportInfo.ionq.names ? (t = {
          gate: u.exportInfo.ionq.name || u.exportInfo.ionq.names[0]
        }, u.params && u.params.length && (t[u.exportInfo.ionq.paramsKey] = [], u.params.map(function(s) {
          let c = Nr(
            f.options.params[s],
            e
          );
          u.exportInfo.ionq.paramsKey !== "rotation" && (c = c / (2 * yi)), t[u.exportInfo.ionq.paramsKey].push(c);
        })), n.circuit.push(t)) : (t = {
          gate: 'Export gate "' + f.name + '" to IONQ not supported yet. Comming soon.'
        }, n.circuit.push(t)) : (t = {
          gate: 'Export gate "' + f.name + '" to IONQ not supported yet. Comming soon.'
        }, n.circuit.push(t));
      }
    }
  return n;
};
me.prototype.exportQuirk = function(t) {
  let e, r, n, i, a, o, f;
  const u = this;
  let s = null;
  function c(b) {
    const C = [];
    for (let A = 0; A < b; A++)
      C.push(A);
    return C;
  }
  function l(b, C) {
    return C.indexOf(b) > -1;
  }
  t = !0;
  const m = this.save(t);
  s = new me();
  const h = new me();
  s.load(m), h.load(m);
  const g = {
    cols: [],
    gates: []
  };
  let d = null;
  const y = this.options && this.options.params ? this.options.params : {}, w = new me(), E = {};
  if (!t) {
    for (f = h.numCols(), o = f - 1; o >= 0; o--)
      for (a = 0; a < h.numQubits; a++)
        if (i = h.gates[a][o], i && i.connector === 0 && !h.basicGates[i.name]) {
          let b = h.decomposeGateAt(o, a), C = !1;
          E[i.name] = {
            info: [],
            isDecomposeCustomCircuit: null
          };
          for (let A = 0; A < b.numCols(); A++)
            for (let T = 0; T < b.numQubits; T++) {
              const _ = b.getGateAt(
                A,
                T
              );
              if (_) {
                const O = b.basicGates[_.name];
                O.exportInfo && !O.exportInfo.quirk && (C = C || !0), _.connector === 0 && E[i.name].info.push({
                  gateInCustomCircuit: _,
                  column: o
                });
              }
              E[i.name].isDecomposeCustomCircuit = C;
            }
          C && s.gates.map(function(A) {
            A.map(function(T) {
              T && T.name === i.name && s.removeGate(T.id);
            });
          });
        }
  }
  let x = Object.keys(E);
  for (let b = 0; b < x.length; b++) {
    let C = x[b];
    if (E[C].isDecomposeCustomCircuit)
      for (let A = E[C].info.length - 1; A >= 0; A--) {
        const T = E[C].info[A], _ = T.gateInCustomCircuit;
        s.insertGate(
          _.name,
          T.column,
          _.wires,
          _.options
        );
      }
  }
  let N = null, D = null;
  for (o = 0; o < f; o++)
    for (a = 0; a < s.numQubits; a++)
      i = s.getGateAt(o, a), i && (D && D.name !== i.name && D.connector !== 0 && N === o && (s.removeGate(i.id), s.insertGate(i.name, i.column + 1, i.wires, i.options)), D = i, N = o);
  for (f = s.numCols(), o = 0; o < f; o++) {
    const b = [];
    let C = [], A = !1;
    for (a = 0; a < s.numQubits; a++)
      if (i = s.getGateAt(o, a), !i || i.name === "measure" || i.name === "reset")
        (A || !l(a, C)) && b.push(1);
      else {
        const T = s.basicGates[i.name], _ = uo(i.wires), O = cg(i.wires), I = i.wires.slice();
        if (C = c(_), T) {
          let B = "", k = !1;
          if (A = !0, T.exportInfo && T.exportInfo.quirk && (B = T.exportInfo.quirk.name, k = T.exportInfo.quirk.controlled), T.matrix.length === 4 && (B && i.name === "swap" && i.connector < i.wires.length - 2 && k || i.name !== "swap" && i.connector < i.wires.length - 1 && k) && (B = "•"), T.matrix.length === 8 && (B && i.name === "cswap" && i.connector < i.wires.length - 2 && k || i.name !== "cswap" && i.connector < i.wires.length - 1 && k) && (B = "•"), B && b.push(B), !B) {
            B = "~" + i.name, T.params.length && i.options.params && T.params.map(function(R) {
              let Q = qt(
                Nr(i.options.params[R], y),
                7
              );
              B += "_" + Q;
            });
            let L = "";
            L += "{";
            const F = u.getRawGate(T, i.options), M = I.sort(), $ = [];
            if (i.wires.map(function(R) {
              $.push(M.indexOf(R));
            }), _ - O + 1 > i.wires.length || i.wires[0] > i.wires[1] ? d = s.transformMatrix(
              _ - O + 1,
              F,
              $
            ) : d = F, d.map(function(R, Q) {
              Q > 0 && (L += ","), L += "{", R.map(function(ee, j) {
                j > 0 && (L += ","), typeof ee != "object" ? ee = zt(ee).toString() : ee = ee.toString(), L += ee;
              }), L += "}";
            }), L += "}", i.connector === 0) {
              for (e = g.gates.find(function(R) {
                return R.id === B;
              }), e || g.gates.push({
                id: B,
                matrix: L
              }), n = !1, r = 0; r < b.length; r++)
                b[r] === B && (n = !0);
              n ? b.push(1) : b.push(B);
            } else if (a < i.wires[0]) {
              for (g.gates.push({
                id: B,
                matrix: L
              }), e = g.gates.find(function(R) {
                return R.id === B;
              }), e || g.gates.push({
                id: B,
                matrix: L
              }), n = !1, r = 0; r < b.length; r++)
                b[r] === B && (n = !0);
              n ? b.push(1) : b.push(B);
            }
          }
        } else {
          const B = [];
          if (A = !1, i.connector === 0) {
            if (!w.gates.find(
              function(L) {
                return L && L[0] && L[0].name === i.name;
              }
            )) {
              const L = i.wires[0];
              i.wires.map(function(F) {
                B.push(F - L);
              }), w.registerGate(i.name, u.customGates[i.name]), w.appendGate(i.name, B);
            }
            b.push("~" + i.name);
          } else
            b.push(1);
        }
      }
    g.cols.push(b);
  }
  return t || s.usedGates().map(function(C) {
    if (!s.basicGates[C] && u.customGates[C]) {
      const _ = new me();
      for (let O = 0; O < w.numCols(); O++) {
        let I;
        for (I = 0; I < w.numGates(); I++) {
          const B = w.getGateAt(O, I);
          if (B && B.name === C) {
            let k = w.decomposeGateAt(
              O,
              I
            );
            _.load(k);
          }
        }
      }
      g.gates.push({
        id: "~" + C,
        circuit: _.exportQuirk(!0)
      });
    }
  }), g;
};
me.prototype.exportCirq = function(t, e, r, n, i, a, o) {
  const f = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: i,
    shots: a,
    exportTfq: o
  };
  return this.exportToCirq(f, r);
};
me.prototype.exportQSharp = function(t, e, r, n, i, a, o) {
  const f = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: i,
    circuitName: a,
    indentDepth: o
  };
  return this.exportToQSharp(f, r);
};
me.prototype.exportQobj = function(t, e, r, n) {
  const i = {
    circuitName: t,
    experimentName: e,
    numShots: r
  };
  return this.exportToQobj(i, n);
};
me.prototype.importQobj = function(t, e) {
  let r, n, i;
  const a = this;
  if (this.init(), !t || !t.experiments || !t.experiments.length) {
    e && e([{ msg: "Invalid input file: no experiments found." }]);
    return;
  }
  const o = t.experiments[0], f = o.header || {};
  this.init(parseInt(f.n_qubits || 0));
  const u = {};
  if (f.creg_sizes && f.creg_sizes.length) {
    let m = 0;
    for (let h = 0; h < f.creg_sizes.length; h++) {
      const g = f.creg_sizes[h];
      if (g.length > 1) {
        const d = g[0] + "", y = parseInt(g[1]);
        this.createCreg(d, y);
        const w = (1 << m + y) - (1 << m);
        u[d] = {
          mask: w,
          offset: m
        }, m += y;
      }
    }
  }
  function s(m, h) {
    for (let g in u) {
      const d = u[g];
      if (d.mask === m)
        return {
          creg: g,
          value: h >> d.offset
        };
    }
  }
  function c(m) {
    let h = 0;
    for (let g in a.cregs) {
      const d = a.cregs[g];
      if (h + d.length > m)
        return {
          name: g,
          bit: m - h
        };
      h += d.length;
    }
    return null;
  }
  const l = {};
  for (let m = 0; m < o.instructions.length; m++) {
    const h = o.instructions[m];
    switch (h.name) {
      case "bfunc":
        {
          if (i = s(
            parseInt(h.mask),
            parseInt(h.val)
          ), !i)
            if (n = "Invalid classical condition.", e) {
              e([{ msg: n }]);
              return;
            } else
              throw new Error(n);
          l[h.register] = i;
        }
        break;
      case "measure":
        for (let g = 0; g < h.qubits.length; g++) {
          const d = h.qubits[g], y = h.memory[g], w = c(y);
          if (!w)
            if (n = "Invalid measurement destination.", e) {
              e([{ msg: n }]);
              return;
            } else
              throw new Error(n);
          r = { creg: w }, this.appendGate("measure", d, r);
        }
        break;
      case "barrier":
        break;
      default: {
        r = {
          params: {},
          condition: {}
        };
        let g = h.name;
        switch (g) {
          case "iden":
            g = "id";
            break;
        }
        const d = this.basicGates[g];
        if (!d)
          if (n = 'Unknown gate "' + h.name + '".', e) {
            e([{ msg: n }]);
            return;
          } else
            throw new Error(n);
        if (d.params && d.params.length) {
          if (!h.params || !h.params.length || h.params.length !== d.params.length)
            if (n = 'Invalid number of params for gate "' + h.name + '".', e) {
              e([{ msg: n }]);
              return;
            } else
              throw new Error(n);
          for (let y = 0; y < d.params.length; y++) {
            const w = d.params[y];
            r.params[w] = h.params[y];
          }
        }
        if (typeof h.conditional < "u") {
          if (i = l[h.conditional], !i)
            if (n = "Invalid classical condition.", e) {
              e([{ msg: n }]);
              return;
            } else
              throw new Error(n);
          r.condition = i;
        }
        this.appendGate(g, h.qubits, r);
      }
    }
  }
  e && e([]);
};
me.prototype.exportTFQ = function(t, e, r, n, i, a) {
  const o = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: i,
    shots: a
  };
  return this.exportToTFQ(o, r);
};
me.prototype.exportBraket = function(t, e, r, n, i, a, o, f) {
  const u = {
    comment: t,
    decompose: e,
    versionStr: n,
    asJupyter: i,
    shots: a,
    hybrid: o,
    indentDepth: f
  };
  return this.exportToBraket(u, r);
};
me.prototype.exportSVG = function(t, e) {
  const r = e || {};
  return r.embedded = !!t, this.exportToSVG(r);
};
me.prototype.exportToSVG = function(t) {
  let e, r, n, i, a, o, f;
  const u = this, s = t || {};
  s.embedded = s.embedded || !1, s.cellWidth = s.cellWidth || 40, s.cellHeight = s.cellHeight || 40, s.hSpacing = s.hSpacing || 28, s.vSpacing = s.vSpacing || 34, s.blackboxPaddingX = s.blackboxPaddingX || 2, s.blackboxPaddingY = s.blackboxPaddingY || 2, s.blackboxLineColor = s.blackboxLineColor || "black", s.blackboxSelectedLineColor = s.blackboxSelectedLineColor || "black", s.wireColor = s.wireColor || "black", s.gateLineColor = s.gateLineColor || "black", s.gateSelectedLineColor = s.gateSelectedLineColor || "black", s.cWireColor = s.cWireColor || "silver", s.cWireSelectedColor = s.cWireSelectedColor || "silver", s.cArrowSize = s.cArrowSize || 10, s.hWireColor = s.hWireColor || "black", s.wireWidth = s.wireWidth || 1, s.wireTextHeight = s.wireTextHeight || 8, s.wireTextDown = s.wireTextDown || 16, s.wireMargin = s.wireMargin || 20, s.wireLabelWidth = s.wireLabelWidth || 40, s.dotRadius = s.dotRadius || 5, s.paramTextHeight = s.paramTextHeight || 6, s.selectionPaddingX = s.selectionPaddingX || 4, s.selectionPaddingY = s.selectionPaddingY || 4, s.selectionLineColor = s.selectionLineColor || "#2185D0", s.drawBlochSpheres = s.drawBlochSpheres || !1, typeof s.drawHybrid > "u" && (s.drawHybrid = this.options ? !!this.options.hybrid : !1);
  const c = function(X) {
    let te = 0;
    for (let ue in u.cregs) {
      if (ue === X)
        return te;
      te++;
    }
    return te;
  }, l = function(X) {
    return s.wireLabelWidth + (s.cellWidth + s.hSpacing) * X + s.hSpacing;
  }, m = function(X) {
    return (s.cellHeight + s.vSpacing) * X + s.vSpacing;
  }, h = this.numQubits, g = this.numCols(), d = this.cregCount();
  let y = g;
  s.drawBlochSpheres && y++;
  const w = y;
  s.drawHybrid && (y += 2);
  const E = l(y), x = l(w), N = (s.cellHeight + s.vSpacing) * (h + d + (s.drawHybrid ? 1 : 0)) + s.vSpacing, D = (s.cellHeight + s.vSpacing) * (h + d) + (s.vSpacing + s.cellHeight / 2);
  function b(X, te, ue, ce) {
    const se = (ce - 90) * Math.PI / 180;
    return {
      x: X + ue * Math.cos(se),
      y: te + ue * Math.sin(se)
    };
  }
  function C(X, te, ue, ce, se) {
    const he = b(X, te, ue, se), le = b(X, te, ue, ce);
    return [
      "M",
      he.x,
      he.y,
      "A",
      ue,
      ue,
      0,
      "0",
      0,
      le.x,
      le.y
    ].join(" ");
  }
  const A = function(X) {
    return (s.cellHeight + s.vSpacing) * X + (s.vSpacing + s.cellHeight / 2);
  }, T = function(X) {
    return (s.cellHeight + s.vSpacing) * X + s.vSpacing;
  }, _ = function(X) {
    return (s.cellHeight + s.vSpacing) * (h + c(X)) + (s.vSpacing + s.cellHeight / 2);
  };
  function O(X, te, ue, ce, se) {
    const he = s.cellWidth, le = s.cellHeight;
    let ve = "";
    return ve += '<rect class="qc-gate-box" x="' + X + '" y="' + te + '" width="' + he + '" height="' + le + '" stroke="' + (se ? s.gateSelectedLineColor : s.gateLineColor) + '" fill="white" stroke-width="1" />', ce && (ve += '<text class="qc-gate-label" x="' + (X + he / 2) + '" y="' + (te + le / 2) + '" dominant-baseline="middle" text-anchor="middle" fill="' + (se ? s.gateSelectedLineColor : s.gateLineColor) + '">' + ce + "</text>"), ve;
  }
  function I(X, te, ue, ce, se) {
    const he = s.cellWidth * 2, le = s.cellHeight;
    let ve = "";
    return ve += '<rect class="qc-gate-rect" x="' + X + '" y="' + te + '" width="' + he + '" height="' + le + '" stroke="' + s.gateLineColor + '" fill="white" stroke-width="1" />', ce && (ve += '<text class="qc-gate-label" x="' + (X + he / 2) + '" y="' + (te + le / 2) + '" dominant-baseline="middle" text-anchor="middle">' + ce + "</text>"), ve;
  }
  function B(X, te, ue, ce, se) {
    const he = X + s.cellWidth / 2, le = te + s.cellHeight / 2, ve = s.cellWidth * 0.8, Ee = s.cellHeight * 0.8, _e = X + (s.cellWidth - ve) / 2, V = te + (s.cellHeight - Ee) / 2;
    let J = "";
    return J += '<ellipse class="qc-gate-not" cx="' + he + '" cy="' + le + '" rx="' + ve / 2 + '" ry="' + Ee / 2 + '" stroke="' + (se ? s.gateSelectedLineColor : s.gateLineColor) + '" fill="white" stroke-width="1" />', ce && (J += '<text class="qc-gate-label" x="' + (_e + ve / 2) + '" y="' + (V + Ee / 2) + '" dominant-baseline="middle" text-anchor="middle">' + ce + "</text>"), J;
  }
  function k(X, te, ue, ce) {
    const se = X + s.cellWidth / 2, he = te + s.cellHeight / 2, le = s.cellWidth * 0.8, ve = s.cellHeight * 0.8, Ee = X + (s.cellWidth - le) / 2, _e = te + (s.cellHeight - ve) / 2;
    let V = "";
    return V += '<ellipse class="qc-gate-not" cx="' + se + '" cy="' + he + '" rx="' + le / 2 + '" ry="' + ve / 2 + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" fill="white" stroke-width="1" />', V += '<line class="qc-gate-not-line" x1="' + se + '" x2="' + se + '" y1="' + _e + '" y2="' + (_e + ve) + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" stroke-width="1" />', V += '<line class="qc-gate-not-line" x1="' + Ee + '" x2="' + (Ee + le) + '" y1="' + he + '" y2="' + he + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" stroke-width="1" />', V;
  }
  function L(X, te, ue, ce) {
    const se = s.cellWidth, he = s.cellHeight, le = X + se / 2, ve = te + he / 2, Ee = he / 5;
    let _e = "";
    return _e += '<rect class="qc-gate-box" x="' + X + '" y="' + te + '" width="' + se + '" height="' + he + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" fill="white" stroke-width="1" />', _e += '<path class="gc-gate-gauge-arc" d="' + C(le, ve + Ee, se / 2.3, 300, 60) + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" fill="none" stroke-width="1" />', _e += '<line class="qc-gate-gauge-scale" x1="' + le + '" x2="' + (X + se - Ee) + '" y1="' + (ve + Ee) + '" y2="' + (te + Ee) + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" stroke-width="1" />', _e;
  }
  function F(X, te, ue, ce) {
    const se = s.cellWidth * 0.4, he = s.cellHeight * 0.4, le = X + (s.cellWidth - se) / 2, ve = te + (s.cellHeight - he) / 2;
    let Ee = "";
    return Ee += '<line class="qc-gate-x" x1="' + le + '" x2="' + (le + se) + '" y1="' + ve + '" y2="' + (ve + he) + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" stroke-width="1" />', Ee += '<line class="qc-gate-x" x1="' + le + '" x2="' + (le + se) + '" y1="' + (ve + he) + '" y2="' + ve + '" stroke="' + (ce ? s.gateSelectedLineColor : s.gateLineColor) + '" stroke-width="1" />', Ee;
  }
  function M(X, te, ue, ce) {
    const se = s.cellWidth, he = s.cellHeight, le = X + se / 2, ve = te + he / 2;
    let Ee = "";
    return Ee += '<circle class="qc-gate-dot" cx="' + le + '" cy="' + ve + '" r="' + s.dotRadius + '" stroke="' + (ce ? s.gateSelectedLineColor : s.wireColor) + '" fill="' + (ce ? s.gateSelectedLineColor : s.wireColor) + '" stroke-width="1" />', Ee;
  }
  function $(X, te, ue, ce) {
    const se = s.cellWidth, he = s.cellHeight, le = X + se / 2, ve = te + he / 2;
    let Ee = "";
    return Ee += '<circle class="qc-gate-ndot" cx="' + le + '" cy="' + ve + '" r="' + s.dotRadius + '" stroke="' + (ce ? s.gateSelectedLineColor : s.wireColor) + '" fill="white" stroke-width="1" />', Ee;
  }
  function R(X, te, ue, ce, se, he, le) {
    let ve = "";
    switch (se !== "box" && he && (ve += O(X, te, ue, "", le)), se) {
      case "box":
        ve += O(X, te, ue, ce, le);
        break;
      case "rect":
        ve += I(X, te, ue, ce);
        break;
      case "circle":
        ve += B(X, te, ue, ce, le);
        break;
      case "not":
        ve += k(X, te, ue, le);
        break;
      case "x":
        ve += F(X, te, ue, le);
        break;
      case "dot":
        ve += M(X, te, ue, le);
        break;
      case "ndot":
        ve += $(X, te, ue, le);
        break;
      case "gauge":
        ve += L(X, te, ue, le);
        break;
    }
    return ve;
  }
  function Q(X, te) {
    let ue, ce, se, he, le, ve, Ee, _e, V = u.basicGates[X.name] ? u.basicGates[X.name].drawingInfo : null;
    V || (V = u.customGates[X.name] ? u.customGates[X.name].drawingInfo : null);
    let J = !1;
    const ye = s && s.selection && s.selection.indexOf(X.id) >= 0;
    for (V || (X.wires.length === 1 ? V = { connectors: ["box"] } : (V = { connectors: [] }, J = !0)); V.connectors.length < X.wires.length; )
      V.connectors.push("box");
    const K = Math.min.apply(null, X.wires), ae = Math.max.apply(null, X.wires);
    let de = _(ae), xe = "";
    xe += '<g class="qc-gate-group" data-id="' + X.id + '" data-gate="' + X.name + '">', J && (le = l(te) - s.blackboxPaddingX, ue = T(K) - s.blackboxPaddingY, ce = s.cellWidth + 2 * s.blackboxPaddingX, se = T(ae) + s.cellHeight - ue + s.blackboxPaddingY, he = le + ce / 2, de = ue + se, xe += '<text class="qc-blackbox-label" x="' + he + '" y="' + (ue - s.wireTextHeight - s.blackboxPaddingY * 2) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">' + (V.label || X.name) + "</text>", xe += '<rect class="qc-gate-blackbox" x="' + le + '" y="' + ue + '" width="' + ce + '" height="' + se + '" stroke="' + (ye ? s.blackboxSelectedLineColor : s.blackboxLineColor) + '" fill="transparent" stroke-width="1" />'), ye && (le = l(te) - s.selectionPaddingX, ue = T(K) - s.selectionPaddingY, ce = s.cellWidth + 2 * s.selectionPaddingX, se = T(ae) + s.cellHeight - ue + s.selectionPaddingY, de = ue + se, xe += '<rect class="qc-gate-selection" x="' + le + '" y="' + ue + '" width="' + ce + '" height="' + se + '" stroke="' + s.selectionLineColor + '" fill="transparent" stroke-dasharray="4" stroke-width="1" />'), K !== ae && !J && (_e = l(te) + s.cellWidth / 2, Ee = m(K) + s.cellHeight / 2, ve = m(ae) + s.cellHeight / 2, xe += '<line class="qc-gate-link" x1="' + _e + '" x2="' + _e + '" y1="' + Ee + '" y2="' + ve + '" stroke="' + (ye ? s.gateSelectedLineColor : s.wireColor) + '" stroke-width="1" />');
    const Ce = Math.max.apply(null, X.wires);
    return X.wires.map(function(G, Z) {
      let ge, be, Se, De, Me;
      switch (V.connectors[Z]) {
        case "box":
          De = l(te), Me = m(G), xe = xe + O(
            De,
            Me,
            X.name,
            J ? dr(Z, h) : V.label || X.name,
            ye
          ), !J && G === ae && (de = Me + s.cellHeight);
          break;
        case "circle":
          De = l(te), Me = m(G), xe = xe + B(
            De,
            Me,
            X.name,
            J ? dr(Z, h) : V.label || X.name,
            ye
          ), !J && G === ae && (Se = s.cellHeight * 0.8, de = Me + Se + (s.cellHeight - Se) / 2);
          break;
        case "not":
          be = l(te), ge = m(G), xe = xe + k(be, ge, X.name, ye), !J && G === ae && (Se = s.cellHeight * 0.8, de = ge + Se + (s.cellHeight - Se) / 2);
          break;
        case "x":
          be = l(te), ge = m(G), xe = xe + F(be, ge, X.name, ye), !J && G === ae && (de = A(ae));
          break;
        case "dot":
          be = l(te), ge = m(G), xe = xe + M(be, ge, X.name, ye), !J && G === ae && (de = A(ae) + s.dotRadius);
          break;
        case "ndot":
          be = l(te), ge = m(G), xe = xe + $(be, ge, X.name, ye), !J && G === ae && (de = A(ae) + s.dotRadius);
          break;
        case "gauge":
          De = l(te), Me = m(G), xe = xe + L(De, Me, X.name, ye), !J && G === ae && (de = Me + s.cellHeight);
          break;
      }
      if (X.options && X.options.params && G === Ce) {
        De = l(te), Me = m(G);
        const Oe = De + s.cellWidth / 2;
        let Be = "", Ie = 0;
        for (let nt in X.options.params) {
          Be && (Be += ", ");
          let We = X.options.params[nt];
          typeof We == "string" && We.match(/^[+\-]?\d*\.?\d+(?:[Ee][+\-]?\d+)?$/) && (We = parseFloat(We)), typeof We == "number" && (We = qt(We, 3)), Be += We, Ie++;
        }
        Be.length > 26 && (Be = "(" + Ie + " params)"), xe += '<text class="qc-gate-params" x="' + Oe + '" y="' + (Me + s.cellHeight + s.paramTextHeight) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">' + Be + "</text>";
      }
    }), X.name === "measure" && X.options && X.options.creg && X.options.creg.name && (_e = l(te) + s.cellWidth / 2, Ee = de, ve = _(X.options.creg.name), xe += '<line class="qc-gate-link-c" x1="' + _e + '" x2="' + _e + '" y1="' + Ee + '" y2="' + ve + '" stroke="' + (ye ? s.cWireSelectedColor : s.cWireColor) + '" stroke-width="1" />', xe += '<line class="qc-gate-link-c" x2="' + _e + '" x1="' + (_e - s.cArrowSize / 2) + '" y1="' + (ve - s.cArrowSize) + '" y2="' + ve + '" stroke="' + (ye ? s.cWireSelectedColor : s.cWireColor) + '" stroke-width="1" />', xe += '<line class="qc-gate-link-c" x2="' + _e + '" x1="' + (_e + s.cArrowSize / 2) + '" y1="' + (ve - s.cArrowSize) + '" y2="' + ve + '" stroke="' + (ye ? s.cWireSelectedColor : s.cWireColor) + '" stroke-width="1" />', xe += '<text class="qc-wire-label" x="' + _e + '" y="' + (ve + s.wireTextHeight) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">' + X.options.creg.bit + "</text>"), X.options && X.options.condition && X.options.condition.creg && (_e = l(te) + s.cellWidth / 2, Ee = de, ve = _(X.options.condition.creg), xe += '<line class="qc-gate-link-c" x1="' + _e + '" x2="' + _e + '" y1="' + Ee + '" y2="' + ve + '" stroke="' + (ye ? s.cWireSelectedColor : s.cWireColor) + '" stroke-width="1" />', xe += '<circle class="qc-gate-dot-c" cx="' + _e + '" cy="' + ve + '" r="' + s.dotRadius + '" stroke="' + (ye ? s.cWireSelectedColor : s.cWireColor) + '" fill="' + (ye ? s.cWireSelectedColor : s.cWireColor) + '" stroke-width="1" />', xe += '<text class="qc-wire-label" x="' + _e + '" y="' + (ve + s.wireTextHeight) + '" dominant-baseline="hanging" text-anchor="middle" font-size="75%">== ' + X.options.condition.value + "</text>"), xe += "</g>", xe;
  }
  function ee(X, te) {
    let ue = "", ce = s.cellWidth + s.hSpacing, se = s.cellHeight + s.vSpacing;
    const he = l(X) - s.hSpacing, le = m(te) - s.vSpacing;
    return te === h && (se = s.vSpacing), X === g && (ce = s.hSpacing), ue += '<rect class="qc-gate-placeholder" data-row="' + te + '" data-col="' + X + '" x="' + he + '" y="' + le + '" width="' + ce + '" height="' + se + '" stroke="none" fill="transparent" stroke-width="0" />', ue;
  }
  function j(X, te, ue) {
    let ce = "";
    const se = s.cellWidth, he = s.cellHeight, le = l(te), ve = m(ue);
    return ce += '<rect class="qc-gate-handle" data-id="' + X.id + '" data-gate="' + X.name + '" data-row="' + ue + '" data-col="' + te + '" x="' + le + '" y="' + ve + '" width="' + se + '" height="' + he + '" stroke="none" fill="transparent" stroke-width="0" />', ce;
  }
  function U(X, te, ue, ce) {
    let se = "";
    const he = s.cellWidth, le = s.cellHeight, ve = l(X), Ee = m(te);
    return se += '<g class="' + ue + '" data-row="' + te + '">', se += '<rect class="qc-canvas-box" x="' + ve + '" y="' + Ee + '" width="' + he + '" height="' + le + '" stroke="transparent" fill="white" stroke-width="1" />', se += '<foreignObject class="qc-canvas-object" x="' + ve + '" y="' + Ee + '" width="' + he + '" height="' + le + '">', se += '<div style="position:relative;">', se += '<canvas id="' + ce + "-" + te + '" class="' + ce + '" width="' + he + '" height="' + le + '">', se += "</canvas>", se += "</div>", se += "</foreignObject>", se += "</g>", se;
  }
  function pe(X) {
    return X.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  if (s.gateGallery || s.gateGalleryRaw || s.customGateGallery) {
    const X = [];
    if (s.gateGallery || s.gateGalleryRaw) {
      const te = [];
      for (let se in this.basicGates) {
        o = this.basicGates[se];
        const he = JSON.parse(
          JSON.stringify(o.drawingInfo || { connectors: ["box"] })
        );
        if (he.connectors) {
          const le = he.label || se;
          let ve = he.connectors ? he.connectors[he.connectors.length - 1] : "box";
          s.gateGallery && (ve === "x" || ve === "dot") && (ve = "box");
          const Ee = le + "|" + ve;
          te.indexOf(Ee) < 0 && se !== "ccx" && (te.push(Ee), a = "", s.embedded || (a += '<?xml version="1.0"?>', a += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), a += '<svg class="qc-gate-gallery-item" data-gate="' + pe(se) + '" data-content="' + pe(o.description) + '" width="' + s.cellWidth + '" height="' + s.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', a = a + R(
            0,
            0,
            se,
            le,
            ve,
            !!s.gateGallery,
            !1
          ), a += "</svg>", s.gateGallery ? X.push(a) : X.push({ name: se, svg: a }));
        }
      }
      let ue = "";
      s.embedded || (ue += '<?xml version="1.0"?>', ue += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), ue += '<svg class="qc-gate-gallery-item" data-gate="dot" data-content="Control" width="' + s.cellWidth + '" height="' + s.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', ue = ue + R(0, 0, "dot", "dot", "dot", !!s.gateGallery, !1), ue += "</svg>", s.gateGallery ? X.push(ue) : X.push({ name: "dot", svg: ue });
      let ce = "";
      s.embedded || (ce += '<?xml version="1.0"?>', ce += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), ce += '<svg class="qc-gate-gallery-item" data-gate="ndot" data-content="Control" width="' + s.cellWidth + '" height="' + s.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', ce = ce + R(0, 0, "ndot", "ndot", "ndot", !!s.gateGallery, !1), ce += "</svg>", s.gateGallery ? X.push(ce) : X.push({ name: "dot", svg: ce });
    }
    if (s.customGateGallery)
      for (f in this.customGates)
        a = "", s.embedded || (a += '<?xml version="1.0"?>', a += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), a += '<svg class="qc-custom-gate-gallery-item" data-gate="' + f + '" width="' + s.cellWidth * 2 + '" height="' + s.cellHeight + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', a = a + R(0, 0, f, f, "rect", !1, !1), a += "</svg>", X.push(a);
    return X;
  } else {
    if (a = "", s.embedded || (a += '<?xml version="1.0"?>', a += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">'), a += '<svg class="qc-circuit" width="' + E + '" height="' + N + '" version="1.1" xmlns="http://www.w3.org/2000/svg">', s.placeholders)
      for (n = 0; n <= g; n++)
        for (i = 0; i <= this.numQubits; i++)
          a += ee(n, i);
    for (i = 0; i < h; i++) {
      r = A(i);
      let X = "0";
      s.customGate && (X = dr(i, h)), a += '<text class="qc-wire-init" x="0" y="' + r + '" dominant-baseline="middle" text-anchor="start">|' + X + "&#x27E9;</text>", a += '<line class="qc-wire" x1="' + s.wireMargin + '" x2="' + x + '" y1="' + r + '" y2="' + r + '" stroke="' + s.wireColor + '" stroke-width="' + s.wireWidth + '" />', a += '<text class="qc-wire-label" x="' + s.wireMargin + '" y="' + (r - s.wireTextHeight * 2) + '" dominant-baseline="hanging" text-anchor="start" font-size="75%">q' + i + "</text>";
    }
    for (const X in this.cregs)
      r = _(X), a += '<text class="qc-wire-init" x="0" y="' + r + '" dominant-baseline="middle" text-anchor="start">0</text>', a += '<line class="qc-wire-c" x1="' + s.wireMargin + '" x2="' + x + '" y1="' + r + '" y2="' + r + '" stroke="' + s.cWireColor + '" stroke-width="' + s.wireWidth + '" />', a += '<text class="qc-wire-label" x="' + s.wireMargin + '" y="' + (r - s.wireTextHeight * 2) + '" dominant-baseline="hanging" text-anchor="start" font-size="75%">' + X + "</text>";
    for (n = 0; n < g; n++)
      for (i = 0; i < this.numQubits; i++)
        o = this.getGateAt(n, i), o && o.connector === 0 && (a += Q(o, n));
    for (n = 0; n < g; n++)
      for (i = 0; i < this.numQubits; i++)
        o = this.getGateAt(n, i), o && s.placeholders && (a += j(o, n, i));
    if (s.drawBlochSpheres)
      for (e = y - 1, s.drawHybrid && (e -= 2), i = 0; i < this.numQubits; i++)
        a += U(
          e,
          i,
          "qc-bloch-group",
          "qc-bloch-canvas"
        );
    if (s.drawHybrid) {
      e = y - 2;
      const X = e, te = l(X) + s.blackboxPaddingX, ue = T(0) + s.blackboxPaddingY, ce = s.cellWidth - 2 * s.blackboxPaddingX, se = T(h + d - 1) + s.cellHeight - ue - s.blackboxPaddingY, he = te + ce / 2, le = ue + se / 2;
      let ve = ue + se;
      a += '<rect class="qc-cost-h" x="' + te + '" y="' + ue + '" width="' + ce + '" height="' + se + '" stroke="' + s.hWireColor + '" fill="white" stroke-width="1" rx="8" />', a += '<text class="qc-label-h" x="' + he + '" y="' + le + '" dominant-baseline="middle" text-anchor="middle" fill="' + s.hWireColor + '" transform="rotate(-90, ' + he + ", " + le + ')">Cost</text>';
      const Ee = l(X + 1) + s.blackboxPaddingX, _e = Ee + ce / 2;
      a += '<marker id="qc-arrow-head" orient="auto" markerWidth="8" markerHeight="10" refX="8" refY="5"><path d="M0,0 V10 L8,5 Z" fill="' + s.hWireColor + '"/></marker>', a += '<line class="qc-link-h" x1="' + (te + ce) + '" x2="' + Ee + '" y1="' + le + '" y2="' + le + '" stroke="' + s.hWireColor + '" stroke-width="' + s.wireWidth + '" marker-end="url(#qc-arrow-head)" />', a += '<rect class="qc-optimizer-h" x="' + Ee + '" y="' + ue + '" width="' + ce + '" height="' + se + '" stroke="' + s.hWireColor + '" fill="white" stroke-width="1" rx="8" />', a += '<text class="qc-label-h" x="' + _e + '" y="' + le + '" dominant-baseline="middle" text-anchor="middle" fill="' + s.hWireColor + '" transform="rotate(-90, ' + _e + ", " + le + ')">Optimizer</text>';
      const V = _e;
      a += '<line class="qc-wire-h" x1="' + V + '" x2="' + V + '" y1="' + ve + '" y2="' + D + '" stroke="' + s.hWireColor + '" stroke-dasharray="4" stroke-width="1" />';
      let J;
      const ye = this.findGlobalParams();
      if (ye.globalParams.length) {
        J = l(ye.cells[0][0]) + s.cellWidth + s.hSpacing / 2;
        for (let K = 0; K < ye.cells.length; K++) {
          const ae = ye.cells[K], de = l(ae[0]) + s.cellWidth + s.hSpacing / 2, xe = m(ae[1]) + s.cellHeight + s.vSpacing - s.paramTextHeight / 2, Ce = D, G = l(ae[0]) + s.cellWidth, Z = m(ae[1]) + s.cellHeight + s.paramTextHeight * 2 + 4;
          a += '<line class="qc-wire-h" x1="' + de + '" x2="' + de + '" y1="' + Ce + '" y2="' + xe + '" stroke="' + s.hWireColor + '" stroke-dasharray="4" stroke-width="1" />', a += '<line class="qc-wire-h" x1="' + de + '" x2="' + G + '" y1="' + xe + '" y2="' + Z + '" stroke="' + s.hWireColor + '" stroke-dasharray="4" stroke-width="1" marker-end="url(#qc-arrow-head)" />';
        }
        r = D, a += '<line class="qc-wire-h" x1="' + J + '" x2="' + _e + '" y1="' + r + '" y2="' + r + '" stroke="' + s.hWireColor + '" stroke-dasharray="4" stroke-width="' + s.wireWidth + '" />';
      } else
        J = l(w + 1), r = D, a += '<line class="qc-wire-h" x1="' + _e + '" x2="' + J + '" y1="' + r + '" y2="' + r + '" stroke="' + s.hWireColor + '" stroke-dasharray="4" stroke-width="' + s.wireWidth + '"  marker-end="url(#qc-arrow-head)" />', a += '<text class="qc-warning-params-h" x="' + (J - 5) + '" y="' + r + '" dominant-baseline="middle" text-anchor="end">(no global params)</text>';
    }
    a += "</svg>";
  }
  return a;
};
me.prototype.exportToQiskit = function(t, e, r, n) {
  let i, a, o, f, u, s, c, l;
  t = t || {};
  const m = t.comment, h = t.decompose, g = t.versionStr;
  let d = t.providerName, y = t.backendName;
  const w = t.asJupyter;
  let E = t.shots, x = t.hybrid;
  typeof x > "u" && (x = this.options ? !!this.options.hybrid : !1);
  let N = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
  const D = this;
  d = d || "Aer", y = y || "", d === "Aer" && (y || (x && N.indexOf("state") >= 0 ? y = "statevector_simulator" : y = "qasm_simulator"), y === "aer_simulator" && (y = "qasm_simulator"), y === "aer_simulator_statevector" && (y = "statevector_simulator")), d === "IONQ" && (y || (y = "ionq_simulator")), E = E || 1024;
  const b = new me();
  b.load(this.save(h));
  let C = "";
  m && (m || "").split(`
`).map(function(I) {
    I.length >= 1 && I[0] !== "#" && (C += "# "), C += I, C += `
`;
  });
  const A = function(O, I) {
    if (O.isSymbolNode) {
      if (["pi", "sin", "cos", "tan", "asin", "acos", "atan"].indexOf(O.name) >= 0)
        return "np." + O.name;
      let k = O.name;
      if (I.replaceVars && typeof I.replaceVars[k] < "u")
        return k = I.replaceVars[k], D.params.indexOf(k) >= 0 && x ? "params[" + D.params.indexOf(k) + "]" : k;
      if (D.params.indexOf(O.name) >= 0 && x)
        return "params[" + D.params.indexOf(O.name) + "]";
    }
  }, T = function(O, I) {
    let B = "";
    const k = O.split(`
`);
    let L = -1;
    k.map(function(M) {
      const $ = M.search(/\S/);
      $ >= 0 && (L < 0 || $ < L) && (L = $);
    }), L < 0 && (L = 0);
    let F = "";
    if (L < I.length)
      for (let M = 0; M < I.length - L; M++)
        F += " ";
    return k.map(function(M) {
      B += F + M + `
`;
    }), B;
  };
  if (e) {
    if (C += "def " + e + "(qc", b.params && b.params.length)
      for (let O = 0; O < b.params.length; O++)
        C += ", ", C += b.params[O];
    for (l = 0; l < b.numQubits; l++)
      C += ", ", C += dr(l, b.numQubits);
    C += `):
`;
  } else if (!r) {
    let O;
    const I = b.usedGates();
    switch (C += `from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
`, s = !1, c = !1, d) {
      case "Aer":
        C += "from qiskit import execute, " + d + `
`, x && N.indexOf("state") >= 0 && y !== "statevector_simulator" && (C += `from qiskit_experiments.library import StateTomography
`);
        break;
      case "IBMQ":
        C += "from qiskit import execute, " + d + `
from qiskit.providers.ibmq import least_busy
`, x && N.indexOf("state") >= 0 && (C += `from qiskit_experiments.library import StateTomography
`);
        break;
      case "IONQ":
        s = !0, C += `from qiskit_ionq import IonQProvider
`, x && N.indexOf("state") >= 0 && (C += `from qiskit_experiments.library import StateTomography
`);
        break;
    }
    switch ((I.indexOf("ms") >= 0 || I.indexOf("gpi") >= 0 || I.indexOf("gpi2") >= 0) && (s = !0, C += `from qiskit_ionq import GPIGate, GPI2Gate, MSGate
`), s && (C += `from qiskit import transpile
`), x && (C += `from scipy.optimize import minimize
`, C += `from collections import Counter
`), C += `import numpy as np
`, C += `
`, u = "", d) {
      case "Aer":
        C += u + "backend = Aer.get_backend('" + y + `')
`, C += `
`;
        break;
      case "IBMQ":
        C += u + `IBMQ.load_account()
`, C += u + `provider = IBMQ.get_provider(hub="ibm-q", group="open", project="main")
`, y ? C += u + 'backend = provider.get_backend("' + y + `")
` : (C += u + `backends = provider.backends()
`, C += u + `backend = least_busy(backends)
`), C += `
`;
        break;
      case "IONQ":
        {
          const k = [
            "measure",
            "delay",
            "barrier",
            "reset",
            "snapshot",
            "ms",
            "gpi2",
            "gpi"
          ];
          c = !0, I.map(function(L) {
            k.indexOf(L) < 0 && (c = !1);
          }), C += u + `# Requires QISKIT_IONQ_API_TOKEN environment variable to be set
`, C += u + `provider = IonQProvider()
`, C += u + 'backend = provider.get_backend("' + y + '"', c && (C += ', gateset="native"'), C += `)

`;
        }
        break;
    }
    E && (C += "shots = " + E + `
`, C += `
`);
    const B = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (l = 0; l < this.params.length; l++) {
        const k = this.params[l];
        f = xt(B[k]);
        const L = f.toString({
          handler: A
        });
        C += k + " = " + L + `
`;
      }
      C += `
`;
    }
    x && (C += "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, C += `
`), h || I.map(function(k) {
      if (!b.basicGates[k]) {
        const F = D.customGates[k];
        if (F) {
          const M = new me();
          M.load(F);
          const $ = {
            comment: "",
            decompose: !0,
            versionStr: g,
            providerName: "",
            backendName: !1,
            asJupyter: !1,
            shots: !1,
            hybrid: null
          };
          C += M.exportToQiskit(
            $,
            k,
            r,
            n
          );
        }
      }
    }), x && (u = "  ", C += `def objective_function(params):
`), C += u + `qc = QuantumCircuit()
`, C += `
`, C += u + "q = QuantumRegister(" + b.numQubits + `, 'q')
`;
    for (O in this.cregs)
      C += u + O + " = ClassicalRegister(" + (this.cregs[O].length || 1) + ", '" + O + `')
`;
    C += `
`, C += u + `qc.add_register(q)
`;
    for (O in this.cregs)
      C += u + "qc.add_register(" + O + `)
`;
    C += `
`;
  }
  const _ = b.numCols();
  for (let O = 0; O < _; O++)
    for (let I = 0; I < this.numQubits; I++) {
      const B = b.getGateAt(O, I);
      let k = null, L = null, F = null;
      if (B && B.connector === 0 && (F = B.options && B.options.condition && B.options.condition.creg ? B.options.condition : null, o = b.getGateDef(B.name), o && o.exportInfo && !c && (o.exportInfo.qiskit && o.exportInfo.qiskit.replacement ? (k = o.exportInfo.qiskit.replacement, k.map(function(M) {
        const $ = new me();
        if (B.options && B.options.params) {
          const Q = Object.keys(B.options.params), ee = Object.keys(M.params);
          Q.map(function(j) {
            ee.indexOf(j) > -1 && (M.params[j] = B.options.params[j]);
          });
        }
        $.addGate(M.name, O, B.wires, {
          params: M.params,
          condition: F
        });
        const R = {
          comment: "",
          decompose: !1,
          versionStr: !1,
          providerName: !1,
          backendName: !1,
          asJupyter: !1,
          shots: !1,
          hybrid: null
        };
        C += T(
          $.exportToQiskit(
            R,
            !1,
            !0,
            !!e || n
          ),
          u
        );
      })) : o.exportInfo.qiskit && o.exportInfo.qiskit.equivalent && (L = o.exportInfo.qiskit.equivalent, L.map(function(M) {
        let $, R;
        const Q = new me(), ee = M.wires.length > 1 ? B.wires : B.wires[M.wires[0]], j = {};
        if (M.params) {
          const pe = {};
          if (B.options && B.options.params)
            for (let X in B.options.params)
              R = xt(B.options.params[X]), $ = R.toString({
                handler: A
              }), pe[X] = $;
          for (let X in M.params)
            R = xt(M.params[X]), $ = R.toString({
              handler: A,
              replaceVars: pe
            }), j[X] = $;
        }
        Q.addGate(M.name, O, ee, {
          params: j,
          condition: F
        });
        const U = {
          comment: "",
          decompose: !1,
          versionStr: !1,
          providerName: !1,
          backendName: !1,
          asJupyter: !1,
          shots: !1,
          hybrid: null
        };
        C += T(
          Q.exportToQiskit(
            U,
            !1,
            !0,
            !!e || n
          ),
          u
        );
      }))), !k && !L && (e || n || x) && (C += "  "), !k && !L)) {
        let M = B.name;
        const $ = B.options && B.options.params ? B.options.params : {};
        y === "statevector_simulator" && M === "measure" && x && (C += "# "), this.basicGates[M] && (C += "qc."), o && o.exportInfo && o.exportInfo.qiskit && o.exportInfo.qiskit.name ? M = o.exportInfo.qiskit.name : M = B.name;
        let R = !1, Q = !1;
        M === "ms" && (R = !0, Q = !0, M = "MSGate"), M === "gpi" && c && (R = !0, Q = !0, M = "GPIGate"), M === "gpi2" && c && (R = !0, Q = !0, M = "GPI2Gate"), R && (C += "append("), C += M + "(";
        let ee = 0;
        if ($ && (o = this.basicGates[B.name], o || (o = this.customGates[B.name], C += "qc", ee++), o)) {
          const j = o.params || [], U = j.length;
          if (U) {
            for (let pe = 0; pe < U; pe++) {
              ee > 0 && (C += ", ");
              const X = j[pe];
              if ($[X] || $[X].toString()) {
                f = xt($[X]);
                let te = f.toString({
                  handler: A
                });
                Q && (te = "(" + te + ") / (2*np.pi)"), C += te;
              }
              ee++;
            }
            M === "cu" && !$.gamma && (C += ", 0", ee++);
          }
        }
        if (R) {
          for (ee && (C += "), "), C += "[", a = 0; a < B.wires.length; a++)
            a > 0 && (C += ", "), e || n ? C += dr(B.wires[a], b.numQubits) : C += B.wires[a], ee++;
          C += "]";
        } else
          for (a = 0; a < B.wires.length; a++)
            ee > 0 && (C += ", "), e || n ? C += dr(B.wires[a], b.numQubits) : C += "q[" + B.wires[a] + "]", ee++;
        M === "measure" && B.options && B.options.creg && (ee > 0 && (C += ", "), C += B.options.creg.name + "[" + B.options.creg.bit + "]", ee++), C += ")", B.options && B.options.condition && B.options.condition.creg && (C += ".c_if(" + B.options.condition.creg + ", " + B.options.condition.value + ")"), C += `
`;
      }
    }
  if (!r) {
    if (e)
      C += `
`;
    else if (C += `
`, s && (C += u + `qc = transpile(qc, backend)
`), u = "", x && (u = "  "), d === "Aer" && (i = "", i += u + "job = execute(qc, backend=backend", E && (i += ", shots=shots"), i += `)
`, i += u + `job_result = job.result()
`, x ? (y === "statevector_simulator" ? (C += i, C += u + `state = job_result.get_statevector(qc).data
`, C += `
`) : N.indexOf("state") >= 0 ? (C += u + `qst = StateTomography(qc)
`, C += u + `qst_analysis = qst.run(backend).block_for_results()
`, C += u + `density = qst_analysis.analysis_results("state").value
`, C += u + `state = np.diag(density)
`) : (C += i, C += u + `counts = Counter(job_result.get_counts(qc))
`, C += `
`), N.trim() || (N = `# CALCULATE COST HERE
cost = 0`), C += T(N, u), C += `
`, C += u + `return cost
`) : (C += i, C += u + `print(job_result.get_counts(qc))
`)), d === "IBMQ" && (i = "", i += u + "job = execute(qc, backend=backend", E && (i += ", shots=shots"), i += `)
`, i += u + `job_result = job.result()
`, x ? (N.indexOf("state") >= 0 ? (C += u + `qst = StateTomography(qc)
`, C += u + `qst_analysis = qst.run(backend).block_for_results()
`, C += u + `density = qst_analysis.analysis_results("state").value
`, C += u + `state = np.diag(density)
`, C += `
`) : (C += i, C += u + `counts = Counter(job_result.get_counts(qc))
`, C += `
`), N.trim() || (N = `# CALCULATE COST HERE
cost = 0`), C += T(N, u), C += `
`, C += u + `return cost
`) : (C += i, C += u + `print(job_result.get_counts(qc))
`)), d === "IONQ" && (i = "", i += u + "job = backend.run(qc", E && (i += ", shots=shots"), i += `)
`, i += u + `job_result = job.result()
`, x ? (N.indexOf("state") >= 0 ? (C += u + `qst = StateTomography(qc)
`, C += u + `qst_analysis = qst.run(backend).block_for_results()
`, C += u + `density = qst_analysis.analysis_results("state").value
`, C += u + `state = np.diag(density)
`) : (C += i, C += u + `counts = Counter(job.get_counts())
`, C += `
`), N.trim() || (N = `# CALCULATE COST HERE
cost = 0`), C += T(N, u), C += `
`, C += u + `return cost
`) : (C += i, C += u + `print(job.get_counts())
`)), x) {
      let O = "";
      this.params.map(function(I, B) {
        B > 0 && (O += ", "), O += I;
      }), C += `
`, C += "params = np.array([" + O + `])
`, C += `
`, C += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, C += `print("cost:", minimum.fun, "params:", minimum.x)
`;
    }
    if (w)
      return JSON.stringify({
        metadata: {
          kernelspec: {
            display_name: "Python 3",
            language: "python",
            name: "python3"
          }
        },
        nbformat: 4,
        nbformat_minor: 0,
        cells: [
          {
            cell_type: "code",
            source: C,
            metadata: {},
            outputs: [],
            execution_count: null
          }
        ]
      });
  }
  return C;
};
me.prototype.exportToQuEST = function(t, e, r) {
  let n, i, a, o, f, u, s;
  t = t || {};
  const c = t.comment, l = t.decompose, m = this;
  r = r || [];
  let h = null;
  const g = ["unitary", "controlledUnitary"];
  h = new me(), h.load(this.save(l));
  let d = "";
  for (c && (c || "").split(`
`).map(function(E) {
    E.length >= 2 && E[0] !== "/" && E[1] !== "/" && (d += "// "), d += E, d += `
`;
  }), o = 0; o < this.numQubits; o++) {
    const w = this.gates[o];
    for (f = 0; f < w.length; f++)
      if (u = w[f], !(!u || !this.basicGates[u.name]) && this.basicGates[u.name].exportInfo && this.basicGates[u.name].exportInfo.quest) {
        if (s = this.basicGates[u.name].exportInfo.quest.name, r.includes(u.name))
          continue;
        (g.includes(s) || this.basicGates[u.name].exportInfo.quest.func) && r.push(u.name);
      }
  }
  if (e) {
    for (d += "Qureg " + e + "(Qureg qubits", o = 0; o < h.numQubits; o++)
      d += ", const int q", d += o;
    if (h.params && h.params.length)
      for (o = 0; o < h.params.length; o++)
        d += ", double " + h.params[o];
    d += `) {
`;
  } else {
    d += `#include <math.h>
#include "QuEST.h"

`, d += `#ifndef M_PI
#define M_PI 3.14159265
#endif

`;
    const w = [], E = h.usedGates();
    for (l || E.map(function(x) {
      if (!h.basicGates[x]) {
        const D = m.customGates[x];
        if (D) {
          const b = new me();
          b.load(D);
          const C = {
            comment: "",
            decompose: !1
          };
          w.push(
            b.exportToQuEST(C, x, r)
          );
        }
      }
    }), o = 0; o < r.length; o++)
      switch (a = r[o], s = this.basicGates[a].exportInfo.quest.name, s) {
        case "unitary":
        case "controlledUnitary":
          {
            let x = this.basicGates[a].exportInfo.quest.matrix;
            if (i = this.basicGates[a].exportInfo.quest.params, d += "void " + a + "(Qureg qubits, const int q", s === "controlledUnitary" && (d += "1, const int q2"), i)
              for (f = 0; f < i.length; f++)
                d += ", double " + i[f];
            d += `) {
`, d += `    ComplexMatrix2 u;
`, d += "    u.r0c0 = (Complex) {.real=" + x[0][0][0] + ", .imag= " + x[0][0][1] + `};
`, d += "    u.r0c1 = (Complex) {.real=" + x[0][1][0] + ", .imag= " + x[0][1][1] + `};
`, d += "    u.r1c0 = (Complex) {.real=" + x[1][0][0] + ", .imag= " + x[1][0][1] + `};
`, d += "    u.r1c1 = (Complex) {.real=" + x[1][1][0] + ", .imag= " + x[1][1][1] + `};
`, d += "    " + s + "(qubits, q", s === "controlledUnitary" && (d += "1, q2"), d += `, u);
}

`;
          }
          break;
        default:
          d += this.basicGates[a].exportInfo.quest.func + `

`;
          break;
      }
    for (o = 0; o < w.length; o++)
      d += w[o];
    d += `int main(int argc, char *argv[]) {
`, d += `    QuESTEnv env = createQuESTEnv();
`, d += "    Qureg qubits = createQureg(" + h.numQubits + `, env);
`, d += "    int measured[" + h.numQubits + `];

`;
  }
  d += `
`;
  const y = h.numCols();
  for (let w = 0; w < y; w++)
    for (let E = 0; E < this.numQubits; E++)
      if (u = h.getGateAt(w, E), u && u.connector === 0) {
        u.options && u.options.condition && u.options.condition.creg && (d += "if(" + u.options.condition.creg + "==" + u.options.condition.value + `) {
`), a = u.name;
        const x = u.options && u.options.params ? u.options.params : {};
        let N = this.basicGates[a];
        if (a === "measure")
          d += "    measured[" + u.wires[0] + "] = measure(qubits, " + u.wires[0];
        else if (N) {
          for (s = N.exportInfo.quest.name, i = N.exportInfo.quest.params, g.includes(s) ? d += "    " + a + "(qubits" : d += "    " + s + "(qubits", n = 0; n < u.wires.length; n++)
            e ? d += ", q" + u.wires[n] : d += ", " + u.wires[n];
          if (i)
            switch (s) {
              case "compactUnitary":
                d += ", " + i.alpha, d += ", " + i.beta;
                break;
              case "phaseShift":
              case "controlledPhaseShift":
                i.theta && (d += ", " + i.theta);
                break;
            }
        } else
          for (N = this.customGates[a], d += "    qubits = " + a + "(qubits", n = 0; n < u.wires.length; n++)
            d += ", " + u.wires[n];
        if (x && (N = this.basicGates[a], N || (N = this.customGates[a]), N)) {
          const D = N.params || [], b = D.length;
          if (b)
            for (let C = 0; C < b; C++) {
              const A = D[C];
              d += ", " + x[A];
            }
        }
        d += `);
`, u.options && u.options.condition && u.options.condition.creg && (d += `}
`);
      }
  return e ? d += `
    return qubits;
}

` : (d += `
    destroyQureg(qubits, env);
`, d += `    destroyQuESTEnv(env);
`, d += `    return 0;
}
`), d;
};
me.prototype.exportToQASM = function(t, e, r, n) {
  let i;
  t = t || {};
  const a = t.comment, o = t.decompose, f = t.compatibilityMode, u = this, s = this.options && this.options.params ? this.options.params : {}, c = function(g, d) {
    if (g.isSymbolNode) {
      let y = g.name;
      if (d.replaceVars && typeof d.replaceVars[y] < "u")
        return y = d.replaceVars[y], !f && u.params.indexOf(y) >= 0 ? "(" + s[y] + ")" : "(" + y + ")";
      if (!f && u.params.indexOf(g.name) >= 0)
        return s[g.name];
    }
  };
  let l = null;
  l = new me(), l.load(this.save(o));
  let m = "";
  if (a && (a || "").split(`
`).map(function(d) {
    d.length >= 2 && d[0] !== "/" && d[1] !== "/" && (m += "// "), m += d, m += `
`;
  }), e) {
    if (m += "gate " + e, l.params && l.params.length) {
      m += "(";
      for (let g = 0; g < l.params.length; g++)
        g > 0 && (m += ", "), m += l.params[g];
      m += ")";
    }
    for (let g = 0; g < l.numQubits; g++)
      g === 0 && (m += " "), g > 0 && (m += ", "), m += dr(g, l.numQubits);
    m += `
{
`;
  } else if (!r) {
    m += `OPENQASM 2.0;
`, m += `include "qelib1.inc";
`, m += "qreg q[" + l.numQubits + `];
`;
    for (let d in l.cregs)
      m += "creg " + d + "[" + (l.cregs[d].length || 1) + `];
`;
    const g = l.usedGates();
    o || g.map(function(d) {
      if (!l.basicGates[d]) {
        const w = u.customGates[d];
        if (w) {
          const E = new me();
          E.load(w);
          const x = {
            comment: "",
            decompose: !1,
            compatibilityMode: f
          };
          m += E.exportToQASM(
            x,
            d,
            !1,
            !1
          );
        }
      }
    });
  }
  const h = l.numCols();
  for (let g = 0; g < h; g++)
    for (let d = 0; d < l.numQubits; d++) {
      const y = l.getGateAt(g, d);
      let w = null, E = null;
      if (y && y.connector === 0) {
        let x = y.name;
        if (f || (i = l.getGateDef(y.name), i && i.exportInfo && (i.exportInfo.qasm && i.exportInfo.qasm.name ? x = i.exportInfo.qasm.name : i.exportInfo.qasm && i.exportInfo.qasm.replacement ? (w = i.exportInfo.qasm.replacement, w.map(function(N) {
          const D = new me();
          if (D.cregs = JSON.parse(JSON.stringify(u.cregs)), y.options && y.options.params) {
            const A = Object.keys(y.options.params), T = Object.keys(N.params);
            A.map(function(_) {
              T.indexOf(_) >= 0 && (N.params[_] = y.options.params[_]);
            });
          }
          const b = y.options && y.options.condition ? y.options.condition : {};
          D.addGate(N.name, g, y.wires, {
            params: N.params,
            condition: b
          });
          const C = {
            comment: "",
            decompose: !1,
            compatibilityMode: f
          };
          m += D.exportToQASM(
            C,
            !1,
            !0,
            !!e || n
          );
        })) : i.exportInfo.qasm && i.exportInfo.qasm.equivalent && (E = i.exportInfo.qasm.equivalent, E.map(function(N) {
          let D, b;
          const C = new me();
          C.cregs = JSON.parse(JSON.stringify(u.cregs));
          const A = N.wires.length > 1 ? y.wires : y.wires[N.wires[0]], T = {};
          if (N.params) {
            const I = {};
            if (y.options && y.options.params)
              for (let B in y.options.params)
                b = xt(y.options.params[B]), D = b.toString({
                  handler: c
                }), I[B] = D;
            for (let B in N.params)
              b = xt(N.params[B]), D = b.toString({
                handler: c,
                replaceVars: I
              }), T[B] = D;
          }
          const _ = y.options && y.options.condition ? y.options.condition : {};
          C.addGate(N.name, g, A, {
            params: T,
            condition: _
          });
          const O = {
            comment: "",
            decompose: !1,
            compatibilityMode: f
          };
          m += C.exportToQASM(
            O,
            "",
            !0,
            !!e || n
          );
        })))), !w && !E && ((e || n) && (m += "  "), y.options && y.options.condition && y.options.condition.creg && (m += "if(" + y.options.condition.creg + "==" + y.options.condition.value + ") ")), !w && !E || f) {
          const N = y.name, D = y.options && y.options.params ? y.options.params : {};
          if (m += f ? y.name : x, D && (i = l.basicGates[N], i || (i = l.customGates[N]), i)) {
            const b = i.params || [], C = b.length;
            if (C) {
              m += " (";
              for (let A = 0; A < C; A++) {
                A > 0 && (m += ", ");
                const T = b[A];
                let _ = D[T];
                !e && !n && !f && (_ = xt(D[T]).toString({
                  handler: c
                })), m += _;
              }
              m += ")";
            }
          }
          for (let b = 0; b < y.wires.length; b++)
            b > 0 && (m += ","), e || n ? m += " " + dr(y.wires[b], l.numQubits) : m += " q[" + y.wires[b] + "]";
          N === "measure" && y.options && y.options.creg && (m += " -> ", m += y.options.creg.name + "[" + y.options.creg.bit + "]"), m += `;
`;
        }
      }
    }
  return e && (m += `}

`), m;
};
me.prototype.exportToPyquil = function(t, e) {
  let r, n, i, a, o, f, u;
  t = t || {};
  const s = t.comment, c = t.decompose, l = t.versionStr, m = t.lattice, h = t.asQVM, g = t.asJupyter;
  let d = t.shots, y = t.hybrid;
  const w = this;
  let E = parseFloat(l || "2.12");
  isNaN(E) && (E = 2.1), d || (d = 1024), typeof y > "u" && (y = this.options ? !!this.options.hybrid : !1);
  const x = new me();
  x.load(this.save(c));
  const N = function(R) {
    if (R.isSymbolNode) {
      if (["pi", "sin", "cos", "tan", "asin", "acos", "atan"].indexOf(R.name) >= 0)
        return "np." + R.name;
      if (w.params.indexOf(R.name) >= 0 && y)
        return "params[" + w.params.indexOf(R.name) + "]";
    }
  }, D = function(R, Q) {
    let ee = "";
    const j = R.split(`
`);
    let U = -1;
    j.map(function(X) {
      const te = X.search(/\S/);
      te >= 0 && (U < 0 || te < U) && (U = te);
    }), U < 0 && (U = 0);
    let pe = "";
    if (U < Q.length)
      for (let X = 0; X < Q.length - U; X++)
        pe += " ";
    return j.map(function(X) {
      ee += pe + X + `
`;
    }), ee;
  };
  let b = "";
  const C = [];
  let A = "", T = "", _ = "", O = x.usedGates();
  const I = x.gotMeasurement(), B = [], k = [];
  O.map(function(R) {
    let Q, ee, j;
    const U = x.basicGates[R];
    if (U)
      if (U.exportInfo && U.exportInfo.pyquil)
        if (j = U.exportInfo.pyquil, j.array) {
          let pe = "";
          j.params && (pe += ", [", j.params.map(function(X, te) {
            te > 0 && (pe += ", "), pe += "p_" + X;
            const ue = "p_" + X + " = Parameter('" + X + "')";
            C.indexOf(ue) < 0 && C.push(ue);
          }), pe += "]"), T += "p.inst(" + j.name + `_defgate)
`, _ += j.name + "_array = np.array(" + j.array + `)
`, A += j.name + "_defgate = DefGate('" + j.name + "', " + j.name + "_array" + pe + `)
`, A += j.name + " = " + j.name + `_defgate.get_constructor()
`, B.push(j.name);
        } else
          ee = "", j.replacement ? (Q = x.basicGates[j.replacement.name], Q && Q.exportInfo && (Q.exportInfo.pyquil ? ee = Q.exportInfo.pyquil.name : Q.exportInfo.quil && (ee = Q.exportInfo.quil.name))) : ee = j.name, ee && (b && (b += ", "), b += ee);
      else
        U.exportInfo && U.exportInfo.quil && (j = U.exportInfo.quil, j.defgate || (ee = "", j.replacement ? (Q = x.basicGates[j.replacement.name], Q && Q.exportInfo && (Q.exportInfo.pyquil ? ee = Q.exportInfo.pyquil.name : Q.exportInfo.quil && (ee = Q.exportInfo.quil.name))) : ee = j.name, ee && (b && (b += ", "), b += ee)));
  });
  const L = x.gotClassicalControl();
  L && (b && (b += ", "), E < 2 ? b += "FALSE, NOT, OR, AND" : b += "MOVE, NOT, IOR, AND");
  let F = "";
  A && (E < 2.12 ? F = `from pyquil.parameters import Parameter, quil_sin, quil_cos, quil_sqrt, quil_exp, quil_cis
from pyquil.quilbase import DefGate` : F = `from pyquil.quilatom import Parameter, quil_sin, quil_cos, quil_sqrt, quil_exp, quil_cis
from pyquil.quilbase import DefGate`);
  let M = "";
  s && (s || "").split(`
`).map(function(Q) {
    Q.length >= 1 && Q[0] !== "#" && (M += "# "), M += Q, M += `
`;
  });
  let $ = "";
  if (e) {
    let R = "";
    for (u = 0, f = 0; f < x.params.length; f++)
      u > 0 && (R += ", "), R += x.params[f], u++;
    for (f = 0; f < x.numQubits; f++)
      u > 0 && (R += ", "), R += "q" + f, u++;
    M += "def " + e + (R ? "(" + R + ")" : "") + `:
`, $ = "  ";
  } else {
    E < 2 ? (M += `from pyquil.api import QVMConnection
`, M += `from pyquil.quil import Program
`) : M += `from pyquil import Program, get_qc
`, b && (M += "from pyquil.gates import " + b + `
`), F && (M += F + `
`), M += `from functools import reduce
`, y && (M += `from scipy.optimize import minimize
`, M += `from collections import Counter
`), M += `import numpy as np
`, d && (M += `
`, M += "shots = " + d + `
`);
    const R = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (M += `
`, f = 0; f < this.params.length; f++) {
        const Q = this.params[f];
        o = xt(R[Q]);
        const ee = o.toString({
          handler: N
        });
        M += Q + " = " + ee + `
`;
      }
      M += `
`;
    }
    y && (M += "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, M += `
`), A && (C.map(function(Q, ee) {
      ee === 0 && (M += `
`), M += Q + `
`;
    }), M += `
`, M += _ + `
`, M += `
`, M += A + `
`), M += `
`, O = x.usedGates(), c || O.map(function(Q) {
      if (!x.basicGates[Q]) {
        const j = w.customGates[Q];
        if (j) {
          const U = new me();
          U.load(j);
          const pe = {
            comment: "",
            decompose: !1,
            versionStr: l
          };
          M += U.exportToPyquil(pe, Q), k.push(Q);
        }
      }
    });
  }
  if (y && ($ += "  ", M += `def objective_function(params):
`), E >= 2 && !e) {
    h || m ? M += $ + `p = Program('PRAGMA INITIAL_REWIRING "PARTIAL"')

` : M += $ + `p = Program()

`;
    let R = x.cregTotalBits();
    L && (R += 1), R && (M += $ + "ro = p.declare('ro', memory_type='BIT', memory_size=" + R + `)
`, M += `
`);
  } else
    M += $ + `p = Program()

`;
  M += T ? $ + T + `
` : "";
  for (let R = 0; R < x.numCols(); R++)
    for (let Q = 0; Q < x.numQubits; Q++) {
      const ee = x.getGateAt(R, Q);
      if (ee && ee.connector === 0) {
        let j = x.getGateDef(ee.name), U = U = ee.options && ee.options.params ? ee.options.params : {}, pe = null;
        if (j) {
          j.exportInfo && (j.exportInfo.pyquil && j.exportInfo.pyquil.replacement ? (j.exportInfo.pyquil.replacement.params && (U = j.exportInfo.pyquil.replacement.params), j = x.getGateDef(j.exportInfo.pyquil.replacement.name)) : j.exportInfo.quil && j.exportInfo.quil.replacement && (j.exportInfo.quil.replacement.params && (U = j.exportInfo.quil.replacement.params), j = x.getGateDef(j.exportInfo.quil.replacement.name)), j && j.exportInfo && (j.exportInfo.pyquil ? pe = j.exportInfo.pyquil : j.exportInfo.quil && (pe = j.exportInfo.quil)));
          let X = !1;
          pe ? (X = B.indexOf(pe.name) >= 0, k.indexOf(pe.name) >= 0) : (X = B.indexOf(ee.name) >= 0, k.indexOf(ee.name) >= 0);
          let te = !1;
          if (ee.options && ee.options.condition && ee.options.condition.creg) {
            te = !0, M += `
`;
            const ce = w.cregTotalBits(), se = ee.options.condition, he = se.value || 0, le = w.cregBase(se.creg);
            if (he === 0) {
              const ve = w.cregs[se.creg].length;
              if (E < 2) {
                for (M += $ + "p.inst(FALSE(" + ce + `))
`, a = 0; a < ve; a++)
                  M += $ + "p.inst(OR(" + (a + le) + ", " + ce + `))
`;
                M += $ + "p.inst(NOT(" + ce + `))
`, M += $ + "p.if_then(" + ce + ", Program(";
              } else {
                for (M += $ + "p.inst(MOVE(ro[" + ce + `], 0))
`, a = 0; a < ve; a++)
                  M += $ + "p.inst(IOR(ro[" + ce + "], ro[" + (a + le) + `]))
`;
                M += $ + "p.inst(NOT(ro[" + ce + `]))
`, M += $ + "p.if_then(ro[" + ce + "], Program(";
              }
            } else {
              const ve = he.toString(2).split("").reverse();
              let Ee = 0, _e = 0;
              ve.map(function(V, J) {
                const ye = parseInt(V);
                ve[J] = ye, ye && (Ee++, _e = J);
              }), Ee === 1 ? E < 2 ? M += $ + "p.if_then(" + (_e + le) + ", Program(" : M += $ + "p.if_then(ro[" + (_e + le) + "], Program(" : E < 2 ? (M += $ + "p.inst(FALSE(" + ce + `))
`, i = !0, ve.map(function(V, J) {
                V && (i ? (i = !1, M += $ + "p.inst(OR(" + (J + le) + ", " + ce + `))
`) : M += $ + "p.inst(AND(" + (J + le) + ", " + ce + `))
`);
              }), M += $ + "p.if_then(" + ce + ", Program(") : (M += $ + "p.inst(MOVE(ro[" + ce + `], 0))
`, i = !0, ve.map(function(V, J) {
                V && (i ? (i = !1, M += $ + "p.inst(IOR(ro[" + ce + "], ro[" + (J + le) + `]))
`) : M += $ + "p.inst(AND(ro[" + ce + "], ro[" + (J + le) + `]))
`);
              }), M += $ + "p.if_then(ro[" + ce + "], Program(");
            }
          } else
            M += $ + "p.inst(";
          pe ? M += pe.name : M += ee.name;
          let ue = !1;
          if (pe && pe.params && pe.params.length) {
            for (u = 0, M += "(", ue = !0, n = 0; n < pe.params.length; n++)
              u > 0 && (M += ", "), typeof U[pe.params[n]] < "u" && (o = xt(String(U[pe.params[n]])), M += o.toString({ handler: N })), u++;
            E < 2 || X ? M += ")" : M += ", ";
          } else if (j && j.params && j.params.length) {
            for (u = 0, M += "(", ue = !0, n = 0; n < j.params.length; n++)
              u > 0 && (M += ", "), typeof U[j.params[n]] < "u" && (o = xt(U[j.params[n]]), M += o.toString({ handler: N })), u++;
            E < 2 || X ? M += ")" : M += ", ";
          }
          if (ee.wires.length) {
            u = 0, (E < 2 || !ue || X) && (M += "(", ue = !0);
            for (let ce = 0; ce < ee.wires.length; ce++)
              u > 0 && (M += ", "), e ? M += "q" + ee.wires[ce] : M += "" + ee.wires[ce], u++;
            if (ee.name === "measure" && ee.options && ee.options.creg) {
              let ce = parseInt(ee.options.creg.bit) || 0;
              isNaN(ce) && (ce = 0), u > 0 && (M += ", "), E < 2 ? M += ce + w.cregBase(ee.options.creg.name) : M += "ro[" + (ce + w.cregBase(ee.options.creg.name)) + "]", u++;
            }
            M += ")";
          }
          M += ")", te && (M += `)
`), M += `
`;
        } else
          M += $ + '# Export to pyquil WARNING: unknown gate "' + ee.name + '".';
      }
    }
  if (e)
    M += $ + `return p
`, M += `
`;
  else {
    if (M += `
`, E < 2)
      M += $ + `qvm = QVMConnection()
`, y ? (M += `
`, M += $ + `# CALCULATE COST HERE
`, r = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "", r.trim() || (r = "cost = 0"), M += D(r, $), M += `
`, M += $ + `return cost
`) : M += $ + `print(qvm.run(p))
`;
    else {
      d && (M += $ + `p.wrap_in_numshots_loop(shots)
`, M += `
`);
      let R = m;
      R || (E < 2.1 ? R = this.numQubits + "q-generic-qvm" : R = this.numQubits + "q-qvm"), M += $ + "qc = get_qc('" + R + "'" + (m ? ", as_qvm=" + (h ? "True" : "False") : "") + `)
`, m ? (M += $ + `ep = qc.compile(p)
`, I ? (M += $ + `results_list = qc.run(ep).readout_data.get("ro")
`, M += $ + `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1], ""), results_list))
`, y ? (M += $ + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, M += `
`, M += $ + `# CALCULATE COST HERE
`, r = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "", r.trim() || (r = "cost = 0"), M += D(r, $), M += `
`, M += $ + `return cost
`) : (M += $ + `counts = dict(zip(results,[results.count(i) for i in results]))
`, M += $ + `print(counts)
`)) : y ? (M += $ + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, M += `
`, M += $ + `# CALCULATE COST HERE
`, r = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "", r.trim() || (r = "cost = 0"), M += D(r, $), M += `
`, M += $ + `return cost
`) : M += $ + `print(qc.run(ep).readout_data.get("ro"))
`) : I ? (M += $ + `results_list = qc.run(p).readout_data.get("ro")
`, M += $ + `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1], ""), results_list))
`, y ? (M += $ + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, M += `
`, M += $ + `# CALCULATE COST HERE
`, r = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "", r.trim() || (r = "cost = 0"), M += D(r, $), M += `
`, M += $ + `return cost
`) : (M += $ + `counts = dict(zip(results,[results.count(i) for i in results]))
`, M += $ + `print(counts)
`)) : (M += $ + `results_list = qc.run(p).readout_data.get("ro")
`, M += $ + `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1], ""), results_list))
`, y ? (M += $ + `counts = Counter(dict(zip(results,[results.count(i) for i in results])))
`, M += `
`, M += $ + `# CALCULATE COST HERE
`, r = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "", r.trim() || (r = "cost = 0"), M += D(r, $), M += `
`, M += $ + `return cost
`) : M += $ + `print(results)
`);
    }
    if (y) {
      let R = "";
      this.params.map(function(Q, ee) {
        ee > 0 && (R += ", "), R += Q;
      }), M += `
`, M += "params = np.array([" + R + `])
`, M += `
`, M += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, M += `print("cost:", minimum.fun, "params:", minimum.x)
`;
    }
  }
  return g ? JSON.stringify({
    metadata: {
      kernelspec: {
        display_name: "Python 3",
        language: "python",
        name: "python3"
      }
    },
    nbformat: 4,
    nbformat_minor: 0,
    cells: [
      {
        cell_type: "code",
        source: M,
        metadata: {},
        outputs: [],
        execution_count: null
      }
    ]
  }) : M;
};
me.prototype.exportToQuil = function(t, e) {
  const r = function(x) {
    if (x.isSymbolNode && h.params.indexOf(x.name) >= 0)
      return "%" + x.name;
  };
  let n, i, a, o, f;
  t = t || {};
  const u = t.comment, s = !0, c = t.versionStr, l = this;
  let m = parseFloat(c || "2.0");
  isNaN(m) && (m = 2);
  const h = new me();
  h.load(this.save(s));
  let g = "";
  u && (u || "").split(`
`).map(function(N) {
    N.length >= 1 && N[0] !== "#" && (g += "# "), g += N, g += `
`;
  });
  let d = h.usedGates();
  d.map(function(x) {
    const N = h.basicGates[x];
    N && N.exportInfo && N.exportInfo.quil && N.exportInfo.quil.defgate && (g += N.exportInfo.quil.defgate, g += `

`);
  });
  const y = this.gotClassicalControl();
  let w = "";
  if (e) {
    let x = "";
    if (h.params.length) {
      for (x += "(", f = 0; f < h.params.length; f++)
        f > 0 && (x += ", "), x += "%" + h.params[f];
      x += ")";
    }
    let N = "";
    for (f = 0; f < h.numQubits; f++)
      f > 0 && (N += " "), N += "q" + f;
    g += "DEFCIRCUIT " + e + (x ? " " + x : "") + (N ? " " + N : "") + `:
`, w = "    ";
  } else {
    if (g += `
`, m >= 2) {
      let N = h.cregTotalBits();
      y && (N += 1), N && (g += "DECLARE ro BIT[" + N + `]
`);
    }
    const x = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (g += `
`, f = 0; f < this.params.length; f++) {
        const N = this.params[f];
        o = xt(x[N]), g += "DECLARE " + N + ` REAL[1]
`;
      }
      g += `
`;
    }
    d = h.usedGates();
  }
  let E = 1;
  for (let x = 0; x < h.numCols(); x++)
    for (let N = 0; N < h.numQubits; N++) {
      const D = h.getGateAt(x, N);
      if (D && D.connector === 0) {
        let b = h.getGateDef(D.name), C = D.options && D.options.params ? D.options.params : {}, A = null;
        if (b) {
          b.exportInfo && (b.exportInfo.quil && b.exportInfo.quil.replacement && (b.exportInfo.quil.replacement.params && (C = b.exportInfo.quil.replacement.params), b = h.getGateDef(b.exportInfo.quil.replacement.name)), A = b && b.exportInfo && b.exportInfo.quil ? b.exportInfo.quil : null);
          let T = !1;
          if (D.options && D.options.condition && D.options.condition.creg) {
            T = !0, g += `
`;
            const O = l.cregTotalBits(), I = D.options.condition, B = I.value || 0, k = l.cregBase(I.creg);
            if (B === 0) {
              const L = l.cregs[I.creg].length;
              if (m < 2) {
                for (g += w + "FALSE [" + O + `]
`, a = 0; a < L; a++)
                  g += w + "OR [" + (a + k) + "] [" + O + `]
`;
                g += w + "NOT [" + O + `]
`, g += "JUMP-WHEN @THEN" + E + " [" + O + `]
`, g += "JUMP @END" + (E + 1) + `
`, g += "LABEL @THEN" + E + `
`;
              } else {
                for (g += w + "FALSE ro[" + O + `]
`, a = 0; a < L; a++)
                  g += w + "OR ro[" + (a + k) + "] ro[" + O + `]
`;
                g += w + "NOT ro[" + O + `]
`, g += "JUMP-WHEN @THEN" + E + " ro[" + O + `]
`, g += "JUMP @END" + (E + 1) + `
`, g += "LABEL @THEN" + E + `
`;
              }
            } else {
              const L = B.toString(2).split("").reverse();
              let F = 0, M = 0;
              L.map(function($, R) {
                const Q = parseInt($);
                L[R] = Q, Q && (F++, M = R);
              }), F === 1 ? m < 2 ? (g += "JUMP-WHEN @THEN" + E + " [" + (M + k) + `]
`, g += "JUMP @END" + (E + 1) + `
`, g += "LABEL @THEN" + E + `
`) : (g += "JUMP-WHEN @THEN" + E + " ro[" + (M + k) + `]
`, g += "JUMP @END" + (E + 1) + `
`, g += "LABEL @THEN" + E + `
`) : m < 2 ? (g += w + "FALSE [" + O + `]
`, i = !0, L.map(function($, R) {
                $ && (i ? (i = !1, g += w + "OR [" + (R + k) + "] [" + O + `]
`) : g += w + "AND [" + (R + k) + "] [" + O + `]
`);
              }), g += "JUMP-WHEN @THEN" + E + " [" + O + `]
`, g += "JUMP @END" + (E + 1) + `
`, g += "LABEL @THEN" + E + `
`) : (g += w + "FALSE ro[" + O + `]
`, i = !0, L.map(function($, R) {
                $ && (i ? (i = !1, g += w + "OR ro[" + (R + k) + "] ro[" + O + `]
`) : g += w + "AND ro[" + (R + k) + "] ro[" + O + `]
`);
              }), g += "JUMP-WHEN @THEN" + E + " ro[" + O + `]
`, g += "JUMP @END" + (E + 1) + `
`, g += "LABEL @THEN" + E + `
`);
            }
          }
          A ? g += w + A.name : g += w + D.name, g += " ";
          let _ = 0;
          if (A && A.params && A.params.length) {
            for (g += "(", n = 0; n < A.params.length; n++)
              _ > 0 && (g += ", "), typeof C[A.params[n]] < "u" && (o = xt(String(C[A.params[n]])), g += o.toString({ handler: r })), _++;
            g += ")";
          } else if (b && b.params && b.params.length) {
            for (g += "(", n = 0; n < b.params.length; n++)
              _ > 0 && (g += ", "), typeof C[b.params[n]] < "u" && (o = xt(C[b.params[n]]), g += o.toString({ handler: r })), _++;
            g += ")";
          }
          for (let O = 0; O < D.wires.length; O++)
            _ > 0 && (g += " "), e ? g += "q" + D.wires[O] : g += "" + D.wires[O], _++;
          if (D.name === "measure" && D.options && D.options.creg) {
            let O = parseInt(D.options.creg.bit) || 0;
            isNaN(O) && (O = 0), _ > 0 && (g += " "), m < 2 ? g += "[" + (O + l.cregBase(D.options.creg.name)) + "]" : g += "ro[" + (O + l.cregBase(D.options.creg.name)) + "]", _++;
          }
          g += `
`, T && (g += "LABEL @END" + (E + 1) + `
`, g += `
`, E += 2);
        } else
          console.log("unknown gate", D.name);
      }
    }
  return e && (g += `
`), g;
};
me.prototype.exportToAQASM = function(t, e, r, n) {
  let i;
  const a = this.options && this.options.params ? this.options.params : {};
  let o, f, u, s, c, l;
  const m = this;
  t = t || {};
  const h = t.decompose, g = t.asJupyter;
  let d, y, w, E;
  d = t.shots, y = e ? t.hybrid : !1, w = null, d = d || 1024, typeof y > "u" && (y = this.options ? !!this.options.hybrid : !1);
  const x = this.save(!!h);
  w = new me(), E = new me(), w.load(x), E.load(x);
  const N = function(I, B) {
    if (I.isSymbolNode) {
      if (["pi"].indexOf(I.name) >= 0)
        return "np." + I.name;
      let L = I.name;
      if (B.replaceVars && typeof B.replaceVars[L] < "u")
        return L = B.replaceVars[L], m.params.indexOf(L) >= 0 ? "(" + a[L] + ")" : "(" + L + ")";
      if (m.params.indexOf(I.name) >= 0)
        return a[I.name];
    }
  }, D = function(I, B) {
    let k = "";
    const L = I.split(`
`);
    let F = -1;
    L.map(function($) {
      const R = $.search(/\S/);
      R >= 0 && (F < 0 || R < F) && (F = R);
    }), F < 0 && (F = 0);
    let M = "";
    if (F < B.length)
      for (let $ = 0; $ < B.length - F; $++)
        M += " ";
    return L.map(function($) {
      k += M + $ + `
`;
    }), k;
  }, b = function(I) {
    let B = "";
    for (let k = 0; k < I; k++)
      B += "    ";
    return B;
  };
  n = n || 0;
  const C = [];
  if (!e) {
    if (!h) {
      const I = E.numCols();
      for (s = I - 1; s >= 0; s--)
        for (c = 0; c < E.numQubits; c++)
          if (l = E.gates[c][s], l && l.connector === 0 && !E.basicGates[l.name]) {
            let B = E.decomposeGateAt(s, c);
            for (let k = 0; k < B.numCols(); k++)
              for (let L = 0; L < B.numQubits; L++) {
                const F = B.getGateAt(
                  k,
                  L
                );
                F && F.connector === 0 && C.push(F), w.gates.map(function(M) {
                  M.map(function($) {
                    $ && $.name === l.name && w.removeGate($.id);
                  });
                });
              }
          }
    }
    C.map(function(I) {
      I && w.insertGate(
        I.name,
        I.column,
        I.wires,
        I.options
      );
    });
  }
  let A = "", T = b(n);
  const _ = w.usedGates(), O = w.numQubits;
  if (e)
    if (r) {
      for (f = "", u = 0, o = 0; o < w.params.length; o++)
        u > 0 && (f += ", "), f += w.params[o], u++;
      for (o = 0; o < w.numQubits; o++)
        u > 0 && (f += ", "), f += dr(o, w.numQubits), u++;
    } else {
      A += T + `from qat.lang.AQASM import *
`, A += T + `from qat.qpus import get_default_qpu
`, A += T + `from collections import Counter
`, y && (A += T + `from scipy.optimize import minimize
`), A += T + `import numpy as np
`, A += `
`;
      let I = "";
      i = 0, _.map(function(B) {
        if (w.basicGates[B]) {
          if (!h && w.basicGates[B].exportInfo.aqasm && w.basicGates[B].exportInfo.aqasm.array) {
            let L = w.basicGates[B].exportInfo.aqasm, F = B + "_gate";
            if (A += T + "def " + F + "(", L.params && L.params.length) {
              let $ = 0;
              L.params.map(function(R) {
                $ > 0 && (A += ", "), A += T + "p_" + R, $++;
              });
            }
            A += `):
`, A += b(n + 1) + "return np.array(" + L.array + `)

`, I += B + ' = AbstractGate("' + B + '", [';
            let M = 0;
            if (L.params)
              for (let $ = 0; $ < L.params.length; $++)
                M > 0 && (I += ", "), I += "float", M++;
            I += "], matrix_generator=" + F + ", arity=" + arity + `)
`;
          }
        } else {
          const L = m.customGates[B];
          if (L) {
            const F = new me();
            F.load(L);
            const M = {
              comment: "",
              decompose: !0,
              asJupyter: !1,
              shots: null,
              hybrid: !1
            };
            A += F.exportToAQASM(
              M,
              e,
              B,
              n
            ), i++;
          }
        }
      }), A += I, A += `
`, d && (A += T + "shots = " + d + `
`, A += `
`), A += T + `program = Program()
`, A += T + "qubits_reg = program.qalloc(" + w.numQubits + `)
`;
      for (let B in w.cregs)
        A += T + B + " = program.calloc(" + w.cregs[B].length + `)
`;
      if (A += `
`, this.params.length) {
        for (o = 0; o < this.params.length; o++) {
          const B = this.params[o], L = xt(a[B]).toString({
            handler: N
          });
          A += B + " = " + L + `
`;
        }
        A += `
`;
      }
      y && (A += T + "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, A += `
`);
    }
  else if (A += T + `BEGIN
`, A += T + "qubits " + O + `
`, w.cregs) {
    let I = 0;
    for (let B in w.cregs)
      I += w.cregs[B].length;
    A += T + "cbits " + I + `
`;
  }
  for (r ? (A += "def " + r + (f ? "(" + f + ")" : "") + `:
`, n++, T = b(n), A += T + `circuit = QRoutine()
`) : y && (A += `def objective_function(params):
`, n++, T = b(n)), r || i && (A += `
`, _.map(function(I) {
    !w.basicGates[I] && w.customGates[I] && (A += T + I + "(");
  })), s = 0; s < w.numCols(); s++)
    for (c = 0; c < w.numQubits; c++)
      if (l = w.getGateAt(s, c), l && l.connector === 0) {
        const I = w.getGateDef(l.name);
        let B = "";
        if (l.name === "measure" && (e ? B += "program.measure" : B += "MEAS"), l.name === "reset" && (e ? B += "program.reset" : B += "RESET"), I && I.exportInfo) {
          if (I.exportInfo.aqasm) {
            const k = I.exportInfo.aqasm;
            let L = "";
            if (k.name)
              I.params.length ? I.params.map(function(F) {
                const $ = xt(gateParams[F]).toString({
                  handler: N
                });
                L = k.name, e ? L += "(" + $ + ")" : L += "[" + $ + "]";
              }) : L += k.name, k.controlled && k.dagger ? e ? B += L + ".dag().ctrl()" : B += "CTRL(DAG(" + L + "))" : k.controlled ? e ? B += L + ".ctrl()" : B += "CTRL(" + L + ")" : k.dagger ? e ? B += L + ".dag()" : B += "DAG(" + L + ")" : B += L;
            else if (k.matrix)
              if (e) {
                B += l.name + "(";
                let F = 0;
                I.params.map(function(M) {
                  F > 0 && (B += ", ");
                  const R = xt(gateParams[M]).toString({
                    handler: N
                  });
                  B += R, F++;
                }), B += ")";
              } else {
                B = "[";
                for (let F = 0; F < k.matrix.length; F++) {
                  let M = k.matrix[F];
                  for (B += "[", o = 0; o < M.length; o++) {
                    B += "(";
                    let $ = M[o];
                    k.params && k.params.map(function(U) {
                      const X = l.options.params[U];
                      $.toString().indexOf(U) > 0 && ($ = $.replace(U, X));
                    });
                    let R = Nr(
                      $,
                      m.options.params
                    ), Q = zt(R), ee = Q.re, j = Q.im;
                    B += ee + ", " + j + ")", o < M.length - 1 && (B += " ");
                  }
                  B += "]", F < k.matrix.length - 1 && (B += " ");
                }
                B += "]";
              }
          }
          A += T + B, e ? A += "(" : A += " ";
        }
        u = 0;
        for (let k = 0; k < l.wires.length; k++)
          u > 0 && (A += ", "), e ? r ? A += dr(l.wires[k], w.numQubits) : A += "qubits_reg[" + l.wires[k] + "]" : A += "q[" + l.wires[k] + "]", u = u + 1;
        l.options && l.options.creg && (A += ", " + l.options.creg.name + "[" + l.options.creg.bit + "]"), e && (A += ")"), A += `
`;
      }
  if (r && (A += T + `return circuit

`), !e)
    A += "END";
  else if (!r)
    if (A += T + `
`, A += T + `circuit = program.to_circ()
`, A += T + `job = circuit.to_job(nbshots=shots, aggregate_data=False)
`, A += T + `qpu = get_default_qpu()
`, A += T + `job_result = qpu.submit(job)
`, A += T + `counts = Counter()

`, A += T + `for state in job_result:
`, A += T + `    string_state = str(state.state)
`, A += T + `    string_state = string_state[string_state.find('|') + 1: string_state.find('>')]
`, A += T + `    string_state = string_state[::-1]
`, A += T + `    counts[string_state] += 1

`, y) {
      A += T + `# CALCULATE COST HERE
`;
      let I = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
      if (I.trim() || (I = "cost = 0"), A += D(I, T), A += `
`, A += T + `return cost
`, n--, T = b(n), y) {
        let B = "";
        this.params.map(function(k, L) {
          L > 0 && (B += ", "), B += k;
        }), A += `
`, A += "params = np.array([" + B + `])
`, A += `
`, A += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, A += `print("cost:", minimum.fun, "params:", minimum.x)
`;
      }
    } else
      A += T + "print(counts)";
  return g && e ? JSON.stringify({
    metadata: {
      kernelspec: {
        display_name: "Python 3",
        language: "python",
        name: "python3"
      }
    },
    nbformat: 4,
    nbformat_minor: 0,
    cells: [
      {
        cell_type: "code",
        source: A,
        metadata: {},
        outputs: [],
        execution_count: null
      }
    ]
  }) : A;
};
me.prototype.exportAQASM = function(t, e, r, n, i, a, o, f) {
  const u = {
    comment: t,
    decompose: e,
    asJupyter: i,
    shots: a,
    hybrid: o
  };
  return this.exportToAQASM(
    u,
    r,
    n,
    f
  );
};
me.prototype.exportToPyAQASM = function(t, e) {
  return this.exportToAQASM(t, !0, e);
};
me.prototype.exportPyAQASM = function(t, e, r, n, i, a) {
  const o = {
    comment: t,
    decompose: e,
    asJupyter: n,
    shots: i,
    hybrid: a
  };
  return this.exportToPyAQASM(o, r);
};
me.prototype.exportToCirq = function(t, e) {
  let r, n, i;
  t = t || {};
  const a = t.comment, o = t.decompose, f = t.versionStr, u = t.asJupyter;
  let s = t.shots;
  const c = t.exportTfq, l = this;
  let m = "";
  c ? m = "TFQ" : m = "cirq";
  let h = parseFloat(f || "0.7");
  isNaN(h) && (h = 0.7), typeof s > "u" && (s = 1024);
  const g = new me();
  g.load(this.save(o));
  let d = "";
  a && (a || "").split(`
`).map(function(C) {
    C.length >= 1 && C[0] !== "#" && (d += "# "), d += C, d += `
`;
  });
  let y;
  const w = function(b) {
    if (b.isSymbolNode && ["pi", "sin", "cos", "tan", "asin", "acos", "atan"].indexOf(b.name) >= 0)
      return "np." + b.name;
  };
  if (e) {
    let b = "";
    for (i = 0, n = 0; n < g.params.length; n++)
      i > 0 && (b += ", "), b += g.params[n], i++;
    for (n = 0; n < g.numQubits; n++)
      i > 0 && (b += ", "), b += dr(n, g.numQubits), i++;
    d += "def " + e + (b ? "(" + b + ")" : "") + `:
`, d += `    return [
`, y = "        ";
  } else {
    c && (d += `import tensorflow_quantum as tfq
`), d += `import cirq
`, d += `import numpy as np
`, d += `from functools import reduce
`, d += `
`;
    const b = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (n = 0; n < this.params.length; n++) {
        const T = this.params[n];
        r = xt(b[T]);
        const _ = r.toString({
          handler: w
        });
        d += T + " = " + _ + `
`;
      }
      d += `
`;
    }
    let C = g.usedGates();
    o || C.map(function(T) {
      if (!g.basicGates[T]) {
        const O = l.customGates[T];
        if (O) {
          const I = new me();
          I.load(O);
          const B = {
            comment: "",
            decompose: !0,
            versionStr: f
          };
          d += I.exportToCirq(B, e);
        }
      }
    });
    let A = "";
    C = g.usedGates(), C.map(function(T) {
      const _ = g.basicGates[T];
      if (_ && _.exportInfo && _.exportInfo.cirq) {
        let O = _.exportInfo.cirq, I = !1;
        if (O.replacement && (O = g.getGateDef(O.replacement.name).exportInfo.cirq, I = !0), O.array && !c) {
          const B = I ? O.name : T;
          if (A.indexOf(B) < 0) {
            if (A += "def " + B + "(", O.params && O.params.map(function(k, L) {
              L > 0 && (A += ", "), A += "p_" + k;
            }), A += `):
`, _.matrix && _.matrix.length)
              if (h < 0.7)
                switch (_.matrix.length) {
                  case 2:
                    A += "    return cirq.SingleQubitMatrixGate(np.array(" + O.array + `))
`;
                    break;
                  case 4:
                    A += "    return cirq.TwoQubitMatrixGate(np.array(" + O.array + `))
`;
                    break;
                  default:
                    A += "    # Export to " + m + " WARNING: Cannot define " + _.matrix.length + " x " + _.matrix.length + ` matrix gate
`;
                }
              else
                A += "    return cirq.MatrixGate(np.array(" + O.array + `))
`;
            A += `
`;
          }
        }
      }
    }), d += A, c ? d += "q = cirq.GridQubit.rect(1, " + g.numQubits + `)
` : d += "q = [cirq.NamedQubit('q' + str(i)) for i in range(" + g.numQubits + `)]
`, d += `
`, h < 0.7 ? d += `circuit = cirq.Circuit.from_ops(
` : d += `circuit = cirq.Circuit(
`, y = "    ";
  }
  const E = g.numCols();
  let x = 0, N = "", D = !1;
  for (let b = 0; b < E; b++)
    for (let C = 0; C < this.numQubits; C++) {
      const A = g.getGateAt(b, C);
      if (A && A.connector === 0) {
        x > 0 && (d += ",", c && D && (d += y + "# Export to TFQ WARNING: Gate not yet supported by Tensorflow Quantum"), d += `
`);
        let T = g.getGateDef(A.name), _ = A.options && A.options.params ? A.options.params : {}, O = null, I = !1;
        const B = !!g.basicGates[A.name];
        if (T) {
          T.exportInfo && (D = !!T.exportInfo.cirq.notTfqSupported, T.exportInfo.cirq && T.exportInfo.cirq.replacement && (T.exportInfo.cirq.replacement.params && (_ = T.exportInfo.cirq.replacement.params), I = T.exportInfo.cirq.replacement.type && T.exportInfo.cirq.replacement.type === "controlled", D = !!T.exportInfo.cirq.replacement.notTfqSupported, T = g.getGateDef(T.exportInfo.cirq.replacement.name)), O = T && T.exportInfo && T.exportInfo.cirq ? T.exportInfo.cirq : null), x++, A.options && A.options.condition && A.options.condition.creg && (d += y + "# Export to " + m + ` WARNING: classical control not implemented yet.
`);
          let k = 0, L = "";
          if (_) {
            let F = T.params || [];
            A.name === "yy" && (F = []);
            const M = F.length;
            if (M)
              for (let $ = 0; $ < M; $++) {
                k === 0 && (L += "("), k > 0 && (L += ", ");
                const R = F[$];
                if (_[R]) {
                  if (r = xt(_[R]), !r.args)
                    for (let Q in A.options.params)
                      r = xt(A.options.params[Q]);
                  L += r.toString({
                    handler: w
                  });
                }
                k === M - 1 && (B ? L += ")" : L += ", "), k++;
              }
          }
          if (O) {
            const F = O.name.indexOf("**") >= 0;
            d += y, F && (d += "("), O.array || (d += "cirq."), c && O.tfqReplacement && O.tfqReplacement.name ? d += "cirq." + O.tfqReplacement.name : d += O.name, F && (d += ")");
          } else
            d += y + A.name;
          d += L, I ? d += ".controlled().on(" : B && (d += "("), i = 0;
          for (let F = 0; F < A.wires.length; F++)
            i > 0 && (d += ", "), e ? d += dr(A.wires[F], g.numQubits) : d += "q[" + A.wires[F] + "]", i++;
          A.name === "measure" && A.options && A.options.creg && (i > 0 && (d += ", key="), d += "'" + A.options.creg.name + A.options.creg.bit + "'", b === E - 1 && C === this.numQubits - 1 ? N += "'" + A.options.creg.name + A.options.creg.bit + "'" : N += "'" + A.options.creg.name + A.options.creg.bit + "', ", i++), d += ")";
        } else
          d += y + "# Export to " + m + ' WARNING: unknown gate "' + A.name + '".';
      }
    }
  return c && D && (d += y + "# Export to TFQ WARNING: Gate not yet supported by Tensorflow Quantu"), e ? (d += `
    ]
`, d += `
`) : (d += `
)
`, d += `
`, c || (d += `simulator = cirq.Simulator()
`, d += "result = simulator.run(circuit, repetitions=" + s + `)
`, d += "result_dict = dict(result.multi_measurement_histogram(keys=[" + N + `]))
`, d += `keys = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1]), result_dict.keys()))
`, d += `counts = dict(zip(keys,[value for value in result_dict.values()]))
`, d += "print(counts)")), u ? JSON.stringify({
    metadata: {
      kernelspec: {
        display_name: "Python 3",
        language: "python",
        name: "python3"
      }
    },
    nbformat: 4,
    nbformat_minor: 0,
    cells: [
      {
        cell_type: "code",
        source: d,
        metadata: {},
        outputs: [],
        execution_count: null
      }
    ]
  }) : d;
};
me.prototype.exportToTFQ = function(t, e) {
  t = t || {};
  const r = t.comment, n = t.decompose, i = t.versionStr, a = t.asJupyter;
  let o = t.shots;
  typeof o > "u" && (o = 1024);
  const f = new me();
  f.load(this.save(n));
  let u = "";
  r && (r || "").split(`
`).map(function(l) {
    l.length >= 1 && l[0];
  });
  const s = {
    comment: r,
    decompose: n,
    versionStr: i,
    asJupyter: !1,
    shots: o,
    exportTfq: !0
  };
  return u += f.exportToCirq(s, e), u += "results_list = tfq.layers.Sample()(circuit, repetitions=" + o + `).to_list()[0]
`, u += `results = list(map(lambda arr: reduce(lambda x, y: str(x) + str(y), arr[::-1]), results_list))
`, u += `counts = dict(zip(results,[results.count(i) for i in results]))
`, u += "print(counts)", a ? JSON.stringify({
    metadata: {
      kernelspec: {
        display_name: "Python 3",
        language: "python",
        name: "python3"
      }
    },
    nbformat: 4,
    nbformat_minor: 0,
    cells: [
      {
        cell_type: "code",
        source: u,
        metadata: {},
        outputs: [],
        execution_count: null
      }
    ]
  }) : u;
};
me.prototype.exportToQSharp = function(t, e) {
  let r, n;
  t = t || {};
  const i = t.decompose, a = t.versionStr, o = t.asJupyter, f = t.circuitName;
  let u = t.indentDepth;
  const s = this, c = function(N) {
    if (N.isSymbolNode) {
      const D = { pi: "PI()" };
      if (D[N.name])
        return D[N.name];
    }
    if (N.isConstantNode && Number.isInteger(N.value))
      return N.value.toFixed(1);
  }, l = f || "Circuit";
  u = u || 0;
  function m(N) {
    let D = "";
    for (let b = 0; b < N; b++)
      D += "    ";
    return D;
  }
  const h = new me();
  h.load(this.save(i));
  let g = "", d = m(u);
  if (e || (o || (g += `namespace Quantum {
`, u++, d = m(u)), g += d + `open Microsoft.Quantum.Intrinsic;
`, g += d + `open Microsoft.Quantum.Canon;
`, g += d + `open Microsoft.Quantum.Math;
`, g += d + `open Microsoft.Quantum.Convert;
`, g += `
`, g += d + `function SetBitValue(reg: Int, bit: Int, value: Bool): Int {
`, g += d + `    if(value) {
`, g += d + `        return reg ||| (1 <<< bit);
`, g += d + `    } else {
`, g += d + `        return reg &&& ~~~(1 <<< bit);
`, g += d + `    }
`, g += d + `}
`, g += d + `
`), e) {
    let N, D = "";
    for (n = 0, N = 0; N < h.params.length; N++)
      n > 0 && (D += ", "), D += h.params[N], n++;
    for (N = 0; N < h.numQubits; N++)
      n > 0 && (D += ", "), D += dr(N, h.numQubits) + ": Qubit", n++;
    g += d + "operation " + e + (D ? "(" + D + ")" : "");
  } else
    r = h.usedGates(), i || r.map(function(N) {
      if (!h.basicGates[N]) {
        const b = s.customGates[N];
        if (b) {
          const C = new me();
          C.load(b);
          const A = {
            comment: "",
            decompose: !0,
            versionStr: a,
            asJupyter: !1,
            circuitName: null,
            indentDepth: u
          };
          g += C.exportToQSharp(A, e);
        }
      }
    }), g += d + "operation " + l + "()";
  u++, d = m(u);
  let y = 0;
  for (let N in h.cregs)
    y++;
  let w = "";
  if (y) {
    g += " : (";
    for (let N in h.cregs)
      w && (g += ", ", w += ", "), g += "Int", w += N;
    g += ")";
  } else
    g += " : Unit";
  if (g += ` {
`, y)
    for (let N in h.cregs)
      g += d + "mutable " + N + ` = 0;
`;
  let E = "qubits";
  e || (g += d + "using(", g += E + " = Qubit[" + h.numQubits + "]", g += `) {
`, u++, d = m(u));
  const x = h.numCols();
  for (let N = 0; N < x; N++)
    for (let D = 0; D < h.numQubits; D++) {
      const b = h.getGateAt(N, D);
      if (b && b.connector === 0) {
        let C = h.getGateDef(b.name);
        C || (C = h.customGates[b.name]);
        let A = b.options && b.options.params ? b.options.params : {}, T = null, _ = !1, O = 0;
        if (C) {
          C.exportInfo && (C.exportInfo.qsharp && C.exportInfo.qsharp.replacement && (C.exportInfo.qsharp.replacement.params && (A = C.exportInfo.qsharp.replacement.params), C = h.getGateDef(C.exportInfo.qsharp.replacement.name)), T = C && C.exportInfo && C.exportInfo.qsharp ? C.exportInfo.qsharp : null), C.drawingInfo && C.drawingInfo.root && b.name !== "cx" && b.name !== "ccx" && (_ = !0);
          let I = 0, B = "";
          if (A) {
            const k = C.params || [], L = k.length;
            if (L)
              for (let F = 0; F < L; F++) {
                I > 0 && (B += ", ");
                const M = k[F];
                if (A[M]) {
                  const $ = xt(A[M]);
                  B += $.toString({
                    handler: c
                  });
                }
                I++;
              }
          }
          if (b.name === "measure")
            b.options && b.options.creg ? (g += d + "set " + b.options.creg.name + " = SetBitValue(" + b.options.creg.name + ", " + b.options.creg.bit + ", ResultAsBool(M(", e ? g += dr(b.wires[0], h.numQubits) + `)));
` : g += E + "[" + b.wires[0] + `])));
`) : g += d + `// Export to qsharp WARNING: missing destination register
`;
          else {
            g += d, b.options && b.options.condition && b.options.condition.creg && (g += "if(" + b.options.condition.creg + " == " + b.options.condition.value + `) {
`, u++, d = m(u), g += d), T ? g += T.name + "(" : g += b.name + "(", _ ? (e ? g += "[" + dr(b.wires[0], h.numQubits) + "], (" : g += "[" + E + "[" + b.wires[0] + "]], (", O = 1) : O = 0, B && (g += B + ", "), n = 0;
            for (let k = O; k < b.wires.length; k++)
              n > 0 && (g += ", "), e ? g += dr(b.wires[k], h.numQubits) : g += E + "[" + b.wires[k] + "]", n++;
            _ && (g += ")"), g += `);
`, b.options && b.options.condition && b.options.condition.creg && (u--, d = m(u), g += d + `}
`);
          }
        }
      }
    }
  if (e || (g += d + "ResetAll(" + E + `);
`, u--, d = m(u), g += d + `}
`), y && (g += d + "return (" + w + `);
`), u--, d = m(u), g += d + `}
`, e ? g += `
` : o || (g += `}
`), o) {
    const N = {
      metadata: {
        kernelspec: {
          display_name: "Q#",
          language: "qsharp",
          name: "iqsharp"
        },
        language_info: {
          name: ""
        }
      },
      nbformat: 4,
      nbformat_minor: 0,
      cells: [
        {
          cell_type: "code",
          source: g,
          metadata: {},
          outputs: [],
          execution_count: null
        },
        {
          cell_type: "code",
          source: "%simulate " + l,
          metadata: {},
          outputs: [],
          execution_count: null
        }
      ]
    };
    return JSON.stringify(N);
  }
  return g;
};
me.prototype.exportToBraket = function(t, e) {
  let r, n;
  t = t || {};
  const i = t.decompose, a = t.versionStr, o = t.asJupyter;
  let f = t.shots, u = t.hybrid, s = t.indentDepth;
  const c = this;
  f = f || 1024, typeof u > "u" && (u = this.options ? !!this.options.hybrid : !1);
  const l = new me();
  l.load(this.save(i));
  const m = function(A) {
    if (A.isSymbolNode) {
      if (["pi", "sin", "cos", "tan", "asin", "acos", "atan"].indexOf(A.name) >= 0)
        return "np." + A.name;
      if (c.params.indexOf(A.name) >= 0 && u)
        return "params[" + c.params.indexOf(A.name) + "]";
    }
  }, h = function(A, T) {
    let _ = "";
    const O = A.split(`
`);
    let I = -1;
    O.map(function(k) {
      const L = k.search(/\S/);
      L >= 0 && (I < 0 || L < I) && (I = L);
    }), I < 0 && (I = 0);
    let B = "";
    if (I < T.length)
      for (let k = 0; k < T.length - I; k++)
        B += " ";
    return O.map(function(k) {
      _ += B + k + `
`;
    }), _;
  }, g = function(A) {
    let T = "";
    for (let _ = 0; _ < A; _++)
      T += "    ";
    return T;
  };
  s = s || 0;
  let d = "", y = g(s);
  const w = l.usedGates();
  w.map(function(A) {
    l.basicGates[A];
  });
  let E = "", x = 0;
  if (e) {
    for (n = 0; n < l.numQubits; n++)
      x > 0 && (E += ", "), E += dr(n, l.numQubits), x++;
    for (n = 0; n < l.params.length; n++)
      x > 0 && (E += ", "), E += l.params[n], x++;
  } else {
    d += y + `import numpy as np
`, d += y + `from braket.devices import LocalSimulator
`, d += y + `from braket.circuits import Circuit
`, d += y + `from collections import Counter
`, u && (d += y + `from scipy.optimize import minimize
`), d += `
`, f && (d += y + "shots = " + f + `
`, d += `
`);
    const A = this.options && this.options.params ? this.options.params : {};
    if (this.params.length) {
      for (n = 0; n < this.params.length; n++) {
        const T = this.params[n];
        r = xt(A[T]);
        const _ = r.toString({
          handler: m
        });
        d += T + " = " + _ + `
`;
      }
      d += `
`;
    }
    u && (d += y + "tolerance = " + (this.options && this.options.hybridOptions && this.options.hybridOptions.tolerance && this.options.hybridOptions.tolerance || "0.001") + `
`, d += `
`);
  }
  let N = null, D = null, b = 0;
  w.map(function(A) {
    if (l.basicGates[A]) {
      if (!i && l.basicGates[A].exportInfo.braket && l.basicGates[A].exportInfo.braket.array) {
        if (N = l.basicGates[A].exportInfo.braket, N.name === "unitary" && (D = A + "_unitary", d += y + "def " + D + "("), N.params && N.params.length) {
          let _ = 0;
          N.params.map(function(O) {
            _ > 0 && (d += ", "), d += y + "p_" + O, _++;
          });
        }
        d += `):
`, d += g(s + 1) + "return np.array(" + N.array + `);

`;
      }
    } else {
      const _ = c.customGates[A];
      if (_) {
        const O = new me();
        O.load(_), d += O.exportBraket(
          "",
          !0,
          A,
          a,
          !1,
          null,
          !1,
          s
        ), b++;
      }
    }
  }), e ? (d += "def " + e + (E ? "(" + E + ")" : "") + `:
`, s++, y = g(s)) : u && (d += `def objective_function(params):
`, s++, y = g(s)), d += y + `circuit = Circuit()
`, e || b && (d += `
`, w.map(function(A) {
    !l.basicGates[A] && l.customGates[A] && (d += y + "circuit.register_subroutine(" + A + `)
`);
  }), d += `
`);
  const C = l.numCols();
  for (let A = 0; A < C; A++)
    for (let T = 0; T < l.numQubits; T++) {
      const _ = l.getGateAt(A, T);
      if (_ && _.connector === 0) {
        const O = l.getGateDef(_.name);
        let I = _.options && _.options.params ? _.options.params : {}, B = O.params || [], k = null, L = _.name, F = "", M = !1;
        if (O && O.exportInfo && O.exportInfo.braket && (k = O.exportInfo.braket, k.params && (Array.isArray(k.params) ? B = k.params : (I = k.params, B = Object.keys(I))), k.name === "unitary" ? M = !0 : L = k.name), !k && !l.customGates[_.name])
          d += y + '# Unsupported gate "' + _.name + `".
`;
        else {
          let $ = 0;
          if (I) {
            const R = B.length;
            if (R)
              for (let Q = 0; Q < R; Q++) {
                $ > 0 && (F += ", ");
                const ee = B[Q];
                typeof I[ee] < "u" && (r = xt(I[ee]), F += r.toString({
                  handler: m
                })), $++;
              }
          }
          d += y + "circuit.", M ? d += "unitary(matrix=" + L + "_unitary(" + F + "), targets=[" : d += L + "(", x = 0;
          for (let R = 0; R < _.wires.length; R++)
            x > 0 && (d += ", "), e ? d += dr(_.wires[R], l.numQubits) : d += _.wires[R], x++;
          M ? d += "]" : F && (d += ", ", d += F), d += ")", d += `
`;
        }
      }
    }
  if (e && (d += y + "return circuit"), d += `

`, !e)
    if (d += y + `local_sim = LocalSimulator()
`, d += y + `result = local_sim.run(circuit, shots=shots).result()
`, d += y + `counts = Counter({ "".join(reversed(k)): v for k, v in result.measurement_counts.items() })
`, d += `
`, u) {
      d += y + `# CALCULATE COST HERE
`;
      let A = this.options && this.options.hybridOptions && this.options.hybridOptions.costFunction && this.options.hybridOptions.costFunction.python || "";
      if (A.trim() || (A = "cost = 0"), d += h(A, y), d += `
`, d += y + `return cost
`, s--, y = g(s), u) {
        let T = "";
        this.params.map(function(_, O) {
          O > 0 && (T += ", "), T += _;
        }), d += `
`, d += "params = np.array([" + T + `])
`, d += `
`, d += 'minimum = minimize(objective_function, params, method="' + (this.options && this.options.hybridOptions && this.options.hybridOptions.optimizer ? this.options.hybridOptions.optimizer : "Powell") + `", tol=tolerance)
`, d += `print("cost:", minimum.fun, "params:", minimum.x)
`;
      }
    } else
      d += y + "print(counts)";
  return o ? JSON.stringify({
    metadata: {
      kernelspec: {
        display_name: "Python 3",
        language: "python",
        name: "python3"
      }
    },
    nbformat: 4,
    nbformat_minor: 0,
    cells: [
      {
        cell_type: "code",
        source: d,
        metadata: {},
        outputs: [],
        execution_count: null
      }
    ]
  }) : d;
};
me.prototype.exportToQobj = function(t, e) {
  let r, n;
  t = t || {};
  let i = t.circuitName, a = t.experimentName, o = t.numShots;
  const f = this;
  let u = this.options && this.options.params ? this.options.params : {};
  u = JSON.parse(JSON.stringify(u));
  for (let E in u)
    u[E] = Nr(u[E]);
  i = i || "", a = a || "", o = o || 1;
  const s = new me();
  s.load(this.save(!0));
  let l = {
    qobj_id: "qobj_" + this.randomString(),
    type: "QASM",
    schema_version: "1.0",
    experiments: [],
    header: { description: i },
    config: { shots: o, memory_slots: 0 }
  };
  const m = {
    header: {
      memory_slots: 0,
      n_qubits: 0,
      qreg_sizes: [],
      qubit_labels: [],
      creg_sizes: [],
      clbit_labels: [],
      name: "circuit0"
    },
    config: { n_qubits: 0, memory_slots: 0 },
    instructions: []
  }, h = Object.keys(s.cregs), g = function(E, x) {
    if (E.isSymbolNode) {
      let N = E.name;
      if (x.replaceVars && typeof x.replaceVars[N] < "u")
        return N = x.replaceVars[N], f.params.indexOf(N) >= 0 ? "(" + u[N] + ")" : "(" + N + ")";
      if (f.params.indexOf(E.name) >= 0)
        return u[E.name];
    }
  };
  if (!e) {
    a && (m.header.description = a);
    for (let E in s.cregs) {
      const x = s.cregs[E].length;
      l.config.memory_slots += x, m.header.creg_sizes.push([E, x]);
      for (let N = 0; N < x; N++)
        m.header.clbit_labels.push([E, N]);
    }
    m.header.memory_slots = l.config.memory_slots, m.header.n_qubits = s.numQubits, m.config.memory_slots = l.config.memory_slots, m.config.n_qubits = s.numQubits, m.header.qreg_sizes.push(["q", s.numQubits]);
  }
  let d = l.config.memory_slots;
  s.usedGates().map(function(E) {
    if (!s.basicGates[E]) {
      const N = f.customGates[E];
      if (N) {
        let D = new me();
        D.load(N);
        const b = {
          circuitName: i,
          experimentName: a,
          numShots: o
        };
        l += D.exportToQobj(b, !1);
      }
    }
  });
  const w = s.numCols();
  for (let E = 0; E < w; E++)
    for (let x = 0; x < s.numQubits; x++) {
      const N = s.getGateAt(E, x), D = { name: "", qubits: [] };
      let b = null, C = null;
      if (E === 0 && m.header.qubit_labels.push(["q", x]), N && N.connector === 0) {
        let A = s.getGateDef(N.name);
        if (A && A.exportInfo && (A.exportInfo.qasm && A.exportInfo.qasm.replacement ? (b = A.exportInfo.qasm.replacement, b.map(function(T) {
          const _ = new me();
          if (_.cregs = JSON.parse(JSON.stringify(f.cregs)), N.options && N.options.params) {
            const B = Object.keys(N.options.params), k = Object.keys(T.params);
            B.map(function(L) {
              k.indexOf(L) > -1 && (T.params[L] = N.options.params[L]);
            });
          }
          const O = N.options && N.options.condition ? N.options.condition : {};
          _.addGate(T.name, E, N.wires, {
            params: T.params,
            condition: O
          });
          const I = {
            circuitName: "",
            experimentName: "",
            numShots: ""
          };
          m.instructions = m.instructions.concat(
            _.exportToQobj(I, !0)
          );
        })) : A.exportInfo.qasm && A.exportInfo.qasm.equivalent && (C = A.exportInfo.qasm.equivalent, C.map(function(T) {
          let _, O;
          const I = new me();
          I.cregs = JSON.parse(JSON.stringify(f.cregs));
          const B = T.wires.length > 1 ? N.wires : N.wires[T.wires[0]], k = {};
          if (T.params) {
            const M = {};
            if (N.options && N.options.params)
              for (let $ in N.options.params)
                O = xt(N.options.params[$]), _ = O.toString({
                  handler: g
                }), M[$] = _;
            for (let $ in T.params)
              O = xt(T.params[$]), _ = O.toString({
                handler: g,
                replaceVars: M
              }), k[$] = _;
          }
          const L = N.options && N.options.condition ? N.options.condition : {};
          I.addGate(T.name, E, B, {
            params: k,
            condition: L
          });
          const F = {
            circuitName: "",
            experimentName: "",
            numShots: ""
          };
          m.instructions = m.instructions.concat(
            I.exportToQobj(F, !0)
          );
        }))), !b && !C) {
          let T = N.name;
          const _ = N.options && N.options.params ? N.options.params : {};
          if (this.basicGates[T]) {
            switch (T) {
              case "id":
                T = "iden";
                break;
            }
            if (D.name = T, D.qubits = N.wires, N.options && N.options.condition && N.options.condition.creg) {
              const O = {
                name: "",
                register: d,
                relation: "==",
                mask: "",
                val: ""
              }, I = s.cregs[N.options.condition.creg].length;
              let B = 0, k = 0, L = "", F = "";
              for (n = h.indexOf(N.options.condition.creg), r = 0; r < n; r++)
                B += s.cregs[h[r]].length;
              if (F = "0x" + (N.options.condition.value % Math.pow(2, I) * Math.pow(2, B)).toString(16).toUpperCase(), B > 0) {
                let $ = Math.pow(2, B);
                for (let R = 0; R < I; R++)
                  k += $, $ *= 2;
                L = "0x" + k.toString(16).toUpperCase();
              } else
                L = "0x" + (Math.pow(2, I) - 1).toString(16).toUpperCase();
              O.name = "bfunc", D.conditional = d, O.mask = L, O.val = F, m.instructions.push(O), d += 1;
            }
            if (T === "measure" && N.options && N.options.creg) {
              D.memory = [], D.register = [];
              let O = 0;
              for (n = h.indexOf(N.options.creg.name), r = 0; r < n; r++)
                O += s.cregs[h[r]].length;
              const I = O + N.options.creg.bit;
              D.memory.push(I), D.register.push(I);
            }
            if (_ && (A = this.basicGates[T], A || (A = this.customGates[T]), A)) {
              let O = A.params || [], I = O.length;
              if (I) {
                D.params = [];
                for (let B = 0; B < I; B++) {
                  let k = O[B];
                  if (_[k] || _[k].toString()) {
                    const L = Nr(_[k], u);
                    D.params.push(L);
                  }
                }
              }
            }
            m.instructions.push(D);
          }
        }
      }
    }
  return e ? m.instructions : (m.instructions.length && l.experiments.push(m), l);
};
me.prototype.clearPartitions = function() {
  this.partitionMap = [], this.partitionCount = 0, this.partitionInfo = {};
  const t = this.numCols();
  for (let e = 0; e < this.numQubits; e++) {
    this.partitionMap.push([]);
    for (let r = 0; r < t; r++)
      this.partitionMap[e].push(-1);
  }
};
me.prototype.createPartitions = function() {
  let t, e;
  this.clearPartitions();
  const r = [];
  for (let a = 0; a < this.numQubits; a++)
    r.push(-1);
  let n = 0;
  const i = this.numCols();
  for (let a = 0; a < i; a++) {
    let o;
    for (o = 0; o < this.numQubits; o++) {
      const f = this.getGateAt(a, o);
      if (f && f.wires) {
        let u;
        const s = [];
        for (u = 0; u < f.wires.length; u++) {
          t = f.wires[u];
          const c = r[t];
          s.indexOf(c) < 0 && s.push(c);
        }
        for (e = -1, s.length !== 1 || s[0] === -1 ? e = n++ : e = s[0], u = 0; u < f.wires.length; u++) {
          t = f.wires[u];
          let c = r[t];
          if (c === -1)
            r[t] = e;
          else
            for (let l = 0; l < this.numQubits; l++)
              r[l] === c && (r[l] = e);
        }
      }
    }
    for (o = 0; o < this.numQubits; o++)
      this.partitionMap[o][a] = r[o];
  }
  for (this.partitionCount = n, e = 0; e < n; e++)
    this.partitionInfo[e] = this.partitionBounds(e);
};
me.prototype.printPartitions = function() {
  const t = this.numCols();
  for (let e = 0; e < this.numQubits; e++) {
    let r = "";
    for (let i = 0; i < t; i++) {
      let a = this.partitionMap[e][i];
      for (a === -1 && (a = " "), this.getGateAt(i, e) ? a = a + "*" : a = a + " "; a.length < 4; )
        a = " " + a;
      r += a;
    }
    let n = e + "";
    for (; n.length < 2; )
      n = "0" + n;
    r = "q" + n + r, console.log(r);
  }
};
me.prototype.partitionBounds = function(t) {
  let e, r;
  const n = {
    wire: {
      top: -1,
      bottom: -1
    },
    column: {
      left: -1,
      right: -1
    },
    wireMap: {},
    parents: {}
  };
  let i = !1;
  const a = this.numCols();
  for (let f = 0; f < a; f++)
    for (r = 0; r < this.numQubits; r++)
      e = this.partitionMap[r][f], e === t && (i = !0, n.wire.top < 0 && (n.wire.top = r), n.wire.bottom < r && (n.wire.bottom = r), n.column.left < 0 && (n.column.left = f), n.column.right < f && (n.column.right = f));
  if (!i)
    return null;
  let o = 0;
  for (r = n.wire.top; r <= n.wire.bottom; r++)
    e = this.partitionMap[r][n.column.left], e === t && (n.wireMap[r] = o, o++);
  if (n.numQubits = o, n.column.left > 0)
    for (r in n.wireMap) {
      const f = this.partitionMap[r][n.column.left - 1];
      if (f >= 0) {
        n.parents[f] || (n.parents[f] = {}, n.parents[f].links = []);
        const u = this.partitionInfo[f];
        for (let s in u.wireMap)
          s === r && n.parents[f].links.push(n.wireMap[r]);
      }
    }
  return n;
};
me.prototype.partitionCircuit = function(t) {
  let e;
  const r = this.partitionInfo[t];
  if (!r)
    return null;
  const n = [];
  let i = [];
  for (let o in r.parents)
    e = {}, e.circuit = this.partitionCache[o], e.wires = [], e.wires = r.parents[o].links, i = i.concat(e.wires), n.push(e);
  const a = new me();
  if (n.length > 0) {
    if (r.numQubits > i.length) {
      e = {}, e.circuit = new me(
        r.numQubits - i.length
      ), e.wires = [];
      for (let o = 0; o < r.numQubits; o++)
        i.indexOf(o) < 0 && e.wires.push(o);
      n.push(e);
    }
    a.setCombinedState(n);
  }
  for (let o = r.column.left; o <= r.column.right; o++)
    for (let f = r.wire.top; f <= r.wire.bottom; f++)
      if (this.partitionMap[f][o] === t) {
        const s = this.getGateAt(o, f);
        if (s && s.connector === 0) {
          const c = [];
          for (let l = 0; l < s.wires.length; l++) {
            const m = s.wires[l];
            c.push(r.wireMap[m]);
          }
          a.addGate(
            s.name,
            o - r.column.left,
            c,
            s.options
          );
        }
      }
  return a;
};
me.prototype.run = function(t, e) {
  let r, n;
  if (e = e || {}, this.measureResetsQubit = !!e.strictMode, e.continue || (this.initState(), this.stats.duration = 0), e.initialState) {
    if (Array.isArray(e.initialState)) {
      this.state = {};
      for (let u = 0; u < e.initialState.length; u++) {
        let s = e.initialState[u];
        Array.isArray(s) && s.length === 2 && (s = zt(s[0], s[1])), typeof s == "string" && (s = this.evalMathString(s)), typeof s == "number" && (s = zt(s, 0)), this.state[u + ""] = s;
      }
    } else
      this.state = e.initialState;
    this.stateBits = 0;
    for (let u in this.state)
      this.stateBits |= parseInt(u);
  }
  this.stats.start = /* @__PURE__ */ new Date();
  const i = new me();
  if (i.load(this.save(!0)), t)
    for (i.insertColumn(0), n = 0; n < i.numQubits; n++)
      t[n] && i.addGate("x", 0, n, {});
  const a = e.partitioning;
  a && i.createPartitions();
  const o = i.numCols();
  let f = 0;
  for (let u = 0; u < o; u++) {
    for (n = 0; n < i.numQubits; n++) {
      const s = i.getGateAt(u, n);
      if (s && s.connector === 0) {
        f++;
        let c = !0;
        if (s.options && s.options.condition && s.options.condition.creg && (c = this.getCregValue(s.options.condition.creg) === s.options.condition.value), c)
          if (a) {
            r = i.partitionMap[n][u], i.partitionCache[r] || (i.partitionCache[r] = i.partitionCircuit(r));
            const l = i.partitionCache[r], m = i.partitionInfo[r], h = u - m.column.left, g = l.getGateAt(h, m.wireMap[n]);
            l.cregs = JSON.parse(JSON.stringify(this.cregs)), l.applyGate(g.name, h, g.wires, g.options), this.cregs = JSON.parse(JSON.stringify(l.cregs));
          } else
            this.applyGate(s.name, u, s.wires, s.options);
        e && e.onGate && e.onGate(u, n, f);
      }
    }
    e && e.onColumn && e.onColumn(u);
  }
  if (a) {
    const u = [];
    for (n = 0; n < i.numQubits; n++)
      r = i.partitionMap[n][o - 1], r >= 0 && u.indexOf(r) < 0 && u.push(r);
    if (u.length)
      if (u.length === 1)
        this.state = i.partitionCache[u[0]].state, this.stateBits = i.partitionCache[u[0]].stateBits;
      else {
        const s = this.stats.start, c = [];
        for (let l = 0; l < u.length; l++) {
          const m = u[l], h = {};
          h.circuit = i.partitionCache[m], h.wires = [];
          const g = i.partitionInfo[m];
          for (n in g.wireMap)
            h.wires.push(parseInt(n));
          c.push(h);
        }
        this.setCombinedState(c), this.stats.start = s;
      }
  }
  this.stats.end = /* @__PURE__ */ new Date(), this.stats.duration += this.stats.end - this.stats.start;
};
me.prototype.continue = function() {
  this.run(null, {
    continue: !0
  });
};
me.prototype.stateAsArray = function(t, e, r, n) {
  const i = [], a = this.numAmplitudes();
  e = e || 0, r = r || (t ? this.numAmplitudes(t) : a);
  let o = 0;
  for (let f = 0; f < a; f++) {
    let u = f;
    n && (u = TA(f, this.numQubits));
    const s = qt(this.state[u] || zt(0, 0), 14);
    if (!t || s.re || s.im) {
      if (o >= e) {
        let c = f.toString(2);
        for (; c.length < this.numQubits; )
          c = "0" + c;
        const l = this.formatComplex(s, {
          fixedWidth: !0,
          decimalPlaces: 8,
          iotaChar: "i"
        }), m = Dt(It(s), 2), h = m * 100, g = h.toFixed(5), d = Cs(s), y = d.toFixed(5);
        i.push({
          index: f,
          indexBinStr: c,
          amplitude: s,
          amplitudeStr: l,
          magnitude: m,
          chance: h,
          chanceStr: g,
          phase: d,
          phaseStr: y
        });
      }
      if (o++, i.length === r)
        return i;
    }
  }
  return i;
};
me.prototype.stateAsSimpleArray = function(t) {
  const e = this.numAmplitudes();
  if (!this.state)
    return [];
  const r = [];
  for (let n = 0; n < e; n++) {
    let i = n;
    t && (i = TA(n, this.numQubits)), r.push(qt(this.state[i] || zt(0, 0), 14));
  }
  return r;
};
me.prototype.stateAsString = function(t) {
  const e = this.numAmplitudes();
  if (!this.state)
    return "Error: circuit is not initialized. Please call initState() or run() method.";
  let r = "";
  for (let n = 0; n < e; n++) {
    const i = qt(this.state[n] || zt(0, 0), 14);
    if (!t || i.re || i.im) {
      const a = Dt(It(i), 2) * 100;
      let o = n.toString(2);
      for (; o.length < this.numQubits; )
        o = "0" + o;
      let f = a.toFixed(5);
      for (; f.length < 9; )
        f = " " + f;
      r += this.formatComplex(i, {
        fixedWidth: !0,
        decimalPlaces: 8,
        iotaChar: "i"
      }) + "|" + o + ">	" + f + `%
`;
    }
  }
  return r;
};
me.prototype.print = function(t) {
  console.log(this.stateAsString(t));
};
me.prototype.gotClassicalControl = function() {
  for (let t = 0; t < this.numCols(); t++)
    for (let e = 0; e < this.numQubits; e++) {
      const r = this.getGateAt(t, e);
      if (r && r.connector === 0 && r.options && r.options.condition && r.options.condition.creg)
        return !0;
    }
  return !1;
};
me.prototype.gotMeasurement = function() {
  for (let t = 0; t < this.numCols(); t++)
    for (let e = 0; e < this.numQubits; e++) {
      const r = this.getGateAt(t, e);
      if (r && r.connector === 0 && r.name === "measure")
        return !0;
    }
  return !1;
};
me.prototype.cregCount = function() {
  let t = 0;
  for (let e in this.cregs)
    t++;
  return t;
};
me.prototype.getCregs = function() {
  const t = {};
  for (let e in this.cregs)
    t[e] = this.getCregValue(e);
  return t;
};
me.prototype.cregsAsString = function() {
  let t = `reg	bin	dec
`;
  for (let e in this.cregs) {
    const r = this.getCregValue(e);
    let n = r.toString(2);
    const i = this.cregs[e] && this.cregs[e].length || 1;
    for (; n.length < i; )
      n = "0" + n;
    t += e + "	" + n + "	" + r + `
`;
  }
  return t;
};
me.prototype.createCreg = function(t, e) {
  for (this.cregs[t] = []; this.cregs[t].length < (e || 1); )
    this.cregs[t].push(0);
};
me.prototype.removeCreg = function(t) {
  const e = this.numCols(), r = [];
  for (let n = 0; n < e; n++)
    for (let i = 0; i < this.numQubits; i++) {
      const a = this.gates[i][n];
      a && a.options && (a.options.creg && a.options.creg.name && a.options.creg.name === t && r.indexOf(a.id) < 0 && r.push(a.id), a.options.condition && a.options.condition.creg && a.options.condition.creg === t && delete a.options.condition);
    }
  delete this.cregs[t];
  for (let n = 0; n < r.length; n++)
    this.removeGate(r[n]);
};
me.prototype.renameCreg = function(t, e) {
  const r = this.numCols();
  for (let n = 0; n < r; n++)
    for (let i = 0; i < this.numQubits; i++) {
      const a = this.gates[i][n];
      a && a.options && (a.options.creg && a.options.creg.name && a.options.creg.name === t && (a.options.creg.name = e), a.options.condition && a.options.condition.creg && a.options.condition.creg === t && (a.options.condition.creg = e));
    }
  this.cregs[e] = JSON.parse(JSON.stringify(this.cregs[t])), delete this.cregs[t];
};
me.prototype.minCregSize = function(t) {
  let e = 0;
  const r = this.numCols();
  for (let n = 0; n < r; n++)
    for (let i = 0; i < this.numQubits; i++) {
      const a = this.gates[i][n];
      if (a && a.options) {
        if (a.options.creg && a.options.creg.name && a.options.creg.name === t) {
          let o = parseInt(a.options.creg.bit || 0);
          isNaN(o) && (o = 0), o > e && (e = o);
        }
        if (a.options.condition && a.options.condition.creg && a.options.condition.creg === t) {
          const o = Math.floor(Math.log2(a.options.condition.value));
          o > e && (e = o);
        }
      }
    }
  return e + 1;
};
me.prototype.resizeCreg = function(t, e) {
  if (!(e < this.minCregSize(t))) {
    for (; this.cregs[t].length < e; )
      this.cregs[t].push(0);
    for (; this.cregs[t].length > e; )
      this.cregs[t].pop();
  }
};
me.prototype.getCreg = function(t) {
  return this.cregs[t];
};
me.prototype.setCregBit = function(t, e, r) {
  const n = parseInt(e);
  if (isNaN(n))
    throw 'Error: invalid "cbit" argument to "setCregBit" method: expected "integer" got "' + typeof e + '".';
  for (this.cregs[t] || (this.cregs[t] = []); n >= this.cregs[t].length; )
    this.cregs[t].push(0);
  this.cregs[t][n] = r ? 1 : 0;
};
me.prototype.getCregBit = function(t, e) {
  if (!this.cregs[t])
    throw 'Error: "getCregBit": unknown register "' + t + '".';
  const r = parseInt(e);
  if (isNaN(r) || r >= this.cregs[t].length)
    throw 'Error: "getCregBit": bit "' + e + '" not found.';
  return this.cregs[t][r];
};
me.prototype.cregBase = function(t) {
  if (!this.cregs[t])
    throw 'Error: "getCregBit": unknown register "' + t + '".';
  let e = 0;
  for (let r in this.cregs) {
    if (r === t)
      return e;
    e += this.cregs[r].length;
  }
};
me.prototype.cregTotalBits = function() {
  let t = 0;
  for (let e in this.cregs)
    t += this.cregs[e].length;
  return t;
};
me.prototype.getCregValue = function(t) {
  if (!this.cregs[t])
    throw 'Error: "getCregBit": unknown register "' + t + '".';
  const e = this.cregs[t].length;
  let r = 0;
  for (let n = 0; n < e; n++)
    this.cregs[t][n] && (r += Dt(2, n));
  return r;
};
me.prototype.measureAll = function(t) {
  let e;
  if (this.collapsed && this.collapsed.length === this.numQubits && !t)
    return this.collapsed;
  this.collapsed = [];
  let r = Math.random();
  for (let n in this.state) {
    const i = qt(this.state[n], 14);
    if (i.re || i.im) {
      const a = qt(Dt(It(i), 2), 14);
      if (r -= a, r <= 0) {
        const o = parseInt(n);
        if (this.reverseBitOrder)
          for (e = this.numQubits - 1; e >= 0; e--)
            this.collapsed.push(1 << e & o ? 1 : 0);
        else
          for (e = 0; e < this.numQubits; e++)
            this.collapsed.push(1 << e & o ? 1 : 0);
        return this.collapsed;
      }
    }
  }
  if (!this.collapsed.length)
    for (; this.collapsed.length < this.numQubits; )
      this.collapsed.push(0);
  return this.collapsed;
};
me.prototype.measureAllMultishot = function(t) {
  t = t || 1;
  const e = {}, r = [];
  for (let i = 0; i < t; i++)
    r.push(Math.random());
  let n = 0;
  do
    for (let i in this.state) {
      const a = qt(this.state[i], 14);
      if (a.re || a.im) {
        const o = qt(Dt(It(a), 2), 14);
        for (let f = 0; f < t; f++)
          if (r[f] > 0 && (r[f] -= o, r[f] <= 0)) {
            let u = parseInt(i).toString(2);
            for (; u.length < this.numQubits; )
              u = "0" + u;
            if (e[u] ? e[u]++ : e[u] = 1, n++, n === t)
              return e;
          }
      }
    }
  while (n < t);
};
me.prototype.measure = function(t, e, r, n) {
  (n || !this.collapsed || this.collapsed.length !== this.numQubits) && this.measureAll(n);
  const i = this.collapsed[t];
  return e && typeof r < "u" && this.setCregBit(e, r, i), i;
};
me.prototype.probabilities = function() {
  let t;
  for (this.prob = [], t = 0; t < this.numQubits; t++)
    this.prob.push(0);
  for (let e in this.state) {
    const r = parseInt(e);
    for (t = 0; t < this.numQubits; t++) {
      let n = null;
      if (this.reverseBitOrder ? n = Dt(2, this.numQubits - 1 - t) : n = Dt(2, t), r & n) {
        const i = this.state[e];
        (i.re || i.im) && (this.prob[t] += Dt(It(i), 2));
      }
    }
  }
  for (t = 0; t < this.numQubits; t++)
    this.prob[t] = qt(this.prob[t], 14);
  return this.prob;
};
me.prototype.probability = function(t) {
  return (!this.prob || this.prob.length !== this.numQubits) && this.probabilities(), this.prob[t];
};
me.prototype.densityMatrix = function() {
  const t = [], e = this.numAmplitudes();
  for (let r = 0; r < e; r++) {
    const n = [], i = this.state[r] || zt(0, 0);
    for (let a = 0; a < e; a++) {
      let o = this.state[a] || zt(0, 0);
      (o.re || o.im) && (o = kn(o)), n.push(Xe(i, o));
    }
    t.push(n);
  }
  return t;
};
me.prototype.partialTrace = function(t) {
  function e(o, f, u) {
    let s = o << 1;
    const c = (2 << f) - 1, l = 1 << f;
    return s = s ^ (s ^ o) & c | l, u || (s = s ^ l), s;
  }
  const r = [], n = this.numQubits - 1, i = Dt(2, n);
  let a;
  this.reverseBitOrder ? a = this.numQubits - 1 - t : a = t;
  for (let o = 0; o < 4; o++) {
    r.push(zt(0, 0));
    let f = i;
    for (; f--; ) {
      const u = e(f, a, o & 2 ? 1 : 0);
      if (this.state[u]) {
        const s = e(f, a, o & 1 ? 1 : 0);
        this.state[s] && (r[o] = rt(
          r[o],
          Xe(this.state[u], kn(this.state[s]))
        ));
      }
    }
  }
  return [
    [r[0], r[1]],
    [r[2], r[3]]
  ];
};
me.prototype.angles = function() {
  let t;
  const e = [];
  for (t = 0; t < this.numQubits; t++)
    e.push({ theta: 0, phi: 0 });
  for (t = 0; t < this.numQubits; t++) {
    const r = this.partialTrace(t), n = qt(ar(r[0][0]), 12), i = qt(Xe(r[1][0], ar(2)), 12), a = qt(
      It(ar(2 * It(mg(Dt(r, 2))) - 1)),
      12
    ), o = Xe(2, jd(n));
    let f = 0;
    qt(i.re, 8) === 0 && qt(i.im, 8) === 0 || (f = Xe(
      zt(0, -1),
      so(Xe(i, Zd(er(o, 2))))
    ).re, isNaN(f) && (f = 0)), e[t].theta = qt(It(o), 12), e[t].phi = qt(f, 12), e[t].thetaDeg = qt(
      Xe(It(o), 180 / yi),
      7
    ), e[t].phiDeg = qt(Xe(f, 180 / yi), 7), e[t].radius = qt(a, 7);
  }
  return e;
};
me.prototype.randomCircuit = function(t, e, r) {
  this.init(t), r = r || {};
  const n = r.useGates && r.useGates.length ? r.useGates : Object.keys(this.basicGates);
  r.noMeasure && n.indexOf("measure") >= 0 && n.splice(n.indexOf("measure"), 1), r.noReset && n.indexOf("reset") >= 0 && n.splice(n.indexOf("reset"), 1);
  let i = 0;
  for (; i < e; ) {
    const a = n[Math.floor(Math.random() * n.length)], o = this.basicGates[a];
    if (o) {
      const f = o.matrix && o.matrix.length ? Ci(o.matrix.length) : 1;
      if (f <= t) {
        const u = [];
        for (; u.length < f; ) {
          let c = -1;
          do
            c = Math.floor(Math.random() * t);
          while (u.indexOf(c) >= 0);
          u.push(c);
        }
        const s = {};
        if (o.params && o.params.length) {
          const c = {};
          o.params.map(function(l) {
            c[l] = Math.PI * 2 * Math.random(), c[l] > Math.PI && (c[l] = Math.PI - c[l]);
          }), s.params = c;
        }
        if (a === "measure")
          s.creg = {
            name: "c",
            bit: u[0]
          };
        else if (!r.noClassicControl && Math.floor(Math.random() * 4) === 0) {
          const c = this.cregTotalBits();
          c && (s.condition = {
            creg: "c",
            value: Math.floor(Math.random() * Dt(2, c))
          });
        }
        this.appendGate(a, u, s), i++;
      }
    }
  }
};
me.prototype.randomUnitary = function(t) {
  const e = new me();
  return e.randomCircuit(t || 1, (t || 1) * 8, {
    useGates: ["rx", "rz", "cz"],
    noMeasure: !0,
    noReset: !0,
    noClassicControl: !0
  }), e.circuitMatrix();
};
me.prototype.eulerAnglesZYZ = function(t) {
  const e = { theta: null, phi: null, lambda: null, phase: null }, r = Dt(th(t), -0.5);
  e.phase = -1 * zt(r).toPolar().phi;
  const n = Xe(r, t);
  e.theta = 2 * sg(It(n[1][0]), It(n[0][0]));
  const i = 2 * zt(n[1][1]).toPolar().phi, a = 2 * zt(n[1][0]).toPolar().phi;
  return e.phi = (i + a) / 2, e.lambda = (i - a) / 2, e;
};
export {
  me as QuantumCircuit
};
